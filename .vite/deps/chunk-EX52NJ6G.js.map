{
  "version": 3,
  "sources": ["../../node_modules/@effect/platform/src/ChannelSchema.ts", "../../node_modules/@effect/platform/src/Error.ts", "../../node_modules/@effect/platform/src/Cookies.ts", "../../node_modules/@effect/platform/src/Etag.ts", "../../node_modules/@effect/platform/src/internal/etag.ts", "../../node_modules/@effect/platform/src/Headers.ts", "../../node_modules/@effect/platform/src/HttpClientError.ts", "../../node_modules/@effect/platform/src/internal/httpClientError.ts", "../../node_modules/@effect/platform/src/FileSystem.ts", "../../node_modules/@effect/platform/src/internal/fileSystem.ts", "../../node_modules/@effect/platform/src/UrlParams.ts", "../../node_modules/@effect/platform/src/HttpIncomingMessage.ts", "../../node_modules/@effect/platform/src/HttpTraceContext.ts", "../../node_modules/@effect/platform/src/HttpApiSchema.ts", "../../node_modules/@effect/platform/src/HttpApiError.ts", "../../node_modules/@effect/platform/src/HttpApi.ts", "../../node_modules/@effect/platform/src/HttpApiMiddleware.ts", "../../node_modules/@effect/platform/src/HttpBody.ts", "../../node_modules/@effect/platform/src/internal/httpBody.ts", "../../node_modules/@effect/platform/src/Template.ts", "../../node_modules/@effect/platform/src/HttpServerResponse.ts", "../../node_modules/@effect/platform/src/internal/httpServerResponse.ts", "../../node_modules/@effect/platform/src/HttpServerRespondable.ts", "../../node_modules/@effect/platform/src/HttpServerError.ts", "../../node_modules/@effect/platform/src/internal/httpServerError.ts", "../../node_modules/@effect/platform/src/Path.ts", "../../node_modules/@effect/platform/src/internal/path.ts", "../../node_modules/@effect/platform/src/Multipart.ts", "../../node_modules/multipasta/src/internal/contentType.ts", "../../node_modules/multipasta/src/internal/headers.ts", "../../node_modules/multipasta/src/internal/search.ts", "../../node_modules/multipasta/src/internal/multipart.ts", "../../node_modules/multipasta/src/index.ts", "../../node_modules/@effect/platform/src/Socket.ts", "../../node_modules/@effect/platform/src/HttpServerRequest.ts", "../../node_modules/@effect/platform/src/internal/httpServerRequest.ts", "../../node_modules/@effect/platform/src/HttpApp.ts", "../../node_modules/@effect/platform/src/internal/httpApp.ts", "../../node_modules/@effect/platform/src/internal/httpMiddleware.ts", "../../node_modules/@effect/platform/src/HttpMethod.ts", "../../node_modules/@effect/platform/src/HttpMiddleware.ts", "../../node_modules/@effect/platform/src/HttpClient.ts", "../../node_modules/@effect/platform/src/internal/httpClientRequest.ts", "../../node_modules/@effect/platform/src/internal/httpClientResponse.ts", "../../node_modules/@effect/platform/src/internal/httpClient.ts", "../../node_modules/@effect/platform/src/HttpClientRequest.ts", "../../node_modules/@effect/platform/src/HttpServer.ts", "../../node_modules/@effect/platform/src/internal/httpPlatform.ts", "../../node_modules/@effect/platform/src/internal/httpServer.ts", "../../node_modules/@effect/platform/src/HttpRouter.ts", "../../node_modules/find-my-way-ts/src/index.ts", "../../node_modules/find-my-way-ts/src/QueryString.ts", "../../node_modules/find-my-way-ts/src/internal/router.ts", "../../node_modules/@effect/platform/src/internal/httpRouter.ts", "../../node_modules/@effect/platform/src/OpenApiJsonSchema.ts", "../../node_modules/@effect/platform/src/OpenApi.ts", "../../node_modules/@effect/platform/src/HttpApiBuilder.ts", "../../node_modules/@effect/platform/src/HttpLayerRouter.ts", "../../node_modules/@effect/platform/src/MsgPack.ts", "../../node_modules/msgpackr/index.js", "../../node_modules/msgpackr/unpack.js", "../../node_modules/msgpackr/pack.js", "../../node_modules/msgpackr/iterators.js", "../../node_modules/@effect/platform/src/SocketServer.ts", "../../node_modules/@effect/platform/src/Transferable.ts", "../../node_modules/@effect/platform/src/WorkerError.ts", "../../node_modules/@effect/platform/src/internal/workerError.ts", "../../node_modules/@effect/platform/src/Worker.ts", "../../node_modules/@effect/platform/src/internal/worker.ts", "../../node_modules/@effect/platform/src/WorkerRunner.ts", "../../node_modules/@effect/platform/src/internal/workerRunner.ts"],
  "sourcesContent": ["/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport * as Channel from \"effect/Channel\"\nimport type * as Chunk from \"effect/Chunk\"\nimport { dual, pipe } from \"effect/Function\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const encode = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) =>\n<IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<I>,\n  Chunk.Chunk<A>,\n  IE | ParseError,\n  IE,\n  Done,\n  Done,\n  R\n> => {\n  const encode = Schema.encode(Schema.ChunkFromSelf(schema))\n  const loop: Channel.Channel<Chunk.Chunk<I>, Chunk.Chunk<A>, IE | ParseError, IE, Done, Done, R> = Channel\n    .readWithCause({\n      onInput: (input: Chunk.Chunk<A>) =>\n        Channel.zipRight(\n          Channel.flatMap(encode(input), Channel.write),\n          loop\n        ),\n      onFailure: (cause: Cause.Cause<IE>) => Channel.failCause(cause),\n      onDone: Channel.succeed\n    })\n  return loop\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const encodeUnknown: <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) => <IE = never, Done = unknown>() => Channel.Channel<\n  Chunk.Chunk<unknown>,\n  Chunk.Chunk<A>,\n  IE | ParseError,\n  IE,\n  Done,\n  Done,\n  R\n> = encode as any\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const decode = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) =>\n<IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<A>,\n  Chunk.Chunk<I>,\n  ParseError | IE,\n  IE,\n  Done,\n  Done,\n  R\n> => {\n  const decode = Schema.decode(Schema.ChunkFromSelf(schema))\n  const loop: Channel.Channel<Chunk.Chunk<A>, Chunk.Chunk<I>, ParseError | IE, IE, Done, Done, R> = Channel\n    .readWithCause({\n      onInput(chunk: Chunk.Chunk<I>) {\n        return decode(chunk).pipe(\n          Channel.flatMap(Channel.write),\n          Channel.zipRight(loop)\n        )\n      },\n      onFailure(cause: Cause.Cause<IE>) {\n        return Channel.failCause(cause)\n      },\n      onDone(done: Done) {\n        return Channel.succeed(done)\n      }\n    })\n  return loop\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const decodeUnknown: <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) => <IE = never, Done = unknown>() => Channel.Channel<\n  Chunk.Chunk<A>,\n  Chunk.Chunk<any>,\n  ParseError | IE,\n  IE,\n  Done,\n  Done,\n  R\n> = decode as any\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplex: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IA, II, IR, OA, OI, OR>(\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): <R, InErr, OutErr, OutDone, InDone>(\n    self: Channel.Channel<\n      Chunk.Chunk<OI>,\n      Chunk.Chunk<II>,\n      OutErr,\n      ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >\n  ) => Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n    self: Channel.Channel<\n      Chunk.Chunk<OI>,\n      Chunk.Chunk<II>,\n      OutErr,\n      ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >,\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n} = dual(2, <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n  self: Channel.Channel<\n    Chunk.Chunk<OI>,\n    Chunk.Chunk<II>,\n    OutErr,\n    ParseError | InErr,\n    OutDone,\n    InDone,\n    R\n  >,\n  options: {\n    readonly inputSchema: Schema.Schema<IA, II, IR>\n    readonly outputSchema: Schema.Schema<OA, OI, OR>\n  }\n): Channel.Channel<\n  Chunk.Chunk<OA>,\n  Chunk.Chunk<IA>,\n  ParseError | OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  R | IR | OR\n> => {\n  const decode = Schema.decode(Schema.ChunkFromSelf(options.outputSchema))\n  return pipe(\n    encode(options.inputSchema)</**\n     * @since 1.0.0\n     * @category combinators\n     */\n    InErr, /**\n     * @since 1.0.0\n     * @category combinators\n     */\n    InDone>(),\n    Channel.pipeTo(self),\n    Channel.mapOutEffect(decode)\n  );\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplexUnknown: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IA, II, IR, OA, OI, OR>(\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): <R, InErr, OutErr, OutDone, InDone>(\n    self: Channel.Channel<\n      Chunk.Chunk<unknown>,\n      Chunk.Chunk<any>,\n      OutErr,\n      ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >\n  ) => Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n    self: Channel.Channel<\n      Chunk.Chunk<unknown>,\n      Chunk.Chunk<any>,\n      OutErr,\n      ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >,\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n} = duplex as any\n", "/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport * as Data from \"effect/Data\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport type { Simplify } from \"effect/Types\"\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Error\")\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isPlatformError = (u: unknown): u is PlatformError => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport const TypeIdError = <const TypeId extends symbol, const Tag extends string>(\n  typeId: TypeId,\n  tag: Tag\n): new<A extends Record<string, any>>(\n  args: Simplify<A>\n) =>\n  & Cause.YieldableError\n  & Record<TypeId, TypeId>\n  & { readonly _tag: Tag }\n  & Readonly<A> =>\n{\n  class Base extends Data.Error<{}> {\n    readonly _tag = tag\n  }\n  ;(Base.prototype as any)[typeId] = typeId\n  ;(Base.prototype as any).name = tag\n  return Base as any\n}\n\n/**\n * @since 1.0.0\n * @category Models\n */\nexport const Module = Schema.Literal(\n  \"Clipboard\",\n  \"Command\",\n  \"FileSystem\",\n  \"KeyValueStore\",\n  \"Path\",\n  \"Stream\",\n  \"Terminal\"\n)\n\n/**\n * @since 1.0.0\n * @category Models\n */\nexport class BadArgument extends Schema.TaggedError<BadArgument>(\"@effect/platform/Error/BadArgument\")(\"BadArgument\", {\n  module: Module,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: typeof TypeId = TypeId\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    return `${this.module}.${this.method}${this.description ? `: ${this.description}` : \"\"}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category Model\n */\nexport const SystemErrorReason = Schema.Literal(\n  \"AlreadyExists\",\n  \"BadResource\",\n  \"Busy\",\n  \"InvalidData\",\n  \"NotFound\",\n  \"PermissionDenied\",\n  \"TimedOut\",\n  \"UnexpectedEof\",\n  \"Unknown\",\n  \"WouldBlock\",\n  \"WriteZero\"\n)\n\n/**\n * @since 1.0.0\n * @category Model\n */\nexport type SystemErrorReason = typeof SystemErrorReason.Type\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport class SystemError extends Schema.TaggedError<SystemError>(\"@effect/platform/Error/SystemError\")(\"SystemError\", {\n  reason: SystemErrorReason,\n  module: Module,\n  method: Schema.String,\n  description: Schema.optional(Schema.String),\n  syscall: Schema.optional(Schema.String),\n  pathOrDescriptor: Schema.optional(Schema.Union(Schema.String, Schema.Number)),\n  cause: Schema.optional(Schema.Defect)\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [TypeId]: typeof TypeId = TypeId\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    return `${this.reason}: ${this.module}.${this.method}${\n      this.pathOrDescriptor !== undefined ? ` (${this.pathOrDescriptor})` : \"\"\n    }${this.description ? `: ${this.description}` : \"\"}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category Models\n */\nexport type PlatformError = BadArgument | SystemError\n\n/**\n * @since 1.0.0\n * @category Models\n */\nexport const PlatformError: Schema.Union<[\n  typeof BadArgument,\n  typeof SystemError\n]> = Schema.Union(BadArgument, SystemError)\n", "/**\n * @since 1.0.0\n */\nimport * as Duration from \"effect/Duration\"\nimport * as Either from \"effect/Either\"\nimport { dual, identity } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport type * as Types from \"effect/Types\"\nimport { TypeIdError } from \"./Error.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCookies = (u: unknown): u is Cookies => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Cookies extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly cookies: Record.ReadonlyRecord<string, Cookie>\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const CookieTypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies/Cookie\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type CookieTypeId = typeof CookieTypeId\n\n/**\n * @since 1.0.0\n * @category cookie\n */\nexport interface Cookie extends Inspectable.Inspectable {\n  readonly [CookieTypeId]: CookieTypeId\n  readonly name: string\n  readonly value: string\n  readonly valueEncoded: string\n  readonly options?: {\n    readonly domain?: string | undefined\n    readonly expires?: Date | undefined\n    readonly maxAge?: Duration.DurationInput | undefined\n    readonly path?: string | undefined\n    readonly priority?: \"low\" | \"medium\" | \"high\" | undefined\n    readonly httpOnly?: boolean | undefined\n    readonly secure?: boolean | undefined\n    readonly partitioned?: boolean | undefined\n    readonly sameSite?: \"lax\" | \"strict\" | \"none\" | undefined\n  } | undefined\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const ErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/Cookies/CookieError\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class CookiesError extends TypeIdError(ErrorTypeId, \"CookieError\")<{\n  readonly reason: \"InvalidName\" | \"InvalidValue\" | \"InvalidDomain\" | \"InvalidPath\" | \"InfinityMaxAge\"\n}> {\n  get message() {\n    return this.reason\n  }\n}\n\nconst Proto: Omit<Cookies, \"cookies\"> = {\n  [TypeId]: TypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: Cookies) {\n    return {\n      _id: \"@effect/platform/Cookies\",\n      cookies: Record.map(this.cookies, (cookie) => cookie.toJSON())\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * Create a Cookies object from an Iterable\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromReadonlyRecord = (cookies: Record.ReadonlyRecord<string, Cookie>): Cookies => {\n  const self = Object.create(Proto)\n  self.cookies = cookies\n  return self\n}\n\n/**\n * Create a Cookies object from an Iterable\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable = (cookies: Iterable<Cookie>): Cookies => {\n  const record: Record<string, Cookie> = {}\n  for (const cookie of cookies) {\n    record[cookie.name] = cookie\n  }\n  return fromReadonlyRecord(record)\n}\n\n/**\n * Create a Cookies object from a set of Set-Cookie headers\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const fromSetCookie = (headers: Iterable<string> | string): Cookies => {\n  const arrayHeaders = typeof headers === \"string\" ? [headers] : headers\n  const cookies: Array<Cookie> = []\n  for (const header of arrayHeaders) {\n    const cookie = parseSetCookie(header.trim())\n    if (Option.isSome(cookie)) {\n      cookies.push(cookie.value)\n    }\n  }\n\n  return fromIterable(cookies)\n}\n\nfunction parseSetCookie(header: string): Option.Option<Cookie> {\n  const parts = header.split(\";\").map((_) => _.trim()).filter((_) => _ !== \"\")\n  if (parts.length === 0) {\n    return Option.none()\n  }\n\n  const firstEqual = parts[0].indexOf(\"=\")\n  if (firstEqual === -1) {\n    return Option.none()\n  }\n  const name = parts[0].slice(0, firstEqual)\n  if (!fieldContentRegExp.test(name)) {\n    return Option.none()\n  }\n\n  const valueEncoded = parts[0].slice(firstEqual + 1)\n  const value = tryDecodeURIComponent(valueEncoded)\n\n  if (parts.length === 1) {\n    return Option.some(Object.assign(Object.create(CookieProto), {\n      name,\n      value,\n      valueEncoded\n    }))\n  }\n\n  const options: Types.Mutable<Cookie[\"options\"]> = {}\n\n  for (let i = 1; i < parts.length; i++) {\n    const part = parts[i]\n    const equalIndex = part.indexOf(\"=\")\n    const key = equalIndex === -1 ? part : part.slice(0, equalIndex).trim()\n    const value = equalIndex === -1 ? undefined : part.slice(equalIndex + 1).trim()\n\n    switch (key.toLowerCase()) {\n      case \"domain\": {\n        if (value === undefined) {\n          break\n        }\n        const domain = value.trim().replace(/^\\./, \"\")\n        if (domain) {\n          options.domain = domain\n        }\n        break\n      }\n      case \"expires\": {\n        if (value === undefined) {\n          break\n        }\n        const date = new Date(value)\n        if (!isNaN(date.getTime())) {\n          options.expires = date\n        }\n        break\n      }\n      case \"max-age\": {\n        if (value === undefined) {\n          break\n        }\n        const maxAge = parseInt(value, 10)\n        if (!isNaN(maxAge)) {\n          options.maxAge = Duration.seconds(maxAge)\n        }\n        break\n      }\n      case \"path\": {\n        if (value === undefined) {\n          break\n        }\n        if (value[0] === \"/\") {\n          options.path = value\n        }\n        break\n      }\n      case \"priority\": {\n        if (value === undefined) {\n          break\n        }\n        switch (value.toLowerCase()) {\n          case \"low\":\n            options.priority = \"low\"\n            break\n          case \"medium\":\n            options.priority = \"medium\"\n            break\n          case \"high\":\n            options.priority = \"high\"\n            break\n        }\n        break\n      }\n      case \"httponly\": {\n        options.httpOnly = true\n        break\n      }\n      case \"secure\": {\n        options.secure = true\n        break\n      }\n      case \"partitioned\": {\n        options.partitioned = true\n        break\n      }\n      case \"samesite\": {\n        if (value === undefined) {\n          break\n        }\n        switch (value.toLowerCase()) {\n          case \"lax\":\n            options.sameSite = \"lax\"\n            break\n          case \"strict\":\n            options.sameSite = \"strict\"\n            break\n          case \"none\":\n            options.sameSite = \"none\"\n            break\n        }\n        break\n      }\n    }\n  }\n\n  return Option.some(Object.assign(Object.create(CookieProto), {\n    name,\n    value,\n    valueEncoded,\n    options: Object.keys(options).length > 0 ? options : undefined\n  }))\n}\n\n/**\n * An empty Cookies object\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Cookies = fromIterable([])\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isEmpty = (self: Cookies): boolean => Record.isEmptyRecord(self.cookies)\n\n// eslint-disable-next-line no-control-regex\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/\n\nconst CookieProto = {\n  [CookieTypeId]: CookieTypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: Cookie) {\n    return {\n      _id: \"@effect/platform/Cookies/Cookie\",\n      name: this.name,\n      value: this.value,\n      options: this.options\n    }\n  }\n}\n\n/**\n * Create a new cookie\n *\n * @since 1.0.0\n * @category constructors\n */\nexport function makeCookie(\n  name: string,\n  value: string,\n  options?: Cookie[\"options\"] | undefined\n): Either.Either<Cookie, CookiesError> {\n  if (!fieldContentRegExp.test(name)) {\n    return Either.left(new CookiesError({ reason: \"InvalidName\" }))\n  }\n  const encodedValue = encodeURIComponent(value)\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    return Either.left(new CookiesError({ reason: \"InvalidValue\" }))\n  }\n\n  if (options !== undefined) {\n    if (options.domain !== undefined && !fieldContentRegExp.test(options.domain)) {\n      return Either.left(new CookiesError({ reason: \"InvalidDomain\" }))\n    }\n\n    if (options.path !== undefined && !fieldContentRegExp.test(options.path)) {\n      return Either.left(new CookiesError({ reason: \"InvalidPath\" }))\n    }\n\n    if (options.maxAge !== undefined && !Duration.isFinite(Duration.decode(options.maxAge))) {\n      return Either.left(new CookiesError({ reason: \"InfinityMaxAge\" }))\n    }\n  }\n\n  return Either.right(Object.assign(Object.create(CookieProto), {\n    name,\n    value,\n    valueEncoded: encodedValue,\n    options\n  }))\n}\n\n/**\n * Create a new cookie, throwing an error if invalid\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeMakeCookie = (\n  name: string,\n  value: string,\n  options?: Cookie[\"options\"] | undefined\n): Cookie => Either.getOrThrowWith(makeCookie(name, value, options), identity)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setCookie: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookie: Cookie): (self: Cookies) => Cookies\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, cookie: Cookie): Cookies\n} = dual(\n  2,\n  (self: Cookies, cookie: Cookie) =>\n    fromReadonlyRecord(Record.set(\n      self.cookies,\n      cookie.name,\n      cookie\n    ))\n)\n\n/**\n * Add multiple cookies to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setAllCookie: {\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookies: Iterable<Cookie>): (self: Cookies) => Cookies\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, cookies: Iterable<Cookie>): Cookies\n} = dual(2, (self: Cookies, cookies: Iterable<Cookie>) => {\n  const record = { ...self.cookies }\n  for (const cookie of cookies) {\n    record[cookie.name] = cookie\n  }\n  return fromReadonlyRecord(record)\n})\n\n/**\n * Combine two Cookies objects, removing duplicates from the first\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const merge: {\n  /**\n   * Combine two Cookies objects, removing duplicates from the first\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (that: Cookies): (self: Cookies) => Cookies\n  /**\n   * Combine two Cookies objects, removing duplicates from the first\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, that: Cookies): Cookies\n} = dual(2, (self: Cookies, that: Cookies) =>\n  fromReadonlyRecord({\n    ...self.cookies,\n    ...that.cookies\n  }))\n\n/**\n * Remove a cookie by name\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * Remove a cookie by name\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Cookies\n  /**\n   * Remove a cookie by name\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Cookies\n} = dual(2, (self: Cookies, name: string) => fromReadonlyRecord(Record.remove(self.cookies, name)))\n\n/**\n * Get a cookie from a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Option.Option<Cookie>\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Option.Option<Cookie>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string): Option.Option<Cookie> => Record.get(self.cookies, name)\n)\n\n/**\n * Get a cookie from a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const getValue: {\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: Cookies) => Option.Option<string>\n  /**\n   * Get a cookie from a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string): Option.Option<string>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string): Option.Option<string> =>\n    Option.map(Record.get(self.cookies, name), (cookie) => cookie.value)\n)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Either.Either<Cookies, CookiesError>\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Either.Either<Cookies, CookiesError>\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]) =>\n    Either.map(\n      makeCookie(name, value, options),\n      (cookie) => fromReadonlyRecord(Record.set(self.cookies, name, cookie))\n    )\n)\n\n/**\n * Add a cookie to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSet: {\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (self: Cookies) => Cookies\n  /**\n   * Add a cookie to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]): Cookies\n} = dual(\n  (args) => isCookies(args[0]),\n  (self: Cookies, name: string, value: string, options?: Cookie[\"options\"]) =>\n    fromReadonlyRecord(Record.set(\n      self.cookies,\n      name,\n      unsafeMakeCookie(name, value, options)\n    ))\n)\n\n/**\n * Add multiple cookies to a Cookies object\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): (self: Cookies) => Either.Either<Cookies, CookiesError>\n  /**\n   * Add multiple cookies to a Cookies object\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Either.Either<Cookies, CookiesError>\n} = dual(\n  2,\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Either.Either<Cookies, CookiesError> => {\n    const record: Record<string, Cookie> = { ...self.cookies }\n    for (const [name, value, options] of cookies) {\n      const either = makeCookie(name, value, options)\n      if (Either.isLeft(either)) {\n        return either as Either.Left<CookiesError, never>\n      }\n      record[name] = either.right\n    }\n    return Either.right(fromReadonlyRecord(record))\n  }\n)\n\n/**\n * Add multiple cookies to a Cookies object, throwing an error if invalid\n *\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSetAll: {\n  /**\n   * Add multiple cookies to a Cookies object, throwing an error if invalid\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): (self: Cookies) => Cookies\n  /**\n   * Add multiple cookies to a Cookies object, throwing an error if invalid\n   *\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Cookies\n} = dual(\n  2,\n  (\n    self: Cookies,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookie[\"options\"]]>\n  ): Cookies => Either.getOrThrowWith(setAll(self, cookies), identity)\n)\n\n/**\n * Serialize a cookie into a string\n *\n * Adapted from https://github.com/fastify/fastify-cookie under MIT License\n *\n * @since 1.0.0\n * @category encoding\n */\nexport function serializeCookie(self: Cookie): string {\n  let str = self.name + \"=\" + self.valueEncoded\n\n  if (self.options === undefined) {\n    return str\n  }\n  const options = self.options\n\n  if (options.maxAge !== undefined) {\n    const maxAge = Duration.toSeconds(options.maxAge)\n    str += \"; Max-Age=\" + Math.trunc(maxAge)\n  }\n\n  if (options.domain !== undefined) {\n    str += \"; Domain=\" + options.domain\n  }\n\n  if (options.path !== undefined) {\n    str += \"; Path=\" + options.path\n  }\n\n  if (options.priority !== undefined) {\n    switch (options.priority) {\n      case \"low\":\n        str += \"; Priority=Low\"\n        break\n      case \"medium\":\n        str += \"; Priority=Medium\"\n        break\n      case \"high\":\n        str += \"; Priority=High\"\n        break\n    }\n  }\n\n  if (options.expires !== undefined) {\n    str += \"; Expires=\" + options.expires.toUTCString()\n  }\n\n  if (options.httpOnly) {\n    str += \"; HttpOnly\"\n  }\n\n  if (options.secure) {\n    str += \"; Secure\"\n  }\n\n  // Draft implementation to support Chrome from 2024-Q1 forward.\n  // See https://datatracker.ietf.org/doc/html/draft-cutler-httpbis-partitioned-cookies#section-2.1\n  if (options.partitioned) {\n    str += \"; Partitioned\"\n  }\n\n  if (options.sameSite !== undefined) {\n    switch (options.sameSite) {\n      case \"lax\":\n        str += \"; SameSite=Lax\"\n        break\n      case \"strict\":\n        str += \"; SameSite=Strict\"\n        break\n      case \"none\":\n        str += \"; SameSite=None\"\n        break\n    }\n  }\n\n  return str\n}\n\n/**\n * Serialize a Cookies object into a Cookie header\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toCookieHeader = (self: Cookies): string =>\n  Object.values(self.cookies).map((cookie) => `${cookie.name}=${cookie.valueEncoded}`).join(\"; \")\n\n/**\n * To record\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toRecord = (self: Cookies): Record<string, string> => {\n  const record: Record<string, string> = {}\n  const cookies = Object.values(self.cookies)\n  for (let index = 0; index < cookies.length; index++) {\n    const cookie = cookies[index]\n    record[cookie.name] = cookie.value\n  }\n  return record\n}\n\n/**\n * Serialize a Cookies object into Headers object containing one or more Set-Cookie headers\n *\n * @since 1.0.0\n * @category encoding\n */\nexport const toSetCookieHeaders = (self: Cookies): Array<string> => Object.values(self.cookies).map(serializeCookie)\n\n/**\n * Parse a cookie header into a record of key-value pairs\n *\n * Adapted from https://github.com/fastify/fastify-cookie under MIT License\n *\n * @since 1.0.0\n * @category decoding\n */\nexport function parseHeader(header: string): Record<string, string> {\n  const result: Record<string, string> = {}\n\n  const strLen = header.length\n  let pos = 0\n  let terminatorPos = 0\n\n  while (true) {\n    if (terminatorPos === strLen) break\n    terminatorPos = header.indexOf(\";\", pos)\n    if (terminatorPos === -1) terminatorPos = strLen // This is the last pair\n\n    let eqIdx = header.indexOf(\"=\", pos)\n    if (eqIdx === -1) break // No key-value pairs left\n    if (eqIdx > terminatorPos) {\n      // Malformed key-value pair\n      pos = terminatorPos + 1\n      continue\n    }\n\n    const key = header.substring(pos, eqIdx++).trim()\n    if (result[key] === undefined) {\n      const val = header.charCodeAt(eqIdx) === 0x22\n        ? header.substring(eqIdx + 1, terminatorPos - 1).trim()\n        : header.substring(eqIdx, terminatorPos).trim()\n\n      result[key] = !(val.indexOf(\"%\") === -1)\n        ? tryDecodeURIComponent(val)\n        : val\n    }\n\n    pos = terminatorPos + 1\n  }\n\n  return result\n}\n\nconst tryDecodeURIComponent = (str: string): string => {\n  try {\n    return decodeURIComponent(str)\n  } catch {\n    return str\n  }\n}\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type { Layer } from \"effect/Layer\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Body from \"./HttpBody.js\"\nimport * as internal from \"./internal/etag.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Etag = Weak | Strong\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Weak {\n  readonly _tag: \"Weak\"\n  readonly value: string\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Strong {\n  readonly _tag: \"Strong\"\n  readonly value: string\n}\n\n/**\n * @since 1.0.0\n * @category convertions\n */\nexport const toString: (self: Etag) => string = internal.toString\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const GeneratorTypeId: unique symbol = internal.GeneratorTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type GeneratorTypeId = typeof GeneratorTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Generator {\n  readonly [GeneratorTypeId]: GeneratorTypeId\n  readonly fromFileInfo: (info: FileSystem.File.Info) => Effect.Effect<Etag>\n  readonly fromFileWeb: (file: Body.HttpBody.FileLike) => Effect.Effect<Etag>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Generator: Context.Tag<Generator, Generator> = internal.tag\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: Layer<Generator> = internal.layer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWeak: Layer<Generator> = internal.layerWeak\n", "import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Layer from \"effect/Layer\"\nimport type * as Etag from \"../Etag.js\"\nimport type * as FileSystem from \"../FileSystem.js\"\nimport type * as Body from \"../HttpBody.js\"\n\n/** @internal */\nexport const GeneratorTypeId: Etag.GeneratorTypeId = Symbol.for(\n  \"@effect/platform/Etag/Generator\"\n) as Etag.GeneratorTypeId\n\n/** @internal */\nexport const tag = Context.GenericTag<Etag.Generator>(\"@effect/platform/Etag/Generator\")\n\n/** @internal */\nexport const toString = (self: Etag.Etag): string => {\n  switch (self._tag) {\n    case \"Weak\":\n      return `W/\"${self.value}\"`\n    case \"Strong\":\n      return `\"${self.value}\"`\n  }\n}\n\nconst fromFileInfo = (info: FileSystem.File.Info) => {\n  const mtime = info.mtime._tag === \"Some\"\n    ? info.mtime.value.getTime().toString(16)\n    : \"0\"\n  return `${info.size.toString(16)}-${mtime}`\n}\n\nconst fromFileWeb = (file: Body.HttpBody.FileLike) => {\n  return `${file.size.toString(16)}-${file.lastModified.toString(16)}`\n}\n\n/** @internal */\nexport const layer = Layer.succeed(\n  tag,\n  tag.of({\n    [GeneratorTypeId]: GeneratorTypeId,\n    fromFileInfo(info) {\n      return Effect.sync(() => ({ _tag: \"Strong\", value: fromFileInfo(info) }))\n    },\n    fromFileWeb(file) {\n      return Effect.sync(() => ({ _tag: \"Strong\", value: fromFileWeb(file) }))\n    }\n  })\n)\n\n/** @internal */\nexport const layerWeak = Layer.succeed(\n  tag,\n  tag.of({\n    [GeneratorTypeId]: GeneratorTypeId,\n    fromFileInfo(info) {\n      return Effect.sync(() => ({ _tag: \"Weak\", value: fromFileInfo(info) }))\n    },\n    fromFileWeb(file) {\n      return Effect.sync(() => ({ _tag: \"Weak\", value: fromFileWeb(file) }))\n    }\n  })\n)\n", "/**\n * @since 1.0.0\n */\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberRefs from \"effect/FiberRefs\"\nimport { dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport { type Redactable, symbolRedactable } from \"effect/Inspectable\"\nimport type * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport * as Redacted from \"effect/Redacted\"\nimport * as Schema from \"effect/Schema\"\nimport * as String from \"effect/String\"\nimport type { Mutable } from \"effect/Types\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const HeadersTypeId: unique symbol = Symbol.for(\"@effect/platform/Headers\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type HeadersTypeId = typeof HeadersTypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHeaders = (u: unknown): u is Headers => Predicate.hasProperty(u, HeadersTypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Headers extends Redactable {\n  readonly [HeadersTypeId]: HeadersTypeId\n  readonly [key: string]: string\n}\n\nconst Proto = Object.assign(Object.create(null), {\n  [HeadersTypeId]: HeadersTypeId,\n  [symbolRedactable](\n    this: Headers,\n    fiberRefs: FiberRefs.FiberRefs\n  ): Record<string, string | Redacted.Redacted<string>> {\n    return redact(this, FiberRefs.getOrDefault(fiberRefs, currentRedactedNames))\n  }\n})\n\nconst make = (input: Record.ReadonlyRecord<string, string>): Mutable<Headers> =>\n  Object.assign(Object.create(Proto), input) as Headers\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schemaFromSelf: Schema.Schema<Headers> = Schema.declare(isHeaders, {\n  identifier: \"Headers\",\n  equivalence: () => Record.getEquivalence(String.Equivalence)\n})\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schema: Schema.Schema<Headers, Record.ReadonlyRecord<string, string>> = Schema\n  .transform(\n    Schema.Record({ key: Schema.String, value: Schema.String }),\n    schemaFromSelf,\n    { strict: true, decode: (record) => fromInput(record), encode: identity }\n  )\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Input =\n  | Record.ReadonlyRecord<string, string | ReadonlyArray<string> | undefined>\n  | Iterable<readonly [string, string]>\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Headers = Object.create(Proto)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromInput: (input?: Input) => Headers = (input) => {\n  if (input === undefined) {\n    return empty\n  } else if (Symbol.iterator in input) {\n    const out: Record<string, string> = Object.create(Proto)\n    for (const [k, v] of input) {\n      out[k.toLowerCase()] = v\n    }\n    return out as Headers\n  }\n  const out: Record<string, string> = Object.create(Proto)\n  for (const [k, v] of Object.entries(input)) {\n    if (Array.isArray(v)) {\n      out[k.toLowerCase()] = v.join(\", \")\n    } else if (v !== undefined) {\n      out[k.toLowerCase()] = v as string\n    }\n  }\n  return out as Headers\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeFromRecord = (input: Record.ReadonlyRecord<string, string>): Headers =>\n  Object.setPrototypeOf(input, Proto) as Headers\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const has: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: Headers) => boolean\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string): boolean\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string) => (self: Headers) => boolean,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string) => boolean\n>(2, (self, key) => key.toLowerCase() in self)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: Headers) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string): Option.Option<string>\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string) => (self: Headers) => Option.Option<string>,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string) => Option.Option<string>\n>(2, (self, key) => Record.get(self as Record<string, string>, key.toLowerCase()))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string, value: string): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string, value: string) => Headers\n>(3, (self, key, value) => {\n  const out = make(self)\n  out[key.toLowerCase()] = value\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Input): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Input): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Input) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Input) => Headers\n>(2, (self, headers) =>\n  make({\n    ...self,\n    ...fromInput(headers)\n  }))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const merge: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Headers): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Headers): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (headers: Headers) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, headers: Headers) => Headers\n>(2, (self, headers) => {\n  const out = make(self)\n  Object.assign(out, headers)\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>): (self: Headers) => Headers\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>): Headers\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>) => (self: Headers) => Headers,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>) => Headers\n>(2, (self, key) => {\n  const out = make(self)\n  const modify = (key: string | RegExp) => {\n    if (typeof key === \"string\") {\n      const k = key.toLowerCase()\n      if (k in self) {\n        delete out[k]\n      }\n    } else {\n      for (const name in self) {\n        if (key.test(name)) {\n          delete out[name]\n        }\n      }\n    }\n  }\n  if (Array.isArray(key)) {\n    for (let i = 0; i < key.length; i++) {\n      modify(key[i])\n    }\n  } else {\n    modify(key as string | RegExp)\n  }\n  return out\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const redact: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string | RegExp | ReadonlyArray<string | RegExp>): (self: Headers) => Record<string, string | Redacted.Redacted>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: Headers, key: string | RegExp | ReadonlyArray<string | RegExp>): Record<string, string | Redacted.Redacted>\n} = dual(\n  2,\n  (\n    self: Headers,\n    key: string | RegExp | ReadonlyArray<string | RegExp>\n  ): Record<string, string | Redacted.Redacted> => {\n    const out: Record<string, string | Redacted.Redacted> = { ...self }\n    const modify = (key: string | RegExp) => {\n      if (typeof key === \"string\") {\n        const k = key.toLowerCase()\n        if (k in self) {\n          out[k] = Redacted.make(self[k])\n        }\n      } else {\n        for (const name in self) {\n          if (key.test(name)) {\n            out[name] = Redacted.make(self[name])\n          }\n        }\n      }\n    }\n    if (Array.isArray(key)) {\n      for (let i = 0; i < key.length; i++) {\n        modify(key[i])\n      }\n    } else {\n      modify(key as string | RegExp)\n    }\n    return out\n  }\n)\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentRedactedNames: FiberRef.FiberRef<ReadonlyArray<string | RegExp>> = globalValue(\n  \"@effect/platform/Headers/currentRedactedNames\",\n  () =>\n    FiberRef.unsafeMake<ReadonlyArray<string | RegExp>>([\n      \"authorization\",\n      \"cookie\",\n      \"set-cookie\",\n      \"x-api-key\"\n    ])\n)\n", "/**\n * @since 1.0.0\n */\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Error from \"./Error.js\"\nimport type * as ClientRequest from \"./HttpClientRequest.js\"\nimport type * as ClientResponse from \"./HttpClientResponse.js\"\nimport * as internal from \"./internal/httpClientError.js\"\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isHttpClientError = (u: unknown): u is HttpClientError => hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport type HttpClientError = RequestError | ResponseError\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class RequestError extends Error.TypeIdError(TypeId, \"RequestError\")<{\n  readonly request: ClientRequest.HttpClientRequest\n  readonly reason: \"Transport\" | \"Encode\" | \"InvalidUrl\"\n  readonly cause?: unknown\n  readonly description?: string\n}> {\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    return this.description ?\n      `${this.reason}: ${this.description} (${this.methodAndUrl})` :\n      `${this.reason} error (${this.methodAndUrl})`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class ResponseError extends Error.TypeIdError(TypeId, \"ResponseError\")<{\n  readonly request: ClientRequest.HttpClientRequest\n  readonly response: ClientResponse.HttpClientResponse\n  readonly reason: \"StatusCode\" | \"Decode\" | \"EmptyBody\"\n  readonly cause?: unknown\n  readonly description?: string\n}> {\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    const info = `${this.response.status} ${this.methodAndUrl}`\n    return this.description ?\n      `${this.reason}: ${this.description} (${info})` :\n      `${this.reason} error (${info})`\n  }\n}\n", "import type * as Error from \"../HttpClientError.js\"\n\n/** @internal */\nexport const TypeId: Error.TypeId = Symbol.for(\n  \"@effect/platform/HttpClientError\"\n) as Error.TypeId\n", "/**\n * @since 1.0.0\n */\nimport * as Brand from \"effect/Brand\"\nimport type { Tag } from \"effect/Context\"\nimport * as Context from \"effect/Context\"\nimport * as Data from \"effect/Data\"\nimport type * as Effect from \"effect/Effect\"\nimport type { Layer } from \"effect/Layer\"\nimport type { Option } from \"effect/Option\"\nimport type { Scope } from \"effect/Scope\"\nimport type { Sink } from \"effect/Sink\"\nimport type { Stream } from \"effect/Stream\"\nimport type { PlatformError } from \"./Error.js\"\nimport * as internal from \"./internal/fileSystem.js\"\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport interface FileSystem {\n  /**\n   * Check if a file can be accessed.\n   * You can optionally specify the level of access to check for.\n   */\n  readonly access: (\n    path: string,\n    options?: AccessFileOptions\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Copy a file or directory from `fromPath` to `toPath`.\n   *\n   * Equivalent to `cp -r`.\n   */\n  readonly copy: (\n    fromPath: string,\n    toPath: string,\n    options?: CopyOptions\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Copy a file from `fromPath` to `toPath`.\n   */\n  readonly copyFile: (\n    fromPath: string,\n    toPath: string\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Change the permissions of a file.\n   */\n  readonly chmod: (\n    path: string,\n    mode: number\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Change the owner and group of a file.\n   */\n  readonly chown: (\n    path: string,\n    uid: number,\n    gid: number\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Check if a path exists.\n   */\n  readonly exists: (\n    path: string\n  ) => Effect.Effect<boolean, PlatformError>\n  /**\n   * Create a hard link from `fromPath` to `toPath`.\n   */\n  readonly link: (\n    fromPath: string,\n    toPath: string\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Create a directory at `path`. You can optionally specify the mode and\n   * whether to recursively create nested directories.\n   */\n  readonly makeDirectory: (\n    path: string,\n    options?: MakeDirectoryOptions\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Create a temporary directory.\n   *\n   * By default the directory will be created inside the system's default\n   * temporary directory, but you can specify a different location by setting\n   * the `directory` option.\n   *\n   * You can also specify a prefix for the directory name by setting the\n   * `prefix` option.\n   */\n  readonly makeTempDirectory: (\n    options?: MakeTempDirectoryOptions\n  ) => Effect.Effect<string, PlatformError>\n  /**\n   * Create a temporary directory inside a scope.\n   *\n   * Functionally equivalent to `makeTempDirectory`, but the directory will be\n   * automatically deleted when the scope is closed.\n   */\n  readonly makeTempDirectoryScoped: (\n    options?: MakeTempDirectoryOptions\n  ) => Effect.Effect<string, PlatformError, Scope>\n  /**\n   * Create a temporary file.\n   * The directory creation is functionally equivalent to `makeTempDirectory`.\n   * The file name will be a randomly generated string.\n   */\n  readonly makeTempFile: (\n    options?: MakeTempFileOptions\n  ) => Effect.Effect<string, PlatformError>\n  /**\n   * Create a temporary file inside a scope.\n   *\n   * Functionally equivalent to `makeTempFile`, but the file will be\n   * automatically deleted when the scope is closed.\n   */\n  readonly makeTempFileScoped: (\n    options?: MakeTempFileOptions\n  ) => Effect.Effect<string, PlatformError, Scope>\n  /**\n   * Open a file at `path` with the specified `options`.\n   *\n   * The file handle will be automatically closed when the scope is closed.\n   */\n  readonly open: (\n    path: string,\n    options?: OpenFileOptions\n  ) => Effect.Effect<File, PlatformError, Scope>\n  /**\n   * List the contents of a directory.\n   *\n   * You can recursively list the contents of nested directories by setting the\n   * `recursive` option.\n   */\n  readonly readDirectory: (\n    path: string,\n    options?: ReadDirectoryOptions\n  ) => Effect.Effect<Array<string>, PlatformError>\n  /**\n   * Read the contents of a file.\n   */\n  readonly readFile: (\n    path: string\n  ) => Effect.Effect<Uint8Array, PlatformError>\n  /**\n   * Read the contents of a file.\n   */\n  readonly readFileString: (\n    path: string,\n    encoding?: string\n  ) => Effect.Effect<string, PlatformError>\n  /**\n   * Read the destination of a symbolic link.\n   */\n  readonly readLink: (\n    path: string\n  ) => Effect.Effect<string, PlatformError>\n  /**\n   * Resolve a path to its canonicalized absolute pathname.\n   */\n  readonly realPath: (\n    path: string\n  ) => Effect.Effect<string, PlatformError>\n  /**\n   * Remove a file or directory.\n   */\n  readonly remove: (\n    path: string,\n    options?: RemoveOptions\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Rename a file or directory.\n   */\n  readonly rename: (\n    oldPath: string,\n    newPath: string\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Create a writable `Sink` for the specified `path`.\n   */\n  readonly sink: (\n    path: string,\n    options?: SinkOptions\n  ) => Sink<void, Uint8Array, never, PlatformError>\n  /**\n   * Get information about a file at `path`.\n   */\n  readonly stat: (\n    path: string\n  ) => Effect.Effect<File.Info, PlatformError>\n  /**\n   * Create a readable `Stream` for the specified `path`.\n   *\n   * Changing the `bufferSize` option will change the internal buffer size of\n   * the stream. It defaults to `4`.\n   *\n   * The `chunkSize` option will change the size of the chunks emitted by the\n   * stream. It defaults to 64kb.\n   *\n   * Changing `offset` and `bytesToRead` will change the offset and the number\n   * of bytes to read from the file.\n   */\n  readonly stream: (\n    path: string,\n    options?: StreamOptions\n  ) => Stream<Uint8Array, PlatformError>\n  /**\n   * Create a symbolic link from `fromPath` to `toPath`.\n   */\n  readonly symlink: (\n    fromPath: string,\n    toPath: string\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Truncate a file to a specified length. If the `length` is not specified,\n   * the file will be truncated to length `0`.\n   */\n  readonly truncate: (\n    path: string,\n    length?: SizeInput\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Change the file system timestamps of the file at `path`.\n   */\n  readonly utimes: (\n    path: string,\n    atime: Date | number,\n    mtime: Date | number\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Watch a directory or file for changes.\n   *\n   * By default, only changes to the direct children of the directory are reported.\n   * Set the `recursive` option to `true` to watch for changes in subdirectories as well.\n   *\n   * Note: The `recursive` option is only supported on macOS and Windows.\n   * On other platforms, it will be ignored.\n   */\n  readonly watch: (path: string, options?: WatchOptions) => Stream<WatchEvent, PlatformError>\n  /**\n   * Write data to a file at `path`.\n   */\n  readonly writeFile: (\n    path: string,\n    data: Uint8Array,\n    options?: WriteFileOptions\n  ) => Effect.Effect<void, PlatformError>\n  /**\n   * Write a string to a file at `path`.\n   */\n  readonly writeFileString: (\n    path: string,\n    data: string,\n    options?: WriteFileStringOptions\n  ) => Effect.Effect<void, PlatformError>\n}\n\n/**\n * Represents a size in bytes.\n *\n * @since 1.0.0\n * @category sizes\n */\nexport type Size = Brand.Branded<bigint, \"Size\">\n\n/**\n * Represents a size in bytes.\n *\n * @since 1.0.0\n * @category sizes\n */\nexport type SizeInput = bigint | number | Size\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const Size: (bytes: SizeInput) => Size = internal.Size\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const KiB: (n: number) => Size = internal.KiB\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const MiB: (n: number) => Size = internal.MiB\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const GiB: (n: number) => Size = internal.GiB\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const TiB: (n: number) => Size = internal.TiB\n\n/**\n * @since 1.0.0\n * @category sizes\n */\nexport const PiB: (n: number) => Size = internal.PiB\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport type OpenFlag =\n  | \"r\"\n  | \"r+\"\n  | \"w\"\n  | \"wx\"\n  | \"w+\"\n  | \"wx+\"\n  | \"a\"\n  | \"ax\"\n  | \"a+\"\n  | \"ax+\"\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface AccessFileOptions {\n  readonly ok?: boolean\n  readonly readable?: boolean\n  readonly writable?: boolean\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface MakeDirectoryOptions {\n  readonly recursive?: boolean\n  readonly mode?: number\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface CopyOptions {\n  readonly overwrite?: boolean\n  readonly preserveTimestamps?: boolean\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface MakeTempDirectoryOptions {\n  readonly directory?: string\n  readonly prefix?: string\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface MakeTempFileOptions {\n  readonly directory?: string\n  readonly prefix?: string\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface OpenFileOptions {\n  readonly flag?: OpenFlag\n  readonly mode?: number\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface ReadDirectoryOptions {\n  readonly recursive?: boolean\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface RemoveOptions {\n  /**\n   * When `true`, you can recursively remove nested directories.\n   */\n  readonly recursive?: boolean\n  /**\n   * When `true`, exceptions will be ignored if `path` does not exist.\n   */\n  readonly force?: boolean\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface SinkOptions extends OpenFileOptions {}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface StreamOptions {\n  readonly bufferSize?: number\n  readonly bytesToRead?: SizeInput\n  readonly chunkSize?: SizeInput\n  readonly offset?: SizeInput\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface WriteFileOptions {\n  readonly flag?: OpenFlag\n  readonly mode?: number\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface WriteFileStringOptions {\n  readonly flag?: OpenFlag\n  readonly mode?: number\n}\n\n/**\n * @since 1.0.0\n * @category options\n */\nexport interface WatchOptions {\n  /**\n   * When `true`, the watcher will also watch for changes in subdirectories.\n   */\n  readonly recursive?: boolean\n}\n\n/**\n * @since 1.0.0\n * @category tag\n */\nexport const FileSystem: Tag<FileSystem, FileSystem> = internal.tag\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nexport const make: (\n  impl: Omit<FileSystem, \"exists\" | \"readFileString\" | \"stream\" | \"sink\" | \"writeFileString\">\n) => FileSystem = internal.make\n\n/**\n * Create a no-op file system that can be used for testing.\n *\n * @since 1.0.0\n * @category constructor\n */\nexport const makeNoop: (fileSystem: Partial<FileSystem>) => FileSystem = internal.makeNoop\n\n/**\n * Create a no-op file system that can be used for testing.\n *\n * @since 1.0.0\n * @category layers\n */\nexport const layerNoop: (fileSystem: Partial<FileSystem>) => Layer<FileSystem> = internal.layerNoop\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport const FileTypeId: unique symbol = Symbol.for(\n  \"@effect/platform/FileSystem/File\"\n)\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport type FileTypeId = typeof FileTypeId\n\n/**\n * @since 1.0.0\n * @category guard\n */\nexport const isFile = (u: unknown): u is File => typeof u === \"object\" && u !== null && FileTypeId in u\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport interface File {\n  readonly [FileTypeId]: FileTypeId\n  readonly fd: File.Descriptor\n  readonly stat: Effect.Effect<File.Info, PlatformError>\n  readonly seek: (offset: SizeInput, from: SeekMode) => Effect.Effect<void>\n  readonly sync: Effect.Effect<void, PlatformError>\n  readonly read: (buffer: Uint8Array) => Effect.Effect<Size, PlatformError>\n  readonly readAlloc: (size: SizeInput) => Effect.Effect<Option<Uint8Array>, PlatformError>\n  readonly truncate: (length?: SizeInput) => Effect.Effect<void, PlatformError>\n  readonly write: (buffer: Uint8Array) => Effect.Effect<Size, PlatformError>\n  readonly writeAll: (buffer: Uint8Array) => Effect.Effect<void, PlatformError>\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace File {\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export type Descriptor = Brand.Branded<number, \"FileDescriptor\">\n\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export type Type =\n    | \"File\"\n    | \"Directory\"\n    | \"SymbolicLink\"\n    | \"BlockDevice\"\n    | \"CharacterDevice\"\n    | \"FIFO\"\n    | \"Socket\"\n    | \"Unknown\"\n\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export interface Info {\n    readonly type: Type\n    readonly mtime: Option<Date>\n    readonly atime: Option<Date>\n    readonly birthtime: Option<Date>\n    readonly dev: number\n    readonly ino: Option<number>\n    readonly mode: number\n    readonly nlink: Option<number>\n    readonly uid: Option<number>\n    readonly gid: Option<number>\n    readonly rdev: Option<number>\n    readonly size: Size\n    readonly blksize: Option<Size>\n    readonly blocks: Option<number>\n  }\n}\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nexport const FileDescriptor = Brand.nominal<File.Descriptor>()\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport type SeekMode = \"start\" | \"current\"\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport type WatchEvent = WatchEvent.Create | WatchEvent.Update | WatchEvent.Remove\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport declare namespace WatchEvent {\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export interface Create {\n    readonly _tag: \"Create\"\n    readonly path: string\n  }\n\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export interface Update {\n    readonly _tag: \"Update\"\n    readonly path: string\n  }\n\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export interface Remove {\n    readonly _tag: \"Remove\"\n    readonly path: string\n  }\n}\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nexport const WatchEventCreate: Data.Case.Constructor<WatchEvent.Create, \"_tag\"> = Data.tagged<WatchEvent.Create>(\n  \"Create\"\n)\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nexport const WatchEventUpdate: Data.Case.Constructor<WatchEvent.Update, \"_tag\"> = Data.tagged<WatchEvent.Update>(\n  \"Update\"\n)\n\n/**\n * @since 1.0.0\n * @category constructor\n */\nexport const WatchEventRemove: Data.Case.Constructor<WatchEvent.Remove, \"_tag\"> = Data.tagged<WatchEvent.Remove>(\n  \"Remove\"\n)\n\n/**\n * @since 1.0.0\n * @category file watcher\n */\nexport class WatchBackend extends Context.Tag(\"@effect/platform/FileSystem/WatchBackend\")<\n  WatchBackend,\n  {\n    readonly register: (\n      path: string,\n      stat: File.Info,\n      options?: WatchOptions\n    ) => Option<Stream<WatchEvent, PlatformError>>\n  }\n>() {\n}\n", "import * as Channel from \"effect/Channel\"\nimport * as Chunk from \"effect/Chunk\"\nimport { GenericTag } from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Option from \"effect/Option\"\nimport * as Sink from \"effect/Sink\"\nimport * as Stream from \"effect/Stream\"\nimport * as Error from \"../Error.js\"\nimport type { File, FileSystem, Size as Size_, SizeInput, StreamOptions } from \"../FileSystem.js\"\n\n/** @internal */\nexport const tag = GenericTag<FileSystem>(\"@effect/platform/FileSystem\")\n\n/** @internal */\nexport const Size = (bytes: SizeInput) => typeof bytes === \"bigint\" ? bytes as Size_ : BigInt(bytes) as Size_\n\n/** @internal */\nexport const KiB = (n: number) => Size(n * 1024)\n\n/** @internal */\nexport const MiB = (n: number) => Size(n * 1024 * 1024)\n\n/** @internal */\nexport const GiB = (n: number) => Size(n * 1024 * 1024 * 1024)\n\n/** @internal */\nexport const TiB = (n: number) => Size(n * 1024 * 1024 * 1024 * 1024)\n\nconst bigint1024 = BigInt(1024)\nconst bigintPiB = bigint1024 * bigint1024 * bigint1024 * bigint1024 * bigint1024\n\n/** @internal */\nexport const PiB = (n: number) => Size(BigInt(n) * bigintPiB)\n\n/** @internal */\nexport const make = (\n  impl: Omit<FileSystem, \"exists\" | \"readFileString\" | \"stream\" | \"sink\" | \"writeFileString\">\n): FileSystem => {\n  return tag.of({\n    ...impl,\n    exists: (path) =>\n      pipe(\n        impl.access(path),\n        Effect.as(true),\n        Effect.catchTag(\"SystemError\", (e) => e.reason === \"NotFound\" ? Effect.succeed(false) : Effect.fail(e))\n      ),\n    readFileString: (path, encoding) =>\n      Effect.tryMap(impl.readFile(path), {\n        try: (_) => new TextDecoder(encoding).decode(_),\n        catch: (cause) =>\n          new Error.BadArgument({\n            module: \"FileSystem\",\n            method: \"readFileString\",\n            description: \"invalid encoding\",\n            cause\n          })\n      }),\n    stream: (path, options) =>\n      pipe(\n        impl.open(path, { flag: \"r\" }),\n        options?.offset ?\n          Effect.tap((file) => file.seek(options.offset!, \"start\")) :\n          identity,\n        Effect.map((file) => stream(file, options)),\n        Stream.unwrapScoped\n      ),\n    sink: (path, options) =>\n      pipe(\n        impl.open(path, { flag: \"w\", ...options }),\n        Effect.map((file) => Sink.forEach((_: Uint8Array) => file.writeAll(_))),\n        Sink.unwrapScoped\n      ),\n    writeFileString: (path, data, options) =>\n      Effect.flatMap(\n        Effect.try({\n          try: () => new TextEncoder().encode(data),\n          catch: (cause) =>\n            new Error.BadArgument({\n              module: \"FileSystem\",\n              method: \"writeFileString\",\n              description: \"could not encode string\",\n              cause\n            })\n        }),\n        (_) => impl.writeFile(path, _, options)\n      )\n  })\n}\n\nconst notFound = (method: string, path: string) =>\n  new Error.SystemError({\n    module: \"FileSystem\",\n    method,\n    reason: \"NotFound\",\n    description: \"No such file or directory\",\n    pathOrDescriptor: path\n  })\n\n/** @internal */\nexport const makeNoop = (\n  fileSystem: Partial<FileSystem>\n): FileSystem => {\n  return {\n    access(path) {\n      return Effect.fail(notFound(\"access\", path))\n    },\n    chmod(path) {\n      return Effect.fail(notFound(\"chmod\", path))\n    },\n    chown(path) {\n      return Effect.fail(notFound(\"chown\", path))\n    },\n    copy(path) {\n      return Effect.fail(notFound(\"copy\", path))\n    },\n    copyFile(path) {\n      return Effect.fail(notFound(\"copyFile\", path))\n    },\n    exists() {\n      return Effect.succeed(false)\n    },\n    link(path) {\n      return Effect.fail(notFound(\"link\", path))\n    },\n    makeDirectory() {\n      return Effect.die(\"not implemented\")\n    },\n    makeTempDirectory() {\n      return Effect.die(\"not implemented\")\n    },\n    makeTempDirectoryScoped() {\n      return Effect.die(\"not implemented\")\n    },\n    makeTempFile() {\n      return Effect.die(\"not implemented\")\n    },\n    makeTempFileScoped() {\n      return Effect.die(\"not implemented\")\n    },\n    open(path) {\n      return Effect.fail(notFound(\"open\", path))\n    },\n    readDirectory(path) {\n      return Effect.fail(notFound(\"readDirectory\", path))\n    },\n    readFile(path) {\n      return Effect.fail(notFound(\"readFile\", path))\n    },\n    readFileString(path) {\n      return Effect.fail(notFound(\"readFileString\", path))\n    },\n    readLink(path) {\n      return Effect.fail(notFound(\"readLink\", path))\n    },\n    realPath(path) {\n      return Effect.fail(notFound(\"realPath\", path))\n    },\n    remove() {\n      return Effect.void\n    },\n    rename(oldPath) {\n      return Effect.fail(notFound(\"rename\", oldPath))\n    },\n    sink(path) {\n      return Sink.fail(notFound(\"sink\", path))\n    },\n    stat(path) {\n      return Effect.fail(notFound(\"stat\", path))\n    },\n    stream(path) {\n      return Stream.fail(notFound(\"stream\", path))\n    },\n    symlink(fromPath) {\n      return Effect.fail(notFound(\"symlink\", fromPath))\n    },\n    truncate(path) {\n      return Effect.fail(notFound(\"truncate\", path))\n    },\n    utimes(path) {\n      return Effect.fail(notFound(\"utimes\", path))\n    },\n    watch(path) {\n      return Stream.fail(notFound(\"watch\", path))\n    },\n    writeFile(path) {\n      return Effect.fail(notFound(\"writeFile\", path))\n    },\n    writeFileString(path) {\n      return Effect.fail(notFound(\"writeFileString\", path))\n    },\n    ...fileSystem\n  }\n}\n\n/** @internal */\nexport const layerNoop = (\n  fileSystem: Partial<FileSystem>\n): Layer.Layer<FileSystem> => Layer.succeed(tag, makeNoop(fileSystem))\n\n/** @internal */\nconst stream = (file: File, {\n  bufferSize = 16,\n  bytesToRead: bytesToRead_,\n  chunkSize: chunkSize_ = Size(64 * 1024)\n}: StreamOptions = {}) => {\n  const bytesToRead = bytesToRead_ !== undefined ? Size(bytesToRead_) : undefined\n  const chunkSize = Size(chunkSize_)\n\n  function loop(\n    totalBytesRead: bigint\n  ): Channel.Channel<Chunk.Chunk<Uint8Array>, unknown, Error.PlatformError, unknown, void, unknown> {\n    if (bytesToRead !== undefined && bytesToRead <= totalBytesRead) {\n      return Channel.void\n    }\n\n    const toRead = bytesToRead !== undefined && (bytesToRead - totalBytesRead) < chunkSize\n      ? bytesToRead - totalBytesRead\n      : chunkSize\n\n    return Channel.flatMap(\n      file.readAlloc(toRead),\n      Option.match({\n        onNone: () => Channel.void,\n        onSome: (buf) =>\n          Channel.flatMap(\n            Channel.write(Chunk.of(buf)),\n            (_) => loop(totalBytesRead + BigInt(buf.length))\n          )\n      })\n    )\n  }\n\n  return Stream.bufferChunks(\n    Stream.fromChannel(loop(BigInt(0))),\n    { capacity: bufferSize }\n  )\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Arr from \"effect/Array\"\nimport type * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface UrlParams extends ReadonlyArray<readonly [string, string]> {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Input =\n  | CoercibleRecord\n  | Iterable<readonly [string, Coercible]>\n  | URLSearchParams\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Coercible = string | number | bigint | boolean | null | undefined\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface CoercibleRecord {\n  readonly [key: string]: Coercible | ReadonlyArray<Coercible> | CoercibleRecord\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromInput = (input: Input): UrlParams => {\n  const parsed = fromInputNested(input)\n  const out: Array<[string, string]> = []\n  for (let i = 0; i < parsed.length; i++) {\n    if (Array.isArray(parsed[i][0])) {\n      const [keys, value] = parsed[i] as [Array<string>, string]\n      out.push([`${keys[0]}[${keys.slice(1).join(\"][\")}]`, value])\n    } else {\n      out.push(parsed[i] as [string, string])\n    }\n  }\n  return out\n}\n\nconst fromInputNested = (input: Input): Array<[string | Array<string>, any]> => {\n  const entries = Symbol.iterator in input ? Arr.fromIterable(input) : Object.entries(input)\n  const out: Array<[string | Array<string>, string]> = []\n  for (const [key, value] of entries) {\n    if (Array.isArray(value)) {\n      for (let i = 0; i < value.length; i++) {\n        if (value[i] !== undefined) {\n          out.push([key, String(value[i])])\n        }\n      }\n    } else if (typeof value === \"object\") {\n      const nested = fromInputNested(value as CoercibleRecord)\n      for (const [k, v] of nested) {\n        out.push([[key, ...(typeof k === \"string\" ? [k] : k)], v])\n      }\n    } else if (value !== undefined) {\n      out.push([key, String(value)])\n    }\n  }\n  return out\n}\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schemaFromSelf: Schema.Schema<UrlParams> = Schema.Array(\n  Schema.Tuple(Schema.String, Schema.String)\n).annotations({ identifier: \"UrlParams\" })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: UrlParams = []\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => ReadonlyArray<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): ReadonlyArray<string>\n} = dual(\n  2,\n  (self: UrlParams, key: string): ReadonlyArray<string> =>\n    Arr.reduce(self, [] as Array<string>, (acc, [k, value]) => {\n      if (k === key) {\n        acc.push(value)\n      }\n      return acc\n    })\n)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getFirst: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): Option.Option<string>\n} = dual(2, (self: UrlParams, key: string): Option.Option<string> =>\n  Option.map(\n    Arr.findFirst(self, ([k]) => k === key),\n    ([, value]) => value\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const getLast: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => Option.Option<string>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): Option.Option<string>\n} = dual(2, (self: UrlParams, key: string): Option.Option<string> =>\n  Option.map(\n    Arr.findLast(self, ([k]) => k === key),\n    ([, value]) => value\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const set: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: Coercible): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string, value: Coercible): UrlParams\n} = dual(3, (self: UrlParams, key: string, value: Coercible): UrlParams =>\n  Arr.append(\n    Arr.filter(self, ([k]) => k !== key),\n    [key, String(value)]\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Input): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, input: Input): UrlParams\n} = dual(2, (self: UrlParams, input: Input): UrlParams => {\n  const toSet = fromInput(input)\n  const keys = toSet.map(([k]) => k)\n  return Arr.appendAll(\n    Arr.filter(self, ([k]) => keys.includes(k)),\n    toSet\n  )\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const append: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: Coercible): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string, value: Coercible): UrlParams\n} = dual(3, (self: UrlParams, key: string, value: Coercible): UrlParams =>\n  Arr.append(\n    self,\n    [key, String(value)]\n  ))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Input): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, input: Input): UrlParams\n} = dual(2, (self: UrlParams, input: Input): UrlParams => Arr.appendAll(self, fromInput(input)))\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const remove: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string): (self: UrlParams) => UrlParams\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: UrlParams, key: string): UrlParams\n} = dual(2, (self: UrlParams, key: string): UrlParams => Arr.filter(self, ([k]) => k !== key))\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const makeUrl = (url: string, params: UrlParams, hash: Option.Option<string>): Either.Either<URL, Error> => {\n  try {\n    const urlInstance = new URL(url, baseUrl())\n    for (let i = 0; i < params.length; i++) {\n      const [key, value] = params[i]\n      if (value !== undefined) {\n        urlInstance.searchParams.append(key, value)\n      }\n    }\n    if (hash._tag === \"Some\") {\n      urlInstance.hash = hash.value\n    }\n    return Either.right(urlInstance)\n  } catch (e) {\n    return Either.left(e as Error)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toString = (self: UrlParams): string => new URLSearchParams(self as any).toString()\n\nconst baseUrl = (): string | undefined => {\n  if (\n    \"location\" in globalThis &&\n    globalThis.location !== undefined &&\n    globalThis.location.origin !== undefined &&\n    globalThis.location.pathname !== undefined\n  ) {\n    return location.origin + location.pathname\n  }\n  return undefined\n}\n\n/**\n * Builds a `Record` containing all the key-value pairs in the given `UrlParams`\n * as `string` (if only one value for a key) or a `NonEmptyArray<string>`\n * (when more than one value for a key)\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { UrlParams } from \"@effect/platform\"\n *\n * const urlParams = UrlParams.fromInput({ a: 1, b: true, c: \"string\", e: [1, 2, 3] })\n * const result = UrlParams.toRecord(urlParams)\n *\n * assert.deepStrictEqual(\n *   result,\n *   { \"a\": \"1\", \"b\": \"true\", \"c\": \"string\", \"e\": [\"1\", \"2\", \"3\"] }\n * )\n * ```\n *\n * @since 1.0.0\n * @category conversions\n */\nexport const toRecord = (self: UrlParams): Record<string, string | Arr.NonEmptyArray<string>> => {\n  const out: Record<string, string | Arr.NonEmptyArray<string>> = Object.create(null)\n  for (const [k, value] of self) {\n    const curr = out[k]\n    if (curr === undefined) {\n      out[k] = value\n    } else if (typeof curr === \"string\") {\n      out[k] = [curr, value]\n    } else {\n      curr.push(value)\n    }\n  }\n  return { ...out }\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined): {\n  (\n    field: string\n  ): (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>\n  (\n    self: UrlParams,\n    field: string\n  ): Effect.Effect<A, ParseResult.ParseError, R>\n} => {\n  const parse = Schema.decodeUnknown(Schema.parseJson(schema), options)\n  return dual<\n    (field: string) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>,\n    (self: UrlParams, field: string) => Effect.Effect<A, ParseResult.ParseError, R>\n  >(2, (self, field) => parse(Option.getOrElse(getLast(self, field), () => \"\")))\n}\n\n/**\n * Extract schema from all key-value pairs in the given `UrlParams`.\n *\n * **Example**\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Effect, Schema } from \"effect\"\n * import { UrlParams } from \"@effect/platform\"\n *\n * Effect.gen(function* () {\n *   const urlParams = UrlParams.fromInput({ \"a\": [10, \"string\"], \"b\": false })\n *   const result = yield* UrlParams.schemaStruct(Schema.Struct({\n *     a: Schema.Tuple(Schema.NumberFromString, Schema.String),\n *     b: Schema.BooleanFromString\n *   }))(urlParams)\n *\n *   assert.deepStrictEqual(result, {\n *     a: [10, \"string\"],\n *     b: false\n *   })\n * })\n * ```\n *\n * @since 1.0.0\n * @category schema\n */\nexport const schemaStruct = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) =>\n(self: UrlParams): Effect.Effect<A, ParseResult.ParseError, R> => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return parse(toRecord(self))\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaFromString: Schema.Schema<UrlParams, string> = Schema.transform(\n  Schema.String,\n  schemaFromSelf,\n  {\n    decode(fromA) {\n      return fromInput(new URLSearchParams(fromA))\n    },\n    encode(toI) {\n      return toString(toI)\n    }\n  }\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaRecord = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>\n): Schema.Schema<A, UrlParams, R> =>\n  Schema.transform(\n    schemaFromSelf,\n    schema,\n    {\n      decode(fromA) {\n        return toRecord(fromA) as I\n      },\n      encode(toI) {\n        return fromInput(toI as Input) as UrlParams\n      }\n    }\n  )\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaParse = <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(\n  schema: Schema.Schema<A, I, R>\n): Schema.Schema<A, string, R> =>\n  Schema.compose(\n    schemaFromString,\n    schemaRecord(schema)\n  )\n", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpIncomingMessage\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpIncomingMessage<E> extends Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly headers: Headers.Headers\n  readonly remoteAddress: Option.Option<string>\n  readonly json: Effect.Effect<unknown, E>\n  readonly text: Effect.Effect<string, E>\n  readonly urlParamsBody: Effect.Effect<UrlParams.UrlParams, E>\n  readonly arrayBuffer: Effect.Effect<ArrayBuffer, E>\n  readonly stream: Stream.Stream<Uint8Array, E>\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, E | ParseResult.ParseError, R> =>\n    Effect.flatMap(self.json, parse)\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyUrlParams = <\n  A,\n  I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>,\n  R\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const decode = UrlParams.schemaStruct(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, E | ParseResult.ParseError, R> =>\n    Effect.flatMap(self.urlParamsBody, decode)\n}\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaHeaders = <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return <E>(self: HttpIncomingMessage<E>): Effect.Effect<A, ParseResult.ParseError, R> => parse(self.headers)\n}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxBodySize extends Context.Reference<MaxBodySize>()(\"@effect/platform/HttpIncomingMessage/MaxBodySize\", {\n  defaultValue: Option.none<FileSystem.Size>\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxBodySize = dual<\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (size: Option.Option<FileSystem.SizeInput>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: Option.Option<FileSystem.SizeInput>) => Effect.Effect<A, E, R>\n>(2, (effect, size) => Effect.provideService(effect, MaxBodySize, Option.map(size, FileSystem.Size)))\n\n/**\n * @since 1.0.0\n */\nexport const inspect = <E>(self: HttpIncomingMessage<E>, that: object): object => {\n  const contentType = self.headers[\"content-type\"] ?? \"\"\n  let body: unknown\n  if (contentType.includes(\"application/json\")) {\n    try {\n      body = Effect.runSync(self.json)\n    } catch {\n      //\n    }\n  } else if (contentType.includes(\"text/\") || contentType.includes(\"urlencoded\")) {\n    try {\n      body = Effect.runSync(self.text)\n    } catch {\n      //\n    }\n  }\n  const obj: any = {\n    ...that,\n    headers: Inspectable.redact(self.headers),\n    remoteAddress: self.remoteAddress.toJSON()\n  }\n  if (body !== undefined) {\n    obj.body = body\n  }\n  return obj\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Option from \"effect/Option\"\nimport * as Tracer from \"effect/Tracer\"\nimport * as Headers from \"./Headers.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FromHeaders {\n  (headers: Headers.Headers): Option.Option<Tracer.ExternalSpan>\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const toHeaders = (span: Tracer.Span): Headers.Headers =>\n  Headers.unsafeFromRecord({\n    b3: `${span.traceId}-${span.spanId}-${span.sampled ? \"1\" : \"0\"}${\n      span.parent._tag === \"Some\" ? `-${span.parent.value.spanId}` : \"\"\n    }`,\n    traceparent: `00-${span.traceId}-${span.spanId}-${span.sampled ? \"01\" : \"00\"}`\n  })\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const fromHeaders = (headers: Headers.Headers): Option.Option<Tracer.ExternalSpan> => {\n  let span = w3c(headers)\n  if (span._tag === \"Some\") {\n    return span\n  }\n  span = b3(headers)\n  if (span._tag === \"Some\") {\n    return span\n  }\n  return xb3(headers)\n}\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const b3: FromHeaders = (headers) => {\n  if (!(\"b3\" in headers)) {\n    return Option.none()\n  }\n  const parts = headers[\"b3\"].split(\"-\")\n  if (parts.length < 2) {\n    return Option.none()\n  }\n  return Option.some(Tracer.externalSpan({\n    traceId: parts[0],\n    spanId: parts[1],\n    sampled: parts[2] ? parts[2] === \"1\" : true\n  }))\n}\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const xb3: FromHeaders = (headers) => {\n  if (!(headers[\"x-b3-traceid\"]) || !(headers[\"x-b3-spanid\"])) {\n    return Option.none()\n  }\n  return Option.some(Tracer.externalSpan({\n    traceId: headers[\"x-b3-traceid\"],\n    spanId: headers[\"x-b3-spanid\"],\n    sampled: headers[\"x-b3-sampled\"] ? headers[\"x-b3-sampled\"] === \"1\" : true\n  }))\n}\n\nconst w3cTraceId = /^[0-9a-f]{32}$/i\nconst w3cSpanId = /^[0-9a-f]{16}$/i\n\n/**\n * @since 1.0.0\n * @category decoding\n */\nexport const w3c: FromHeaders = (headers) => {\n  if (!(headers[\"traceparent\"])) {\n    return Option.none()\n  }\n  const parts = headers[\"traceparent\"].split(\"-\")\n  if (parts.length !== 4) {\n    return Option.none()\n  }\n  const [version, traceId, spanId, flags] = parts\n  switch (version) {\n    case \"00\": {\n      if (w3cTraceId.test(traceId) === false || w3cSpanId.test(spanId) === false) {\n        return Option.none()\n      }\n      return Option.some(Tracer.externalSpan({\n        traceId,\n        spanId,\n        sampled: (parseInt(flags, 16) & 1) === 1\n      }))\n    }\n    default: {\n      return Option.none()\n    }\n  }\n}\n", "/**\n * @since 1.0.0\n */\nimport type { Brand } from \"effect/Brand\"\nimport * as Effect from \"effect/Effect\"\nimport * as Effectable from \"effect/Effectable\"\nimport type { LazyArg } from \"effect/Function\"\nimport { constant, constVoid, dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport type * as Option from \"effect/Option\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as AST from \"effect/SchemaAST\"\nimport * as Struct from \"effect/Struct\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Multipart_ from \"./Multipart.js\"\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipart: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationMultipart\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationMultipartStream: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationMultipartStream\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationStatus: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationStatus\")\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEmptyDecodeable: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationEmptyDecodeable\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationEncoding: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/AnnotationEncoding\")\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const AnnotationParam: unique symbol = Symbol.for(\n  \"@effect/platform/HttpApiSchema/AnnotationParam\"\n)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const extractAnnotations = (ast: AST.Annotations): AST.Annotations => {\n  const result: Record<symbol, unknown> = {}\n  if (AnnotationStatus in ast) {\n    result[AnnotationStatus] = ast[AnnotationStatus]\n  }\n  if (AnnotationEmptyDecodeable in ast) {\n    result[AnnotationEmptyDecodeable] = ast[AnnotationEmptyDecodeable]\n  }\n  if (AnnotationEncoding in ast) {\n    result[AnnotationEncoding] = ast[AnnotationEncoding]\n  }\n  if (AnnotationParam in ast) {\n    result[AnnotationParam] = ast[AnnotationParam]\n  }\n  if (AnnotationMultipart in ast) {\n    result[AnnotationMultipart] = ast[AnnotationMultipart]\n  }\n  if (AnnotationMultipartStream in ast) {\n    result[AnnotationMultipartStream] = ast[AnnotationMultipartStream]\n  }\n  return result\n}\n\nconst mergedAnnotations = (ast: AST.AST): Record<symbol, unknown> =>\n  ast._tag === \"Transformation\" ?\n    {\n      ...ast.to.annotations,\n      ...ast.annotations\n    } :\n    ast.annotations\n\nconst getAnnotation = <A>(ast: AST.AST, key: symbol): A | undefined => mergedAnnotations(ast)[key] as A\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getStatus = (ast: AST.AST, defaultStatus: number): number =>\n  getAnnotation<number>(ast, AnnotationStatus) ?? defaultStatus\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEmptyDecodeable = (ast: AST.AST): boolean =>\n  getAnnotation<boolean>(ast, AnnotationEmptyDecodeable) ?? false\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipart = (ast: AST.AST): Multipart_.withLimits.Options | undefined =>\n  getAnnotation<Multipart_.withLimits.Options>(ast, AnnotationMultipart)\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getMultipartStream = (ast: AST.AST): Multipart_.withLimits.Options | undefined =>\n  getAnnotation<Multipart_.withLimits.Options>(ast, AnnotationMultipartStream)\n\nconst encodingJson: Encoding = {\n  kind: \"Json\",\n  contentType: \"application/json\"\n}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getEncoding = (ast: AST.AST, fallback = encodingJson): Encoding =>\n  getAnnotation<Encoding>(ast, AnnotationEncoding) ?? fallback\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const getParam = (ast: AST.AST | Schema.PropertySignature.AST): string | undefined => {\n  const annotations = ast._tag === \"PropertySignatureTransformation\" ? ast.to.annotations : ast.annotations\n  return (annotations[AnnotationParam] as any)?.name as string | undefined\n}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const annotations = <A>(\n  annotations: Schema.Annotations.Schema<NoInfer<A>> & {\n    readonly status?: number | undefined\n  }\n): Schema.Annotations.Schema<A> => {\n  const result: Record<symbol, unknown> = Struct.omit(annotations, \"status\")\n  if (annotations.status !== undefined) {\n    result[AnnotationStatus] = annotations.status\n  }\n  return result\n}\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const isVoid = (ast: AST.AST): boolean => {\n  switch (ast._tag) {\n    case \"VoidKeyword\": {\n      return true\n    }\n    case \"Transformation\": {\n      return isVoid(ast.from)\n    }\n    case \"Suspend\": {\n      return isVoid(ast.f())\n    }\n    default: {\n      return false\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccessAST = (ast: AST.AST): number => getStatus(ast, isVoid(ast) ? 204 : 200)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusSuccess = <A extends Schema.Schema.Any>(self: A): number => getStatusSuccessAST(self.ast)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusErrorAST = (ast: AST.AST): number => getStatus(ast, 500)\n\n/**\n * @since 1.0.0\n * @category reflection\n */\nexport const getStatusError = <A extends Schema.Schema.All>(self: A): number => getStatusErrorAST(self.ast)\n\n/**\n * Extracts all individual types from a union type recursively.\n *\n * **Details**\n *\n * This function traverses an AST and collects all the types within a union,\n * even if they are nested. It ensures that every type in a union (including\n * deeply nested unions) is included in the resulting array. The returned array\n * contains each type as an individual AST node, preserving the order in which\n * they appear.\n *\n * @internal\n */\nexport const extractUnionTypes = (ast: AST.AST): ReadonlyArray<AST.AST> => {\n  function process(ast: AST.AST): void {\n    if (AST.isUnion(ast)) {\n      for (const type of ast.types) {\n        process(type)\n      }\n    } else {\n      out.push(ast)\n    }\n  }\n  const out: Array<AST.AST> = []\n  process(ast)\n  return out\n}\n\n/** @internal */\nexport const UnionUnifyAST = (self: AST.AST, that: AST.AST): AST.AST =>\n  AST.Union.make(Array.from(new Set<AST.AST>([...extractUnionTypes(self), ...extractUnionTypes(that)])))\n\n/**\n * @since 1.0.0\n */\nexport const UnionUnify = <A extends Schema.Schema.All, B extends Schema.Schema.All>(self: A, that: B): Schema.Schema<\n  A[\"Type\"] | B[\"Type\"],\n  A[\"Encoded\"] | B[\"Encoded\"],\n  A[\"Context\"] | B[\"Context\"]\n> => Schema.make(UnionUnifyAST(self.ast, that.ast))\n\ntype Void$ = typeof Schema.Void\n\n/**\n * @since 1.0.0\n * @category path params\n */\nexport interface Param<Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>\n  extends Schema.Schema<Schema.Schema.Type<S>, Schema.Schema.Encoded<S>, Schema.Schema.Context<S>>\n{\n  readonly [AnnotationParam]: {\n    readonly name: Name\n    readonly schema: S\n  }\n}\n\n/**\n * @since 1.0.0\n * @category path params\n */\nexport const param: {\n  /**\n   * @since 1.0.0\n   * @category path params\n   */\n  <Name extends string>(name: Name): <S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    schema:\n      & S\n      & ([Schema.Schema.Encoded<S> & {}] extends [string] ? unknown : \"Schema must be encodable to a string\")\n  ) => Param<Name, S>\n  /**\n   * @since 1.0.0\n   * @category path params\n   */\n  <Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    name: Name,\n    schema:\n      & S\n      & ([Schema.Schema.Encoded<S> & {}] extends [string] ? unknown : \"Schema must be encodable to a string\")\n  ): Param<Name, S>\n} = dual(\n  2,\n  <Name extends string, S extends Schema.Schema.Any | Schema.PropertySignature.Any>(\n    name: Name,\n    schema: S\n  ): Param<Name, S> =>\n    schema.annotations({\n      [AnnotationParam]: { name, schema }\n    }) as any\n)\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Empty = (status: number): typeof Schema.Void => Schema.Void.annotations(annotations({ status }))\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface asEmpty<\n  S extends Schema.Schema.Any\n> extends Schema.transform<typeof Schema.Void, S> {}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const asEmpty: {\n  /**\n   * @since 1.0.0\n   * @category empty response\n   */\n  <S extends Schema.Schema.Any>(\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): (self: S) => asEmpty<S>\n  /**\n   * @since 1.0.0\n   * @category empty response\n   */\n  <S extends Schema.Schema.Any>(\n    self: S,\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): asEmpty<S>\n} = dual(\n  2,\n  <S extends Schema.Schema.Any>(\n    self: S,\n    options: {\n      readonly status: number\n      readonly decode: LazyArg<Schema.Schema.Type<S>>\n    }\n  ): asEmpty<S> =>\n    Schema.transform(\n      Schema.Void.annotations(self.ast.annotations),\n      Schema.typeSchema(self),\n      {\n        decode: options.decode,\n        encode: constVoid\n      }\n    ).annotations(annotations({\n      status: options.status,\n      [AnnotationEmptyDecodeable]: true\n    })) as any\n)\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface Created extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Created: Created = Empty(201) as any\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface Accepted extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const Accepted: Accepted = Empty(202) as any\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport interface NoContent extends Void$ {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category empty response\n */\nexport const NoContent: NoContent = Empty(204) as any\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/Multipart\")\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport type MultipartTypeId = typeof MultipartTypeId\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport interface Multipart<S extends Schema.Schema.Any>\n  extends\n    Schema.Schema<Schema.Schema.Type<S> & Brand<MultipartTypeId>, Schema.Schema.Encoded<S>, Schema.Schema.Context<S>>\n{}\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const Multipart = <S extends Schema.Schema.Any>(self: S, options?: {\n  readonly maxParts?: Option.Option<number> | undefined\n  readonly maxFieldSize?: FileSystem.SizeInput | undefined\n  readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n}): Multipart<S> =>\n  self.annotations({\n    [AnnotationMultipart]: options ?? {}\n  }) as any\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStreamTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiSchema/MultipartStream\")\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport type MultipartStreamTypeId = typeof MultipartStreamTypeId\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport interface MultipartStream<S extends Schema.Schema.Any> extends\n  Schema.Schema<\n    Schema.Schema.Type<S> & Brand<MultipartStreamTypeId>,\n    Schema.Schema.Encoded<S>,\n    Schema.Schema.Context<S>\n  >\n{}\n\n/**\n * @since 1.0.0\n * @category multipart\n */\nexport const MultipartStream = <S extends Schema.Schema.Any>(self: S, options?: {\n  readonly maxParts?: Option.Option<number> | undefined\n  readonly maxFieldSize?: FileSystem.SizeInput | undefined\n  readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n}): MultipartStream<S> =>\n  self.annotations({\n    [AnnotationMultipartStream]: options ?? {}\n  }) as any\n\nconst defaultContentType = (encoding: Encoding[\"kind\"]) => {\n  switch (encoding) {\n    case \"Json\": {\n      return \"application/json\"\n    }\n    case \"UrlParams\": {\n      return \"application/x-www-form-urlencoded\"\n    }\n    case \"Uint8Array\": {\n      return \"application/octet-stream\"\n    }\n    case \"Text\": {\n      return \"text/plain\"\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport interface Encoding {\n  readonly kind: \"Json\" | \"UrlParams\" | \"Uint8Array\" | \"Text\"\n  readonly contentType: string\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport declare namespace Encoding {\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  export type Validate<A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]> = Kind extends \"Json\" ? {}\n    : Kind extends \"UrlParams\" ? [A[\"Encoded\"]] extends [Readonly<Record<string, string | undefined>>] ? {}\n      : `'UrlParams' kind can only be encoded to 'Record<string, string | undefined>'`\n    : Kind extends \"Uint8Array\" ?\n      [A[\"Encoded\"]] extends [Uint8Array] ? {} : `'Uint8Array' kind can only be encoded to 'Uint8Array'`\n    : Kind extends \"Text\" ? [A[\"Encoded\"]] extends [string] ? {} : `'Text' kind can only be encoded to 'string'`\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const withEncoding: {\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  <A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]>(\n    options: {\n      readonly kind: Kind\n      readonly contentType?: string | undefined\n    } & Encoding.Validate<A, Kind>\n  ): (self: A) => A\n  /**\n   * @since 1.0.0\n   * @category encoding\n   */\n  <A extends Schema.Schema.Any, Kind extends Encoding[\"kind\"]>(\n    self: A,\n    options: {\n      readonly kind: Kind\n      readonly contentType?: string | undefined\n    } & Encoding.Validate<A, Kind>\n  ): A\n} = dual(2, <A extends Schema.Schema.Any>(self: A, options: {\n  readonly kind: Encoding[\"kind\"]\n  readonly contentType?: string | undefined\n}): A =>\n  self.annotations({\n    [AnnotationEncoding]: {\n      kind: options.kind,\n      contentType: options.contentType ?? defaultContentType(options.kind)\n    },\n    ...(options.kind === \"Uint8Array\" ?\n      {\n        jsonSchema: {\n          type: \"string\",\n          format: \"binary\"\n        }\n      } :\n      undefined)\n  }) as any)\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Text = (options?: {\n  readonly contentType?: string\n}): typeof Schema.String => withEncoding(Schema.String, { kind: \"Text\", ...options })\n\n/**\n * @since 1.0.0\n * @category encoding\n */\nexport const Uint8Array = (options?: {\n  readonly contentType?: string\n}): typeof Schema.Uint8ArrayFromSelf => withEncoding(Schema.Uint8ArrayFromSelf, { kind: \"Uint8Array\", ...options })\n\nconst astCache = globalValue(\n  \"@effect/platform/HttpApiSchema/astCache\",\n  () => new WeakMap<AST.AST, Schema.Schema.Any>()\n)\n\n/**\n * @since 1.0.0\n */\nexport const deunionize = (\n  schemas: Set<Schema.Schema.Any>,\n  schema: Schema.Schema.Any\n): void => {\n  if (astCache.has(schema.ast)) {\n    schemas.add(astCache.get(schema.ast)!)\n    return\n  }\n  const ast = schema.ast\n  if (ast._tag === \"Union\") {\n    for (const astType of ast.types) {\n      if (astCache.has(astType)) {\n        schemas.add(astCache.get(astType)!)\n        continue\n      }\n      const memberSchema = Schema.make(AST.annotations(astType, {\n        ...ast.annotations,\n        ...astType.annotations\n      }))\n      astCache.set(astType, memberSchema)\n      schemas.add(memberSchema)\n    }\n  } else {\n    astCache.set(ast, schema)\n    schemas.add(schema)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport interface EmptyErrorClass<Self, Tag> extends Schema.Schema<Self, void> {\n  new(_: void): { readonly _tag: Tag } & Effect.Effect<never, Self>\n}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport const EmptyError = <Self>() =>\n<const Tag extends string>(options: {\n  readonly tag: Tag\n  readonly status: number\n}): EmptyErrorClass<Self, Tag> => {\n  const symbol = Symbol.for(`@effect/platform/HttpApiSchema/EmptyError/${options.tag}`)\n  class EmptyError extends Effectable.StructuralClass<never, Self> {\n    readonly _tag: Tag = options.tag\n    commit(): Effect.Effect<never, Self> {\n      return Effect.fail(this) as any\n    }\n  }\n  ;(EmptyError as any).prototype[symbol] = symbol\n  Object.assign(EmptyError, {\n    [Schema.TypeId]: Schema.Void[Schema.TypeId],\n    pipe: Schema.Void.pipe,\n    annotations(this: any, annotations: any) {\n      return Schema.make(this.ast).annotations(annotations)\n    }\n  })\n  let transform: Schema.Schema.Any | undefined\n  Object.defineProperty(EmptyError, \"ast\", {\n    get() {\n      if (transform) {\n        return transform.ast\n      }\n      const self = this as any\n      transform = asEmpty(\n        Schema.declare((u) => hasProperty(u, symbol), {\n          identifier: options.tag,\n          title: options.tag\n        }),\n        {\n          status: options.status,\n          decode: constant(new self())\n        }\n      )\n      return transform.ast\n    }\n  })\n  return EmptyError as any\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Effect from \"effect/Effect\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport * as HttpApiSchema from \"./HttpApiSchema.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiError\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport class Issue extends Schema.ArrayFormatterIssue.annotations({\n  identifier: \"Issue\",\n  description: \"Represents an error encountered while parsing a value to match the schema\"\n}) {}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class HttpApiDecodeError extends Schema.TaggedError<HttpApiDecodeError>()(\n  \"HttpApiDecodeError\",\n  {\n    issues: Schema.Array(Issue),\n    message: Schema.String\n  },\n  HttpApiSchema.annotations({\n    status: 400,\n    description: \"The request did not match the expected schema\"\n  })\n) {\n  /**\n   * @since 1.0.0\n   */\n  static fromParseError(error: ParseResult.ParseError): Effect.Effect<HttpApiDecodeError> {\n    return ParseResult.ArrayFormatter.formatError(error).pipe(\n      Effect.zip(ParseResult.TreeFormatter.formatError(error)),\n      Effect.map(([issues, message]) => new HttpApiDecodeError({ issues, message }))\n    )\n  }\n  /**\n   * @since 1.0.0\n   */\n  static refailParseError(error: ParseResult.ParseError): Effect.Effect<never, HttpApiDecodeError> {\n    return Effect.flatMap(HttpApiDecodeError.fromParseError(error), Effect.fail)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class BadRequest extends HttpApiSchema.EmptyError<BadRequest>()({\n  tag: \"BadRequest\",\n  status: 400\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class Unauthorized extends HttpApiSchema.EmptyError<Unauthorized>()({\n  tag: \"Unauthorized\",\n  status: 401\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class Forbidden extends HttpApiSchema.EmptyError<Forbidden>()({\n  tag: \"Forbidden\",\n  status: 403\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class NotFound extends HttpApiSchema.EmptyError<NotFound>()({\n  tag: \"NotFound\",\n  status: 404\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class MethodNotAllowed extends HttpApiSchema.EmptyError<MethodNotAllowed>()({\n  tag: \"MethodNotAllowed\",\n  status: 405\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class NotAcceptable extends HttpApiSchema.EmptyError<NotAcceptable>()({\n  tag: \"NotAcceptable\",\n  status: 406\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class RequestTimeout extends HttpApiSchema.EmptyError<RequestTimeout>()({\n  tag: \"RequestTimeout\",\n  status: 408\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class Conflict extends HttpApiSchema.EmptyError<Conflict>()({\n  tag: \"Conflict\",\n  status: 409\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class Gone extends HttpApiSchema.EmptyError<Gone>()({\n  tag: \"Gone\",\n  status: 410\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class InternalServerError extends HttpApiSchema.EmptyError<InternalServerError>()({\n  tag: \"InternalServerError\",\n  status: 500\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class NotImplemented extends HttpApiSchema.EmptyError<NotImplemented>()({\n  tag: \"NotImplemented\",\n  status: 501\n}) {}\n\n/**\n * @since 1.0.0\n * @category empty errors\n */\nexport class ServiceUnavailable extends HttpApiSchema.EmptyError<ServiceUnavailable>()({\n  tag: \"ServiceUnavailable\",\n  status: 503\n}) {}\n", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Record from \"effect/Record\"\nimport type * as Schema from \"effect/Schema\"\nimport * as AST from \"effect/SchemaAST\"\nimport type { Mutable } from \"effect/Types\"\nimport type * as HttpApiEndpoint from \"./HttpApiEndpoint.js\"\nimport { HttpApiDecodeError } from \"./HttpApiError.js\"\nimport type * as HttpApiGroup from \"./HttpApiGroup.js\"\nimport type * as HttpApiMiddleware from \"./HttpApiMiddleware.js\"\nimport * as HttpApiSchema from \"./HttpApiSchema.js\"\nimport type { HttpMethod } from \"./HttpMethod.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApi\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isHttpApi = (u: unknown): u is HttpApi.Any => Predicate.hasProperty(u, TypeId)\n\n/**\n * An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to\n * represent a portion of your domain.\n *\n * The endpoints can be implemented later using the `HttpApiBuilder.make` api.\n *\n * @since 1.0.0\n * @category models\n */\nexport interface HttpApi<\n  out Id extends string,\n  out Groups extends HttpApiGroup.HttpApiGroup.Any = never,\n  in out E = never,\n  out R = never\n> extends Pipeable {\n  new(_: never): {}\n  readonly [TypeId]: TypeId\n  readonly identifier: Id\n  readonly groups: Record.ReadonlyRecord<string, Groups>\n  readonly annotations: Context.Context<never>\n  readonly errorSchema: Schema.Schema<E, unknown, R>\n  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>\n\n  /**\n   * Add a `HttpApiGroup` to the `HttpApi`.\n   */\n  add<A extends HttpApiGroup.HttpApiGroup.Any>(group: A): HttpApi<Id, Groups | A, E, R>\n  /**\n   * Add another `HttpApi` to the `HttpApi`.\n   */\n  addHttpApi<Id2 extends string, Groups2 extends HttpApiGroup.HttpApiGroup.Any, E2, R2>(\n    api: HttpApi<Id2, Groups2, E2, R2>\n  ): HttpApi<\n    Id,\n    Groups | HttpApiGroup.HttpApiGroup.AddContext<Groups2, R2>,\n    E | E2,\n    R\n  >\n  /**\n   * Add an global error to the `HttpApi`.\n   */\n  addError<A, I, RX>(\n    schema: Schema.Schema<A, I, RX>,\n    annotations?: {\n      readonly status?: number | undefined\n    }\n  ): HttpApi<Id, Groups, E | A, R | RX>\n  /**\n   * Prefix all endpoints in the `HttpApi`.\n   */\n  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApi<Id, Groups, E, R>\n  /**\n   * Add a middleware to a `HttpApi`. It will be applied to all endpoints in the\n   * `HttpApi`.\n   */\n  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(\n    middleware: Context.Tag<I, S>\n  ): HttpApi<\n    Id,\n    Groups,\n    E | HttpApiMiddleware.HttpApiMiddleware.Error<I>,\n    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>\n  >\n  /**\n   * Annotate the `HttpApi`.\n   */\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApi<Id, Groups, E, R>\n  /**\n   * Annotate the `HttpApi` with a Context.\n   */\n  annotateContext<I>(context: Context.Context<I>): HttpApi<Id, Groups, E, R>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class Api extends Context.Tag(\"@effect/platform/HttpApi/Api\")<\n  Api,\n  {\n    readonly api: HttpApi<string, HttpApiGroup.HttpApiGroup.AnyWithProps>\n    readonly context: Context.Context<never>\n  }\n>() {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace HttpApi {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Any {\n    readonly [TypeId]: TypeId\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type AnyWithProps = HttpApi<string, HttpApiGroup.HttpApiGroup.AnyWithProps, any, any>\n}\n\nconst Proto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  add(\n    this: HttpApi.AnyWithProps,\n    group: HttpApiGroup.HttpApiGroup.AnyWithProps\n  ) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: Record.set(this.groups, group.identifier, group),\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  addHttpApi(\n    this: HttpApi.AnyWithProps,\n    api: HttpApi.AnyWithProps\n  ) {\n    const newGroups = { ...this.groups }\n    for (const key in api.groups) {\n      const newGroup: Mutable<HttpApiGroup.HttpApiGroup.AnyWithProps> = api.groups[key].annotateContext(Context.empty())\n      newGroup.annotations = Context.merge(api.annotations, newGroup.annotations)\n      newGroup.middlewares = new Set([...api.middlewares, ...newGroup.middlewares])\n      newGroups[key] = newGroup as any\n    }\n    return makeProto({\n      identifier: this.identifier,\n      groups: newGroups,\n      errorSchema: HttpApiSchema.UnionUnify(this.errorSchema, api.errorSchema),\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  addError(\n    this: HttpApi.AnyWithProps,\n    schema: Schema.Schema.Any,\n    annotations?: { readonly status?: number }\n  ) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: this.groups,\n      errorSchema: HttpApiSchema.UnionUnify(\n        this.errorSchema,\n        annotations?.status\n          ? schema.annotations(HttpApiSchema.annotations({ status: annotations.status }))\n          : schema\n      ),\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  prefix(this: HttpApi.AnyWithProps, prefix: HttpApiEndpoint.PathSegment) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: Record.map(this.groups, (group) => group.prefix(prefix)),\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  middleware(this: HttpApi.AnyWithProps, tag: HttpApiMiddleware.TagClassAny) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: this.groups,\n      errorSchema: HttpApiSchema.UnionUnify(this.errorSchema, tag.failure),\n      annotations: this.annotations,\n      middlewares: new Set([...this.middlewares, tag])\n    })\n  },\n  annotate(this: HttpApi.AnyWithProps, tag: Context.Tag<any, any>, value: any) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: this.groups,\n      errorSchema: this.errorSchema,\n      annotations: Context.add(this.annotations, tag, value),\n      middlewares: this.middlewares\n    })\n  },\n  annotateContext(this: HttpApi.AnyWithProps, context: Context.Context<any>) {\n    return makeProto({\n      identifier: this.identifier,\n      groups: this.groups,\n      errorSchema: this.errorSchema,\n      annotations: Context.merge(this.annotations, context),\n      middlewares: this.middlewares\n    })\n  }\n}\n\nconst makeProto = <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, I, R>(\n  options: {\n    readonly identifier: Id\n    readonly groups: Record.ReadonlyRecord<string, Groups>\n    readonly errorSchema: Schema.Schema<E, I, R>\n    readonly annotations: Context.Context<never>\n    readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>\n  }\n): HttpApi<Id, Groups, E, R> => {\n  function HttpApi() {}\n  Object.setPrototypeOf(HttpApi, Proto)\n  HttpApi.groups = options.groups\n  HttpApi.errorSchema = options.errorSchema\n  HttpApi.annotations = options.annotations\n  HttpApi.middlewares = options.middlewares\n  return HttpApi as any\n}\n\n/**\n * An `HttpApi` is a collection of `HttpApiEndpoint`s. You can use an `HttpApi` to\n * represent a portion of your domain.\n *\n * The endpoints can be implemented later using the `HttpApiBuilder.make` api.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const make = <const Id extends string>(identifier: Id): HttpApi<Id, never, HttpApiDecodeError> =>\n  makeProto({\n    identifier,\n    groups: new Map() as any,\n    errorSchema: HttpApiDecodeError,\n    annotations: Context.empty(),\n    middlewares: new Set()\n  })\n\n/**\n * Extract metadata from an `HttpApi`, which can be used to generate documentation\n * or other tooling.\n *\n * See the `OpenApi` & `HttpApiClient` modules for examples of how to use this function.\n *\n * @since 1.0.0\n * @category reflection\n */\nexport const reflect = <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(\n  self: HttpApi<Id, Groups, Error, R>,\n  options: {\n    readonly predicate?: Predicate.Predicate<{\n      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.AnyWithProps\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps\n    }>\n    readonly onGroup: (options: {\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps\n      readonly mergedAnnotations: Context.Context<never>\n    }) => void\n    readonly onEndpoint: (options: {\n      readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps\n      readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>\n      readonly mergedAnnotations: Context.Context<never>\n      readonly middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>\n      readonly payloads: ReadonlyMap<string, {\n        readonly encoding: HttpApiSchema.Encoding\n        readonly ast: AST.AST\n      }>\n      readonly successes: ReadonlyMap<number, {\n        readonly ast: Option.Option<AST.AST>\n        readonly description: Option.Option<string>\n      }>\n      readonly errors: ReadonlyMap<number, {\n        readonly ast: Option.Option<AST.AST>\n        readonly description: Option.Option<string>\n      }>\n    }) => void\n  }\n) => {\n  const apiErrors = extractMembers(self.errorSchema.ast, new Map(), HttpApiSchema.getStatusErrorAST)\n  const groups = Object.values(self.groups) as any as Array<HttpApiGroup.HttpApiGroup.AnyWithProps>\n  for (const group of groups) {\n    const groupErrors = extractMembers(group.errorSchema.ast, apiErrors, HttpApiSchema.getStatusErrorAST)\n    const groupAnnotations = Context.merge(self.annotations, group.annotations)\n    options.onGroup({\n      group,\n      mergedAnnotations: groupAnnotations\n    })\n    const endpoints = Object.values(group.endpoints) as Iterable<HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>>\n    for (const endpoint of endpoints) {\n      if (\n        options.predicate && !options.predicate({\n          endpoint,\n          group\n        } as any)\n      ) continue\n\n      const errors = extractMembers(endpoint.errorSchema.ast, groupErrors, HttpApiSchema.getStatusErrorAST)\n      options.onEndpoint({\n        group,\n        endpoint,\n        middleware: new Set([...group.middlewares, ...endpoint.middlewares]),\n        mergedAnnotations: Context.merge(groupAnnotations, endpoint.annotations),\n        payloads: endpoint.payloadSchema._tag === \"Some\" ? extractPayloads(endpoint.payloadSchema.value.ast) : emptyMap,\n        successes: extractMembers(endpoint.successSchema.ast, new Map(), HttpApiSchema.getStatusSuccessAST),\n        errors\n      })\n    }\n  }\n}\n\n// -------------------------------------------------------------------------------------\n\nconst emptyMap = new Map<never, never>()\n\nconst extractMembers = (\n  ast: AST.AST,\n  inherited: ReadonlyMap<number, {\n    readonly ast: Option.Option<AST.AST>\n    readonly description: Option.Option<string>\n  }>,\n  getStatus: (ast: AST.AST) => number\n): ReadonlyMap<number, {\n  readonly ast: Option.Option<AST.AST>\n  readonly description: Option.Option<string>\n}> => {\n  const members = new Map(inherited)\n  function process(type: AST.AST) {\n    if (AST.isNeverKeyword(type)) {\n      return\n    }\n    const annotations = HttpApiSchema.extractAnnotations(ast.annotations)\n    // Avoid changing the reference unless necessary\n    // Otherwise, deduplication of the ASTs below will not be possible\n    if (!Record.isEmptyRecord(annotations)) {\n      type = AST.annotations(type, {\n        ...annotations,\n        ...type.annotations\n      })\n    }\n    const status = getStatus(type)\n    const emptyDecodeable = HttpApiSchema.getEmptyDecodeable(type)\n    const current = members.get(status)\n    members.set(\n      status,\n      {\n        description: (current ? current.description : Option.none()).pipe(\n          Option.orElse(() => getDescriptionOrIdentifier(type))\n        ),\n        ast: (current ? current.ast : Option.none()).pipe(\n          // Deduplicate the ASTs\n          Option.map((current) => HttpApiSchema.UnionUnifyAST(current, type)),\n          Option.orElse(() =>\n            !emptyDecodeable && AST.isVoidKeyword(AST.encodedAST(type)) ? Option.none() : Option.some(type)\n          )\n        )\n      }\n    )\n  }\n\n  HttpApiSchema.extractUnionTypes(ast).forEach(process)\n  return members\n}\n\nconst extractPayloads = (topAst: AST.AST): ReadonlyMap<string, {\n  readonly encoding: HttpApiSchema.Encoding\n  readonly ast: AST.AST\n}> => {\n  const members = new Map<string, {\n    encoding: HttpApiSchema.Encoding\n    ast: AST.AST\n  }>()\n  function process(ast: AST.AST) {\n    if (ast._tag === \"NeverKeyword\") {\n      return\n    }\n    ast = AST.annotations(ast, {\n      ...HttpApiSchema.extractAnnotations(topAst.annotations),\n      ...ast.annotations\n    })\n    const encoding = HttpApiSchema.getEncoding(ast)\n    const contentType = HttpApiSchema.getMultipart(ast) || HttpApiSchema.getMultipartStream(ast)\n      ? \"multipart/form-data\"\n      : encoding.contentType\n    const current = members.get(contentType)\n    if (current === undefined) {\n      members.set(contentType, {\n        encoding,\n        ast\n      })\n    } else {\n      current.ast = AST.Union.make([current.ast, ast])\n    }\n  }\n  if (topAst._tag === \"Union\") {\n    for (const type of topAst.types) {\n      process(type)\n    }\n  } else {\n    process(topAst)\n  }\n  return members\n}\n\nconst getDescriptionOrIdentifier = (ast: AST.PropertySignature | AST.AST): Option.Option<string> => {\n  const annotations = \"to\" in ast ?\n    {\n      ...ast.to.annotations,\n      ...ast.annotations\n    } :\n    ast.annotations\n  return Option.fromNullable(annotations[AST.DescriptionAnnotationId] ?? annotations[AST.IdentifierAnnotationId] as any)\n}\n\n/**\n * Adds additional schemas to components/schemas.\n * The provided schemas must have a `identifier` annotation.\n *\n * @since 1.0.0\n * @category tags\n */\nexport class AdditionalSchemas extends Context.Tag(\"@effect/platform/HttpApi/AdditionalSchemas\")<\n  AdditionalSchemas,\n  ReadonlyArray<Schema.Schema.All>\n>() {}\n", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport type { Mutable, Simplify } from \"effect/Types\"\nimport type * as HttpApiSecurity from \"./HttpApiSecurity.js\"\nimport type * as HttpRouter from \"./HttpRouter.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiMiddleware\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const SecurityTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiMiddleware/Security\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type SecurityTypeId = typeof SecurityTypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isSecurity = (u: TagClassAny): u is TagClassSecurityAny => hasProperty(u, SecurityTypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpApiMiddleware<Provides, E> extends Effect.Effect<Provides, E, HttpRouter.HttpRouter.Provided> {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type HttpApiMiddlewareSecurity<Security extends Record<string, HttpApiSecurity.HttpApiSecurity>, Provides, E> = {\n  readonly [K in keyof Security]: (\n    _: HttpApiSecurity.HttpApiSecurity.Type<Security[K]>\n  ) => Effect.Effect<Provides, E, HttpRouter.HttpRouter.Provided>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace HttpApiMiddleware {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Any {\n    readonly [TypeId]: TypeId\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface AnyId {\n    readonly [TypeId]: {\n      readonly provides: any\n    }\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Provides<A> = A extends { readonly [TypeId]: { readonly provides: infer P } } ? P : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type ExtractProvides<A> = Provides<Only<A>>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Error<A> = A extends { readonly [TypeId]: { readonly failure: infer E } } ? E : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type ErrorContext<A> = A extends { readonly [TypeId]: { readonly failureContext: infer R } } ? R : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Only<R> = Extract<R, AnyId>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Without<R> = Exclude<R, AnyId>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type TagClass<\n  Self,\n  Name extends string,\n  Options\n> = Options extends { readonly security: Record<string, HttpApiSecurity.HttpApiSecurity> } ? TagClass.BaseSecurity<\n    Self,\n    Name,\n    Options,\n    Simplify<\n      HttpApiMiddlewareSecurity<\n        Options[\"security\"],\n        TagClass.Service<Options>,\n        TagClass.FailureService<Options>\n      >\n    >,\n    Options[\"security\"]\n  >\n  : TagClass.Base<\n    Self,\n    Name,\n    Options,\n    HttpApiMiddleware<\n      TagClass.Service<Options>,\n      TagClass.FailureService<Options>\n    >\n  >\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace TagClass {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Provides<Options> = Options extends {\n    readonly provides: Context.Tag<any, any>\n    readonly optional?: false\n  } ? Context.Tag.Identifier<Options[\"provides\"]>\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Service<Options> = Options extends { readonly provides: Context.Tag<any, any> }\n    ? Context.Tag.Service<Options[\"provides\"]>\n    : void\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureSchema<Options> = Options extends\n    { readonly failure: Schema.Schema.All; readonly optional?: false } ? Options[\"failure\"]\n    : typeof Schema.Never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Failure<Options> = Options extends\n    { readonly failure: Schema.Schema<infer _A, infer _I, infer _R>; readonly optional?: false } ? _A\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureContext<Options> = Schema.Schema.Context<FailureSchema<Options>>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureService<Options> = Optional<Options> extends true ? unknown : Failure<Options>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Optional<Options> = Options extends { readonly optional: true } ? true : false\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Base<Self, Name extends string, Options, Service> extends Context.Tag<Self, Service> {\n    new(_: never):\n      & Context.TagClassShape<Name, Service>\n      & {\n        readonly [TypeId]: {\n          readonly provides: Provides<Options>\n          readonly failure: Failure<Options>\n          readonly failureContext: FailureContext<Options>\n        }\n      }\n    readonly [TypeId]: TypeId\n    readonly optional: Optional<Options>\n    readonly failure: FailureSchema<Options>\n    readonly provides: Options extends { readonly provides: Context.Tag<any, any> } ? Options[\"provides\"]\n      : undefined\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface BaseSecurity<\n    Self,\n    Name extends string,\n    Options,\n    Service,\n    Security extends Record<string, HttpApiSecurity.HttpApiSecurity>\n  > extends Base<Self, Name, Options, Service> {\n    readonly [SecurityTypeId]: SecurityTypeId\n    readonly security: Security\n  }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TagClassAny extends Context.Tag<any, HttpApiMiddleware.Any> {\n  readonly [TypeId]: TypeId\n  readonly optional: boolean\n  readonly provides?: Context.Tag<any, any>\n  readonly failure: Schema.Schema.All\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TagClassSecurityAny extends TagClassAny {\n  readonly [SecurityTypeId]: SecurityTypeId\n  readonly security: Record<string, HttpApiSecurity.HttpApiSecurity>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Tag = <Self>(): <\n  const Name extends string,\n  const Options extends {\n    readonly optional?: boolean\n    readonly failure?: Schema.Schema.All\n    readonly provides?: Context.Tag<any, any>\n    readonly security?: Record<string, HttpApiSecurity.HttpApiSecurity>\n  }\n>(\n  id: Name,\n  options?: Options | undefined\n) => TagClass<Self, Name, Options> =>\n(\n  id: string,\n  options?: {\n    readonly optional?: boolean\n    readonly security?: Record<string, HttpApiSecurity.HttpApiSecurity>\n    readonly failure?: Schema.Schema.All\n    readonly provides?: Context.Tag<any, any>\n  }\n) => {\n  const Err = globalThis.Error as any\n  const limit = Err.stackTraceLimit\n  Err.stackTraceLimit = 2\n  const creationError = new Err()\n  Err.stackTraceLimit = limit\n\n  function TagClass() {}\n  const TagClass_ = TagClass as any as Mutable<TagClassSecurityAny>\n  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))\n  TagClass.key = id\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  TagClass_[TypeId] = TypeId\n  TagClass_.failure = options?.optional === true || options?.failure === undefined ? Schema.Never : options.failure\n  if (options?.provides) {\n    TagClass_.provides = options.provides\n  }\n  TagClass_.optional = options?.optional ?? false\n  if (options?.security) {\n    if (Object.keys(options.security).length === 0) {\n      throw new Error(\"HttpApiMiddleware.Tag: security object must not be empty\")\n    }\n    TagClass_[SecurityTypeId] = SecurityTypeId\n    TagClass_.security = options.security\n  }\n  return TagClass as any\n}\n", "/**\n * @since 1.0.0\n */\nimport type * as Effect from \"effect/Effect\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as Stream_ from \"effect/Stream\"\nimport type * as PlatformError from \"./Error.js\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport * as internal from \"./internal/httpBody.js\"\nimport type * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isHttpBody = (u: unknown): u is HttpBody => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type HttpBody = Empty | Raw | Uint8Array | FormData | Stream\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpBody {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Proto extends Inspectable {\n    readonly [TypeId]: TypeId\n    readonly _tag: string\n    readonly contentType?: string | undefined\n    readonly contentLength?: number | undefined\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface FileLike {\n    readonly name: string\n    readonly lastModified: number\n    readonly size: number\n    readonly stream: () => unknown\n    readonly type: string\n  }\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const ErrorTypeId: unique symbol = internal.ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport interface HttpBodyError {\n  readonly [ErrorTypeId]: ErrorTypeId\n  readonly _tag: \"HttpBodyError\"\n  readonly reason: ErrorReason\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport const HttpBodyError: (reason: ErrorReason) => HttpBodyError = internal.HttpBodyError\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type ErrorReason = {\n  readonly _tag: \"JsonError\"\n  readonly error: unknown\n} | {\n  readonly _tag: \"SchemaError\"\n  readonly error: ParseResult.ParseError\n}\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Empty extends HttpBody.Proto {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: Empty = internal.empty\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Raw extends HttpBody.Proto {\n  readonly _tag: \"Raw\"\n  readonly body: unknown\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const raw: (\n  body: unknown,\n  options?: {\n    readonly contentType?: string | undefined\n    readonly contentLength?: number | undefined\n  } | undefined\n) => Raw = internal.raw\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Uint8Array extends HttpBody.Proto {\n  readonly _tag: \"Uint8Array\"\n  readonly body: globalThis.Uint8Array\n  readonly contentType: string\n  readonly contentLength: number\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const uint8Array: (body: globalThis.Uint8Array, contentType?: string) => Uint8Array = internal.uint8Array\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const text: (body: string, contentType?: string) => Uint8Array = internal.text\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeJson: (body: unknown) => Uint8Array = internal.unsafeJson\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const json: (body: unknown) => Effect.Effect<Uint8Array, HttpBodyError> = internal.json\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const jsonSchema: <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) => (body: A) => Effect.Effect<Uint8Array, HttpBodyError, R> = internal.jsonSchema\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const urlParams: (urlParams: UrlParams.UrlParams) => Uint8Array = internal.urlParams\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FormData extends HttpBody.Proto {\n  readonly _tag: \"FormData\"\n  readonly formData: globalThis.FormData\n}\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport const formData: (body: globalThis.FormData) => FormData = internal.formData\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport type FormDataInput = Record<string, FormDataCoercible | ReadonlyArray<FormDataCoercible>>\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport type FormDataCoercible = string | number | boolean | File | Blob | null | undefined\n\n/**\n * @since 1.0.0\n * @category FormData\n */\nexport const formDataRecord: (entries: FormDataInput) => FormData = internal.formDataRecord\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Stream extends HttpBody.Proto {\n  readonly _tag: \"Stream\"\n  readonly stream: Stream_.Stream<globalThis.Uint8Array, unknown>\n  readonly contentType: string\n  readonly contentLength?: number | undefined\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const stream: (\n  body: Stream_.Stream<globalThis.Uint8Array, unknown>,\n  contentType?: string,\n  contentLength?: number\n) => Stream = internal.stream\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const file: (\n  path: string,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n) => Effect.Effect<Stream, PlatformError.PlatformError, FileSystem.FileSystem> = internal.file\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fileInfo: (\n  path: string,\n  info: FileSystem.File.Info,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n) => Effect.Effect<Stream, PlatformError.PlatformError, FileSystem.FileSystem> = internal.fileInfo\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fileWeb: (file: HttpBody.FileLike) => Stream = internal.fileWeb\n", "import * as Data from \"effect/Data\"\nimport * as Effect from \"effect/Effect\"\nimport { identity } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Stream_ from \"effect/Stream\"\nimport type * as PlatformError from \"../Error.js\"\nimport * as FileSystem from \"../FileSystem.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport * as UrlParams from \"../UrlParams.js\"\n\n/** @internal */\nexport const TypeId: Body.TypeId = Symbol.for(\n  \"@effect/platform/HttpBody\"\n) as Body.TypeId\n\n/** @internal */\nexport const ErrorTypeId: Body.ErrorTypeId = Symbol.for(\n  \"@effect/platform/HttpBody/HttpBodyError\"\n) as Body.ErrorTypeId\n\nconst bodyError = Data.tagged<Body.HttpBodyError>(\"HttpBodyError\")\n\n/** @internal */\nexport const HttpBodyError = (reason: Body.ErrorReason): Body.HttpBodyError =>\n  bodyError({ [ErrorTypeId]: ErrorTypeId, reason })\n\nabstract class BodyBase implements Body.HttpBody.Proto {\n  readonly [TypeId]: Body.TypeId\n  abstract readonly _tag: string\n  constructor() {\n    this[TypeId] = TypeId\n  }\n  abstract toJSON(): unknown\n  [Inspectable.NodeInspectSymbol](): unknown {\n    return this.toJSON()\n  }\n  toString(): string {\n    return Inspectable.format(this)\n  }\n}\n\nclass EmptyImpl extends BodyBase implements Body.Empty {\n  readonly _tag = \"Empty\"\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Empty\"\n    }\n  }\n}\n\n/** @internal */\nexport const empty: Body.Empty = new EmptyImpl()\n\nclass RawImpl extends BodyBase implements Body.Raw {\n  readonly _tag = \"Raw\"\n  constructor(\n    readonly body: unknown,\n    readonly contentType?: string | undefined,\n    readonly contentLength?: number | undefined\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Raw\",\n      body: this.body,\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const raw = (body: unknown, options?: {\n  readonly contentType?: string | undefined\n  readonly contentLength?: number | undefined\n}): Body.Raw => new RawImpl(body, options?.contentType, options?.contentLength)\n\nclass Uint8ArrayImpl extends BodyBase implements Body.Uint8Array {\n  readonly _tag = \"Uint8Array\"\n  constructor(\n    readonly body: Uint8Array,\n    readonly contentType: string\n  ) {\n    super()\n  }\n  get contentLength(): number {\n    return this.body.length\n  }\n  toJSON(): unknown {\n    const toString = this.contentType.startsWith(\"text/\") || this.contentType.endsWith(\"json\")\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Uint8Array\",\n      body: toString ? new TextDecoder().decode(this.body) : `Uint8Array(${this.body.length})`,\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const uint8Array = (body: Uint8Array, contentType?: string): Body.Uint8Array =>\n  new Uint8ArrayImpl(body, contentType ?? \"application/octet-stream\")\n\nconst encoder = new TextEncoder()\n\n/** @internal */\nexport const text = (body: string, contentType?: string): Body.Uint8Array =>\n  uint8Array(encoder.encode(body), contentType ?? \"text/plain\")\n\n/** @internal */\nexport const unsafeJson = (body: unknown): Body.Uint8Array => text(JSON.stringify(body), \"application/json\")\n\n/** @internal */\nexport const json = (body: unknown): Effect.Effect<Body.Uint8Array, Body.HttpBodyError> =>\n  Effect.try({\n    try: () => unsafeJson(body),\n    catch: (error) => HttpBodyError({ _tag: \"JsonError\", error })\n  })\n\n/** @internal */\nexport const urlParams = (urlParams: UrlParams.UrlParams): Body.Uint8Array =>\n  text(UrlParams.toString(urlParams), \"application/x-www-form-urlencoded\")\n\n/** @internal */\nexport const jsonSchema = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions) => {\n  const encode = Schema.encode(schema, options)\n  return (body: A): Effect.Effect<Body.Uint8Array, Body.HttpBodyError, R> =>\n    Effect.flatMap(\n      Effect.mapError(encode(body), (error) => HttpBodyError({ _tag: \"SchemaError\", error })),\n      json\n    )\n}\n\n/** @internal */\nexport const file = (\n  path: string,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n): Effect.Effect<Body.Stream, PlatformError.PlatformError, FileSystem.FileSystem> =>\n  Effect.flatMap(\n    FileSystem.FileSystem,\n    (fs) =>\n      Effect.map(fs.stat(path), (info) =>\n        stream(\n          fs.stream(path, options),\n          options?.contentType,\n          Number(info.size)\n        ))\n  )\n\n/** @internal */\nexport const fileInfo = (\n  path: string,\n  info: FileSystem.File.Info,\n  options?: FileSystem.StreamOptions & { readonly contentType?: string }\n): Effect.Effect<Body.Stream, PlatformError.PlatformError, FileSystem.FileSystem> =>\n  Effect.map(\n    FileSystem.FileSystem,\n    (fs) =>\n      stream(\n        fs.stream(path, options),\n        options?.contentType,\n        Number(info.size)\n      )\n  )\n\n/** @internal */\nexport const fileWeb = (file: Body.HttpBody.FileLike): Body.Stream =>\n  stream(Stream_.fromReadableStream(() => file.stream() as ReadableStream<Uint8Array>, identity), file.type, file.size)\n\nclass FormDataImpl extends BodyBase implements Body.FormData {\n  readonly _tag = \"FormData\"\n  constructor(\n    readonly formData: FormData\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"FormData\",\n      formData: this.formData\n    }\n  }\n}\n\n/** @internal */\nexport const formData = (body: FormData): Body.FormData => new FormDataImpl(body)\n\n/** @internal */\nexport const formDataRecord = (\n  entries: Body.FormDataInput\n): Body.FormData => {\n  const formData = new FormData()\n  for (const [key, value] of Object.entries(entries)) {\n    if (Array.isArray(value)) {\n      for (const item of value) {\n        if (item == null) continue\n        formData.append(key, typeof value === \"object\" ? item as any : String(item))\n      }\n    } else if (value != null) {\n      formData.append(key, typeof value === \"object\" ? value as any : String(value))\n    }\n  }\n  return new FormDataImpl(formData)\n}\n\nclass StreamImpl extends BodyBase implements Body.Stream {\n  readonly _tag = \"Stream\"\n  constructor(\n    readonly stream: Stream_.Stream<Uint8Array, unknown>,\n    readonly contentType: string,\n    readonly contentLength?: number | undefined\n  ) {\n    super()\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpBody\",\n      _tag: \"Stream\",\n      contentType: this.contentType,\n      contentLength: this.contentLength\n    }\n  }\n}\n\n/** @internal */\nexport const stream = (\n  body: Stream_.Stream<Uint8Array, unknown>,\n  contentType?: string | undefined,\n  contentLength?: number | undefined\n): Body.Stream => new StreamImpl(body, contentType ?? \"application/octet-stream\", contentLength)\n", "/**\n * @since 1.0.0\n */\nimport * as Effect from \"effect/Effect\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Stream from \"effect/Stream\"\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type PrimitiveValue = string | number | bigint | boolean | null | undefined\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type Primitive = PrimitiveValue | ReadonlyArray<PrimitiveValue>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type Interpolated =\n  | Primitive\n  | Option.Option<Primitive>\n  | Effect.Effect<Primitive, any, any>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type InterpolatedWithStream = Interpolated | Stream.Stream<Primitive, any, any>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport declare namespace Interpolated {\n  /**\n   * @category models\n   * @since 1.0.0\n   */\n  export type Context<A> = A extends infer T ? T extends Option.Option<infer _> ? never\n    : T extends Stream.Stream<infer _A, infer _E, infer R> ? R\n    : never\n    : never\n\n  /**\n   * @category models\n   * @since 1.0.0\n   */\n  export type Error<A> = A extends infer T ? T extends Option.Option<infer _> ? never\n    : T extends Stream.Stream<infer _A, infer E, infer _R> ? E\n    : never\n    : never\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function make<A extends ReadonlyArray<Interpolated>>(\n  strings: TemplateStringsArray,\n  ...args: A\n): Effect.Effect<\n  string,\n  Interpolated.Error<A[number]>,\n  Interpolated.Context<A[number]>\n> {\n  const argsLength = args.length\n  const values = new Array<string>(argsLength)\n  const effects: Array<\n    [index: number, effect: Effect.Effect<Primitive, any, any>]\n  > = []\n\n  for (let i = 0; i < argsLength; i++) {\n    const arg = args[i]\n\n    if (Option.isOption(arg)) {\n      values[i] = arg._tag === \"Some\" ? primitiveToString(arg.value) : \"\"\n    } else if (isSuccess(arg)) {\n      values[i] = primitiveToString((arg as any).effect_instruction_i0)\n    } else if (Effect.isEffect(arg)) {\n      effects.push([i, arg])\n    } else {\n      values[i] = primitiveToString(arg)\n    }\n  }\n\n  if (effects.length === 0) {\n    return Effect.succeed(consolidate(strings, values))\n  }\n\n  return Effect.map(\n    Effect.forEach(\n      effects,\n      ([index, effect]) =>\n        Effect.tap(effect, (value) => {\n          values[index] = primitiveToString(value)\n        }),\n      {\n        concurrency: \"inherit\",\n        discard: true\n      }\n    ),\n    (_) => consolidate(strings, values)\n  )\n}\n\n/**\n * @category constructors\n * @since 1.0.0\n */\nexport function stream<A extends ReadonlyArray<InterpolatedWithStream>>(\n  strings: TemplateStringsArray,\n  ...args: A\n): Stream.Stream<\n  string,\n  Interpolated.Error<A[number]>,\n  Interpolated.Context<A[number]>\n> {\n  const chunks: Array<string | Stream.Stream<string, any, any>> = []\n  let buffer = \"\"\n\n  for (let i = 0, len = args.length; i < len; i++) {\n    buffer += strings[i]\n    const arg = args[i]\n    if (Option.isOption(arg)) {\n      buffer += arg._tag === \"Some\" ? primitiveToString(arg.value) : \"\"\n    } else if (isSuccess(arg)) {\n      buffer += primitiveToString((arg as any).effect_instruction_i0)\n    } else if (Predicate.hasProperty(arg, Stream.StreamTypeId)) {\n      if (buffer.length > 0) {\n        chunks.push(buffer)\n        buffer = \"\"\n      }\n      if (Effect.isEffect(arg)) {\n        chunks.push(Effect.map(arg, primitiveToString))\n      } else {\n        chunks.push(Stream.map(arg, primitiveToString))\n      }\n    } else {\n      buffer += primitiveToString(arg)\n    }\n  }\n\n  buffer += strings[strings.length - 1]\n  if (buffer.length > 0) {\n    chunks.push(buffer)\n    buffer = \"\"\n  }\n\n  return Stream.flatMap(\n    Stream.fromIterable(chunks),\n    (chunk) => typeof chunk === \"string\" ? Stream.succeed(chunk) : chunk,\n    { concurrency: \"unbounded\" }\n  )\n}\n\nfunction primitiveToString(value: Primitive): string {\n  if (Array.isArray(value)) {\n    return value.map(primitiveToString).join(\"\")\n  }\n\n  switch (typeof value) {\n    case \"string\": {\n      return value\n    }\n    case \"number\":\n    case \"bigint\": {\n      return value.toString()\n    }\n    case \"boolean\": {\n      return value ? \"true\" : \"false\"\n    }\n    default: {\n      return \"\"\n    }\n  }\n}\n\nfunction consolidate(\n  strings: ReadonlyArray<string>,\n  values: ReadonlyArray<string>\n): string {\n  let out = \"\"\n  for (let i = 0, len = values.length; i < len; i++) {\n    out += strings[i]\n    out += values[i]\n  }\n  return out + strings[strings.length - 1]\n}\n\nfunction isSuccess(u: unknown) {\n  return Effect.isEffect(u) && (u as any)._op === \"Success\"\n}\n", "/**\n * @since 1.0.0\n */\nimport type * as Effect from \"effect/Effect\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as Runtime from \"effect/Runtime\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport type { Cookie, Cookies, CookiesError } from \"./Cookies.js\"\nimport type * as PlatformError from \"./Error.js\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport type * as Body from \"./HttpBody.js\"\nimport type * as Platform from \"./HttpPlatform.js\"\nimport type { Respondable } from \"./HttpServerRespondable.js\"\nimport * as internal from \"./internal/httpServerResponse.js\"\nimport type * as Template from \"./Template.js\"\nimport type * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpServerResponse\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpServerResponse extends Effect.Effect<HttpServerResponse>, Inspectable, Respondable {\n  readonly [TypeId]: TypeId\n  readonly status: number\n  readonly statusText?: string | undefined\n  readonly headers: Headers.Headers\n  readonly cookies: Cookies\n  readonly body: Body.HttpBody\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Options {\n  readonly status?: number | undefined\n  readonly statusText?: string | undefined\n  readonly headers?: Headers.Input | undefined\n  readonly cookies?: Cookies | undefined\n  readonly contentType?: string | undefined\n  readonly contentLength?: number | undefined\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Options {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface WithContent extends Omit<Options, \"contentType\" | \"contentLength\"> {}\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface WithContentType extends Omit<Options, \"contentLength\"> {}\n}\n\n/**\n * @since 1.0.0\n */\nexport const isServerResponse: (u: unknown) => u is HttpServerResponse = internal.isServerResponse\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: (options?: Options.WithContent | undefined) => HttpServerResponse = internal.empty\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const redirect: (location: string | URL, options?: Options.WithContentType | undefined) => HttpServerResponse =\n  internal.redirect\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const uint8Array: (body: Uint8Array, options?: Options.WithContentType | undefined) => HttpServerResponse =\n  internal.uint8Array\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const text: (body: string, options?: Options.WithContentType | undefined) => HttpServerResponse = internal.text\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const html: {\n  /**\n   * @since 1.0.0\n   * @category constructors\n   */\n  <A extends ReadonlyArray<Template.Interpolated>>(strings: TemplateStringsArray, ...args: A): Effect.Effect<HttpServerResponse, Template.Interpolated.Error<A[number]>, Template.Interpolated.Context<A[number]>>\n  /**\n   * @since 1.0.0\n   * @category constructors\n   */\n  (html: string): HttpServerResponse\n} = internal.html\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const htmlStream: <A extends ReadonlyArray<Template.InterpolatedWithStream>>(\n  strings: TemplateStringsArray,\n  ...args: A\n) => Effect.Effect<HttpServerResponse, never, Template.Interpolated.Context<A[number]>> = internal.htmlStream\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const json: (\n  body: unknown,\n  options?: Options.WithContentType | undefined\n) => Effect.Effect<HttpServerResponse, Body.HttpBodyError> = internal.json\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const schemaJson: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => (body: A, options?: Options.WithContent | undefined) => Effect.Effect<HttpServerResponse, Body.HttpBodyError, R> =\n  internal.schemaJson\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeJson: (body: unknown, options?: Options.WithContentType | undefined) => HttpServerResponse =\n  internal.unsafeJson\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const urlParams: (body: UrlParams.Input, options?: Options.WithContentType | undefined) => HttpServerResponse =\n  internal.urlParams\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const raw: (body: unknown, options?: Options | undefined) => HttpServerResponse = internal.raw\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const formData: (body: FormData, options?: Options.WithContent | undefined) => HttpServerResponse =\n  internal.formData\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const stream: <E>(\n  body: Stream.Stream<Uint8Array, E, never>,\n  options?: Options | undefined\n) => HttpServerResponse = internal.stream\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const file: (\n  path: string,\n  options?: (Options & FileSystem.StreamOptions) | undefined\n) => Effect.Effect<HttpServerResponse, PlatformError.PlatformError, Platform.HttpPlatform> = internal.file\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fileWeb: (\n  file: Body.HttpBody.FileLike,\n  options?: (Options.WithContent & FileSystem.StreamOptions) | undefined\n) => Effect.Effect<HttpServerResponse, never, Platform.HttpPlatform> = internal.fileWeb\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeader: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, key: string, value: string): HttpServerResponse\n} = internal.setHeader\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeaders: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Headers.Input): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, input: Headers.Input): HttpServerResponse\n} = internal.setHeaders\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const removeCookie: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, name: string): HttpServerResponse\n} = internal.removeCookie\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const replaceCookies: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookies: Cookies): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, cookies: Cookies): HttpServerResponse\n} = internal.replaceCookies\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setCookie: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (\n    self: HttpServerResponse\n  ) => Effect.Effect<\n    HttpServerResponse,\n    CookiesError\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: HttpServerResponse,\n    name: string,\n    value: string,\n    options?: Cookie[\"options\"]\n  ): Effect.Effect<\n    HttpServerResponse,\n    CookiesError\n  >\n} = internal.setCookie\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSetCookie: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (name: string, value: string, options?: Cookie[\"options\"]): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: HttpServerResponse,\n    name: string,\n    value: string,\n    options?: Cookie[\"options\"]\n  ): HttpServerResponse\n} = internal.unsafeSetCookie\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const updateCookies: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (f: (cookies: Cookies) => Cookies): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, f: (cookies: Cookies) => Cookies): HttpServerResponse\n} = internal.updateCookies\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const mergeCookies: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (cookies: Cookies): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, cookies: Cookies): HttpServerResponse\n} = internal.mergeCookies\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setCookies: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<\n      readonly [\n        name: string,\n        value: string,\n        options?: Cookie[\"options\"]\n      ]\n    >\n  ): (self: HttpServerResponse) => Effect.Effect<HttpServerResponse, CookiesError, never>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: HttpServerResponse,\n    cookies: Iterable<\n      readonly [\n        name: string,\n        value: string,\n        options?: Cookie[\"options\"]\n      ]\n    >\n  ): Effect.Effect<HttpServerResponse, CookiesError, never>\n} = internal.setCookies\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const unsafeSetCookies: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    cookies: Iterable<\n      readonly [\n        name: string,\n        value: string,\n        options?: Cookie[\"options\"]\n      ]\n    >\n  ): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n    self: HttpServerResponse,\n    cookies: Iterable<\n      readonly [\n        name: string,\n        value: string,\n        options?: Cookie[\"options\"]\n      ]\n    >\n  ): HttpServerResponse\n} = internal.unsafeSetCookies\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setBody: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: Body.HttpBody): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, body: Body.HttpBody): HttpServerResponse\n} = internal.setBody\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setStatus: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (status: number, statusText?: string | undefined): (self: HttpServerResponse) => HttpServerResponse\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpServerResponse, status: number, statusText?: string | undefined): HttpServerResponse\n} = internal.setStatus\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWeb: (\n  response: HttpServerResponse,\n  options?: {\n    readonly withoutBody?: boolean | undefined\n    readonly runtime?: Runtime.Runtime<never> | undefined\n  }\n) => Response = internal.toWeb\n", "import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Effectable from \"effect/Effectable\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Runtime from \"effect/Runtime\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Stream from \"effect/Stream\"\nimport * as Cookies from \"../Cookies.js\"\nimport type * as PlatformError from \"../Error.js\"\nimport type * as FileSystem from \"../FileSystem.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport type * as Platform from \"../HttpPlatform.js\"\nimport type * as Respondable from \"../HttpServerRespondable.js\"\nimport type * as ServerResponse from \"../HttpServerResponse.js\"\nimport * as Template from \"../Template.js\"\nimport * as UrlParams from \"../UrlParams.js\"\nimport * as internalBody from \"./httpBody.js\"\n\n/** @internal */\nexport const TypeId: ServerResponse.TypeId = Symbol.for(\"@effect/platform/HttpServerResponse\") as ServerResponse.TypeId\n\nconst respondableSymbol: typeof Respondable.symbol = Symbol.for(\n  \"@effect/platform/HttpServerRespondable\"\n) as typeof Respondable.symbol\n\nclass ServerResponseImpl extends Effectable.StructuralClass<ServerResponse.HttpServerResponse>\n  implements ServerResponse.HttpServerResponse\n{\n  readonly [TypeId]: ServerResponse.TypeId\n  readonly headers: Headers.Headers\n  constructor(\n    readonly status: number,\n    readonly statusText: string | undefined,\n    headers: Headers.Headers,\n    readonly cookies: Cookies.Cookies,\n    readonly body: Body.HttpBody\n  ) {\n    super()\n    this[TypeId] = TypeId\n    if (body.contentType || body.contentLength) {\n      const newHeaders = { ...headers }\n      if (body.contentType) {\n        newHeaders[\"content-type\"] = body.contentType\n      }\n      if (body.contentLength) {\n        newHeaders[\"content-length\"] = body.contentLength.toString()\n      }\n      this.headers = newHeaders\n    } else {\n      this.headers = headers\n    }\n  }\n\n  commit(): Effect.Effect<ServerResponse.HttpServerResponse> {\n    return Effect.succeed(this)\n  }\n\n  [respondableSymbol](): Effect.Effect<ServerResponse.HttpServerResponse, unknown> {\n    return Effect.succeed(this)\n  }\n\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n\n  toString(): string {\n    return Inspectable.format(this)\n  }\n\n  toJSON() {\n    return {\n      _id: \"@effect/platform/HttpServerResponse\",\n      status: this.status,\n      statusText: this.statusText,\n      headers: Inspectable.redact(this.headers),\n      cookies: this.cookies.toJSON(),\n      body: this.body.toJSON()\n    }\n  }\n}\n\n/** @internal */\nexport const isServerResponse = (u: unknown): u is ServerResponse.HttpServerResponse =>\n  typeof u === \"object\" && u !== null && TypeId in u\n\n/** @internal */\nexport const empty = (options?: ServerResponse.Options.WithContent | undefined): ServerResponse.HttpServerResponse =>\n  new ServerResponseImpl(\n    options?.status ?? 204,\n    options?.statusText,\n    options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n    options?.cookies ?? Cookies.empty,\n    internalBody.empty\n  )\n\n/** @internal */\nexport const redirect = (\n  location: string | URL,\n  options?: ServerResponse.Options.WithContentType | undefined\n): ServerResponse.HttpServerResponse => {\n  const headers = Headers.unsafeFromRecord({ location: location.toString() })\n  return new ServerResponseImpl(\n    options?.status ?? 301,\n    options?.statusText,\n    options?.headers ?\n      Headers.merge(\n        headers,\n        Headers.fromInput(options.headers)\n      ) :\n      headers,\n    options?.cookies ?? Cookies.empty,\n    internalBody.empty\n  )\n}\n\n/** @internal */\nexport const uint8Array = (\n  body: Uint8Array,\n  options?: ServerResponse.Options.WithContentType\n): ServerResponse.HttpServerResponse => {\n  const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty\n  return new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    headers,\n    options?.cookies ?? Cookies.empty,\n    internalBody.uint8Array(body, getContentType(options, headers))\n  )\n}\n\n/** @internal */\nexport const text = (\n  body: string,\n  options?: ServerResponse.Options.WithContentType\n): ServerResponse.HttpServerResponse => {\n  const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty\n  return new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    headers,\n    options?.cookies ?? Cookies.empty,\n    internalBody.text(body, getContentType(options, headers))\n  )\n}\n\n/** @internal */\nexport const html: {\n  <A extends ReadonlyArray<Template.Interpolated>>(\n    strings: TemplateStringsArray,\n    ...args: A\n  ): Effect.Effect<\n    ServerResponse.HttpServerResponse,\n    Template.Interpolated.Error<A[number]>,\n    Template.Interpolated.Context<A[number]>\n  >\n  (html: string): ServerResponse.HttpServerResponse\n} = (\n  strings: TemplateStringsArray | string,\n  ...args: ReadonlyArray<Template.Interpolated>\n) => {\n  if (typeof strings === \"string\") {\n    return text(strings, { contentType: \"text/html\" })\n  }\n\n  return Effect.map(\n    Template.make(strings, ...args),\n    (_) => text(_, { contentType: \"text/html\" })\n  ) as any\n}\n\n/** @internal */\nexport const htmlStream = <A extends ReadonlyArray<Template.InterpolatedWithStream>>(\n  strings: TemplateStringsArray,\n  ...args: A\n): Effect.Effect<\n  ServerResponse.HttpServerResponse,\n  never,\n  Template.Interpolated.Context<A[number]>\n> =>\n  Effect.map(\n    Effect.context<any>(),\n    (context) =>\n      stream(\n        Stream.provideContext(\n          Stream.encodeText(Template.stream(strings, ...args)),\n          context\n        ),\n        { contentType: \"text/html\" }\n      )\n  )\n\n/** @internal */\nexport const json = (\n  body: unknown,\n  options?: ServerResponse.Options.WithContent | undefined\n): Effect.Effect<ServerResponse.HttpServerResponse, Body.HttpBodyError> =>\n  Effect.map(internalBody.json(body), (body) =>\n    new ServerResponseImpl(\n      options?.status ?? 200,\n      options?.statusText,\n      options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n      options?.cookies ?? Cookies.empty,\n      body\n    ))\n\n/** @internal */\nexport const unsafeJson = (\n  body: unknown,\n  options?: ServerResponse.Options.WithContent | undefined\n): ServerResponse.HttpServerResponse =>\n  new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n    options?.cookies ?? Cookies.empty,\n    internalBody.unsafeJson(body)\n  )\n\n/** @internal */\nexport const schemaJson = <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const encode = internalBody.jsonSchema(schema, options)\n  return (\n    body: A,\n    options?: ServerResponse.Options.WithContent | undefined\n  ): Effect.Effect<ServerResponse.HttpServerResponse, Body.HttpBodyError, R> =>\n    Effect.map(encode(body), (body) =>\n      new ServerResponseImpl(\n        options?.status ?? 200,\n        options?.statusText,\n        options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n        options?.cookies ?? Cookies.empty,\n        body\n      ))\n}\n\nconst httpPlatform = Context.GenericTag<Platform.HttpPlatform>(\"@effect/platform/HttpPlatform\")\n\n/** @internal */\nexport const file = (\n  path: string,\n  options?: (ServerResponse.Options & FileSystem.StreamOptions) | undefined\n): Effect.Effect<ServerResponse.HttpServerResponse, PlatformError.PlatformError, Platform.HttpPlatform> =>\n  Effect.flatMap(\n    httpPlatform,\n    (platform) => platform.fileResponse(path, options)\n  )\n\n/** @internal */\nexport const fileWeb = (\n  file: Body.HttpBody.FileLike,\n  options?: (ServerResponse.Options.WithContent & FileSystem.StreamOptions) | undefined\n): Effect.Effect<ServerResponse.HttpServerResponse, never, Platform.HttpPlatform> =>\n  Effect.flatMap(\n    httpPlatform,\n    (platform) => platform.fileWebResponse(file, options)\n  )\n\n/** @internal */\nexport const urlParams = (\n  body: UrlParams.Input,\n  options?: ServerResponse.Options.WithContent | undefined\n): ServerResponse.HttpServerResponse =>\n  new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n    options?.cookies ?? Cookies.empty,\n    internalBody.text(UrlParams.toString(UrlParams.fromInput(body)), \"application/x-www-form-urlencoded\")\n  )\n\n/** @internal */\nexport const raw = (body: unknown, options?: ServerResponse.Options | undefined): ServerResponse.HttpServerResponse =>\n  new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n    options?.cookies ?? Cookies.empty,\n    internalBody.raw(body, {\n      contentType: options?.contentType,\n      contentLength: options?.contentLength\n    })\n  )\n\n/** @internal */\nexport const formData = (\n  body: FormData,\n  options?: ServerResponse.Options.WithContent | undefined\n): ServerResponse.HttpServerResponse =>\n  new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n    options?.cookies ?? Cookies.empty,\n    internalBody.formData(body)\n  )\n\n/** @internal */\nexport const stream = <E>(\n  body: Stream.Stream<Uint8Array, E>,\n  options?: ServerResponse.Options | undefined\n): ServerResponse.HttpServerResponse => {\n  const headers = options?.headers ? Headers.fromInput(options.headers) : Headers.empty\n  return new ServerResponseImpl(\n    options?.status ?? 200,\n    options?.statusText,\n    headers,\n    options?.cookies ?? Cookies.empty,\n    internalBody.stream(body, getContentType(options, headers), options?.contentLength)\n  )\n}\n\n/** @internal */\nexport const getContentType = (\n  options: ServerResponse.Options | undefined,\n  headers: Headers.Headers\n): string | undefined => {\n  if (options?.contentType) {\n    return options.contentType\n  } else if (options?.headers) {\n    return headers[\"content-type\"]\n  } else {\n    return\n  }\n}\n\n/** @internal */\nexport const setHeader = dual<\n  (key: string, value: string) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (self: ServerResponse.HttpServerResponse, key: string, value: string) => ServerResponse.HttpServerResponse\n>(3, (self, key, value) =>\n  new ServerResponseImpl(\n    self.status,\n    self.statusText,\n    Headers.set(self.headers, key, value),\n    self.cookies,\n    self.body\n  ))\n\n/** @internal */\nexport const replaceCookies = dual<\n  (cookies: Cookies.Cookies) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (self: ServerResponse.HttpServerResponse, cookies: Cookies.Cookies) => ServerResponse.HttpServerResponse\n>(2, (self, cookies) =>\n  new ServerResponseImpl(\n    self.status,\n    self.statusText,\n    self.headers,\n    cookies,\n    self.body\n  ))\n\n/** @internal */\nexport const setCookie = dual<\n  (\n    name: string,\n    value: string,\n    options?: Cookies.Cookie[\"options\"]\n  ) => (\n    self: ServerResponse.HttpServerResponse\n  ) => Effect.Effect<ServerResponse.HttpServerResponse, Cookies.CookiesError>,\n  (\n    self: ServerResponse.HttpServerResponse,\n    name: string,\n    value: string,\n    options?: Cookies.Cookie[\"options\"]\n  ) => Effect.Effect<ServerResponse.HttpServerResponse, Cookies.CookiesError>\n>(\n  (args) => isServerResponse(args[0]),\n  (self, name, value, options) =>\n    Effect.map(Cookies.set(self.cookies, name, value, options), (cookies) =>\n      new ServerResponseImpl(\n        self.status,\n        self.statusText,\n        self.headers,\n        cookies,\n        self.body\n      ))\n)\n\n/** @internal */\nexport const unsafeSetCookie = dual<\n  (\n    name: string,\n    value: string,\n    options?: Cookies.Cookie[\"options\"]\n  ) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (\n    self: ServerResponse.HttpServerResponse,\n    name: string,\n    value: string,\n    options?: Cookies.Cookie[\"options\"]\n  ) => ServerResponse.HttpServerResponse\n>(\n  (args) => isServerResponse(args[0]),\n  (self, name, value, options) =>\n    new ServerResponseImpl(\n      self.status,\n      self.statusText,\n      self.headers,\n      Cookies.unsafeSet(self.cookies, name, value, options),\n      self.body\n    )\n)\n\n/** @internal */\nexport const updateCookies = dual<\n  (\n    f: (cookies: Cookies.Cookies) => Cookies.Cookies\n  ) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (\n    self: ServerResponse.HttpServerResponse,\n    f: (cookies: Cookies.Cookies) => Cookies.Cookies\n  ) => ServerResponse.HttpServerResponse\n>(2, (self, f) =>\n  new ServerResponseImpl(\n    self.status,\n    self.statusText,\n    self.headers,\n    f(self.cookies),\n    self.body\n  ))\n\n/** @internal */\nexport const setCookies = dual<\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookies.Cookie[\"options\"]]>\n  ) => (\n    self: ServerResponse.HttpServerResponse\n  ) => Effect.Effect<ServerResponse.HttpServerResponse, Cookies.CookiesError>,\n  (\n    self: ServerResponse.HttpServerResponse,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookies.Cookie[\"options\"]]>\n  ) => Effect.Effect<ServerResponse.HttpServerResponse, Cookies.CookiesError>\n>(\n  2,\n  (self, cookies) =>\n    Effect.map(Cookies.setAll(self.cookies, cookies), (cookies) =>\n      new ServerResponseImpl(\n        self.status,\n        self.statusText,\n        self.headers,\n        cookies,\n        self.body\n      ))\n)\n\n/** @internal */\nexport const mergeCookies = dual<\n  (\n    cookies: Cookies.Cookies\n  ) => (\n    self: ServerResponse.HttpServerResponse\n  ) => ServerResponse.HttpServerResponse,\n  (\n    self: ServerResponse.HttpServerResponse,\n    cookies: Cookies.Cookies\n  ) => ServerResponse.HttpServerResponse\n>(\n  2,\n  (self, cookies) =>\n    new ServerResponseImpl(\n      self.status,\n      self.statusText,\n      self.headers,\n      Cookies.merge(self.cookies, cookies),\n      self.body\n    )\n)\n\n/** @internal */\nexport const unsafeSetCookies = dual<\n  (\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookies.Cookie[\"options\"]]>\n  ) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (\n    self: ServerResponse.HttpServerResponse,\n    cookies: Iterable<readonly [name: string, value: string, options?: Cookies.Cookie[\"options\"]]>\n  ) => ServerResponse.HttpServerResponse\n>(\n  2,\n  (self, cookies) =>\n    new ServerResponseImpl(\n      self.status,\n      self.statusText,\n      self.headers,\n      Cookies.unsafeSetAll(self.cookies, cookies),\n      self.body\n    )\n)\n\n/** @internal */\nexport const removeCookie = dual<\n  (\n    name: string\n  ) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (\n    self: ServerResponse.HttpServerResponse,\n    name: string\n  ) => ServerResponse.HttpServerResponse\n>(\n  2,\n  (self, name) =>\n    new ServerResponseImpl(\n      self.status,\n      self.statusText,\n      self.headers,\n      Cookies.remove(self.cookies, name),\n      self.body\n    )\n)\n\n/** @internal */\nexport const setHeaders = dual<\n  (input: Headers.Input) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (self: ServerResponse.HttpServerResponse, input: Headers.Input) => ServerResponse.HttpServerResponse\n>(2, (self, input) =>\n  new ServerResponseImpl(\n    self.status,\n    self.statusText,\n    Headers.setAll(self.headers, input),\n    self.cookies,\n    self.body\n  ))\n\n/** @internal */\nexport const setStatus = dual<\n  (\n    status: number,\n    statusText?: string\n  ) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (self: ServerResponse.HttpServerResponse, status: number, statusText?: string) => ServerResponse.HttpServerResponse\n>((args) => isServerResponse(args[0]), (self, status, statusText) =>\n  new ServerResponseImpl(\n    status,\n    statusText,\n    self.headers,\n    self.cookies,\n    self.body\n  ))\n\n/** @internal */\nexport const setBody = dual<\n  (body: Body.HttpBody) => (self: ServerResponse.HttpServerResponse) => ServerResponse.HttpServerResponse,\n  (self: ServerResponse.HttpServerResponse, body: Body.HttpBody) => ServerResponse.HttpServerResponse\n>(2, (self, body) => {\n  let headers = self.headers\n  if (body._tag === \"Empty\") {\n    headers = Headers.remove(Headers.remove(headers, \"Content-Type\"), \"Content-length\")\n  }\n  return new ServerResponseImpl(\n    self.status,\n    self.statusText,\n    headers,\n    self.cookies,\n    body\n  )\n})\n\n/** @internal */\nexport const toWeb = (response: ServerResponse.HttpServerResponse, options?: {\n  readonly withoutBody?: boolean | undefined\n  readonly runtime?: Runtime.Runtime<never> | undefined\n}): Response => {\n  const headers = new globalThis.Headers(response.headers)\n  if (!Cookies.isEmpty(response.cookies)) {\n    const toAdd = Cookies.toSetCookieHeaders(response.cookies)\n    for (const header of toAdd) {\n      headers.append(\"set-cookie\", header)\n    }\n  }\n  if (options?.withoutBody) {\n    return new Response(undefined, {\n      status: response.status,\n      statusText: response.statusText as string,\n      headers\n    })\n  }\n  const body = response.body\n  switch (body._tag) {\n    case \"Empty\": {\n      return new Response(undefined, {\n        status: response.status,\n        statusText: response.statusText as string,\n        headers\n      })\n    }\n    case \"Uint8Array\":\n    case \"Raw\": {\n      if (body.body instanceof Response) {\n        for (const [key, value] of headers as any) {\n          body.body.headers.set(key, value)\n        }\n        return body.body\n      }\n      return new Response(body.body as any, {\n        status: response.status,\n        statusText: response.statusText,\n        headers\n      })\n    }\n    case \"FormData\": {\n      return new Response(body.formData as any, {\n        status: response.status,\n        statusText: response.statusText,\n        headers\n      })\n    }\n    case \"Stream\": {\n      return new Response(Stream.toReadableStreamRuntime(body.stream, options?.runtime ?? Runtime.defaultRuntime), {\n        status: response.status,\n        statusText: response.statusText,\n        headers\n      })\n    }\n  }\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Cause from \"effect/Cause\"\nimport * as Effect from \"effect/Effect\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport { hasProperty } from \"effect/Predicate\"\nimport type { HttpServerResponse } from \"./HttpServerResponse.js\"\nimport * as ServerResponse from \"./HttpServerResponse.js\"\n\n/**\n * @since 1.0.0\n * @category symbols\n */\nexport const symbol: unique symbol = Symbol.for(\"@effect/platform/HttpServerRespondable\")\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Respondable {\n  readonly [symbol]: () => Effect.Effect<HttpServerResponse, unknown>\n}\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isRespondable = (u: unknown): u is Respondable => hasProperty(u, symbol)\n\nconst badRequest = ServerResponse.empty({ status: 400 })\nconst notFound = ServerResponse.empty({ status: 404 })\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const toResponse = (self: Respondable): Effect.Effect<HttpServerResponse> => {\n  if (ServerResponse.isServerResponse(self)) {\n    return Effect.succeed(self)\n  }\n  return Effect.orDie(self[symbol]())\n}\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const toResponseOrElse = (u: unknown, orElse: HttpServerResponse): Effect.Effect<HttpServerResponse> => {\n  if (ServerResponse.isServerResponse(u)) {\n    return Effect.succeed(u)\n  } else if (isRespondable(u)) {\n    return Effect.catchAllCause(u[symbol](), () => Effect.succeed(orElse))\n    // add support for some commmon types\n  } else if (ParseResult.isParseError(u)) {\n    return Effect.succeed(badRequest)\n  } else if (Cause.isNoSuchElementException(u)) {\n    return Effect.succeed(notFound)\n  }\n  return Effect.succeed(orElse)\n}\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const toResponseOrElseDefect = (u: unknown, orElse: HttpServerResponse): Effect.Effect<HttpServerResponse> => {\n  if (ServerResponse.isServerResponse(u)) {\n    return Effect.succeed(u)\n  } else if (isRespondable(u)) {\n    return Effect.catchAllCause(u[symbol](), () => Effect.succeed(orElse))\n  }\n  return Effect.succeed(orElse)\n}\n", "/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport type * as Effect from \"effect/Effect\"\nimport type * as Exit from \"effect/Exit\"\nimport type * as FiberId from \"effect/FiberId\"\nimport type * as Option from \"effect/Option\"\nimport { TypeIdError } from \"./Error.js\"\nimport type * as ServerRequest from \"./HttpServerRequest.js\"\nimport * as Respondable from \"./HttpServerRespondable.js\"\nimport * as ServerResponse from \"./HttpServerResponse.js\"\nimport * as internal from \"./internal/httpServerError.js\"\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type id\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport type HttpServerError = RequestError | ResponseError | RouteNotFound | ServeError\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class RequestError extends TypeIdError(TypeId, \"RequestError\")<{\n  readonly request: ServerRequest.HttpServerRequest\n  readonly reason: \"Transport\" | \"Decode\"\n  readonly cause?: unknown\n  readonly description?: string\n}> implements Respondable.Respondable {\n  /**\n   * @since 1.0.0\n   */\n  [Respondable.symbol]() {\n    return ServerResponse.empty({ status: 400 })\n  }\n\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    return this.description ?\n      `${this.reason}: ${this.description} (${this.methodAndUrl})` :\n      `${this.reason} error (${this.methodAndUrl})`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category predicates\n */\nexport const isServerError: (u: unknown) => u is HttpServerError = internal.isServerError\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class RouteNotFound extends TypeIdError(TypeId, \"RouteNotFound\")<{\n  readonly request: ServerRequest.HttpServerRequest\n}> {\n  constructor(options: { request: ServerRequest.HttpServerRequest }) {\n    super(options)\n    ;(this as any).stack = `${this.name}: ${this.message}`\n  }\n  /**\n   * @since 1.0.0\n   */\n  [Respondable.symbol]() {\n    return ServerResponse.empty({ status: 404 })\n  }\n  get message() {\n    return `${this.request.method} ${this.request.url} not found`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class ResponseError extends TypeIdError(TypeId, \"ResponseError\")<{\n  readonly request: ServerRequest.HttpServerRequest\n  readonly response: ServerResponse.HttpServerResponse\n  readonly reason: \"Decode\"\n  readonly cause?: unknown\n  readonly description?: string\n}> {\n  /**\n   * @since 1.0.0\n   */\n  [Respondable.symbol]() {\n    return ServerResponse.empty({ status: 500 })\n  }\n\n  get methodAndUrl() {\n    return `${this.request.method} ${this.request.url}`\n  }\n\n  get message() {\n    const info = `${this.response.status} ${this.methodAndUrl}`\n    return this.description ?\n      `${this.description} (${info})` :\n      `${this.reason} error (${info})`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category error\n */\nexport class ServeError extends TypeIdError(TypeId, \"ServeError\")<{\n  readonly cause: unknown\n}> {}\n\n/**\n * @since 1.0.0\n */\nexport const clientAbortFiberId: FiberId.FiberId = internal.clientAbortFiberId\n\n/**\n * @since 1.0.0\n */\nexport const causeResponse: <E>(\n  cause: Cause.Cause<E>\n) => Effect.Effect<readonly [ServerResponse.HttpServerResponse, Cause.Cause<E>]> = internal.causeResponse\n\n/**\n * @since 1.0.0\n */\nexport const causeResponseStripped: <E>(\n  cause: Cause.Cause<E>\n) => readonly [response: ServerResponse.HttpServerResponse, cause: Option.Option<Cause.Cause<E>>] =\n  internal.causeResponseStripped\n\n/**\n * @since 1.0.0\n */\nexport const exitResponse: <E>(\n  exit: Exit.Exit<ServerResponse.HttpServerResponse, E>\n) => ServerResponse.HttpServerResponse = internal.exitResponse\n", "import * as Cause from \"effect/Cause\"\nimport * as Effect from \"effect/Effect\"\nimport type * as Exit from \"effect/Exit\"\nimport * as FiberId from \"effect/FiberId\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport type * as Error from \"../HttpServerError.js\"\nimport * as Respondable from \"../HttpServerRespondable.js\"\nimport type { HttpServerResponse } from \"../HttpServerResponse.js\"\nimport * as internalServerResponse from \"./httpServerResponse.js\"\n\n/** @internal */\nexport const TypeId: Error.TypeId = Symbol.for(\n  \"@effect/platform/HttpServerError\"\n) as Error.TypeId\n\n/** @internal */\nexport const isServerError = (u: unknown): u is Error.HttpServerError => Predicate.hasProperty(u, TypeId)\n\n/** @internal */\nexport const clientAbortFiberId = globalValue(\n  \"@effect/platform/HttpServerError/clientAbortFiberId\",\n  () => FiberId.runtime(-499, 0)\n)\n\n/** @internal */\nexport const causeResponse = <E>(\n  cause: Cause.Cause<E>\n): Effect.Effect<readonly [HttpServerResponse, Cause.Cause<E>]> => {\n  const [effect, stripped] = Cause.reduce(\n    cause,\n    [Effect.succeed(internalServerError), Cause.empty as Cause.Cause<E>] as const,\n    (acc, cause) => {\n      switch (cause._tag) {\n        case \"Empty\": {\n          return Option.some(acc)\n        }\n        case \"Fail\": {\n          return Option.some([Respondable.toResponseOrElse(cause.error, internalServerError), cause] as const)\n        }\n        case \"Die\": {\n          return Option.some([Respondable.toResponseOrElseDefect(cause.defect, internalServerError), cause] as const)\n        }\n        case \"Interrupt\": {\n          if (acc[1]._tag !== \"Empty\") {\n            return Option.none()\n          }\n          const response = cause.fiberId === clientAbortFiberId ? clientAbortError : serverAbortError\n          return Option.some([Effect.succeed(response), cause] as const)\n        }\n        default: {\n          return Option.none()\n        }\n      }\n    }\n  )\n  return Effect.map(effect, (response) => {\n    if (Cause.isEmptyType(stripped)) {\n      return [response, Cause.die(response)] as const\n    }\n    return [response, Cause.sequential(stripped, Cause.die(response))] as const\n  })\n}\n\n/** @internal */\nexport const causeResponseStripped = <E>(\n  cause: Cause.Cause<E>\n): readonly [response: HttpServerResponse, cause: Option.Option<Cause.Cause<E>>] => {\n  let response: HttpServerResponse | undefined\n  const stripped = Cause.stripSomeDefects(cause, (defect) => {\n    if (internalServerResponse.isServerResponse(defect)) {\n      response = defect\n      return Option.some(Cause.empty)\n    }\n    return Option.none()\n  })\n  return [response ?? internalServerError, stripped]\n}\n\nconst internalServerError = internalServerResponse.empty({ status: 500 })\nconst clientAbortError = internalServerResponse.empty({ status: 499 })\nconst serverAbortError = internalServerResponse.empty({ status: 503 })\n\n/** @internal */\nexport const exitResponse = <E>(exit: Exit.Exit<HttpServerResponse, E>): HttpServerResponse => {\n  if (exit._tag === \"Success\") {\n    return exit.value\n  }\n  return causeResponseStripped(exit.cause)[0]\n}\n", "/**\n * @since 1.0.0\n */\n\nimport type { Tag } from \"effect/Context\"\nimport type { Effect } from \"effect/Effect\"\nimport type { Layer } from \"effect/Layer\"\nimport type { BadArgument } from \"./Error.js\"\nimport * as internal from \"./internal/path.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category model\n */\nexport interface Path {\n  readonly [TypeId]: TypeId\n  readonly sep: string\n  readonly basename: (path: string, suffix?: string) => string\n  readonly dirname: (path: string) => string\n  readonly extname: (path: string) => string\n  readonly format: (pathObject: Partial<Path.Parsed>) => string\n  readonly fromFileUrl: (url: URL) => Effect<string, BadArgument>\n  readonly isAbsolute: (path: string) => boolean\n  readonly join: (...paths: ReadonlyArray<string>) => string\n  readonly normalize: (path: string) => string\n  readonly parse: (path: string) => Path.Parsed\n  readonly relative: (from: string, to: string) => string\n  readonly resolve: (...pathSegments: ReadonlyArray<string>) => string\n  readonly toFileUrl: (path: string) => Effect<URL, BadArgument>\n  readonly toNamespacedPath: (path: string) => string\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Path {\n  /**\n   * @since 1.0.0\n   * @category model\n   */\n  export interface Parsed {\n    readonly root: string\n    readonly dir: string\n    readonly base: string\n    readonly ext: string\n    readonly name: string\n  }\n}\n\n/**\n * @since 1.0.0\n * @category tag\n */\nexport const Path: Tag<Path, Path> = internal.Path\n\n/**\n * An implementation of the Path interface that can be used in all environments\n * (including browsers).\n *\n * It uses the POSIX standard for paths.\n *\n * @since 1.0.0\n * @category layer\n */\nexport const layer: Layer<Path> = internal.layer\n", "import { GenericTag } from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport { BadArgument } from \"../Error.js\"\nimport type * as Api from \"../Path.js\"\n\n/** @internal */\nexport const TypeId: Api.TypeId = Symbol.for(\"@effect/platform/Path\") as Api.TypeId\n\n/** @internal */\nexport const Path = GenericTag<Api.Path>(\"@effect/platform/Path\")\n\n/**\n * The following functions are adapted from the Node.js source code:\n * https://github.com/nodejs/node/blob/main/lib/internal/url.js\n *\n * The following license applies to these functions:\n * - MIT\n */\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path: string, allowAboveRoot: boolean) {\n  let res = \"\"\n  let lastSegmentLength = 0\n  let lastSlash = -1\n  let dots = 0\n  let code\n  for (let i = 0; i <= path.length; ++i) {\n    if (i < path.length) {\n      code = path.charCodeAt(i)\n    } else if (code === 47 /*/*/) {\n      break\n    } else {\n      code = 47 /*/*/\n    }\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (\n          res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ ||\n          res.charCodeAt(res.length - 2) !== 46 /*.*/\n        ) {\n          if (res.length > 2) {\n            const lastSlashIndex = res.lastIndexOf(\"/\")\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = \"\"\n                lastSegmentLength = 0\n              } else {\n                res = res.slice(0, lastSlashIndex)\n                lastSegmentLength = res.length - 1 - res.lastIndexOf(\"/\")\n              }\n              lastSlash = i\n              dots = 0\n              continue\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = \"\"\n            lastSegmentLength = 0\n            lastSlash = i\n            dots = 0\n            continue\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0) {\n            res += \"/..\"\n          } else {\n            res = \"..\"\n          }\n          lastSegmentLength = 2\n        }\n      } else {\n        if (res.length > 0) {\n          res += \"/\" + path.slice(lastSlash + 1, i)\n        } else {\n          res = path.slice(lastSlash + 1, i)\n        }\n        lastSegmentLength = i - lastSlash - 1\n      }\n      lastSlash = i\n      dots = 0\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ;++dots\n    } else {\n      dots = -1\n    }\n  }\n  return res\n}\n\nfunction _format(sep: string, pathObject: Partial<Api.Path.Parsed>) {\n  const dir = pathObject.dir || pathObject.root\n  const base = pathObject.base || (pathObject.name || \"\") + (pathObject.ext || \"\")\n  if (!dir) {\n    return base\n  }\n  if (dir === pathObject.root) {\n    return dir + base\n  }\n  return dir + sep + base\n}\n\nfunction fromFileUrl(url: URL): Effect.Effect<string, BadArgument> {\n  if (url.protocol !== \"file:\") {\n    return Effect.fail(\n      new BadArgument({\n        module: \"Path\",\n        method: \"fromFileUrl\",\n        description: \"URL must be of scheme file\"\n      })\n    )\n  } else if (url.hostname !== \"\") {\n    return Effect.fail(\n      new BadArgument({\n        module: \"Path\",\n        method: \"fromFileUrl\",\n        description: \"Invalid file URL host\"\n      })\n    )\n  }\n  const pathname = url.pathname\n  for (let n = 0; n < pathname.length; n++) {\n    if (pathname[n] === \"%\") {\n      const third = pathname.codePointAt(n + 2)! | 0x20\n      if (pathname[n + 1] === \"2\" && third === 102) {\n        return Effect.fail(\n          new BadArgument({\n            module: \"Path\",\n            method: \"fromFileUrl\",\n            description: \"must not include encoded / characters\"\n          })\n        )\n      }\n    }\n  }\n  return Effect.succeed(decodeURIComponent(pathname))\n}\n\nconst resolve: Api.Path[\"resolve\"] = function resolve() {\n  let resolvedPath = \"\"\n  let resolvedAbsolute = false\n  let cwd: string | undefined = undefined\n\n  for (let i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    let path: string\n    if (i >= 0) {\n      path = arguments[i]\n    } else {\n      const process = (globalThis as any).process\n      if (\n        cwd === undefined && \"process\" in globalThis &&\n        typeof process === \"object\" &&\n        process !== null &&\n        typeof process.cwd === \"function\"\n      ) {\n        cwd = process.cwd()\n      }\n      path = cwd!\n    }\n\n    // Skip empty entries\n    if (path.length === 0) {\n      continue\n    }\n\n    resolvedPath = path + \"/\" + resolvedPath\n    resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute)\n\n  if (resolvedAbsolute) {\n    if (resolvedPath.length > 0) {\n      return \"/\" + resolvedPath\n    } else {\n      return \"/\"\n    }\n  } else if (resolvedPath.length > 0) {\n    return resolvedPath\n  } else {\n    return \".\"\n  }\n}\n\nconst CHAR_FORWARD_SLASH = 47\n\nfunction toFileUrl(filepath: string) {\n  const outURL = new URL(\"file://\")\n  let resolved = resolve(filepath)\n  // path.resolve strips trailing slashes so we must add them back\n  const filePathLast = filepath.charCodeAt(filepath.length - 1)\n  if (\n    (filePathLast === CHAR_FORWARD_SLASH) &&\n    resolved[resolved.length - 1] !== \"/\"\n  ) {\n    resolved += \"/\"\n  }\n  outURL.pathname = encodePathChars(resolved)\n  return Effect.succeed(outURL)\n}\n\nconst percentRegEx = /%/g\nconst backslashRegEx = /\\\\/g\nconst newlineRegEx = /\\n/g\nconst carriageReturnRegEx = /\\r/g\nconst tabRegEx = /\\t/g\n\nfunction encodePathChars(filepath: string) {\n  if (filepath.includes(\"%\")) {\n    filepath = filepath.replace(percentRegEx, \"%25\")\n  }\n  if (filepath.includes(\"\\\\\")) {\n    filepath = filepath.replace(backslashRegEx, \"%5C\")\n  }\n  if (filepath.includes(\"\\n\")) {\n    filepath = filepath.replace(newlineRegEx, \"%0A\")\n  }\n  if (filepath.includes(\"\\r\")) {\n    filepath = filepath.replace(carriageReturnRegEx, \"%0D\")\n  }\n  if (filepath.includes(\"\\t\")) {\n    filepath = filepath.replace(tabRegEx, \"%09\")\n  }\n  return filepath\n}\n\nconst posixImpl = Path.of({\n  [TypeId]: TypeId,\n  resolve,\n  normalize(path) {\n    if (path.length === 0) return \".\"\n\n    const isAbsolute = path.charCodeAt(0) === 47 /*/*/\n    const trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute)\n\n    if (path.length === 0 && !isAbsolute) path = \".\"\n    if (path.length > 0 && trailingSeparator) path += \"/\"\n\n    if (isAbsolute) return \"/\" + path\n    return path\n  },\n\n  isAbsolute(path) {\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/\n  },\n\n  join() {\n    if (arguments.length === 0) {\n      return \".\"\n    }\n    let joined\n    for (let i = 0; i < arguments.length; ++i) {\n      const arg = arguments[i]\n      if (arg.length > 0) {\n        if (joined === undefined) {\n          joined = arg\n        } else {\n          joined += \"/\" + arg\n        }\n      }\n    }\n    if (joined === undefined) {\n      return \".\"\n    }\n    return posixImpl.normalize(joined)\n  },\n\n  relative(from, to) {\n    if (from === to) return \"\"\n\n    from = posixImpl.resolve(from)\n    to = posixImpl.resolve(to)\n\n    if (from === to) return \"\"\n\n    // Trim any leading backslashes\n    let fromStart = 1\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/) {\n        break\n      }\n    }\n    const fromEnd = from.length\n    const fromLen = fromEnd - fromStart\n\n    // Trim any leading backslashes\n    let toStart = 1\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/) {\n        break\n      }\n    }\n    const toEnd = to.length\n    const toLen = toEnd - toStart\n\n    // Compare paths to find the longest common path from root\n    const length = fromLen < toLen ? fromLen : toLen\n    let lastCommonSep = -1\n    let i = 0\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1)\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i)\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0\n          }\n        }\n        break\n      }\n      const fromCode = from.charCodeAt(fromStart + i)\n      const toCode = to.charCodeAt(toStart + i)\n      if (fromCode !== toCode) {\n        break\n      } else if (fromCode === 47 /*/*/) {\n        lastCommonSep = i\n      }\n    }\n\n    let out = \"\"\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0) {\n          out += \"..\"\n        } else {\n          out += \"/..\"\n        }\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0) {\n      return out + to.slice(toStart + lastCommonSep)\n    } else {\n      toStart += lastCommonSep\n      if (to.charCodeAt(toStart) === 47 /*/*/) {\n        ;++toStart\n      }\n      return to.slice(toStart)\n    }\n  },\n\n  dirname(path) {\n    if (path.length === 0) return \".\"\n    let code = path.charCodeAt(0)\n    const hasRoot = code === 47 /*/*/\n    let end = -1\n    let matchedSlash = true\n    for (let i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i)\n      if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i\n          break\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false\n      }\n    }\n\n    if (end === -1) return hasRoot ? \"/\" : \".\"\n    if (hasRoot && end === 1) return \"//\"\n    return path.slice(0, end)\n  },\n\n  basename(path, ext) {\n    let start = 0\n    let end = -1\n    let matchedSlash = true\n    let i\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return \"\"\n      let extIdx = ext.length - 1\n      let firstNonSlashEnd = -1\n      for (i = path.length - 1; i >= 0; --i) {\n        const code = path.charCodeAt(i)\n        if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false\n            firstNonSlashEnd = i + 1\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1\n              end = firstNonSlashEnd\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd\n      else if (end === -1) end = path.length\n      return path.slice(start, end)\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1\n            break\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false\n          end = i + 1\n        }\n      }\n\n      if (end === -1) return \"\"\n      return path.slice(start, end)\n    }\n  },\n\n  extname(path) {\n    let startDot = -1\n    let startPart = 0\n    let end = -1\n    let matchedSlash = true\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0\n    for (let i = path.length - 1; i >= 0; --i) {\n      const code = path.charCodeAt(i)\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) {\n          startDot = i\n        } else if (preDotState !== 1) {\n          preDotState = 1\n        }\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n    ) {\n      return \"\"\n    }\n    return path.slice(startDot, end)\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== \"object\") {\n      throw new TypeError(\"The \\\"pathObject\\\" argument must be of type Object. Received type \" + typeof pathObject)\n    }\n    return _format(\"/\", pathObject)\n  },\n\n  parse(path) {\n    const ret = { root: \"\", dir: \"\", base: \"\", ext: \"\", name: \"\" }\n    if (path.length === 0) return ret\n    let code = path.charCodeAt(0)\n    const isAbsolute = code === 47 /*/*/\n    let start\n    if (isAbsolute) {\n      ret.root = \"/\"\n      start = 1\n    } else {\n      start = 0\n    }\n    let startDot = -1\n    let startPart = 0\n    let end = -1\n    let matchedSlash = true\n    let i = path.length - 1\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    let preDotState = 0\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i)\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1\n          break\n        }\n        continue\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false\n        end = i + 1\n      }\n      if (code === 46 /*.*/) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i\n        else if (preDotState !== 1) preDotState = 1\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1\n      }\n    }\n\n    if (\n      startDot === -1 || end === -1 ||\n      // We saw a non-dot character immediately before the dot\n      preDotState === 0 ||\n      // The (right-most) trimmed path component is exactly '..'\n      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1\n    ) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end)\n        else ret.base = ret.name = path.slice(startPart, end)\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot)\n        ret.base = path.slice(1, end)\n      } else {\n        ret.name = path.slice(startPart, startDot)\n        ret.base = path.slice(startPart, end)\n      }\n      ret.ext = path.slice(startDot, end)\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1)\n    else if (isAbsolute) ret.dir = \"/\"\n\n    return ret\n  },\n\n  sep: \"/\",\n  fromFileUrl,\n  toFileUrl,\n  toNamespacedPath: identity\n})\n\n/** @internal */\nexport const layer = Layer.succeed(Path, posixImpl)\n", "/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport * as Channel from \"effect/Channel\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport { constant, dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as AsyncInput from \"effect/SingleProducerAsyncInput\"\nimport * as Stream from \"effect/Stream\"\nimport * as MP from \"multipasta\"\nimport * as FileSystem from \"./FileSystem.js\"\nimport * as IncomingMessage from \"./HttpIncomingMessage.js\"\nimport * as Path from \"./Path.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Multipart\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Part = Field | File\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Part {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Proto extends Inspectable.Inspectable {\n    readonly [TypeId]: TypeId\n    readonly _tag: string\n  }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Field extends Part.Proto {\n  readonly _tag: \"Field\"\n  readonly key: string\n  readonly contentType: string\n  readonly value: string\n}\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isPart = (u: unknown): u is Part => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isField = (u: unknown): u is Field => isPart(u) && u._tag === \"Field\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface File extends Part.Proto {\n  readonly _tag: \"File\"\n  readonly key: string\n  readonly name: string\n  readonly contentType: string\n  readonly content: Stream.Stream<Uint8Array, MultipartError>\n  readonly contentEffect: Effect.Effect<Uint8Array, MultipartError>\n}\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isFile = (u: unknown): u is File => isPart(u) && u._tag === \"File\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface PersistedFile extends Part.Proto {\n  readonly _tag: \"PersistedFile\"\n  readonly key: string\n  readonly name: string\n  readonly contentType: string\n  readonly path: string\n}\n\n/**\n * @since 1.0.0\n * @category Guards\n */\nexport const isPersistedFile = (u: unknown): u is PersistedFile =>\n  Predicate.hasProperty(u, TypeId) && Predicate.isTagged(u, \"PersistedFile\")\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Persisted {\n  readonly [key: string]: ReadonlyArray<PersistedFile> | ReadonlyArray<string> | string\n}\n\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport const ErrorTypeId: unique symbol = Symbol.for(\n  \"@effect/platform/Multipart/MultipartError\"\n)\n\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category Errors\n */\nexport class MultipartError extends Schema.TaggedError<MultipartError>()(\"MultipartError\", {\n  reason: Schema.Literal(\"FileTooLarge\", \"FieldTooLarge\", \"BodyTooLarge\", \"TooManyParts\", \"InternalError\", \"Parse\"),\n  cause: Schema.Defect\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [ErrorTypeId]: ErrorTypeId = ErrorTypeId\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    return this.reason\n  }\n}\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const FileSchema: Schema.Schema<PersistedFile> = Schema.declare(isPersistedFile, {\n  identifier: \"PersistedFile\",\n  jsonSchema: {\n    type: \"string\",\n    format: \"binary\"\n  }\n})\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const FilesSchema: Schema.Schema<ReadonlyArray<PersistedFile>> = Schema.Array(FileSchema)\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const SingleFileSchema: Schema.transform<\n  Schema.Schema<ReadonlyArray<PersistedFile>>,\n  Schema.Schema<PersistedFile>\n> = Schema.transform(FilesSchema.pipe(Schema.itemsCount(1)), FileSchema, {\n  strict: true,\n  decode: ([file]) => file,\n  encode: (file) => [file]\n})\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const schemaPersisted = <A, I extends Partial<Persisted>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n): (persisted: Persisted) => Effect.Effect<\n  A,\n  ParseResult.ParseError,\n  R\n> => Schema.decodeUnknown(schema, options)\n\n/**\n * @since 1.0.0\n * @category Schemas\n */\nexport const schemaJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined): {\n  (\n    field: string\n  ): (persisted: Persisted) => Effect.Effect<A, ParseResult.ParseError, R>\n  (\n    persisted: Persisted,\n    field: string\n  ): Effect.Effect<A, ParseResult.ParseError, R>\n} => {\n  const fromJson = Schema.parseJson(schema)\n  return dual<\n    (\n      field: string\n    ) => (\n      persisted: Persisted\n    ) => Effect.Effect<A, ParseResult.ParseError, R>,\n    (\n      persisted: Persisted,\n      field: string\n    ) => Effect.Effect<A, ParseResult.ParseError, R>\n  >(2, (persisted, field) =>\n    Effect.map(\n      Schema.decodeUnknown(\n        Schema.Struct({\n          [field]: fromJson\n        }),\n        options\n      )(persisted),\n      (_) => _[field]\n    ))\n}\n\n/**\n * @since 1.0.0\n * @category Config\n */\nexport const makeConfig = (\n  headers: Record<string, string>\n): Effect.Effect<MP.BaseConfig> =>\n  Effect.withFiberRuntime((fiber) => {\n    const mimeTypes = Context.get(fiber.currentContext, FieldMimeTypes)\n    return Effect.succeed<MP.BaseConfig>({\n      headers,\n      maxParts: Option.getOrUndefined(Context.get(fiber.currentContext, MaxParts)),\n      maxFieldSize: Number(Context.get(fiber.currentContext, MaxFieldSize)),\n      maxPartSize: Context.get(fiber.currentContext, MaxFileSize).pipe(Option.map(Number), Option.getOrUndefined),\n      maxTotalSize: Context.get(fiber.currentContext, IncomingMessage.MaxBodySize).pipe(\n        Option.map(Number),\n        Option.getOrUndefined\n      ),\n      isFile: mimeTypes.length === 0 ? undefined : (info: MP.PartInfo): boolean =>\n        !Chunk.some(\n          mimeTypes,\n          (_) => info.contentType.includes(_)\n        ) && MP.defaultIsFile(info)\n    })\n  })\n\n/**\n * @since 1.0.0\n * @category Parsers\n */\nexport const makeChannel = <IE>(\n  headers: Record<string, string>,\n  bufferSize = 16\n): Channel.Channel<\n  Chunk.Chunk<Part>,\n  Chunk.Chunk<Uint8Array>,\n  MultipartError | IE,\n  IE,\n  unknown,\n  unknown\n> =>\n  Channel.acquireUseRelease(\n    Effect.all([\n      makeConfig(headers),\n      Mailbox.make<Chunk.Chunk<Uint8Array>>(bufferSize)\n    ]),\n    ([config, mailbox]) => {\n      let partsBuffer: Array<Part> = []\n      let exit = Option.none<Exit.Exit<void, IE | MultipartError>>()\n\n      const input: AsyncInput.AsyncInputProducer<IE, Chunk.Chunk<Uint8Array>, unknown> = {\n        awaitRead: () => Effect.void,\n        emit(element) {\n          return mailbox.offer(element)\n        },\n        error(cause) {\n          exit = Option.some(Exit.failCause(cause))\n          return mailbox.end\n        },\n        done(_value) {\n          return mailbox.end\n        }\n      }\n\n      const parser = MP.make({\n        ...config,\n        onField(info, value) {\n          partsBuffer.push(new FieldImpl(info.name, info.contentType, MP.decodeField(info, value)))\n        },\n        onFile(info) {\n          let chunks: Array<Uint8Array> = []\n          let finished = false\n          const take: Channel.Channel<Chunk.Chunk<Uint8Array>> = Channel.suspend(() => {\n            if (chunks.length === 0) {\n              return finished ? Channel.void : Channel.zipRight(pump, take)\n            }\n            const chunk = Chunk.unsafeFromArray(chunks)\n            chunks = []\n            return finished ? Channel.write(chunk) : Channel.zipRight(\n              Channel.write(chunk),\n              Channel.zipRight(pump, take)\n            )\n          })\n          partsBuffer.push(new FileImpl(info, take))\n          return function(chunk) {\n            if (chunk === null) {\n              finished = true\n            } else {\n              chunks.push(chunk)\n            }\n          }\n        },\n        onError(error_) {\n          exit = Option.some(Exit.fail(convertError(error_)))\n        },\n        onDone() {\n          exit = Option.some(Exit.void)\n        }\n      })\n\n      const pump = Channel.flatMap(\n        mailbox.takeAll,\n        ([chunks, done]) =>\n          Channel.sync(() => {\n            Chunk.forEach(chunks, Chunk.forEach(parser.write))\n            if (done) {\n              parser.end()\n            }\n          })\n      )\n\n      const partsChannel: Channel.Channel<\n        Chunk.Chunk<Part>,\n        unknown,\n        IE | MultipartError\n      > = Channel.flatMap(\n        pump,\n        () => {\n          if (partsBuffer.length === 0) {\n            return exit._tag === \"None\" ? partsChannel : writeExit(exit.value)\n          }\n          const chunk = Chunk.unsafeFromArray(partsBuffer)\n          partsBuffer = []\n          return Channel.zipRight(\n            Channel.write(chunk),\n            exit._tag === \"None\" ? partsChannel : writeExit(exit.value)\n          )\n        }\n      )\n\n      return Channel.embedInput(partsChannel, input)\n    },\n    ([, mailbox]) => mailbox.shutdown\n  )\n\nconst writeExit = <A, E>(\n  self: Exit.Exit<A, E>\n): Channel.Channel<never, unknown, E> => self._tag === \"Success\" ? Channel.void : Channel.failCause(self.cause)\n\nfunction convertError(cause: MP.MultipartError): MultipartError {\n  switch (cause._tag) {\n    case \"ReachedLimit\": {\n      switch (cause.limit) {\n        case \"MaxParts\": {\n          return new MultipartError({ reason: \"TooManyParts\", cause })\n        }\n        case \"MaxFieldSize\": {\n          return new MultipartError({ reason: \"FieldTooLarge\", cause })\n        }\n        case \"MaxPartSize\": {\n          return new MultipartError({ reason: \"FileTooLarge\", cause })\n        }\n        case \"MaxTotalSize\": {\n          return new MultipartError({ reason: \"BodyTooLarge\", cause })\n        }\n      }\n    }\n    default: {\n      return new MultipartError({ reason: \"Parse\", cause })\n    }\n  }\n}\n\nabstract class PartBase extends Inspectable.Class {\n  readonly [TypeId]: TypeId\n  constructor() {\n    super()\n    this[TypeId] = TypeId\n  }\n}\n\nclass FieldImpl extends PartBase implements Field {\n  readonly _tag = \"Field\"\n\n  constructor(\n    readonly key: string,\n    readonly contentType: string,\n    readonly value: string\n  ) {\n    super()\n  }\n\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"Field\",\n      key: this.key,\n      contentType: this.contentType,\n      value: this.value\n    }\n  }\n}\n\nclass FileImpl extends PartBase implements File {\n  readonly _tag = \"File\"\n  readonly key: string\n  readonly name: string\n  readonly contentType: string\n  readonly content: Stream.Stream<Uint8Array, MultipartError>\n  readonly contentEffect: Effect.Effect<Uint8Array, MultipartError>\n\n  constructor(\n    info: MP.PartInfo,\n    channel: Channel.Channel<Chunk.Chunk<Uint8Array>, unknown, never, unknown, void, unknown>\n  ) {\n    super()\n    this.key = info.name\n    this.name = info.filename ?? info.name\n    this.contentType = info.contentType\n    this.content = Stream.fromChannel(channel)\n    this.contentEffect = channel.pipe(\n      Channel.pipeTo(collectUint8Array),\n      Channel.run,\n      Effect.mapError((cause) => new MultipartError({ reason: \"InternalError\", cause }))\n    )\n  }\n\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"File\",\n      key: this.key,\n      name: this.name,\n      contentType: this.contentType\n    }\n  }\n}\n\nconst defaultWriteFile = (path: string, file: File) =>\n  Effect.flatMap(\n    FileSystem.FileSystem,\n    (fs) =>\n      Effect.mapError(\n        Stream.run(file.content, fs.sink(path)),\n        (cause) => new MultipartError({ reason: \"InternalError\", cause })\n      )\n  )\n\n/**\n * @since 1.0.0\n */\nexport const collectUint8Array = Channel.suspend(() => {\n  let accumulator = new Uint8Array(0)\n  const loop: Channel.Channel<\n    never,\n    Chunk.Chunk<Uint8Array>,\n    unknown,\n    unknown,\n    Uint8Array\n  > = Channel.readWithCause({\n    onInput(chunk: Chunk.Chunk<Uint8Array>) {\n      for (const element of chunk) {\n        const newAccumulator = new Uint8Array(accumulator.length + element.length)\n        newAccumulator.set(accumulator, 0)\n        newAccumulator.set(element, accumulator.length)\n        accumulator = newAccumulator\n      }\n      return loop\n    },\n    onFailure: (cause: Cause.Cause<unknown>) => Channel.failCause(cause),\n    onDone: () => Channel.succeed(accumulator)\n  })\n  return loop\n})\n\n/**\n * @since 1.0.0\n * @category Conversions\n */\nexport const toPersisted = (\n  stream: Stream.Stream<Part, MultipartError>,\n  writeFile = defaultWriteFile\n): Effect.Effect<Persisted, MultipartError, FileSystem.FileSystem | Path.Path | Scope.Scope> =>\n  Effect.gen(function*() {\n    const fs = yield* FileSystem.FileSystem\n    const path_ = yield* Path.Path\n    const dir = yield* fs.makeTempDirectoryScoped()\n    const persisted: Record<string, Array<PersistedFile> | Array<string> | string> = Object.create(null)\n    yield* Stream.runForEach(stream, (part) => {\n      if (part._tag === \"Field\") {\n        if (!(part.key in persisted)) {\n          persisted[part.key] = part.value\n        } else if (typeof persisted[part.key] === \"string\") {\n          persisted[part.key] = [persisted[part.key] as string, part.value]\n        } else {\n          ;(persisted[part.key] as Array<string>).push(part.value)\n        }\n        return Effect.void\n      } else if (part.name === \"\") {\n        return Effect.void\n      }\n      const file = part\n      const path = path_.join(dir, path_.basename(file.name).slice(-128))\n      const filePart = new PersistedFileImpl(\n        file.key,\n        file.name,\n        file.contentType,\n        path\n      )\n      if (Array.isArray(persisted[part.key])) {\n        ;(persisted[part.key] as Array<PersistedFile>).push(filePart)\n      } else {\n        persisted[part.key] = [filePart]\n      }\n      return writeFile(path, file)\n    })\n    return persisted\n  }).pipe(\n    Effect.catchTags({\n      SystemError: (cause) => Effect.fail(new MultipartError({ reason: \"InternalError\", cause })),\n      BadArgument: (cause) => Effect.fail(new MultipartError({ reason: \"InternalError\", cause }))\n    })\n  )\n\nclass PersistedFileImpl extends PartBase implements PersistedFile {\n  readonly _tag = \"PersistedFile\"\n\n  constructor(\n    readonly key: string,\n    readonly name: string,\n    readonly contentType: string,\n    readonly path: string\n  ) {\n    super()\n  }\n\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/Multipart/Part\",\n      _tag: \"PersistedFile\",\n      key: this.key,\n      name: this.name,\n      contentType: this.contentType,\n      path: this.path\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withLimits: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (\n    options: {\n      readonly maxParts?: Option.Option<number> | undefined\n      readonly maxFieldSize?: FileSystem.SizeInput | undefined\n      readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n    }\n  ): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    options: {\n      readonly maxParts?: Option.Option<number> | undefined\n      readonly maxFieldSize?: FileSystem.SizeInput | undefined\n      readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n    }\n  ): Effect.Effect<A, E, R>\n} = dual(2, <A, E, R>(\n  effect: Effect.Effect<A, E, R>,\n  options: {\n    readonly maxParts?: Option.Option<number> | undefined\n    readonly maxFieldSize?: FileSystem.SizeInput | undefined\n    readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n  }\n): Effect.Effect<A, E, R> => Effect.provide(effect, withLimitsContext(options)))\n\nconst withLimitsContext = (options: {\n  readonly maxParts?: Option.Option<number> | undefined\n  readonly maxFieldSize?: FileSystem.SizeInput | undefined\n  readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n  readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n}) => {\n  const contextMap = new Map<string, unknown>()\n  if (options.maxParts !== undefined) {\n    contextMap.set(MaxParts.key, options.maxParts)\n  }\n  if (options.maxFieldSize !== undefined) {\n    contextMap.set(MaxFieldSize.key, FileSystem.Size(options.maxFieldSize))\n  }\n  if (options.maxFileSize !== undefined) {\n    contextMap.set(MaxFileSize.key, Option.map(options.maxFileSize, FileSystem.Size))\n  }\n  if (options.maxTotalSize !== undefined) {\n    contextMap.set(IncomingMessage.MaxBodySize.key, Option.map(options.maxTotalSize, FileSystem.Size))\n  }\n  if (options.fieldMimeTypes !== undefined) {\n    contextMap.set(FieldMimeTypes.key, Chunk.fromIterable(options.fieldMimeTypes))\n  }\n  return Context.unsafeMake(contextMap)\n}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withLimitsStream: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (\n    options: {\n      readonly maxParts?: Option.Option<number> | undefined\n      readonly maxFieldSize?: FileSystem.SizeInput | undefined\n      readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n    }\n  ): <A, E, R>(stream: Stream.Stream<A, E, R>) => Stream.Stream<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(\n    stream: Stream.Stream<A, E, R>,\n    options: {\n      readonly maxParts?: Option.Option<number> | undefined\n      readonly maxFieldSize?: FileSystem.SizeInput | undefined\n      readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n      readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n    }\n  ): Stream.Stream<A, E, R>\n} = dual(2, <A, E, R>(\n  stream: Stream.Stream<A, E, R>,\n  options: {\n    readonly maxParts?: Option.Option<number> | undefined\n    readonly maxFieldSize?: FileSystem.SizeInput | undefined\n    readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n  }\n): Stream.Stream<A, E, R> => Stream.provideSomeContext(stream, withLimitsContext(options)))\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport declare namespace withLimits {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  export type Options = {\n    readonly maxParts?: Option.Option<number> | undefined\n    readonly maxFieldSize?: FileSystem.SizeInput | undefined\n    readonly maxFileSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly maxTotalSize?: Option.Option<FileSystem.SizeInput> | undefined\n    readonly fieldMimeTypes?: ReadonlyArray<string> | undefined\n  }\n}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxParts extends Context.Reference<MaxParts>()(\"@effect/platform/Multipart/MaxParts\", {\n  defaultValue: Option.none<number>\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxParts: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (count: Option.Option<number>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, count: Option.Option<number>): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, count: Option.Option<number>): Effect.Effect<A, E, R> =>\n    Effect.provideService(effect, MaxParts, count)\n)\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxFieldSize extends Context.Reference<MaxFieldSize>()(\"@effect/platform/Multipart/MaxFieldSize\", {\n  defaultValue: constant(FileSystem.Size(10 * 1024 * 1024))\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxFieldSize: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (size: FileSystem.SizeInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: FileSystem.SizeInput): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: FileSystem.SizeInput): Effect.Effect<A, E, R> =>\n    Effect.provideService(effect, MaxFieldSize, FileSystem.Size(size))\n)\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class MaxFileSize extends Context.Reference<MaxFileSize>()(\"@effect/platform/Multipart/MaxFileSize\", {\n  defaultValue: Option.none<FileSystem.Size>\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withMaxFileSize: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (size: Option.Option<FileSystem.SizeInput>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: Option.Option<FileSystem.SizeInput>): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: Option.Option<FileSystem.SizeInput>): Effect.Effect<A, E, R> =>\n    Effect.provideService(\n      effect,\n      MaxFileSize,\n      Option.map(size, FileSystem.Size)\n    )\n)\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport class FieldMimeTypes extends Context.Reference<FieldMimeTypes>()(\"@effect/platform/Multipart/FieldMimeTypes\", {\n  defaultValue: constant<Chunk.Chunk<string>>(Chunk.make(\"application/json\"))\n}) {}\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withFieldMimeTypes: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (mimeTypes: ReadonlyArray<string>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, mimeTypes: ReadonlyArray<string>): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, mimeTypes: ReadonlyArray<string>): Effect.Effect<A, E, R> =>\n    Effect.provideService(effect, FieldMimeTypes, Chunk.fromIterable(mimeTypes))\n)\n", "// taken from https://github.com/fastify/fast-content-type-parse\n// under the MIT license\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nconst paramRE =\n  /; *([!#$%&'*+.^\\w`|~-]+)=(\"(?:[\\v\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\v\\u0020-\\u00ff])*\"|[!#$%&'*+.^\\w`|~-]+) */gu\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nconst quotedPairRE = /\\\\([\\v\\u0020-\\u00ff])/gu\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nconst mediaTypeRE = /^[!#$%&'*+.^\\w|~-]+\\/[!#$%&'*+.^\\w|~-]+$/u\nconst mediaTypeRENoSlash = /^[!#$%&'*+.^\\w|~-]+$/u\n\n// default ContentType to prevent repeated object creation\nconst defaultContentType = { value: \"\", parameters: Object.create(null) }\n\nexport function parse(\n  header: string | undefined,\n  withoutSlash = false,\n): {\n  readonly value: string\n  readonly parameters: Record<string, string>\n} {\n  if (typeof header !== \"string\") {\n    return defaultContentType\n  }\n\n  let index = header.indexOf(\";\")\n  const type = index !== -1 ? header.slice(0, index).trim() : header.trim()\n  const mediaRE = withoutSlash ? mediaTypeRENoSlash : mediaTypeRE\n\n  if (mediaRE.test(type) === false) {\n    return defaultContentType\n  }\n\n  const result = {\n    value: type.toLowerCase(),\n    parameters: Object.create(null),\n  }\n\n  // parse parameters\n  if (index === -1) {\n    return result\n  }\n\n  let key: string\n  let match: RegExpExecArray | null\n  let value: string\n\n  paramRE.lastIndex = index\n\n  while ((match = paramRE.exec(header))) {\n    if (match.index !== index) {\n      return defaultContentType\n    }\n\n    index += match[0].length\n    key = match[1].toLowerCase()\n    value = match[2]\n\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value.slice(1, value.length - 1)\n\n      !withoutSlash &&\n        quotedPairRE.test(value) &&\n        (value = value.replace(quotedPairRE, \"$1\"))\n    }\n\n    result.parameters[key] = value\n  }\n\n  if (index !== header.length) {\n    return defaultContentType\n  }\n\n  return result\n}\n", "import { Continue, FailureReason, ReturnValue } from \"../HeadersParser.js\"\n\nconst constMaxPairs = 100\nconst constMaxSize = 16 * 1024\n\nconst enum State {\n  key,\n  whitespace,\n  value,\n}\n\nconst constContinue: Continue = { _tag: \"Continue\" }\n\nconst constNameChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,\n]\n\nconst constValueChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n]\n\nexport function make() {\n  const decoder = new TextDecoder()\n  const state = {\n    state: State.key,\n    headers: Object.create(null) as Record<string, string | Array<string>>,\n    key: \"\",\n    value: undefined as undefined | Uint8Array,\n    crlf: 0,\n    previousChunk: undefined as undefined | Uint8Array,\n    pairs: 0,\n    size: 0,\n  }\n\n  function reset(value: ReturnValue): ReturnValue {\n    state.state = State.key\n    state.headers = Object.create(null)\n    state.key = \"\"\n    state.value = undefined\n    state.crlf = 0\n    state.previousChunk = undefined\n    state.pairs = 0\n    state.size = 0\n    return value\n  }\n\n  function concatUint8Array(a: Uint8Array, b: Uint8Array): Uint8Array {\n    const newUint8Array = new Uint8Array(a.length + b.length)\n    newUint8Array.set(a)\n    newUint8Array.set(b, a.length)\n    return newUint8Array\n  }\n\n  function error(reason: FailureReason) {\n    return reset({ _tag: \"Failure\", reason, headers: state.headers })\n  }\n\n  return function write(chunk: Uint8Array, start: number): ReturnValue {\n    let endOffset = 0\n    let previousCursor: number | undefined\n    if (state.previousChunk !== undefined) {\n      endOffset = state.previousChunk.length\n      previousCursor = endOffset\n\n      const newChunk = new Uint8Array(chunk.length + endOffset)\n      newChunk.set(state.previousChunk)\n      newChunk.set(chunk, endOffset)\n      state.previousChunk = undefined\n      chunk = newChunk\n    }\n    const end = chunk.length\n\n    outer: while (start < end) {\n      if (state.state === State.key) {\n        let i = start\n        for (; i < end; i++) {\n          if (state.size++ > constMaxSize) {\n            return error(\"HeaderTooLarge\")\n          }\n\n          if (chunk[i] === 58) {\n            state.key += decoder.decode(chunk.subarray(start, i)).toLowerCase()\n            if (state.key.length === 0) {\n              return error(\"InvalidHeaderName\")\n            }\n\n            if (\n              chunk[i + 1] === 32 &&\n              chunk[i + 2] !== 32 &&\n              chunk[i + 2] !== 9\n            ) {\n              start = i + 2\n              state.state = State.value\n              state.size++\n            } else if (chunk[i + 1] !== 32 && chunk[i + 1] !== 9) {\n              start = i + 1\n              state.state = State.value\n            } else {\n              start = i + 1\n              state.state = State.whitespace\n            }\n\n            break\n          } else if (constNameChars[chunk[i]] !== 1) {\n            return error(\"InvalidHeaderName\")\n          }\n        }\n        if (i === end) {\n          state.key += decoder.decode(chunk.subarray(start, end)).toLowerCase()\n          return constContinue\n        }\n      }\n\n      if (state.state === State.whitespace) {\n        for (; start < end; start++) {\n          if (state.size++ > constMaxSize) {\n            return error(\"HeaderTooLarge\")\n          }\n\n          if (chunk[start] !== 32 && chunk[start] !== 9) {\n            state.state = State.value\n            break\n          }\n        }\n        if (start === end) {\n          return constContinue\n        }\n      }\n\n      if (state.state === State.value) {\n        let i = start\n        if (previousCursor !== undefined) {\n          i = previousCursor\n          previousCursor = undefined\n        }\n        for (; i < end; i++) {\n          if (state.size++ > constMaxSize) {\n            return error(\"HeaderTooLarge\")\n          }\n\n          if (chunk[i] === 13 || state.crlf > 0) {\n            let byte = chunk[i]\n\n            if (byte === 13 && state.crlf === 0) {\n              state.crlf = 1\n              i++\n              state.size++\n              byte = chunk[i]\n            }\n            if (byte === 10 && state.crlf === 1) {\n              state.crlf = 2\n              i++\n              state.size++\n              byte = chunk[i]\n            }\n            if (byte === 13 && state.crlf === 2) {\n              state.crlf = 3\n              i++\n              state.size++\n              byte = chunk[i]\n            }\n            if (byte === 10 && state.crlf === 3) {\n              state.crlf = 4\n              i++\n              state.size++\n            }\n\n            if (state.crlf < 4 && i >= end) {\n              state.previousChunk = chunk.subarray(start)\n              return constContinue\n            } else if (state.crlf >= 2) {\n              state.value =\n                state.value === undefined\n                  ? chunk.subarray(start, i - state.crlf)\n                  : concatUint8Array(\n                      state.value,\n                      chunk.subarray(start, i - state.crlf),\n                    )\n              const value = decoder.decode(state.value)\n              if (state.headers[state.key] === undefined) {\n                state.headers[state.key] = value\n              } else if (typeof state.headers[state.key] === \"string\") {\n                state.headers[state.key] = [\n                  state.headers[state.key] as string,\n                  value,\n                ]\n              } else {\n                ;(state.headers[state.key] as Array<string>).push(value)\n              }\n\n              start = i\n              state.size--\n\n              if (state.crlf !== 4 && state.pairs === constMaxPairs) {\n                return error(\"TooManyHeaders\")\n              } else if (state.crlf === 3) {\n                return error(\"InvalidHeaderValue\")\n              } else if (state.crlf === 4) {\n                return reset({\n                  _tag: \"Headers\",\n                  headers: state.headers,\n                  endPosition: start - endOffset,\n                })\n              }\n\n              state.pairs++\n              state.key = \"\"\n              state.value = undefined\n              state.crlf = 0\n              state.state = State.key\n\n              continue outer\n            }\n          } else if (constValueChars[chunk[i]] !== 1) {\n            return error(\"InvalidHeaderValue\")\n          }\n        }\n\n        if (i === end) {\n          state.value =\n            state.value === undefined\n              ? chunk.subarray(start, end)\n              : concatUint8Array(state.value, chunk.subarray(start, end))\n          return constContinue\n        }\n      }\n    }\n\n    if (start > end) {\n      state.size += end - start\n    }\n\n    return constContinue\n  }\n}\n", "interface SearchState {\n  readonly needle: Uint8Array\n  readonly needleLength: number\n  readonly indexes: Record<number, ReadonlyArray<number>>\n  readonly firstByte: number\n\n  previousChunk: Uint8Array | undefined\n  previousChunkLength: number\n  matchIndex: number\n}\n\nfunction makeState(needle_: string): SearchState {\n  const needle = new TextEncoder().encode(needle_)\n  const needleLength = needle.length\n\n  const indexes: Record<number, number[]> = {}\n  for (let i = 0; i < needleLength; i++) {\n    const b = needle[i]\n    if (indexes[b] === undefined) indexes[b] = []\n    indexes[b].push(i)\n  }\n\n  return {\n    needle,\n    needleLength,\n    indexes,\n    firstByte: needle[0],\n    previousChunk: undefined,\n    previousChunkLength: 0,\n    matchIndex: 0,\n  }\n}\n\nexport function make(\n  needle: string,\n  callback: (index: number, chunk: Uint8Array) => void,\n  seed?: Uint8Array,\n) {\n  const state = makeState(needle)\n  if (seed !== undefined) {\n    state.previousChunk = seed\n    state.previousChunkLength = seed.length\n  }\n\n  function makeIndexOf(): (\n    chunk: Uint8Array,\n    needle: Uint8Array,\n    fromIndex: number,\n  ) => number {\n    // on node.js use the Buffer api\n    if (\n      \"Buffer\" in globalThis &&\n      !(\"Bun\" in globalThis || \"Deno\" in globalThis)\n    ) {\n      return function (chunk, needle, fromIndex) {\n        return Buffer.prototype.indexOf.call(chunk, needle, fromIndex)\n      }\n    }\n\n    const skipTable = new Uint8Array(256).fill(state.needle.length)\n    for (let i = 0, lastIndex = state.needle.length - 1; i < lastIndex; ++i) {\n      skipTable[state.needle[i]] = lastIndex - i\n    }\n\n    return function (chunk, needle, fromIndex) {\n      const lengthTotal = chunk.length\n      let i = fromIndex + state.needleLength - 1\n\n      while (i < lengthTotal) {\n        for (\n          let j = state.needleLength - 1, k = i;\n          j >= 0 && chunk[k] === needle[j];\n          j--, k--\n        ) {\n          if (j === 0) return k\n        }\n        i += skipTable[chunk[i]]\n      }\n\n      return -1\n    }\n  }\n\n  const indexOf = makeIndexOf()\n\n  function write(chunk: Uint8Array): void {\n    let chunkLength = chunk.length\n\n    if (state.previousChunk !== undefined) {\n      const newChunk = new Uint8Array(state.previousChunkLength + chunkLength)\n      newChunk.set(state.previousChunk)\n      newChunk.set(chunk, state.previousChunkLength)\n      chunk = newChunk\n      chunkLength = state.previousChunkLength + chunkLength\n      state.previousChunk = undefined\n    }\n\n    if (chunkLength < state.needleLength) {\n      state.previousChunk = chunk\n      state.previousChunkLength = chunkLength\n      return\n    }\n\n    let pos = 0\n    while (pos < chunkLength) {\n      const match = indexOf(chunk, state.needle, pos)\n\n      if (match > -1) {\n        if (match > pos) {\n          callback(state.matchIndex, chunk.subarray(pos, match))\n        }\n        state.matchIndex += 1\n        pos = match + state.needleLength\n        continue\n      } else if (chunk[chunkLength - 1] in state.indexes) {\n        const indexes = state.indexes[chunk[chunkLength - 1]]\n        let earliestIndex = -1\n        for (let i = 0, len = indexes.length; i < len; i++) {\n          const index = indexes[i]\n          if (\n            chunk[chunkLength - 1 - index] === state.firstByte &&\n            i > earliestIndex\n          ) {\n            earliestIndex = index\n          }\n        }\n        if (earliestIndex === -1) {\n          if (pos === 0) {\n            callback(state.matchIndex, chunk)\n          } else {\n            callback(state.matchIndex, chunk.subarray(pos))\n          }\n        } else {\n          if (chunkLength - 1 - earliestIndex > pos) {\n            callback(\n              state.matchIndex,\n              chunk.subarray(pos, chunkLength - 1 - earliestIndex),\n            )\n          }\n          state.previousChunk = chunk.subarray(chunkLength - 1 - earliestIndex)\n          state.previousChunkLength = earliestIndex + 1\n        }\n      } else if (pos === 0) {\n        callback(state.matchIndex, chunk)\n      } else {\n        callback(state.matchIndex, chunk.subarray(pos))\n      }\n\n      break\n    }\n  }\n\n  function end(): void {\n    if (state.previousChunk !== undefined && state.previousChunk !== seed) {\n      callback(state.matchIndex, state.previousChunk)\n    }\n\n    state.previousChunk = seed\n    state.previousChunkLength = seed?.length ?? 0\n    state.matchIndex = 0\n  }\n\n  return { write, end } as const\n}\n", "import { Config, MultipartError, PartInfo } from \"../index.js\"\nimport * as CT from \"./contentType.js\"\nimport * as HP from \"./headers.js\"\nimport * as Search from \"./search.js\"\n\nconst enum State {\n  headers,\n  body,\n}\n\nconst errInvalidDisposition: MultipartError = { _tag: \"InvalidDisposition\" }\nconst errEndNotReached: MultipartError = { _tag: \"EndNotReached\" }\nconst errMaxParts: MultipartError = { _tag: \"ReachedLimit\", limit: \"MaxParts\" }\nconst errMaxTotalSize: MultipartError = {\n  _tag: \"ReachedLimit\",\n  limit: \"MaxTotalSize\",\n}\nconst errMaxPartSize: MultipartError = {\n  _tag: \"ReachedLimit\",\n  limit: \"MaxPartSize\",\n}\nconst errMaxFieldSize: MultipartError = {\n  _tag: \"ReachedLimit\",\n  limit: \"MaxFieldSize\",\n}\n\nconst constCR = new TextEncoder().encode(\"\\r\\n\")\n\nexport function defaultIsFile(info: PartInfo) {\n  return (\n    info.filename !== undefined ||\n    info.contentType === \"application/octet-stream\"\n  )\n}\n\nfunction parseBoundary(headers: Record<string, string>) {\n  const contentType = CT.parse(headers[\"content-type\"])\n  return contentType.parameters.boundary\n}\n\nfunction noopOnChunk(_chunk: Uint8Array | null) {}\n\nexport function make({\n  headers,\n  onFile: onPart,\n  onField,\n  onError,\n  onDone,\n  isFile = defaultIsFile,\n  maxParts = Infinity,\n  maxTotalSize = Infinity,\n  maxPartSize = Infinity,\n  maxFieldSize = 1024 * 1024,\n}: Config) {\n  const boundary = parseBoundary(headers)\n  if (boundary === undefined) {\n    onError({ _tag: \"InvalidBoundary\" })\n    return {\n      write: noopOnChunk,\n      end() {},\n    }\n  }\n\n  const state = {\n    state: State.headers,\n    index: 0,\n    parts: 0,\n    onChunk: noopOnChunk,\n    info: undefined as any as PartInfo,\n    headerSkip: 0,\n    partSize: 0,\n    totalSize: 0,\n    isFile: false,\n    fieldChunks: [] as Array<Uint8Array>,\n    fieldSize: 0,\n  }\n\n  function skipBody() {\n    state.state = State.body\n    state.isFile = true\n    state.onChunk = noopOnChunk\n  }\n\n  const headerParser = HP.make()\n\n  const split = Search.make(\n    `\\r\\n--${boundary}`,\n    function (index, chunk) {\n      if (index === 0) {\n        // data before the first boundary\n        skipBody()\n        return\n      } else if (index !== state.index) {\n        if (state.index > 0) {\n          if (state.isFile) {\n            state.onChunk(null)\n            state.partSize = 0\n          } else {\n            if (state.fieldChunks.length === 1) {\n              onField(state.info, state.fieldChunks[0])\n            } else {\n              const buf = new Uint8Array(state.fieldSize)\n              let offset = 0\n              for (let i = 0; i < state.fieldChunks.length; i++) {\n                const chunk = state.fieldChunks[i]\n                buf.set(chunk, offset)\n                offset += chunk.length\n              }\n              onField(state.info, buf)\n            }\n            state.fieldSize = 0\n            state.fieldChunks = []\n          }\n        }\n\n        state.state = State.headers\n        state.index = index\n        state.headerSkip = 2 // skip the first \\r\\n\n\n        // trailing --\n        if (chunk[0] === 45 && chunk[1] === 45) {\n          return onDone()\n        }\n\n        state.parts++\n        if (state.parts > maxParts) {\n          onError(errMaxParts)\n        }\n      }\n\n      if ((state.partSize += chunk.length) > maxPartSize) {\n        onError(errMaxPartSize)\n      }\n\n      if (state.state === State.headers) {\n        const result = headerParser(chunk, state.headerSkip)\n        state.headerSkip = 0\n\n        if (result._tag === \"Continue\") {\n          return\n        } else if (result._tag === \"Failure\") {\n          skipBody()\n          return onError({ _tag: \"BadHeaders\", error: result })\n        }\n\n        const contentType = CT.parse(result.headers[\"content-type\"] as string)\n        const contentDisposition = CT.parse(\n          result.headers[\"content-disposition\"] as string,\n          true,\n        )\n\n        if (\n          \"form-data\" === contentDisposition.value &&\n          !(\"name\" in contentDisposition.parameters)\n        ) {\n          skipBody()\n          return onError(errInvalidDisposition)\n        }\n\n        let encodedFilename: string | undefined\n        if (\"filename*\" in contentDisposition.parameters) {\n          const parts = contentDisposition.parameters[\"filename*\"].split(\"''\")\n          if (parts.length === 2) {\n            encodedFilename = decodeURIComponent(parts[1])\n          }\n        }\n\n        state.info = {\n          name: contentDisposition.parameters.name ?? \"\",\n          filename: encodedFilename ?? contentDisposition.parameters.filename,\n          contentType:\n            contentType.value === \"\"\n              ? contentDisposition.parameters.filename !== undefined\n                ? \"application/octet-stream\"\n                : \"text/plain\"\n              : contentType.value,\n          contentTypeParameters: contentType.parameters,\n          contentDisposition: contentDisposition.value,\n          contentDispositionParameters: contentDisposition.parameters as any,\n          headers: result.headers,\n        }\n\n        state.state = State.body\n        state.isFile = isFile(state.info)\n\n        if (state.isFile) {\n          state.onChunk = onPart(state.info)\n        }\n\n        if (result.endPosition < chunk.length) {\n          if (state.isFile) {\n            state.onChunk(chunk.subarray(result.endPosition))\n          } else {\n            const buf = chunk.subarray(result.endPosition)\n            if ((state.fieldSize += buf.length) > maxFieldSize) {\n              onError(errMaxFieldSize)\n            }\n            state.fieldChunks.push(buf)\n          }\n        }\n      } else if (state.isFile) {\n        state.onChunk(chunk)\n      } else {\n        if ((state.fieldSize += chunk.length) > maxFieldSize) {\n          onError(errMaxFieldSize)\n        }\n        state.fieldChunks.push(chunk)\n      }\n    },\n    constCR,\n  )\n\n  return {\n    write(chunk: Uint8Array) {\n      if ((state.totalSize += chunk.length) > maxTotalSize) {\n        return onError(errMaxTotalSize)\n      }\n      return split.write(chunk)\n    },\n    end() {\n      split.end()\n      if (state.state === State.body) {\n        onError(errEndNotReached)\n      }\n\n      state.state = State.headers\n      state.index = 0\n      state.parts = 0\n      state.onChunk = noopOnChunk\n      state.info = undefined as any as PartInfo\n      state.totalSize = 0\n      state.partSize = 0\n      state.fieldChunks = []\n      state.fieldSize = 0\n    },\n  } as const\n}\n\nconst utf8Decoder = new TextDecoder(\"utf-8\")\nfunction getDecoder(charset: string) {\n  if (charset === \"utf-8\" || charset === \"utf8\" || charset === \"\") {\n    return utf8Decoder\n  }\n\n  try {\n    return new TextDecoder(charset)\n  } catch (error) {\n    return utf8Decoder\n  }\n}\n\nexport function decodeField(info: PartInfo, value: Uint8Array): string {\n  return getDecoder(info.contentTypeParameters.charset ?? \"utf-8\").decode(value)\n}\n", "import * as internal from \"./internal/multipart.js\"\nimport type * as HeadersParser from \"./HeadersParser.js\"\n\nexport interface PartInfo {\n  readonly name: string\n  readonly filename?: string | undefined\n  readonly contentType: string\n  readonly contentTypeParameters: Record<string, string>\n  readonly contentDisposition: string\n  readonly contentDispositionParameters: Record<string, string>\n  readonly headers: Record<string, string | Array<string>>\n}\n\nexport type MultipartError =\n  | {\n      readonly _tag: \"InvalidBoundary\"\n    }\n  | {\n      readonly _tag: \"BadHeaders\"\n      readonly error: HeadersParser.Failure\n    }\n  | {\n      readonly _tag: \"InvalidDisposition\"\n    }\n  | {\n      readonly _tag: \"ReachedLimit\"\n      readonly limit:\n        | \"MaxParts\"\n        | \"MaxTotalSize\"\n        | \"MaxPartSize\"\n        | \"MaxFieldSize\"\n    }\n  | {\n      readonly _tag: \"EndNotReached\"\n    }\n\nexport type BaseConfig = {\n  readonly headers: Record<string, string>\n  readonly isFile?: ((info: PartInfo) => boolean) | undefined\n  readonly maxParts?: number | undefined\n  readonly maxTotalSize?: number | undefined\n  readonly maxPartSize?: number | undefined\n  readonly maxFieldSize?: number | undefined\n}\n\nexport type Config = BaseConfig & {\n  readonly onField: (info: PartInfo, value: Uint8Array) => void\n  readonly onFile: (info: PartInfo) => (chunk: Uint8Array | null) => void\n  readonly onError: (error: MultipartError) => void\n  readonly onDone: () => void\n}\nexport interface Parser {\n  readonly write: (chunk: Uint8Array) => void\n  readonly end: () => void\n}\n\nexport const make: (options: Config) => Parser = internal.make\n\nexport const defaultIsFile: (info: PartInfo) => boolean = internal.defaultIsFile\n\nexport const decodeField: (info: PartInfo, value: Uint8Array) => string =\n  internal.decodeField\n", "/**\n * @since 1.0.0\n */\nimport * as Channel from \"effect/Channel\"\nimport type * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport type { DurationInput } from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as ExecutionStrategy from \"effect/ExecutionStrategy\"\nimport * as Exit from \"effect/Exit\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberSet from \"effect/FiberSet\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Scope from \"effect/Scope\"\nimport type * as AsyncProducer from \"effect/SingleProducerAsyncInput\"\nimport { TypeIdError } from \"./Error.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/Socket\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isSocket = (u: unknown): u is Socket => Predicate.hasProperty(u, TypeId)\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Socket: Context.Tag<Socket, Socket> = Context.GenericTag<Socket>(\n  \"@effect/platform/Socket\"\n)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Socket {\n  readonly [TypeId]: TypeId\n  readonly run: <_, E = never, R = never>(\n    handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void\n  ) => Effect.Effect<void, SocketError | E, R>\n  readonly runRaw: <_, E = never, R = never>(\n    handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void\n  ) => Effect.Effect<void, SocketError | E, R>\n  readonly writer: Effect.Effect<\n    (chunk: Uint8Array | string | CloseEvent) => Effect.Effect<void, SocketError>,\n    never,\n    Scope.Scope\n  >\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const CloseEventTypeId: unique symbol = Symbol.for(\"@effect/platform/Socket/CloseEvent\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type CloseEventTypeId = typeof CloseEventTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport class CloseEvent {\n  /**\n   * @since 1.0.0\n   */\n  readonly [CloseEventTypeId]: CloseEventTypeId\n  constructor(readonly code = 1000, readonly reason?: string) {\n    this[CloseEventTypeId] = CloseEventTypeId\n  }\n  /**\n   * @since 1.0.0\n   */\n  toString() {\n    return this.reason ? `${this.code}: ${this.reason}` : `${this.code}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isCloseEvent = (u: unknown): u is CloseEvent => Predicate.hasProperty(u, CloseEventTypeId)\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const SocketErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/Socket/SocketError\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type SocketErrorTypeId = typeof SocketErrorTypeId\n\n/**\n * @since 1.0.0\n * @category refinements\n */\nexport const isSocketError = (u: unknown): u is SocketError => Predicate.hasProperty(u, SocketErrorTypeId)\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type SocketError = SocketGenericError | SocketCloseError\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketGenericError extends TypeIdError(SocketErrorTypeId, \"SocketError\")<{\n  readonly reason: \"Write\" | \"Read\" | \"Open\" | \"OpenTimeout\"\n  readonly cause: unknown\n}> {\n  get message() {\n    return `An error occurred during ${this.reason}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketCloseError extends TypeIdError(SocketErrorTypeId, \"SocketError\")<{\n  readonly reason: \"Close\"\n  readonly code: number\n  readonly closeReason?: string | undefined\n}> {\n  /**\n   * @since 1.0.0\n   */\n  static is(u: unknown): u is SocketCloseError {\n    return isSocketError(u) && u.reason === \"Close\"\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  static isClean(isClean: (code: number) => boolean) {\n    return function(u: unknown): u is SocketCloseError {\n      return SocketCloseError.is(u) && isClean(u.code)\n    }\n  }\n\n  get message() {\n    if (this.closeReason) {\n      return `${this.reason}: ${this.code}: ${this.closeReason}`\n    }\n    return `${this.reason}: ${this.code}`\n  }\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelMap = <IE, A>(\n  self: Socket,\n  f: (data: Uint8Array | string) => A\n): Channel.Channel<\n  Chunk.Chunk<A>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> =>\n  Effect.gen(function*() {\n    const scope = yield* Effect.scope\n    const mailbox = yield* Mailbox.make<A, SocketError | IE>()\n    const writeScope = yield* Scope.fork(scope, ExecutionStrategy.sequential)\n    const write = yield* Scope.extend(self.writer, writeScope)\n    function* emit(chunk: Chunk.Chunk<Uint8Array | string | CloseEvent>) {\n      for (const data of chunk) {\n        yield* write(data)\n      }\n    }\n    const input: AsyncProducer.AsyncInputProducer<IE, Chunk.Chunk<Uint8Array | string | CloseEvent>, unknown> = {\n      awaitRead: () => Effect.void,\n      emit(chunk) {\n        return Effect.catchAllCause(\n          Effect.gen(() => emit(chunk)),\n          (cause) => mailbox.failCause(cause)\n        )\n      },\n      error(error) {\n        return Effect.zipRight(\n          Scope.close(writeScope, Exit.void),\n          mailbox.failCause(error)\n        )\n      },\n      done() {\n        return Scope.close(writeScope, Exit.void)\n      }\n    }\n\n    yield* self.runRaw((data) => {\n      mailbox.unsafeOffer(f(data))\n    }).pipe(\n      Mailbox.into(mailbox),\n      Effect.forkIn(scope),\n      Effect.interruptible\n    )\n\n    return Channel.embedInput(Mailbox.toChannel(mailbox), input)\n  }).pipe(Channel.unwrapScoped)\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannel = <IE>(\n  self: Socket\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => {\n  const encoder = new TextEncoder()\n  return toChannelMap(self, (data) => typeof data === \"string\" ? encoder.encode(data) : data)\n}\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelString: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (encoding?: string | undefined): <IE>(self: Socket) => Channel.Channel<\n    Chunk.Chunk<string>,\n    Chunk.Chunk<Uint8Array | string | CloseEvent>,\n    SocketError | IE,\n    IE,\n    void,\n    unknown\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IE>(self: Socket, encoding?: string | undefined): Channel.Channel<\n    Chunk.Chunk<string>,\n    Chunk.Chunk<Uint8Array | string | CloseEvent>,\n    SocketError | IE,\n    IE,\n    void,\n    unknown\n  >\n} = dual((args) => isSocket(args[0]), <IE>(\n  self: Socket,\n  encoding?: string | undefined\n): Channel.Channel<\n  Chunk.Chunk<string>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => {\n  const decoder = new TextDecoder(encoding)\n  return toChannelMap(self, (data) => typeof data === \"string\" ? data : decoder.decode(data))\n})\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toChannelWith = <IE = never>() =>\n(\n  self: Socket\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown\n> => toChannel(self)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeChannel = <IE = never>(): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown,\n  Socket\n> => Channel.unwrap(Effect.map(Socket, toChannelWith<IE>()))\n\n/**\n * @since 1.0.0\n */\nexport const defaultCloseCodeIsError = (code: number) => code !== 1000 && code !== 1006\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface WebSocket {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocket: Context.Tag<WebSocket, globalThis.WebSocket> = Context.GenericTag(\n  \"@effect/platform/Socket/WebSocket\"\n)\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport interface WebSocketConstructor {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WebSocketConstructor: Context.Tag<\n  WebSocketConstructor,\n  (url: string, protocols?: string | Array<string> | undefined) => globalThis.WebSocket\n> = Context\n  .GenericTag(\"@effect/platform/Socket/WebSocketConstructor\")\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocketConstructorGlobal: Layer.Layer<WebSocketConstructor> = Layer.succeed(\n  WebSocketConstructor,\n  (url, protocols) => new globalThis.WebSocket(url, protocols)\n)\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocket = (url: string | Effect.Effect<string>, options?: {\n  readonly closeCodeIsError?: ((code: number) => boolean) | undefined\n  readonly openTimeout?: DurationInput | undefined\n  readonly protocols?: string | Array<string> | undefined\n}): Effect.Effect<Socket, never, WebSocketConstructor> =>\n  fromWebSocket(\n    Effect.acquireRelease(\n      (typeof url === \"string\" ? Effect.succeed(url) : url).pipe(\n        Effect.flatMap((url) => Effect.map(WebSocketConstructor, (f) => f(url, options?.protocols)))\n      ),\n      (ws) => Effect.sync(() => ws.close(1000))\n    ),\n    options\n  )\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromWebSocket = <RO>(\n  acquire: Effect.Effect<globalThis.WebSocket, SocketError, RO>,\n  options?: {\n    readonly closeCodeIsError?: (code: number) => boolean\n    readonly openTimeout?: DurationInput\n  }\n): Effect.Effect<Socket, never, Exclude<RO, Scope.Scope>> =>\n  Effect.withFiberRuntime((fiber) => {\n    let currentWS: globalThis.WebSocket | undefined\n    const latch = Effect.unsafeMakeLatch(false)\n    const acquireContext = fiber.currentContext as Context.Context<RO>\n    const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError\n\n    const runRaw = <_, E, R>(handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void) =>\n      Effect.scopedWith((scope) =>\n        Effect.gen(function*() {\n          const fiberSet = yield* FiberSet.make<any, E | SocketError>().pipe(\n            Scope.extend(scope)\n          )\n          const ws = yield* Scope.extend(acquire, scope)\n          const run = yield* Effect.provideService(FiberSet.runtime(fiberSet)<R>(), WebSocket, ws)\n          let open = false\n\n          function onMessage(event: MessageEvent) {\n            if (event.data instanceof Blob) {\n              return Effect.promise(() => event.data.arrayBuffer() as Promise<ArrayBuffer>).pipe(\n                Effect.andThen((buffer) => handler(new Uint8Array(buffer))),\n                run\n              )\n            }\n            const result = handler(event.data)\n            if (Effect.isEffect(result)) {\n              run(result)\n            }\n          }\n          function onError(cause: Event) {\n            ws.removeEventListener(\"message\", onMessage)\n            ws.removeEventListener(\"close\", onClose)\n            Deferred.unsafeDone(\n              fiberSet.deferred,\n              Effect.fail(new SocketGenericError({ reason: open ? \"Read\" : \"Open\", cause }))\n            )\n          }\n          function onClose(event: globalThis.CloseEvent) {\n            ws.removeEventListener(\"message\", onMessage)\n            ws.removeEventListener(\"error\", onError)\n            Deferred.unsafeDone(\n              fiberSet.deferred,\n              Effect.fail(\n                new SocketCloseError({\n                  reason: \"Close\",\n                  code: event.code,\n                  closeReason: event.reason\n                })\n              )\n            )\n          }\n\n          ws.addEventListener(\"close\", onClose, { once: true })\n          ws.addEventListener(\"error\", onError, { once: true })\n          ws.addEventListener(\"message\", onMessage)\n\n          if (ws.readyState !== 1) {\n            const openDeferred = Deferred.unsafeMake<void>(fiber.id())\n            ws.addEventListener(\"open\", () => {\n              open = true\n              Deferred.unsafeDone(openDeferred, Effect.void)\n            }, { once: true })\n            yield* Deferred.await(openDeferred).pipe(\n              Effect.timeoutFail({\n                duration: options?.openTimeout ?? 10000,\n                onTimeout: () =>\n                  new SocketGenericError({ reason: \"OpenTimeout\", cause: \"timeout waiting for \\\"open\\\"\" })\n              }),\n              Effect.raceFirst(FiberSet.join(fiberSet))\n            )\n          }\n          open = true\n          currentWS = ws\n          yield* latch.open\n          return yield* FiberSet.join(fiberSet).pipe(\n            Effect.catchIf(\n              SocketCloseError.isClean((_) => !closeCodeIsError(_)),\n              (_) => Effect.void\n            )\n          )\n        })\n      ).pipe(\n        Effect.mapInputContext((input: Context.Context<R>) => Context.merge(acquireContext, input)),\n        Effect.ensuring(Effect.sync(() => {\n          latch.unsafeClose()\n          currentWS = undefined\n        })),\n        Effect.interruptible\n      )\n\n    const encoder = new TextEncoder()\n    const run = <_, E, R>(handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void) =>\n      runRaw((data) =>\n        typeof data === \"string\"\n          ? handler(encoder.encode(data))\n          : data instanceof Uint8Array\n          ? handler(data)\n          : handler(new Uint8Array(data))\n      )\n\n    const write = (chunk: Uint8Array | string | CloseEvent) =>\n      latch.whenOpen(Effect.sync(() => {\n        const ws = currentWS!\n        if (isCloseEvent(chunk)) {\n          ws.close(chunk.code, chunk.reason)\n        } else {\n          ws.send(chunk)\n        }\n      }))\n    const writer = Effect.succeed(write)\n\n    return Effect.succeed(Socket.of({\n      [TypeId]: TypeId,\n      run,\n      runRaw,\n      writer\n    }))\n  })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWebSocketChannel = <IE = never>(\n  url: string,\n  options?: {\n    readonly closeCodeIsError?: (code: number) => boolean\n  }\n): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<Uint8Array | string | CloseEvent>,\n  SocketError | IE,\n  IE,\n  void,\n  unknown,\n  WebSocketConstructor\n> =>\n  Channel.unwrapScoped(\n    Effect.map(makeWebSocket(url, options), toChannelWith<IE>())\n  )\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerWebSocket = (url: string, options?: {\n  readonly closeCodeIsError?: (code: number) => boolean\n}): Layer.Layer<Socket, never, WebSocketConstructor> =>\n  Layer.effect(\n    Socket,\n    makeWebSocket(url, options)\n  )\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentSendQueueCapacity: FiberRef.FiberRef<number> = globalValue(\n  \"@effect/platform/Socket/currentSendQueueCapacity\",\n  () => FiberRef.unsafeMake(16)\n)\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface InputTransformStream {\n  readonly readable: ReadableStream<Uint8Array> | ReadableStream<string> | ReadableStream<Uint8Array | string>\n  readonly writable: WritableStream<Uint8Array>\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromTransformStream = <R>(acquire: Effect.Effect<InputTransformStream, SocketError, R>, options?: {\n  readonly closeCodeIsError?: (code: number) => boolean\n}): Effect.Effect<Socket, never, Exclude<R, Scope.Scope>> =>\n  Effect.withFiberRuntime((fiber) => {\n    const latch = Effect.unsafeMakeLatch(false)\n    let currentStream: {\n      readonly stream: InputTransformStream\n      readonly fiberSet: FiberSet.FiberSet<any, any>\n    } | undefined\n    const acquireContext = fiber.currentContext as Context.Context<R>\n    const closeCodeIsError = options?.closeCodeIsError ?? defaultCloseCodeIsError\n    const runRaw = <_, E, R>(handler: (_: string | Uint8Array) => Effect.Effect<_, E, R> | void) =>\n      Effect.scopedWith((scope) =>\n        Effect.gen(function*() {\n          const stream = yield* Scope.extend(acquire, scope)\n          const reader = stream.readable.getReader()\n          yield* Scope.addFinalizer(scope, Effect.promise(() => reader.cancel()))\n          const fiberSet = yield* FiberSet.make<any, E | SocketError>().pipe(\n            Scope.extend(scope)\n          )\n          const runFork = yield* FiberSet.runtime(fiberSet)<R>()\n\n          yield* Effect.tryPromise({\n            try: async () => {\n              while (true) {\n                const { done, value } = await reader.read()\n                if (done) {\n                  throw new SocketCloseError({ reason: \"Close\", code: 1000 })\n                }\n                const result = handler(value)\n                if (Effect.isEffect(result)) {\n                  runFork(result)\n                }\n              }\n            },\n            catch: (cause) => isSocketError(cause) ? cause : new SocketGenericError({ reason: \"Read\", cause })\n          }).pipe(\n            FiberSet.run(fiberSet)\n          )\n\n          currentStream = { stream, fiberSet }\n          yield* latch.open\n\n          return yield* FiberSet.join(fiberSet).pipe(\n            Effect.catchIf(\n              SocketCloseError.isClean((_) => !closeCodeIsError(_)),\n              (_) => Effect.void\n            )\n          )\n        })\n      ).pipe(\n        (_) => _,\n        Effect.mapInputContext((input: Context.Context<R>) => Context.merge(acquireContext, input)),\n        Effect.ensuring(Effect.sync(() => {\n          latch.unsafeClose()\n          currentStream = undefined\n        })),\n        Effect.interruptible\n      )\n\n    const encoder = new TextEncoder()\n    const run = <_, E, R>(handler: (_: Uint8Array) => Effect.Effect<_, E, R> | void) =>\n      runRaw((data) =>\n        typeof data === \"string\"\n          ? handler(encoder.encode(data))\n          : handler(data)\n      )\n\n    const writers = new WeakMap<InputTransformStream, WritableStreamDefaultWriter<Uint8Array>>()\n    const getWriter = (stream: InputTransformStream) => {\n      let writer = writers.get(stream)\n      if (!writer) {\n        writer = stream.writable.getWriter()\n        writers.set(stream, writer)\n      }\n      return writer\n    }\n    const write = (chunk: Uint8Array | string | CloseEvent) =>\n      latch.whenOpen(Effect.suspend(() => {\n        const { fiberSet, stream } = currentStream!\n        if (isCloseEvent(chunk)) {\n          return Deferred.fail(\n            fiberSet.deferred,\n            new SocketCloseError({ reason: \"Close\", code: chunk.code, closeReason: chunk.reason })\n          )\n        }\n        return Effect.promise(() => getWriter(stream).write(typeof chunk === \"string\" ? encoder.encode(chunk) : chunk))\n      }))\n    const writer = Effect.acquireRelease(\n      Effect.succeed(write),\n      () =>\n        Effect.promise(async () => {\n          if (!currentStream) return\n          await getWriter(currentStream.stream).close()\n        })\n    )\n\n    return Effect.succeed(Socket.of({\n      [TypeId]: TypeId,\n      run,\n      runRaw,\n      writer\n    }))\n  })\n", "/**\n * @since 1.0.0\n */\nimport type { Channel } from \"effect/Channel\"\nimport type { Chunk } from \"effect/Chunk\"\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type { Option } from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport type { ReadonlyRecord } from \"effect/Record\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as Stream from \"effect/Stream\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport type * as IncomingMessage from \"./HttpIncomingMessage.js\"\nimport type { HttpMethod } from \"./HttpMethod.js\"\nimport type * as Error from \"./HttpServerError.js\"\nimport * as internal from \"./internal/httpServerRequest.js\"\nimport type * as Multipart from \"./Multipart.js\"\nimport type * as Path from \"./Path.js\"\nimport type * as Socket from \"./Socket.js\"\n\nexport {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  MaxBodySize,\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  withMaxBodySize\n} from \"./HttpIncomingMessage.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpServerRequest extends IncomingMessage.HttpIncomingMessage<Error.RequestError> {\n  readonly [TypeId]: TypeId\n  readonly source: unknown\n  readonly url: string\n  readonly originalUrl: string\n  readonly method: HttpMethod\n  readonly cookies: ReadonlyRecord<string, string>\n\n  readonly multipart: Effect.Effect<\n    Multipart.Persisted,\n    Multipart.MultipartError,\n    Scope.Scope | FileSystem.FileSystem | Path.Path\n  >\n  readonly multipartStream: Stream.Stream<Multipart.Part, Multipart.MultipartError>\n\n  readonly upgrade: Effect.Effect<Socket.Socket, Error.RequestError>\n\n  readonly modify: (\n    options: {\n      readonly url?: string\n      readonly headers?: Headers.Headers\n      readonly remoteAddress?: string\n    }\n  ) => HttpServerRequest\n}\n\n/**\n * @since 1.0.0\n * @category context\n */\nexport const HttpServerRequest: Context.Tag<HttpServerRequest, HttpServerRequest> = internal.serverRequestTag\n\n/**\n * @since 1.0.0\n * @category search params\n */\nexport interface ParsedSearchParams {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category search params\n */\nexport const ParsedSearchParams: Context.Tag<ParsedSearchParams, ReadonlyRecord<string, string | Array<string>>> =\n  internal.parsedSearchParamsTag\n\n/**\n * @since 1.0.0\n * @category search params\n */\nexport const searchParamsFromURL: (url: URL) => ReadonlyRecord<string, string | Array<string>> =\n  internal.searchParamsFromURL\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const persistedMultipart: Effect.Effect<\n  unknown,\n  Multipart.MultipartError,\n  Scope.Scope | FileSystem.FileSystem | Path.Path | HttpServerRequest\n> = internal.multipartPersisted\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const upgrade: Effect.Effect<Socket.Socket, Error.RequestError, HttpServerRequest> = internal.upgrade\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const upgradeChannel: <IE = never>() => Channel<\n  Chunk<Uint8Array>,\n  Chunk<Uint8Array | string | Socket.CloseEvent>,\n  Error.RequestError | IE | Socket.SocketError,\n  IE,\n  void,\n  unknown,\n  HttpServerRequest\n> = internal.upgradeChannel\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaCookies: <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError, HttpServerRequest | R> = internal.schemaCookies\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaHeaders: <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError, HttpServerRequest | R> = internal.schemaHeaders\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaSearchParams: <A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError, ParsedSearchParams | R> = internal.schemaSearchParams\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyJson: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, Error.RequestError | ParseResult.ParseError, HttpServerRequest | R> = internal.schemaBodyJson\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyForm: <A, I extends Partial<Multipart.Persisted>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<\n  A,\n  Multipart.MultipartError | ParseResult.ParseError | Error.RequestError,\n  R | HttpServerRequest | Scope.Scope | FileSystem.FileSystem | Path.Path\n> = internal.schemaBodyForm\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyUrlParams: <\n  A,\n  I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>,\n  R\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError | Error.RequestError, R | HttpServerRequest> = internal.schemaBodyUrlParams\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyMultipart: <A, I extends Partial<Multipart.Persisted>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<\n  A,\n  Multipart.MultipartError | ParseResult.ParseError,\n  R | HttpServerRequest | Scope.Scope | FileSystem.FileSystem | Path.Path\n> = internal.schemaBodyMultipart\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schemaBodyFormJson: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => (\n  field: string\n) => Effect.Effect<\n  A,\n  ParseResult.ParseError | Error.RequestError,\n  R | HttpServerRequest | FileSystem.FileSystem | Path.Path | Scope.Scope\n> = internal.schemaBodyFormJson\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const fromWeb: (request: Request) => HttpServerRequest = internal.fromWeb\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toURL: (self: HttpServerRequest) => Option<URL> = internal.toURL\n", "import * as Channel from \"effect/Channel\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport type { ReadonlyRecord } from \"effect/Record\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Cookies from \"../Cookies.js\"\nimport type * as FileSystem from \"../FileSystem.js\"\nimport * as Headers from \"../Headers.js\"\nimport * as IncomingMessage from \"../HttpIncomingMessage.js\"\nimport type { HttpMethod } from \"../HttpMethod.js\"\nimport * as Error from \"../HttpServerError.js\"\nimport type * as ServerRequest from \"../HttpServerRequest.js\"\nimport * as Multipart from \"../Multipart.js\"\nimport type * as Path from \"../Path.js\"\nimport * as Socket from \"../Socket.js\"\nimport * as UrlParams from \"../UrlParams.js\"\n\n/** @internal */\nexport const TypeId: ServerRequest.TypeId = Symbol.for(\"@effect/platform/HttpServerRequest\") as ServerRequest.TypeId\n\n/** @internal */\nexport const serverRequestTag = Context.GenericTag<ServerRequest.HttpServerRequest>(\n  \"@effect/platform/HttpServerRequest\"\n)\n\n/** @internal */\nexport const parsedSearchParamsTag = Context.GenericTag<\n  ServerRequest.ParsedSearchParams,\n  ReadonlyRecord<string, string | Array<string>>\n>(\"@effect/platform/HttpServerRequest/ParsedSearchParams\")\n\n/** @internal */\nexport const upgrade = Effect.flatMap(serverRequestTag, (request) => request.upgrade)\n\n/** @internal */\nexport const upgradeChannel = <IE = never>() => Channel.unwrap(Effect.map(upgrade, Socket.toChannelWith<IE>()))\n\n/** @internal */\nexport const multipartPersisted = Effect.flatMap(serverRequestTag, (request) => request.multipart)\n\n/** @internal */\nexport const searchParamsFromURL = (url: URL): ReadonlyRecord<string, string | Array<string>> => {\n  const out: Record<string, string | Array<string>> = {}\n  for (const [key, value] of url.searchParams.entries()) {\n    const entry = out[key]\n    if (entry !== undefined) {\n      if (Array.isArray(entry)) {\n        entry.push(value)\n      } else {\n        out[key] = [entry, value]\n      }\n    } else {\n      out[key] = value\n    }\n  }\n  return out\n}\n\n/** @internal */\nexport const schemaCookies = <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(serverRequestTag, (req) => parse(req.cookies))\n}\n\n/** @internal */\nexport const schemaHeaders = <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = IncomingMessage.schemaHeaders(schema, options)\n  return Effect.flatMap(serverRequestTag, parse)\n}\n\n/** @internal */\nexport const schemaSearchParams = <\n  A,\n  I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>,\n  R\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(parsedSearchParamsTag, parse)\n}\n\n/** @internal */\nexport const schemaBodyJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = IncomingMessage.schemaBodyJson(schema, options)\n  return Effect.flatMap(serverRequestTag, parse)\n}\n\nconst isMultipart = (request: ServerRequest.HttpServerRequest) =>\n  request.headers[\"content-type\"]?.toLowerCase().includes(\"multipart/form-data\")\n\n/** @internal */\nexport const schemaBodyForm = <A, I extends Partial<Multipart.Persisted>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parseMultipart = Multipart.schemaPersisted(schema, options)\n  const parseUrlParams = IncomingMessage.schemaBodyUrlParams(schema as Schema.Schema<A, any, R>, options)\n  return Effect.flatMap(serverRequestTag, (request): Effect.Effect<\n    A,\n    Multipart.MultipartError | ParseResult.ParseError | Error.RequestError,\n    R | ServerRequest.HttpServerRequest | Scope.Scope | FileSystem.FileSystem | Path.Path\n  > => {\n    if (isMultipart(request)) {\n      return Effect.flatMap(request.multipart, parseMultipart)\n    }\n    return parseUrlParams(request)\n  })\n}\n\n/** @internal */\nexport const schemaBodyUrlParams = <\n  A,\n  I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>,\n  R\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = IncomingMessage.schemaBodyUrlParams(schema, options)\n  return Effect.flatMap(serverRequestTag, parse)\n}\n\n/** @internal */\nexport const schemaBodyMultipart = <A, I extends Partial<Multipart.Persisted>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Multipart.schemaPersisted(schema, options)\n  return Effect.flatMap(multipartPersisted, parse)\n}\n\n/** @internal */\nexport const schemaBodyFormJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parseMultipart = Multipart.schemaJson(schema, options)\n  const parseUrlParams = UrlParams.schemaJson(schema, options)\n  return (field: string) =>\n    Effect.flatMap(\n      serverRequestTag,\n      (\n        request\n      ): Effect.Effect<\n        A,\n        ParseResult.ParseError | Error.RequestError,\n        R | FileSystem.FileSystem | Path.Path | Scope.Scope | ServerRequest.HttpServerRequest\n      > => {\n        if (isMultipart(request)) {\n          return Effect.flatMap(\n            Effect.mapError(request.multipart, (cause) =>\n              new Error.RequestError({\n                request,\n                reason: \"Decode\",\n                cause\n              })),\n            parseMultipart(field)\n          )\n        }\n        return Effect.flatMap(request.urlParamsBody, parseUrlParams(field))\n      }\n    )\n}\n\n/** @internal */\nexport const fromWeb = (request: globalThis.Request): ServerRequest.HttpServerRequest =>\n  new ServerRequestImpl(request, removeHost(request.url))\n\nconst removeHost = (url: string) => {\n  if (url[0] === \"/\") {\n    return url\n  }\n  const index = url.indexOf(\"/\", url.indexOf(\"//\") + 2)\n  return index === -1 ? \"/\" : url.slice(index)\n}\n\nclass ServerRequestImpl extends Inspectable.Class implements ServerRequest.HttpServerRequest {\n  readonly [TypeId]: ServerRequest.TypeId\n  readonly [IncomingMessage.TypeId]: IncomingMessage.TypeId\n  constructor(\n    readonly source: Request,\n    readonly url: string,\n    public headersOverride?: Headers.Headers,\n    private remoteAddressOverride?: string\n  ) {\n    super()\n    this[TypeId] = TypeId\n    this[IncomingMessage.TypeId] = IncomingMessage.TypeId\n  }\n  toJSON(): unknown {\n    return IncomingMessage.inspect(this, {\n      _id: \"@effect/platform/HttpServerRequest\",\n      method: this.method,\n      url: this.originalUrl\n    })\n  }\n  modify(\n    options: {\n      readonly url?: string | undefined\n      readonly headers?: Headers.Headers | undefined\n      readonly remoteAddress?: string | undefined\n    }\n  ) {\n    return new ServerRequestImpl(\n      this.source,\n      options.url ?? this.url,\n      options.headers ?? this.headersOverride,\n      options.remoteAddress ?? this.remoteAddressOverride\n    )\n  }\n  get method(): HttpMethod {\n    return this.source.method.toUpperCase() as HttpMethod\n  }\n  get originalUrl() {\n    return this.source.url\n  }\n  get remoteAddress(): Option.Option<string> {\n    return this.remoteAddressOverride ? Option.some(this.remoteAddressOverride) : Option.none()\n  }\n  get headers(): Headers.Headers {\n    this.headersOverride ??= Headers.fromInput(this.source.headers as any)\n    return this.headersOverride\n  }\n\n  private cachedCookies: ReadonlyRecord<string, string> | undefined\n  get cookies() {\n    if (this.cachedCookies) {\n      return this.cachedCookies\n    }\n    return this.cachedCookies = Cookies.parseHeader(this.headers.cookie ?? \"\")\n  }\n\n  get stream(): Stream.Stream<Uint8Array, Error.RequestError> {\n    return this.source.body\n      ? Stream.fromReadableStream(() => this.source.body as any, (cause) =>\n        new Error.RequestError({\n          request: this,\n          reason: \"Decode\",\n          cause\n        }))\n      : Stream.fail(\n        new Error.RequestError({\n          request: this,\n          reason: \"Decode\",\n          description: \"can not create stream from empty body\"\n        })\n      )\n  }\n\n  private textEffect: Effect.Effect<string, Error.RequestError> | undefined\n  get text(): Effect.Effect<string, Error.RequestError> {\n    if (this.textEffect) {\n      return this.textEffect\n    }\n    this.textEffect = Effect.runSync(Effect.cached(\n      Effect.tryPromise({\n        try: () => this.source.text(),\n        catch: (cause) =>\n          new Error.RequestError({\n            request: this,\n            reason: \"Decode\",\n            cause\n          })\n      })\n    ))\n    return this.textEffect\n  }\n\n  get json(): Effect.Effect<unknown, Error.RequestError> {\n    return Effect.tryMap(this.text, {\n      try: (_) => JSON.parse(_) as unknown,\n      catch: (cause) =>\n        new Error.RequestError({\n          request: this,\n          reason: \"Decode\",\n          cause\n        })\n    })\n  }\n\n  get urlParamsBody(): Effect.Effect<UrlParams.UrlParams, Error.RequestError> {\n    return Effect.flatMap(this.text, (_) =>\n      Effect.try({\n        try: () => UrlParams.fromInput(new URLSearchParams(_)),\n        catch: (cause) =>\n          new Error.RequestError({\n            request: this,\n            reason: \"Decode\",\n            cause\n          })\n      }))\n  }\n\n  private multipartEffect:\n    | Effect.Effect<\n      Multipart.Persisted,\n      Multipart.MultipartError,\n      Scope.Scope | FileSystem.FileSystem | Path.Path\n    >\n    | undefined\n  get multipart(): Effect.Effect<\n    Multipart.Persisted,\n    Multipart.MultipartError,\n    Scope.Scope | FileSystem.FileSystem | Path.Path\n  > {\n    if (this.multipartEffect) {\n      return this.multipartEffect\n    }\n    this.multipartEffect = Effect.runSync(Effect.cached(\n      Multipart.toPersisted(this.multipartStream)\n    ))\n    return this.multipartEffect\n  }\n\n  get multipartStream(): Stream.Stream<Multipart.Part, Multipart.MultipartError> {\n    return Stream.pipeThroughChannel(\n      Stream.mapError(this.stream, (cause) => new Multipart.MultipartError({ reason: \"InternalError\", cause })),\n      Multipart.makeChannel(this.headers)\n    )\n  }\n\n  private arrayBufferEffect: Effect.Effect<ArrayBuffer, Error.RequestError> | undefined\n  get arrayBuffer(): Effect.Effect<ArrayBuffer, Error.RequestError> {\n    if (this.arrayBufferEffect) {\n      return this.arrayBufferEffect\n    }\n    this.arrayBufferEffect = Effect.runSync(Effect.cached(\n      Effect.tryPromise({\n        try: () => this.source.arrayBuffer(),\n        catch: (cause) =>\n          new Error.RequestError({\n            request: this,\n            reason: \"Decode\",\n            cause\n          })\n      })\n    ))\n    return this.arrayBufferEffect\n  }\n\n  get upgrade(): Effect.Effect<Socket.Socket, Error.RequestError> {\n    return Effect.fail(\n      new Error.RequestError({\n        request: this,\n        reason: \"Decode\",\n        description: \"Not an upgradeable ServerRequest\"\n      })\n    )\n  }\n}\n\n/** @internal */\nexport const toURL = (self: ServerRequest.HttpServerRequest): Option.Option<URL> => {\n  const host = self.headers.host ?? \"localhost\"\n  const protocol = self.headers[\"x-forwarded-proto\"] === \"https\" ? \"https\" : \"http\"\n  try {\n    return Option.some(new URL(self.url, `${protocol}://${host}`))\n  } catch {\n    return Option.none()\n  }\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as GlobalValue from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Option from \"effect/Option\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport { unify } from \"effect/Unify\"\nimport * as HttpBody from \"./HttpBody.js\"\nimport type { HttpMiddleware } from \"./HttpMiddleware.js\"\nimport * as ServerError from \"./HttpServerError.js\"\nimport * as ServerRequest from \"./HttpServerRequest.js\"\nimport * as ServerResponse from \"./HttpServerResponse.js\"\nimport * as internal from \"./internal/httpApp.js\"\nimport * as internalMiddleware from \"./internal/httpMiddleware.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type HttpApp<A = ServerResponse.HttpServerResponse, E = never, R = never> = Effect.Effect<\n  A,\n  E,\n  R | ServerRequest.HttpServerRequest\n>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Default<E = never, R = never> = HttpApp<ServerResponse.HttpServerResponse, E, R>\n\nconst handledSymbol = Symbol.for(\"@effect/platform/HttpApp/handled\")\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toHandled = <E, R, _, EH, RH>(\n  self: Default<E, R>,\n  handleResponse: (\n    request: ServerRequest.HttpServerRequest,\n    response: ServerResponse.HttpServerResponse\n  ) => Effect.Effect<_, EH, RH>,\n  middleware?: HttpMiddleware | undefined\n): Effect.Effect<void, never, Exclude<R | RH | ServerRequest.HttpServerRequest, Scope.Scope>> => {\n  const responded = Effect.withFiberRuntime<\n    ServerResponse.HttpServerResponse,\n    E | EH | ServerError.ResponseError,\n    R | RH | ServerRequest.HttpServerRequest\n  >((fiber) =>\n    Effect.flatMap(self, (response) => {\n      const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n      const handler = fiber.getFiberRef(currentPreResponseHandlers)\n      if (handler._tag === \"None\") {\n        ;(request as any)[handledSymbol] = true\n        return Effect.as(handleResponse(request, response), response)\n      }\n      return Effect.tap(handler.value(request, response), (response) => {\n        ;(request as any)[handledSymbol] = true\n        return handleResponse(request, response)\n      })\n    })\n  )\n\n  const withErrorHandling = Effect.catchAllCause(\n    responded,\n    (cause) =>\n      Effect.withFiberRuntime<\n        ServerResponse.HttpServerResponse,\n        E | EH | ServerError.ResponseError,\n        ServerRequest.HttpServerRequest | RH\n      >((fiber) =>\n        Effect.flatMap(ServerError.causeResponse(cause), ([response, cause]) => {\n          const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n          const handler = fiber.getFiberRef(currentPreResponseHandlers)\n          if (handler._tag === \"None\") {\n            ;(request as any)[handledSymbol] = true\n            return Effect.zipRight(handleResponse(request, response), Effect.failCause(cause))\n          }\n          return Effect.zipRight(\n            Effect.tap(handler.value(request, response), (response) => {\n              ;(request as any)[handledSymbol] = true\n              return handleResponse(request, response)\n            }),\n            Effect.failCause(cause)\n          )\n        })\n      )\n  )\n\n  const withMiddleware = unify(\n    middleware === undefined ?\n      internalMiddleware.tracer(withErrorHandling) :\n      Effect.matchCauseEffect(middleware(internalMiddleware.tracer(withErrorHandling)), {\n        onFailure: (cause): Effect.Effect<void, EH, RH> =>\n          Effect.withFiberRuntime((fiber) => {\n            const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n            if (handledSymbol in request) {\n              return Effect.void\n            }\n            return Effect.matchCauseEffect(ServerError.causeResponse(cause), {\n              onFailure: (_cause) => handleResponse(request, ServerResponse.empty({ status: 500 })),\n              onSuccess: ([response]) => handleResponse(request, response)\n            })\n          }),\n        onSuccess: (response): Effect.Effect<void, EH, RH> =>\n          Effect.withFiberRuntime((fiber) => {\n            const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n            return handledSymbol in request ? Effect.void : handleResponse(request, response)\n          })\n      })\n  )\n\n  return Effect.uninterruptible(scoped(withMiddleware)) as any\n}\n\n/**\n * If you want to finalize the http request scope elsewhere, you can use this\n * function to eject from the default scope closure.\n *\n * @since 1.0.0\n * @category Scope\n */\nexport const ejectDefaultScopeClose = (scope: Scope.Scope): void => {\n  ejectedScopes.add(scope)\n}\n\n/**\n * @since 1.0.0\n * @category Scope\n */\nexport const unsafeEjectStreamScope = (\n  response: ServerResponse.HttpServerResponse\n): ServerResponse.HttpServerResponse => {\n  if (response.body._tag !== \"Stream\") {\n    return response\n  }\n  const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n  const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope) as Scope.CloseableScope\n  ejectDefaultScopeClose(scope)\n  return ServerResponse.setBody(\n    response,\n    HttpBody.stream(\n      Stream.ensuring(response.body.stream, Scope.close(scope, Exit.void)),\n      response.body.contentType,\n      response.body.contentLength\n    )\n  )\n}\n\nconst ejectedScopes = GlobalValue.globalValue(\n  \"@effect/platform/HttpApp/ejectedScopes\",\n  () => new WeakSet<Scope.Scope>()\n)\n\nconst scoped = <A, E, R>(effect: Effect.Effect<A, E, R>) =>\n  Effect.flatMap(Scope.make(), (scope) =>\n    Effect.onExit(Scope.extend(effect, scope), (exit) => {\n      if (ejectedScopes.has(scope)) {\n        return Effect.void\n      }\n      return Scope.close(scope, exit)\n    }))\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PreResponseHandler = (\n  request: ServerRequest.HttpServerRequest,\n  response: ServerResponse.HttpServerResponse\n) => Effect.Effect<ServerResponse.HttpServerResponse, ServerError.ResponseError>\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentPreResponseHandlers: FiberRef.FiberRef<Option.Option<PreResponseHandler>> =\n  internal.currentPreResponseHandlers\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const appendPreResponseHandler: (handler: PreResponseHandler) => Effect.Effect<void> =\n  internal.appendPreResponseHandler\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withPreResponseHandler = internal.withPreResponseHandler\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandlerRuntime = <R>(runtime: Runtime.Runtime<R>) => {\n  const run = Runtime.runFork(runtime)\n  return <E>(self: Default<E, R | Scope.Scope>, middleware?: HttpMiddleware | undefined) => {\n    const resolveSymbol = Symbol.for(\"@effect/platform/HttpApp/resolve\")\n    const httpApp = toHandled(self, (request, response) => {\n      response = unsafeEjectStreamScope(response)\n      ;(request as any)[resolveSymbol](\n        ServerResponse.toWeb(response, { withoutBody: request.method === \"HEAD\", runtime })\n      )\n      return Effect.void\n    }, middleware)\n    return (request: Request, context?: Context.Context<never> | undefined): Promise<Response> =>\n      new Promise((resolve) => {\n        const contextMap = new Map<string, any>(runtime.context.unsafeMap)\n        if (Context.isContext(context)) {\n          for (const [key, value] of context.unsafeMap) {\n            contextMap.set(key, value)\n          }\n        }\n        const httpServerRequest = ServerRequest.fromWeb(request)\n        contextMap.set(ServerRequest.HttpServerRequest.key, httpServerRequest)\n        ;(httpServerRequest as any)[resolveSymbol] = resolve\n        const fiber = run(Effect.locally(httpApp as any, FiberRef.currentContext, Context.unsafeMake(contextMap)))\n        request.signal?.addEventListener(\"abort\", () => {\n          fiber.unsafeInterruptAsFork(ServerError.clientAbortFiberId)\n        }, { once: true })\n      })\n  }\n}\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandler: <E>(\n  self: Default<E, Scope.Scope>,\n  middleware?: HttpMiddleware | undefined\n) => (request: Request, context?: Context.Context<never> | undefined) => Promise<Response> = toWebHandlerRuntime(\n  Runtime.defaultRuntime\n)\n\n/**\n * @since 1.0.0\n * @category conversions\n */\nexport const toWebHandlerLayer = <E, R, RE>(\n  self: Default<E, R | Scope.Scope>,\n  layer: Layer.Layer<R, RE>,\n  middleware?: HttpMiddleware | undefined\n): {\n  readonly close: () => Promise<void>\n  readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>\n} => {\n  const scope = Effect.runSync(Scope.make())\n  const close = () => Effect.runPromise(Scope.close(scope, Exit.void))\n  const build = Effect.map(Layer.toRuntime(layer), (_) => toWebHandlerRuntime(_)(self, middleware))\n  const runner = Effect.runPromise(Scope.extend(build, scope))\n  const handler = (request: Request, context?: Context.Context<never> | undefined): Promise<Response> =>\n    runner.then((handler) => handler(request, context))\n  return { close, handler } as const\n}\n", "import * as Effect from \"effect/Effect\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Option from \"effect/Option\"\nimport type { HttpApp, PreResponseHandler } from \"../HttpApp.js\"\n\n/** @internal */\nexport const currentPreResponseHandlers: FiberRef.FiberRef<Option.Option<PreResponseHandler>> = globalValue(\n  Symbol.for(\"@effect/platform/HttpApp/preResponseHandlers\"),\n  () => FiberRef.unsafeMake<Option.Option<PreResponseHandler>>(Option.none())\n)\n\n/** @internal */\nexport const appendPreResponseHandler: (handler: PreResponseHandler) => Effect.Effect<void> = (\n  handler: PreResponseHandler\n) =>\n  FiberRef.update(\n    currentPreResponseHandlers,\n    Option.match({\n      onNone: () => Option.some(handler),\n      onSome: (prev) =>\n        Option.some((request, response) =>\n          Effect.flatMap(prev(request, response), (response) => handler(request, response))\n        )\n    })\n  )\n\n/** @internal */\nexport const withPreResponseHandler = dual<\n  (handler: PreResponseHandler) => <A, E, R>(self: HttpApp<A, E, R>) => HttpApp<A, E, R>,\n  <A, E, R>(self: HttpApp<A, E, R>, handler: PreResponseHandler) => HttpApp<A, E, R>\n>(2, (self, handler) =>\n  Effect.locallyWith(\n    self,\n    currentPreResponseHandlers,\n    Option.match({\n      onNone: () => Option.some(handler),\n      onSome: (prev) =>\n        Option.some((request, response) =>\n          Effect.flatMap(prev(request, response), (response) => handler(request, response))\n        )\n    })\n  ))\n", "import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { constFalse, dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Option from \"effect/Option\"\nimport type * as Predicate from \"effect/Predicate\"\nimport type { ReadonlyRecord } from \"effect/Record\"\nimport * as Headers from \"../Headers.js\"\nimport type * as App from \"../HttpApp.js\"\nimport type * as Middleware from \"../HttpMiddleware.js\"\nimport * as ServerError from \"../HttpServerError.js\"\nimport * as ServerRequest from \"../HttpServerRequest.js\"\nimport * as ServerResponse from \"../HttpServerResponse.js\"\nimport type { HttpServerResponse } from \"../HttpServerResponse.js\"\nimport * as TraceContext from \"../HttpTraceContext.js\"\nimport * as internalHttpApp from \"./httpApp.js\"\n\n/** @internal */\nexport const make = <M extends Middleware.HttpMiddleware>(middleware: M): M => middleware\n\n/** @internal */\nexport const loggerDisabled = globalValue(\n  Symbol.for(\"@effect/platform/HttpMiddleware/loggerDisabled\"),\n  () => FiberRef.unsafeMake(false)\n)\n\n/** @internal */\nexport const withLoggerDisabled = <A, E, R>(self: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  Effect.zipRight(\n    FiberRef.set(loggerDisabled, true),\n    self\n  )\n\n/** @internal */\nexport const currentTracerDisabledWhen = globalValue(\n  Symbol.for(\"@effect/platform/HttpMiddleware/tracerDisabledWhen\"),\n  () => FiberRef.unsafeMake<Predicate.Predicate<ServerRequest.HttpServerRequest>>(constFalse)\n)\n\n/** @internal */\nexport const withTracerDisabledWhen = dual<\n  (\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ) => <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>,\n  <A, E, R>(\n    layer: Layer.Layer<A, E, R>,\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ) => Layer.Layer<A, E, R>\n>(2, (self, pred) => Layer.locally(self, currentTracerDisabledWhen, pred))\n\n/** @internal */\nexport const withTracerDisabledWhenEffect = dual<\n  (\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ) => Effect.Effect<A, E, R>\n>(2, (self, pred) => Effect.locally(self, currentTracerDisabledWhen, pred))\n\n/** @internal */\nexport const withTracerDisabledForUrls = dual<\n  (\n    urls: ReadonlyArray<string>\n  ) => <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>,\n  <A, E, R>(\n    layer: Layer.Layer<A, E, R>,\n    urls: ReadonlyArray<string>\n  ) => Layer.Layer<A, E, R>\n>(2, (self, urls) => Layer.locally(self, currentTracerDisabledWhen, (req) => urls.includes(req.url)))\n\n/** @internal */\nexport const SpanNameGenerator = Context.Reference<Middleware.SpanNameGenerator>()(\n  \"@effect/platform/HttpMiddleware/SpanNameGenerator\",\n  {\n    defaultValue: () => (request: ServerRequest.HttpServerRequest) => `http.server ${request.method}`\n  }\n)\n\n/** @internal */\nexport const withSpanNameGenerator = dual<\n  (\n    f: (request: ServerRequest.HttpServerRequest) => string\n  ) => <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>,\n  <A, E, R>(\n    layer: Layer.Layer<A, E, R>,\n    f: (request: ServerRequest.HttpServerRequest) => string\n  ) => Layer.Layer<A, E, R>\n>(2, (self, f) => Layer.provide(self, Layer.succeed(SpanNameGenerator, f)))\n\n/** @internal */\nexport const logger = make((httpApp) => {\n  let counter = 0\n  return Effect.withFiberRuntime((fiber) => {\n    const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n    return Effect.withLogSpan(\n      Effect.flatMap(Effect.exit(httpApp), (exit) => {\n        if (fiber.getFiberRef(loggerDisabled)) {\n          return exit\n        } else if (exit._tag === \"Failure\") {\n          const [response, cause] = ServerError.causeResponseStripped(exit.cause)\n          return Effect.zipRight(\n            Effect.annotateLogs(Effect.log(cause._tag === \"Some\" ? cause.value : \"Sent HTTP Response\"), {\n              \"http.method\": request.method,\n              \"http.url\": request.url,\n              \"http.status\": response.status\n            }),\n            exit\n          )\n        }\n        return Effect.zipRight(\n          Effect.annotateLogs(Effect.log(\"Sent HTTP response\"), {\n            \"http.method\": request.method,\n            \"http.url\": request.url,\n            \"http.status\": exit.value.status\n          }),\n          exit\n        )\n      }),\n      `http.span.${++counter}`\n    )\n  })\n})\n\n/** @internal */\nexport const tracer = make((httpApp) =>\n  Effect.withFiberRuntime((fiber) => {\n    const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n    const disabled = fiber.getFiberRef(currentTracerDisabledWhen)(request)\n    if (disabled) {\n      return httpApp\n    }\n    const url = Option.getOrUndefined(ServerRequest.toURL(request))\n    if (url !== undefined && (url.username !== \"\" || url.password !== \"\")) {\n      url.username = \"REDACTED\"\n      url.password = \"REDACTED\"\n    }\n    const redactedHeaderNames = fiber.getFiberRef(Headers.currentRedactedNames)\n    const redactedHeaders = Headers.redact(request.headers, redactedHeaderNames)\n    const nameGenerator = Context.get(fiber.currentContext, SpanNameGenerator)\n    return Effect.useSpan(\n      nameGenerator(request),\n      {\n        parent: Option.getOrUndefined(TraceContext.fromHeaders(request.headers)),\n        kind: \"server\",\n        captureStackTrace: false\n      },\n      (span) => {\n        span.attribute(\"http.request.method\", request.method)\n        if (url !== undefined) {\n          span.attribute(\"url.full\", url.toString())\n          span.attribute(\"url.path\", url.pathname)\n          const query = url.search.slice(1)\n          if (query !== \"\") {\n            span.attribute(\"url.query\", url.search.slice(1))\n          }\n          span.attribute(\"url.scheme\", url.protocol.slice(0, -1))\n        }\n        if (request.headers[\"user-agent\"] !== undefined) {\n          span.attribute(\"user_agent.original\", request.headers[\"user-agent\"])\n        }\n        for (const name in redactedHeaders) {\n          span.attribute(`http.request.header.${name}`, String(redactedHeaders[name]))\n        }\n        if (request.remoteAddress._tag === \"Some\") {\n          span.attribute(\"client.address\", request.remoteAddress.value)\n        }\n        return Effect.flatMap(\n          Effect.exit(Effect.withParentSpan(httpApp, span)),\n          (exit) => {\n            const response = ServerError.exitResponse(exit)\n            span.attribute(\"http.response.status_code\", response.status)\n            const redactedHeaders = Headers.redact(response.headers, redactedHeaderNames)\n            for (const name in redactedHeaders) {\n              span.attribute(`http.response.header.${name}`, String(redactedHeaders[name]))\n            }\n            return exit\n          }\n        )\n      }\n    )\n  })\n)\n\n/** @internal */\nexport const xForwardedHeaders = make((httpApp) =>\n  Effect.updateService(httpApp, ServerRequest.HttpServerRequest, (request) =>\n    request.headers[\"x-forwarded-host\"]\n      ? request.modify({\n        headers: Headers.set(\n          request.headers,\n          \"host\",\n          request.headers[\"x-forwarded-host\"]\n        ),\n        remoteAddress: request.headers[\"x-forwarded-for\"]?.split(\",\")[0].trim()\n      })\n      : request)\n)\n\n/** @internal */\nexport const searchParamsParser = <E, R>(httpApp: App.Default<E, R>) =>\n  Effect.withFiberRuntime<\n    HttpServerResponse,\n    E,\n    ServerRequest.HttpServerRequest | Exclude<R, ServerRequest.ParsedSearchParams>\n  >((fiber) => {\n    const context = fiber.currentContext\n    const request = Context.unsafeGet(context, ServerRequest.HttpServerRequest)\n    const params = ServerRequest.searchParamsFromURL(new URL(request.originalUrl))\n    return Effect.locally(\n      httpApp,\n      FiberRef.currentContext,\n      Context.add(context, ServerRequest.ParsedSearchParams, params)\n    ) as any\n  })\n\n/** @internal */\nexport const cors = (options?: {\n  readonly allowedOrigins?: ReadonlyArray<string> | undefined\n  readonly allowedMethods?: ReadonlyArray<string> | undefined\n  readonly allowedHeaders?: ReadonlyArray<string> | undefined\n  readonly exposedHeaders?: ReadonlyArray<string> | undefined\n  readonly maxAge?: number | undefined\n  readonly credentials?: boolean | undefined\n}) => {\n  const opts = {\n    allowedOrigins: [\"*\"],\n    allowedMethods: [\"GET\", \"HEAD\", \"PUT\", \"PATCH\", \"POST\", \"DELETE\"],\n    allowedHeaders: [],\n    exposedHeaders: [],\n    credentials: false,\n    ...options\n  }\n\n  const isAllowedOrigin = (origin: string) => opts.allowedOrigins.includes(origin)\n\n  const allowOrigin = (originHeader: string): ReadonlyRecord<string, string> | undefined => {\n    if (opts.allowedOrigins.length === 0) {\n      return { \"access-control-allow-origin\": \"*\" }\n    }\n\n    if (opts.allowedOrigins.length === 1) {\n      return {\n        \"access-control-allow-origin\": opts.allowedOrigins[0],\n        vary: \"Origin\"\n      }\n    }\n\n    if (isAllowedOrigin(originHeader)) {\n      return {\n        \"access-control-allow-origin\": originHeader,\n        vary: \"Origin\"\n      }\n    }\n\n    return undefined\n  }\n\n  const allowMethods = opts.allowedMethods.length > 0\n    ? { \"access-control-allow-methods\": opts.allowedMethods.join(\", \") }\n    : undefined\n\n  const allowCredentials = opts.credentials\n    ? { \"access-control-allow-credentials\": \"true\" }\n    : undefined\n\n  const allowHeaders = (\n    accessControlRequestHeaders: string | undefined\n  ): ReadonlyRecord<string, string> | undefined => {\n    if (opts.allowedHeaders.length === 0 && accessControlRequestHeaders) {\n      return {\n        vary: \"Access-Control-Request-Headers\",\n        \"access-control-allow-headers\": accessControlRequestHeaders\n      }\n    }\n\n    if (opts.allowedHeaders) {\n      return {\n        \"access-control-allow-headers\": opts.allowedHeaders.join(\",\")\n      }\n    }\n\n    return undefined\n  }\n\n  const exposeHeaders = opts.exposedHeaders.length > 0\n    ? { \"access-control-expose-headers\": opts.exposedHeaders.join(\",\") }\n    : undefined\n\n  const maxAge = opts.maxAge\n    ? { \"access-control-max-age\": opts.maxAge.toString() }\n    : undefined\n\n  const headersFromRequest = (request: ServerRequest.HttpServerRequest) => {\n    const origin = request.headers[\"origin\"]\n    return Headers.unsafeFromRecord({\n      ...allowOrigin(origin),\n      ...allowCredentials,\n      ...exposeHeaders\n    })\n  }\n\n  const headersFromRequestOptions = (request: ServerRequest.HttpServerRequest) => {\n    const origin = request.headers[\"origin\"]\n    const accessControlRequestHeaders = request.headers[\"access-control-request-headers\"]\n    return Headers.unsafeFromRecord({\n      ...allowOrigin(origin),\n      ...allowCredentials,\n      ...exposeHeaders,\n      ...allowMethods,\n      ...allowHeaders(accessControlRequestHeaders),\n      ...maxAge\n    })\n  }\n\n  const preResponseHandler = (request: ServerRequest.HttpServerRequest, response: HttpServerResponse) =>\n    Effect.succeed(ServerResponse.setHeaders(response, headersFromRequest(request)))\n\n  return <E, R>(httpApp: App.Default<E, R>): App.Default<E, R> =>\n    Effect.withFiberRuntime((fiber) => {\n      const request = Context.unsafeGet(fiber.currentContext, ServerRequest.HttpServerRequest)\n      if (request.method === \"OPTIONS\") {\n        return Effect.succeed(ServerResponse.empty({\n          status: 204,\n          headers: headersFromRequestOptions(request)\n        }))\n      }\n      return Effect.zipRight(internalHttpApp.appendPreResponseHandler(preResponseHandler), httpApp)\n    })\n}\n", "/**\n * @since 1.0.0\n * @category models\n */\nexport type HttpMethod =\n  | \"GET\"\n  | \"POST\"\n  | \"PUT\"\n  | \"DELETE\"\n  | \"PATCH\"\n  | \"HEAD\"\n  | \"OPTIONS\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace HttpMethod {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type NoBody = \"GET\" | \"HEAD\" | \"OPTIONS\"\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type WithBody = Exclude<HttpMethod, NoBody>\n}\n\n/**\n * @since 1.0.0\n */\nexport const hasBody = (method: HttpMethod): boolean => method !== \"GET\" && method !== \"HEAD\" && method !== \"OPTIONS\"\n\n/**\n * @since 1.0.0\n */\nexport const all: ReadonlySet<HttpMethod> = new Set([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"HEAD\", \"OPTIONS\"])\n\n/**\n * Tests if a value is a `HttpMethod`.\n *\n * **Example**\n *\n * ```ts\n * import { HttpMethod } from \"@effect/platform\"\n *\n * console.log(HttpMethod.isHttpMethod(\"GET\"))\n * // true\n * console.log(HttpMethod.isHttpMethod(\"get\"))\n * // false\n * console.log(HttpMethod.isHttpMethod(1))\n * // false\n * ```\n *\n * @since 1.0.0\n * @category refinements\n */\nexport const isHttpMethod = (u: unknown): u is HttpMethod => all.has(u as HttpMethod)\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type * as FiberRef from \"effect/FiberRef\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as Predicate from \"effect/Predicate\"\nimport type * as App from \"./HttpApp.js\"\nimport type * as ServerRequest from \"./HttpServerRequest.js\"\nimport * as internal from \"./internal/httpMiddleware.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpMiddleware {\n  <E, R>(self: App.Default<E, R>): App.Default<any, any>\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpMiddleware {\n  /**\n   * @since 1.0.0\n   */\n  export interface Applied<A extends App.Default<any, any>, E, R> {\n    (self: App.Default<E, R>): A\n  }\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: <M extends HttpMiddleware>(middleware: M) => M = internal.make\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const logger: <E, R>(httpApp: App.Default<E, R>) => App.Default<E, R> = internal.logger\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const loggerDisabled: FiberRef.FiberRef<boolean> = internal.loggerDisabled\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withLoggerDisabled: <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R> =\n  internal.withLoggerDisabled\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const currentTracerDisabledWhen: FiberRef.FiberRef<Predicate.Predicate<ServerRequest.HttpServerRequest>> =\n  internal.currentTracerDisabledWhen\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withTracerDisabledWhen: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>): <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(\n    layer: Layer.Layer<A, E, R>,\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ): Layer.Layer<A, E, R>\n} = internal.withTracerDisabledWhen\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withTracerDisabledWhenEffect: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    predicate: Predicate.Predicate<ServerRequest.HttpServerRequest>\n  ): Effect.Effect<A, E, R>\n} = internal.withTracerDisabledWhenEffect\n\n/**\n * @since 1.0.0\n * @category fiber refs\n */\nexport const withTracerDisabledForUrls: {\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  (urls: ReadonlyArray<string>): <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category fiber refs\n   */\n  <A, E, R>(layer: Layer.Layer<A, E, R>, urls: ReadonlyArray<string>): Layer.Layer<A, E, R>\n} = internal.withTracerDisabledForUrls\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const xForwardedHeaders: <E, R>(httpApp: App.Default<E, R>) => App.Default<E, R> = internal.xForwardedHeaders\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const searchParamsParser: <E, R>(\n  httpApp: App.Default<E, R>\n) => App.Default<\n  E,\n  Exclude<R, ServerRequest.ParsedSearchParams>\n> = internal.searchParamsParser\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const cors: (\n  options?: {\n    readonly allowedOrigins?: ReadonlyArray<string> | undefined\n    readonly allowedMethods?: ReadonlyArray<string> | undefined\n    readonly allowedHeaders?: ReadonlyArray<string> | undefined\n    readonly exposedHeaders?: ReadonlyArray<string> | undefined\n    readonly maxAge?: number | undefined\n    readonly credentials?: boolean | undefined\n  } | undefined\n) => <E, R>(httpApp: App.Default<E, R>) => App.Default<E, R> = internal.cors\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport interface SpanNameGenerator {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const SpanNameGenerator: Context.Reference<\n  SpanNameGenerator,\n  (request: ServerRequest.HttpServerRequest) => string\n> = internal.SpanNameGenerator\n\n/**\n * Customizes the span name for the http app.\n *\n * ```ts\n * import {\n *   HttpMiddleware,\n *   HttpRouter,\n *   HttpServer,\n *   HttpServerResponse\n * } from \"@effect/platform\"\n * import { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\"\n * import { Layer } from \"effect\"\n * import { createServer } from \"http\"\n *\n * HttpRouter.empty.pipe(\n *   HttpRouter.get(\"/\", HttpServerResponse.empty()),\n *   HttpServer.serve(),\n *   // Customize the span names for this HttpApp\n *   HttpMiddleware.withSpanNameGenerator((request) => `GET ${request.url}`),\n *   Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n *   Layer.launch,\n *   NodeRuntime.runMain\n * )\n * ```\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withSpanNameGenerator: {\n  /**\n   * Customizes the span name for the http app.\n   *\n   * ```ts\n   * import {\n   *   HttpMiddleware,\n   *   HttpRouter,\n   *   HttpServer,\n   *   HttpServerResponse\n   * } from \"@effect/platform\"\n   * import { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\"\n   * import { Layer } from \"effect\"\n   * import { createServer } from \"http\"\n   *\n   * HttpRouter.empty.pipe(\n   *   HttpRouter.get(\"/\", HttpServerResponse.empty()),\n   *   HttpServer.serve(),\n   *   // Customize the span names for this HttpApp\n   *   HttpMiddleware.withSpanNameGenerator((request) => `GET ${request.url}`),\n   *   Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n   *   Layer.launch,\n   *   NodeRuntime.runMain\n   * )\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (f: (request: ServerRequest.HttpServerRequest) => string): <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R>\n  /**\n   * Customizes the span name for the http app.\n   *\n   * ```ts\n   * import {\n   *   HttpMiddleware,\n   *   HttpRouter,\n   *   HttpServer,\n   *   HttpServerResponse\n   * } from \"@effect/platform\"\n   * import { NodeHttpServer, NodeRuntime } from \"@effect/platform-node\"\n   * import { Layer } from \"effect\"\n   * import { createServer } from \"http\"\n   *\n   * HttpRouter.empty.pipe(\n   *   HttpRouter.get(\"/\", HttpServerResponse.empty()),\n   *   HttpServer.serve(),\n   *   // Customize the span names for this HttpApp\n   *   HttpMiddleware.withSpanNameGenerator((request) => `GET ${request.url}`),\n   *   Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n   *   Layer.launch,\n   *   NodeRuntime.runMain\n   * )\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <A, E, R>(\n    layer: Layer.Layer<A, E, R>,\n    f: (request: ServerRequest.HttpServerRequest) => string\n  ): Layer.Layer<A, E, R>\n} = internal.withSpanNameGenerator\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type { RuntimeFiber } from \"effect/Fiber\"\nimport type * as FiberRef from \"effect/FiberRef\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type { Layer } from \"effect/Layer\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport type * as Predicate from \"effect/Predicate\"\nimport type { Ref } from \"effect/Ref\"\nimport type * as Schedule from \"effect/Schedule\"\nimport type { Scope } from \"effect/Scope\"\nimport type { NoExcessProperties, NoInfer } from \"effect/Types\"\nimport type { Cookies } from \"./Cookies.js\"\nimport type * as Error from \"./HttpClientError.js\"\nimport type * as ClientRequest from \"./HttpClientRequest.js\"\nimport type * as ClientResponse from \"./HttpClientResponse.js\"\nimport * as internal from \"./internal/httpClient.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpClient extends HttpClient.With<Error.HttpClientError> {}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpClient {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface With<E, R = never> extends Pipeable, Inspectable {\n    readonly [TypeId]: TypeId\n    readonly execute: (\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n\n    readonly get: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoBody\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly head: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoBody\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly post: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly patch: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly put: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly del: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    readonly options: (\n      url: string | URL,\n      options?: ClientRequest.Options.NoUrl\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Preprocess<E, R> = (\n    request: ClientRequest.HttpClientRequest\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, E, R>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Postprocess<E = never, R = never> = (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E, R>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const HttpClient: Context.Tag<HttpClient, HttpClient> = internal.tag\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const execute: (\n  request: ClientRequest.HttpClientRequest\n) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError, HttpClient> = internal.execute\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const get: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoBody | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.get\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const head: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoBody | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.head\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const post: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.post\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const patch: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.patch\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const put: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.put\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const del: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.del\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const options: (\n  url: string | URL,\n  options?: ClientRequest.Options.NoUrl | undefined\n) => Effect.Effect<\n  ClientResponse.HttpClientResponse,\n  Error.HttpClientError,\n  HttpClient\n> = internal.options\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchAll: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, E2, R2>(f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E2, R2 | R>\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, A2, E2, R2>(self: HttpClient.With<E, R>, f: (e: E) => Effect.Effect<A2, E2, R2>): HttpClient.With<E2, R | R2>\n} = internal.catchAll\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchTag: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, E1, R1>(\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <R, E, K extends E extends { _tag: string } ? E[\"_tag\"] : never, R1, E1>(\n    self: HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n} = internal.catchTag\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport const catchTags: {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <\n    E,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(cases: Cases): <R>(\n    self: HttpClient.With<E, R>\n  ) => HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string }>[\"_tag\"]>]: never })\n  >(self: HttpClient.With<E, R>, cases: Cases): HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n    }[keyof Cases]\n  >\n} = internal.catchTags\n\n/**\n * Filters the result of a response, or runs an alternative effect if the predicate fails.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterOrElse: {\n  /**\n   * Filters the result of a response, or runs an alternative effect if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E2, R2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>\n  /**\n   * Filters the result of a response, or runs an alternative effect if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): HttpClient.With<E2 | E, R2 | R>\n} = internal.filterOrElse\n\n/**\n * Filters the result of a response, or throws an error if the predicate fails.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterOrFail: {\n  /**\n   * Filters the result of a response, or throws an error if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>\n  /**\n   * Filters the result of a response, or throws an error if the predicate fails.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R, E2>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): HttpClient.With<E2 | E, R>\n} = internal.filterOrFail\n\n/**\n * Filters responses by HTTP status code.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterStatus: {\n  /**\n   * Filters responses by HTTP status code.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>\n  /**\n   * Filters responses by HTTP status code.\n   *\n   * @since 1.0.0\n   * @category filters\n   */\n  <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>\n} = internal.filterStatus\n\n/**\n * Filters responses that return a 2xx status code.\n *\n * @since 1.0.0\n * @category filters\n */\nexport const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R> =\n  internal.filterStatusOk\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeWith: <E2, R2, E, R>(\n  postprocess: (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n  preprocess: HttpClient.Preprocess<E2, R2>\n) => HttpClient.With<E, R> = internal.makeWith\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: (\n  f: (\n    request: ClientRequest.HttpClientRequest,\n    url: URL,\n    signal: AbortSignal,\n    fiber: RuntimeFiber<ClientResponse.HttpClientResponse, Error.HttpClientError>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError>\n) => HttpClient = internal.make\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const transform: {\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): (self: HttpClient.With<E, R>) => HttpClient.With<E | E1, R | R1>\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    self: HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E | E1, R | R1>\n} = internal.transform\n\n/**\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const transformResponse: {\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): (self: HttpClient.With<E, R>) => HttpClient.With<E1, R1>\n  /**\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E1, R1>(\n    self: HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): HttpClient.With<E1, R1>\n} = internal.transformResponse\n\n/**\n * Appends a transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequest: {\n  /**\n   * Appends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Appends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ): HttpClient.With<E, R>\n} = internal.mapRequest\n\n/**\n * Appends an effectful transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestEffect: {\n  /**\n   * Appends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Appends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.mapRequestEffect\n\n/**\n * Prepends a transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestInput: {\n  /**\n   * Prepends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Prepends a transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ): HttpClient.With<E, R>\n} = internal.mapRequestInput\n\n/**\n * Prepends an effectful transformation of the request object before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const mapRequestInputEffect: {\n  /**\n   * Prepends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Prepends an effectful transformation of the request object before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.mapRequestInputEffect\n\n/**\n * @since 1.0.0\n * @category error handling\n */\nexport declare namespace Retry {\n  /**\n   * @since 1.0.0\n   * @category error handling\n   */\n  export type Return<R, E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>> = HttpClient.With<\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer _R> } ? E\n      : O extends { until: Predicate.Refinement<E, infer E2> } ? E2\n      : E)\n    | (O extends { while: (...args: Array<any>) => Effect.Effect<infer _A, infer E, infer _R> } ? E : never)\n    | (O extends { until: (...args: Array<any>) => Effect.Effect<infer _A, infer E, infer _R> } ? E : never),\n    | R\n    | (O extends { schedule: Schedule.Schedule<infer _O, infer _I, infer R> } ? R : never)\n    | (O extends { while: (...args: Array<any>) => Effect.Effect<infer _A, infer _E, infer R> } ? R : never)\n    | (O extends { until: (...args: Array<any>) => Effect.Effect<infer _A, infer _E, infer R> } ? R : never)\n  > extends infer Z ? Z : never\n}\n\n/**\n * Retries the request based on a provided schedule or policy.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const retry: {\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>\n  /**\n   * Retries the request based on a provided schedule or policy.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>\n} = internal.retry\n\n/**\n * Retries common transient errors, such as rate limiting, timeouts or network issues.\n *\n * Specifying a `while` predicate allows you to consider other errors as\n * transient.\n *\n * @since 1.0.0\n * @category error handling\n */\nexport const retryTransient: {\n  /**\n   * Retries common transient errors, such as rate limiting, timeouts or network issues.\n   *\n   * Specifying a `while` predicate allows you to consider other errors as\n   * transient.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <B, E, R1 = never>(\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>\n  /**\n   * Retries common transient errors, such as rate limiting, timeouts or network issues.\n   *\n   * Specifying a `while` predicate allows you to consider other errors as\n   * transient.\n   *\n   * @since 1.0.0\n   * @category error handling\n   */\n  <E, R, B, R1 = never>(\n    self: HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): HttpClient.With<E, R1 | R>\n} = internal.retryTransient\n\n/**\n * Performs an additional effect after a successful request.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tap: {\n  /**\n   * Performs an additional effect after a successful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E2, R2>(\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect after a successful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tap\n\n/**\n * Performs an additional effect after an unsuccessful request.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tapError: {\n  /**\n   * Performs an additional effect after an unsuccessful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect after an unsuccessful request.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tapError\n\n/**\n * Performs an additional effect on the request before sending it.\n *\n * @since 1.0.0\n * @category mapping & sequencing\n */\nexport const tapRequest: {\n  /**\n   * Performs an additional effect on the request before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <_, E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>\n  /**\n   * Performs an additional effect on the request before sending it.\n   *\n   * @since 1.0.0\n   * @category mapping & sequencing\n   */\n  <E, R, _, E2, R2>(\n    self: HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ): HttpClient.With<E | E2, R | R2>\n} = internal.tapRequest\n\n/**\n * Associates a `Ref` of cookies with the client for handling cookies across requests.\n *\n * @since 1.0.0\n * @category cookies\n */\nexport const withCookiesRef: {\n  /**\n   * Associates a `Ref` of cookies with the client for handling cookies across requests.\n   *\n   * @since 1.0.0\n   * @category cookies\n   */\n  (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Associates a `Ref` of cookies with the client for handling cookies across requests.\n   *\n   * @since 1.0.0\n   * @category cookies\n   */\n  <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>\n} = internal.withCookiesRef\n\n/**\n * Follows HTTP redirects up to a specified number of times.\n *\n * @since 1.0.0\n * @category redirects\n */\nexport const followRedirects: {\n  /**\n   * Follows HTTP redirects up to a specified number of times.\n   *\n   * @since 1.0.0\n   * @category redirects\n   */\n  (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Follows HTTP redirects up to a specified number of times.\n   *\n   * @since 1.0.0\n   * @category redirects\n   */\n  <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>\n} = internal.followRedirects\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const currentTracerDisabledWhen: FiberRef.FiberRef<Predicate.Predicate<ClientRequest.HttpClientRequest>> =\n  internal.currentTracerDisabledWhen\n\n/**\n * Disables tracing for specific requests based on a provided predicate.\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withTracerDisabledWhen: {\n  /**\n   * Disables tracing for specific requests based on a provided predicate.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Disables tracing for specific requests based on a provided predicate.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ): HttpClient.With<E, R>\n} = internal.withTracerDisabledWhen\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const currentTracerPropagation: FiberRef.FiberRef<boolean> = internal.currentTracerPropagation\n\n/**\n * Enables or disables tracing propagation for the request.\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withTracerPropagation: {\n  /**\n   * Enables or disables tracing propagation for the request.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (enabled: boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Enables or disables tracing propagation for the request.\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(self: HttpClient.With<E, R>, enabled: boolean): HttpClient.With<E, R>\n} = internal.withTracerPropagation\n\n/**\n * @since 1.0.0\n */\nexport const layerMergedContext: <E, R>(\n  effect: Effect.Effect<HttpClient, E, R>\n) => Layer<HttpClient, E, R> = internal.layerMergedContext\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport interface SpanNameGenerator {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category Tracing\n */\nexport const SpanNameGenerator: Context.Reference<\n  SpanNameGenerator,\n  (request: ClientRequest.HttpClientRequest) => string\n> = internal.SpanNameGenerator\n\n/**\n * Customizes the span names for tracing.\n *\n * ```ts\n * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n * import { NodeRuntime } from \"@effect/platform-node\"\n * import { Effect } from \"effect\"\n *\n * Effect.gen(function* () {\n *   const client = (yield* HttpClient.HttpClient).pipe(\n *     // Customize the span names for this HttpClient\n *     HttpClient.withSpanNameGenerator(\n *       (request) => `http.client ${request.method} ${request.url}`\n *     )\n *   )\n *\n *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n * ```\n *\n * @since 1.0.0\n * @category Tracing\n */\nexport const withSpanNameGenerator: {\n  /**\n   * Customizes the span names for tracing.\n   *\n   * ```ts\n   * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n   * import { NodeRuntime } from \"@effect/platform-node\"\n   * import { Effect } from \"effect\"\n   *\n   * Effect.gen(function* () {\n   *   const client = (yield* HttpClient.HttpClient).pipe(\n   *     // Customize the span names for this HttpClient\n   *     HttpClient.withSpanNameGenerator(\n   *       (request) => `http.client ${request.method} ${request.url}`\n   *     )\n   *   )\n   *\n   *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n   * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  (f: (request: ClientRequest.HttpClientRequest) => string): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>\n  /**\n   * Customizes the span names for tracing.\n   *\n   * ```ts\n   * import { FetchHttpClient, HttpClient } from \"@effect/platform\"\n   * import { NodeRuntime } from \"@effect/platform-node\"\n   * import { Effect } from \"effect\"\n   *\n   * Effect.gen(function* () {\n   *   const client = (yield* HttpClient.HttpClient).pipe(\n   *     // Customize the span names for this HttpClient\n   *     HttpClient.withSpanNameGenerator(\n   *       (request) => `http.client ${request.method} ${request.url}`\n   *     )\n   *   )\n   *\n   *   yield* client.get(\"https://jsonplaceholder.typicode.com/posts/1\")\n   * }).pipe(Effect.provide(FetchHttpClient.layer), NodeRuntime.runMain)\n   * ```\n   *\n   * @since 1.0.0\n   * @category Tracing\n   */\n  <E, R>(\n    self: HttpClient.With<E, R>,\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ): HttpClient.With<E, R>\n} = internal.withSpanNameGenerator\n\n/**\n * Ties the lifetime of the `HttpClientRequest` to a `Scope`.\n *\n * @since 1.0.0\n * @category Scope\n */\nexport const withScope: <E, R>(\n  self: HttpClient.With<E, R>\n) => HttpClient.With<E, R | Scope> = internal.withScope\n", "import * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Redacted from \"effect/Redacted\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport type * as PlatformError from \"../Error.js\"\nimport type * as FileSystem from \"../FileSystem.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type { HttpMethod } from \"../HttpMethod.js\"\nimport * as UrlParams from \"../UrlParams.js\"\nimport * as internalBody from \"./httpBody.js\"\n\n/** @internal */\nexport const TypeId: ClientRequest.TypeId = Symbol.for(\"@effect/platform/HttpClientRequest\") as ClientRequest.TypeId\n\nconst Proto = {\n  [TypeId]: TypeId,\n  ...Inspectable.BaseProto,\n  toJSON(this: ClientRequest.HttpClientRequest): unknown {\n    return {\n      _id: \"@effect/platform/HttpClientRequest\",\n      method: this.method,\n      url: this.url,\n      urlParams: this.urlParams,\n      hash: this.hash,\n      headers: Inspectable.redact(this.headers),\n      body: this.body.toJSON()\n    }\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeInternal(\n  method: HttpMethod,\n  url: string,\n  urlParams: UrlParams.UrlParams,\n  hash: Option.Option<string>,\n  headers: Headers.Headers,\n  body: Body.HttpBody\n): ClientRequest.HttpClientRequest {\n  const self = Object.create(Proto)\n  self.method = method\n  self.url = url\n  self.urlParams = urlParams\n  self.hash = hash\n  self.headers = headers\n  self.body = body\n  return self\n}\n\n/** @internal */\nexport const isClientRequest = (u: unknown): u is ClientRequest.HttpClientRequest =>\n  typeof u === \"object\" && u !== null && TypeId in u\n\n/** @internal */\nexport const empty: ClientRequest.HttpClientRequest = makeInternal(\n  \"GET\",\n  \"\",\n  UrlParams.empty,\n  Option.none(),\n  Headers.empty,\n  internalBody.empty\n)\n\n/** @internal */\nexport const make = <M extends HttpMethod>(method: M) =>\n(\n  url: string | URL,\n  options?: M extends \"GET\" | \"HEAD\" ? ClientRequest.Options.NoBody : ClientRequest.Options.NoUrl\n) =>\n  modify(empty, {\n    method,\n    url,\n    ...(options ?? undefined)\n  })\n\n/** @internal */\nexport const get = make(\"GET\")\n\n/** @internal */\nexport const post = make(\"POST\")\n\n/** @internal */\nexport const put = make(\"PUT\")\n\n/** @internal */\nexport const patch = make(\"PATCH\")\n\n/** @internal */\nexport const del = make(\"DELETE\")\n\n/** @internal */\nexport const head = make(\"HEAD\")\n\n/** @internal */\nexport const options = make(\"OPTIONS\")\n\n/** @internal */\nexport const modify = dual<\n  (options: ClientRequest.Options) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, options: ClientRequest.Options) => ClientRequest.HttpClientRequest\n>(2, (self, options) => {\n  let result = self\n\n  if (options.method) {\n    result = setMethod(result, options.method)\n  }\n  if (options.url) {\n    result = setUrl(result, options.url)\n  }\n  if (options.headers) {\n    result = setHeaders(result, options.headers)\n  }\n  if (options.urlParams) {\n    result = setUrlParams(result, options.urlParams)\n  }\n  if (options.hash) {\n    result = setHash(result, options.hash)\n  }\n  if (options.body) {\n    result = setBody(result, options.body)\n  }\n  if (options.accept) {\n    result = accept(result, options.accept)\n  }\n  if (options.acceptJson) {\n    result = acceptJson(result)\n  }\n\n  return result\n})\n\n/** @internal */\nexport const setHeader = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    Headers.set(self.headers, key, value),\n    self.body\n  ))\n\n/** @internal */\nexport const setHeaders = dual<\n  (input: Headers.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: Headers.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    Headers.setAll(self.headers, input),\n    self.body\n  ))\n\nconst stringOrRedacted = (value: string | Redacted.Redacted): string =>\n  typeof value === \"string\" ? value : Redacted.value(value)\n\n/** @internal */\nexport const basicAuth = dual<\n  (\n    username: string | Redacted.Redacted,\n    password: string | Redacted.Redacted\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (\n    self: ClientRequest.HttpClientRequest,\n    username: string | Redacted.Redacted,\n    password: string | Redacted.Redacted\n  ) => ClientRequest.HttpClientRequest\n>(\n  3,\n  (self, username, password) =>\n    setHeader(self, \"Authorization\", `Basic ${btoa(`${stringOrRedacted(username)}:${stringOrRedacted(password)}`)}`)\n)\n\n/** @internal */\nexport const bearerToken = dual<\n  (token: string | Redacted.Redacted) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, token: string | Redacted.Redacted) => ClientRequest.HttpClientRequest\n>(2, (self, token) => setHeader(self, \"Authorization\", `Bearer ${stringOrRedacted(token)}`))\n\n/** @internal */\nexport const accept = dual<\n  (mediaType: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, mediaType: string) => ClientRequest.HttpClientRequest\n>(2, (self, mediaType) => setHeader(self, \"Accept\", mediaType))\n\n/** @internal */\nexport const acceptJson = accept(\"application/json\")\n\n/** @internal */\nexport const setMethod = dual<\n  (method: HttpMethod) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, method: HttpMethod) => ClientRequest.HttpClientRequest\n>(2, (self, method) =>\n  makeInternal(\n    method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrl = dual<\n  (url: string | URL) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, url: string | URL) => ClientRequest.HttpClientRequest\n>(2, (self, url) => {\n  if (typeof url === \"string\") {\n    return makeInternal(\n      self.method,\n      url,\n      self.urlParams,\n      self.hash,\n      self.headers,\n      self.body\n    )\n  }\n  const clone = new URL(url.toString())\n  const urlParams = UrlParams.fromInput(clone.searchParams)\n  const hash = clone.hash ? Option.some(clone.hash.slice(1)) : Option.none()\n  clone.search = \"\"\n  clone.hash = \"\"\n  return makeInternal(\n    self.method,\n    clone.toString(),\n    urlParams,\n    hash,\n    self.headers,\n    self.body\n  )\n})\n\n/** @internal */\nexport const appendUrl = dual<\n  (path: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, path: string) => ClientRequest.HttpClientRequest\n>(2, (self, url) =>\n  makeInternal(\n    self.method,\n    self.url.endsWith(\"/\") && url.startsWith(\"/\") ?\n      self.url + url.slice(1) :\n      self.url + url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const prependUrl = dual<\n  (path: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, path: string) => ClientRequest.HttpClientRequest\n>(2, (self, url) =>\n  makeInternal(\n    self.method,\n    url.endsWith(\"/\") && self.url.startsWith(\"/\") ?\n      url + self.url.slice(1) :\n      url + self.url,\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const updateUrl = dual<\n  (f: (url: string) => string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, f: (url: string) => string) => ClientRequest.HttpClientRequest\n>(2, (self, f) =>\n  makeInternal(\n    self.method,\n    f(self.url),\n    self.urlParams,\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const appendUrlParam = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.append(self.urlParams, key, value),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const appendUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.appendAll(self.urlParams, input),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrlParam = dual<\n  (key: string, value: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, key: string, value: string) => ClientRequest.HttpClientRequest\n>(3, (self, key, value) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.set(self.urlParams, key, value),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, input) =>\n  makeInternal(\n    self.method,\n    self.url,\n    UrlParams.setAll(self.urlParams, input),\n    self.hash,\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const setHash = dual<\n  (hash: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, hash: string) => ClientRequest.HttpClientRequest\n>(2, (self, hash) =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    Option.some(hash),\n    self.headers,\n    self.body\n  ))\n\n/** @internal */\nexport const removeHash = (self: ClientRequest.HttpClientRequest): ClientRequest.HttpClientRequest =>\n  makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    Option.none(),\n    self.headers,\n    self.body\n  )\n\n/** @internal */\nexport const toUrl = (self: ClientRequest.HttpClientRequest): Option.Option<URL> =>\n  Either.getRight(UrlParams.makeUrl(self.url, self.urlParams, self.hash))\n\n/** @internal */\nexport const setBody = dual<\n  (body: Body.HttpBody) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: Body.HttpBody) => ClientRequest.HttpClientRequest\n>(2, (self, body) => {\n  let headers = self.headers\n  if (body._tag === \"Empty\" || body._tag === \"FormData\") {\n    headers = Headers.remove(headers, [\"Content-type\", \"Content-length\"])\n  } else {\n    const contentType = body.contentType\n    if (contentType) {\n      headers = Headers.set(headers, \"content-type\", contentType)\n    }\n\n    const contentLength = body.contentLength\n    if (contentLength) {\n      headers = Headers.set(headers, \"content-length\", contentLength.toString())\n    }\n  }\n  return makeInternal(\n    self.method,\n    self.url,\n    self.urlParams,\n    self.hash,\n    headers,\n    body\n  )\n})\n\n/** @internal */\nexport const bodyUint8Array = dual<\n  (\n    body: Uint8Array,\n    contentType?: string\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: Uint8Array, contentType?: string) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, contentType = \"application/octet-stream\") => setBody(self, internalBody.uint8Array(body, contentType))\n)\n\n/** @internal */\nexport const bodyText = dual<\n  (body: string, contentType?: string) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: string, contentType?: string) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, contentType = \"text/plain\") => setBody(self, internalBody.text(body, contentType))\n)\n\n/** @internal */\nexport const bodyJson = dual<\n  (\n    body: unknown\n  ) => (self: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError>,\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: unknown\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError>\n>(2, (self, body) => Effect.map(internalBody.json(body), (body) => setBody(self, body)))\n\n/** @internal */\nexport const bodyUnsafeJson = dual<\n  (body: unknown) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: unknown) => ClientRequest.HttpClientRequest\n>(2, (self, body) => setBody(self, internalBody.unsafeJson(body)))\n\n/** @internal */\nexport const bodyFile = dual<\n  (\n    path: string,\n    options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ) => (\n    self: ClientRequest.HttpClientRequest\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>,\n  (\n    self: ClientRequest.HttpClientRequest,\n    path: string,\n    options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ) => Effect.Effect<ClientRequest.HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n>(\n  (args) => isClientRequest(args[0]),\n  (self, path, options) => Effect.map(internalBody.file(path, options), (body) => setBody(self, body))\n)\n\n/** @internal */\nexport const bodyFileWeb = dual<\n  (file: Body.HttpBody.FileLike) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, file: Body.HttpBody.FileLike) => ClientRequest.HttpClientRequest\n>(2, (self, file) => setBody(self, internalBody.fileWeb(file)))\n\n/** @internal */\nexport const schemaBodyJson = <A, I, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined): {\n  (\n    body: A\n  ): (self: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: A\n  ): Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n} => {\n  const encode = internalBody.jsonSchema(schema, options)\n  return dual<\n    (\n      body: A\n    ) => (\n      self: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>,\n    (\n      self: ClientRequest.HttpClientRequest,\n      body: A\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, Body.HttpBodyError, R>\n  >(2, (self, body) => Effect.map(encode(body), (body) => setBody(self, body)))\n}\n\n/** @internal */\nexport const bodyUrlParams = dual<\n  (input: UrlParams.Input) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, input: UrlParams.Input) => ClientRequest.HttpClientRequest\n>(2, (self, body) =>\n  setBody(\n    self,\n    internalBody.text(\n      UrlParams.toString(UrlParams.fromInput(body)),\n      \"application/x-www-form-urlencoded\"\n    )\n  ))\n\n/** @internal */\nexport const bodyFormData = dual<\n  (body: FormData) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, body: FormData) => ClientRequest.HttpClientRequest\n>(2, (self, body) => setBody(self, internalBody.formData(body)))\n\n/** @internal */\nexport const bodyFormDataRecord = dual<\n  (entries: Body.FormDataInput) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (self: ClientRequest.HttpClientRequest, entries: Body.FormDataInput) => ClientRequest.HttpClientRequest\n>(2, (self, entries) => setBody(self, internalBody.formDataRecord(entries)))\n\n/** @internal */\nexport const bodyStream = dual<\n  (\n    body: Stream.Stream<Uint8Array, unknown>,\n    options?: {\n      readonly contentType?: string | undefined\n      readonly contentLength?: number | undefined\n    }\n  ) => (self: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest,\n  (\n    self: ClientRequest.HttpClientRequest,\n    body: Stream.Stream<Uint8Array, unknown>,\n    options?: {\n      readonly contentType?: string | undefined\n      readonly contentLength?: number | undefined\n    }\n  ) => ClientRequest.HttpClientRequest\n>(\n  (args) => isClientRequest(args[0]),\n  (self, body, { contentLength, contentType = \"application/octet-stream\" } = {}) =>\n    setBody(self, internalBody.stream(body, contentType, contentLength))\n)\n", "import * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Stream from \"effect/Stream\"\nimport type { Unify } from \"effect/Unify\"\nimport * as Cookies from \"../Cookies.js\"\nimport * as Headers from \"../Headers.js\"\nimport * as Error from \"../HttpClientError.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type * as ClientResponse from \"../HttpClientResponse.js\"\nimport * as IncomingMessage from \"../HttpIncomingMessage.js\"\nimport * as UrlParams from \"../UrlParams.js\"\n\n/** @internal */\nexport const TypeId: ClientResponse.TypeId = Symbol.for(\"@effect/platform/HttpClientResponse\") as ClientResponse.TypeId\n\n/** @internal */\nexport const fromWeb = (\n  request: ClientRequest.HttpClientRequest,\n  source: globalThis.Response\n): ClientResponse.HttpClientResponse => new ClientResponseImpl(request, source)\n\nclass ClientResponseImpl extends Inspectable.Class implements ClientResponse.HttpClientResponse {\n  readonly [IncomingMessage.TypeId]: IncomingMessage.TypeId\n  readonly [TypeId]: ClientResponse.TypeId\n\n  constructor(\n    readonly request: ClientRequest.HttpClientRequest,\n    private readonly source: globalThis.Response\n  ) {\n    super()\n    this[IncomingMessage.TypeId] = IncomingMessage.TypeId\n    this[TypeId] = TypeId\n  }\n\n  toJSON(): unknown {\n    return IncomingMessage.inspect(this, {\n      _id: \"@effect/platform/HttpClientResponse\",\n      request: this.request.toJSON(),\n      status: this.status\n    })\n  }\n\n  get status(): number {\n    return this.source.status\n  }\n\n  get headers(): Headers.Headers {\n    return Headers.fromInput(this.source.headers as any)\n  }\n\n  cachedCookies?: Cookies.Cookies\n  get cookies(): Cookies.Cookies {\n    if (this.cachedCookies) {\n      return this.cachedCookies\n    }\n    return this.cachedCookies = Cookies.fromSetCookie(this.source.headers.getSetCookie())\n  }\n\n  get remoteAddress(): Option.Option<string> {\n    return Option.none()\n  }\n\n  get stream(): Stream.Stream<Uint8Array, Error.ResponseError> {\n    return this.source.body\n      ? Stream.fromReadableStream(() => this.source.body!, (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        }))\n      : Stream.fail(\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"EmptyBody\",\n          description: \"can not create stream from empty body\"\n        })\n      )\n  }\n\n  get json(): Effect.Effect<unknown, Error.ResponseError> {\n    return Effect.tryMap(this.text, {\n      try: (text) => text === \"\" ? null : JSON.parse(text) as unknown,\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    })\n  }\n\n  private textBody?: Effect.Effect<string, Error.ResponseError>\n  get text(): Effect.Effect<string, Error.ResponseError> {\n    return this.textBody ??= Effect.tryPromise({\n      try: () => this.source.text(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n\n  get urlParamsBody(): Effect.Effect<UrlParams.UrlParams, Error.ResponseError> {\n    return Effect.flatMap(this.text, (_) =>\n      Effect.try({\n        try: () => UrlParams.fromInput(new URLSearchParams(_)),\n        catch: (cause) =>\n          new Error.ResponseError({\n            request: this.request,\n            response: this,\n            reason: \"Decode\",\n            cause\n          })\n      }))\n  }\n\n  private formDataBody?: Effect.Effect<FormData, Error.ResponseError>\n  get formData(): Effect.Effect<FormData, Error.ResponseError> {\n    return this.formDataBody ??= Effect.tryPromise({\n      try: () => this.source.formData(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n\n  private arrayBufferBody?: Effect.Effect<ArrayBuffer, Error.ResponseError>\n  get arrayBuffer(): Effect.Effect<ArrayBuffer, Error.ResponseError> {\n    return this.arrayBufferBody ??= Effect.tryPromise({\n      try: () => this.source.arrayBuffer(),\n      catch: (cause) =>\n        new Error.ResponseError({\n          request: this.request,\n          response: this,\n          reason: \"Decode\",\n          cause\n        })\n    }).pipe(Effect.cached, Effect.runSync)\n  }\n}\n\n/** @internal */\nexport const schemaJson = <\n  R,\n  I extends {\n    readonly status?: number | undefined\n    readonly headers?: Readonly<Record<string, string>> | undefined\n    readonly body?: unknown | undefined\n  },\n  A\n>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return (self: ClientResponse.HttpClientResponse): Effect.Effect<A, Error.ResponseError | ParseResult.ParseError, R> =>\n    Effect.flatMap(\n      self.json,\n      (body) =>\n        parse({\n          status: self.status,\n          headers: self.headers,\n          body\n        })\n    )\n}\n\n/** @internal */\nexport const schemaNoBody = <\n  R,\n  I extends {\n    readonly status?: number | undefined\n    readonly headers?: Readonly<Record<string, string>> | undefined\n  },\n  A\n>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return (self: ClientResponse.HttpClientResponse): Effect.Effect<A, ParseResult.ParseError, R> =>\n    parse({\n      status: self.status,\n      headers: self.headers\n    })\n}\n\n/** @internal */\nexport const stream = <E, R>(effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>) =>\n  Stream.unwrap(Effect.map(effect, (_) => _.stream))\n\n/** @internal */\nexport const matchStatus = dual<\n  <\n    const Cases extends {\n      readonly [status: number]: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"2xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"3xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"4xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"5xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly orElse: (_: ClientResponse.HttpClientResponse) => any\n    }\n  >(\n    cases: Cases\n  ) => (self: ClientResponse.HttpClientResponse) => Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never,\n  <\n    const Cases extends {\n      readonly [status: number]: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"2xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"3xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"4xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly \"5xx\"?: (_: ClientResponse.HttpClientResponse) => any\n      readonly orElse: (_: ClientResponse.HttpClientResponse) => any\n    }\n  >(\n    self: ClientResponse.HttpClientResponse,\n    cases: Cases\n  ) => Cases[keyof Cases] extends (_: any) => infer R ? Unify<R> : never\n>(2, (self, cases) => {\n  const status = self.status\n  if (cases[status]) {\n    return cases[status](self)\n  } else if (status >= 200 && status < 300 && cases[\"2xx\"]) {\n    return cases[\"2xx\"](self)\n  } else if (status >= 300 && status < 400 && cases[\"3xx\"]) {\n    return cases[\"3xx\"](self)\n  } else if (status >= 400 && status < 500 && cases[\"4xx\"]) {\n    return cases[\"4xx\"](self)\n  } else if (status >= 500 && status < 600 && cases[\"5xx\"]) {\n    return cases[\"5xx\"](self)\n  }\n  return cases.orElse(self)\n})\n\n/** @internal */\nexport const filterStatus = dual<\n  (\n    f: (status: number) => boolean\n  ) => (\n    self: ClientResponse.HttpClientResponse\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError>,\n  (\n    self: ClientResponse.HttpClientResponse,\n    f: (status: number) => boolean\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError>\n>(\n  2,\n  (self, f) =>\n    Effect.suspend(() =>\n      f(self.status) ? Effect.succeed(self) : Effect.fail(\n        new Error.ResponseError({\n          response: self,\n          request: self.request,\n          reason: \"StatusCode\",\n          description: \"invalid status code\"\n        })\n      )\n    )\n)\n\n/** @internal */\nexport const filterStatusOk = (\n  self: ClientResponse.HttpClientResponse\n): Effect.Effect<ClientResponse.HttpClientResponse, Error.ResponseError> =>\n  self.status >= 200 && self.status < 300 ? Effect.succeed(self) : Effect.fail(\n    new Error.ResponseError({\n      response: self,\n      request: self.request,\n      reason: \"StatusCode\",\n      description: \"non 2xx status code\"\n    })\n  )\n", "import * as Cause from \"effect/Cause\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport type * as Fiber from \"effect/Fiber\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { constFalse, dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Layer from \"effect/Layer\"\nimport { pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Ref from \"effect/Ref\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport type { NoExcessProperties, NoInfer } from \"effect/Types\"\nimport * as Cookies from \"../Cookies.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Client from \"../HttpClient.js\"\nimport * as Error from \"../HttpClientError.js\"\nimport type * as ClientRequest from \"../HttpClientRequest.js\"\nimport type * as ClientResponse from \"../HttpClientResponse.js\"\nimport * as IncomingMessage from \"../HttpIncomingMessage.js\"\nimport * as TraceContext from \"../HttpTraceContext.js\"\nimport * as UrlParams from \"../UrlParams.js\"\nimport * as internalRequest from \"./httpClientRequest.js\"\nimport * as internalResponse from \"./httpClientResponse.js\"\n\n/** @internal */\nexport const TypeId: Client.TypeId = Symbol.for(\n  \"@effect/platform/HttpClient\"\n) as Client.TypeId\n\n/** @internal */\nexport const tag = Context.GenericTag<Client.HttpClient>(\"@effect/platform/HttpClient\")\n\n/** @internal */\nexport const currentTracerDisabledWhen = globalValue(\n  Symbol.for(\"@effect/platform/HttpClient/tracerDisabledWhen\"),\n  () => FiberRef.unsafeMake<Predicate.Predicate<ClientRequest.HttpClientRequest>>(constFalse)\n)\n\n/** @internal */\nexport const withTracerDisabledWhen = dual<\n  (\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, pred) => transformResponse(self, Effect.locally(currentTracerDisabledWhen, pred)))\n\n/** @internal */\nexport const currentTracerPropagation = globalValue(\n  Symbol.for(\"@effect/platform/HttpClient/currentTracerPropagation\"),\n  () => FiberRef.unsafeMake(true)\n)\n\n/** @internal */\nexport const withTracerPropagation = dual<\n  (\n    enabled: boolean\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    enabled: boolean\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, enabled) => transformResponse(self, Effect.locally(currentTracerPropagation, enabled)))\n\n/** @internal */\nexport const SpanNameGenerator = Context.Reference<Client.SpanNameGenerator>()(\n  \"@effect/platform/HttpClient/SpanNameGenerator\",\n  {\n    defaultValue: () => (request: ClientRequest.HttpClientRequest) => `http.client ${request.method}`\n  }\n)\n\n/** @internal */\nexport const withSpanNameGenerator = dual<\n  (\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (request: ClientRequest.HttpClientRequest) => string\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => transformResponse(self, Effect.provideService(SpanNameGenerator, f)))\n\nconst ClientProto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  ...Inspectable.BaseProto,\n  toJSON() {\n    return {\n      _id: \"@effect/platform/HttpClient\"\n    }\n  },\n  get(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.get(url, options))\n  },\n  head(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.head(url, options))\n  },\n  post(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.post(url, options))\n  },\n  put(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.put(url, options))\n  },\n  patch(this: Client.HttpClient, url: string | URL, options: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.patch(url, options))\n  },\n  del(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoUrl) {\n    return this.execute(internalRequest.del(url, options))\n  },\n  options(this: Client.HttpClient, url: string | URL, options?: ClientRequest.Options.NoBody) {\n    return this.execute(internalRequest.options(url, options))\n  }\n}\n\nconst isClient = (u: unknown): u is Client.HttpClient.With<unknown, unknown> => Predicate.hasProperty(u, TypeId)\n\ninterface HttpClientImpl<E, R> extends Client.HttpClient.With<E, R> {\n  readonly preprocess: Client.HttpClient.Preprocess<E, R>\n  readonly postprocess: Client.HttpClient.Postprocess<E, R>\n}\n\n/** @internal */\nexport const makeWith = <E2, R2, E, R>(\n  postprocess: (\n    request: Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n  preprocess: Client.HttpClient.Preprocess<E2, R2>\n): Client.HttpClient.With<E, R> => {\n  const self = Object.create(ClientProto)\n  self.preprocess = preprocess\n  self.postprocess = postprocess\n  self.execute = function(request: ClientRequest.HttpClientRequest) {\n    return postprocess(preprocess(request))\n  }\n  return self\n}\n\nconst responseRegistry = globalValue(\n  \"@effect/platform/HttpClient/responseRegistry\",\n  () => {\n    if (\"FinalizationRegistry\" in globalThis && globalThis.FinalizationRegistry) {\n      const registry = new FinalizationRegistry((controller: AbortController) => {\n        controller.abort()\n      })\n      return {\n        register(response: ClientResponse.HttpClientResponse, controller: AbortController) {\n          registry.register(response, controller, response)\n        },\n        unregister(response: ClientResponse.HttpClientResponse) {\n          registry.unregister(response)\n        }\n      }\n    }\n\n    const timers = new Map<ClientResponse.HttpClientResponse, any>()\n    return {\n      register(response: ClientResponse.HttpClientResponse, controller: AbortController) {\n        timers.set(response, setTimeout(() => controller.abort(), 5000))\n      },\n      unregister(response: ClientResponse.HttpClientResponse) {\n        const timer = timers.get(response)\n        if (timer === undefined) return\n        clearTimeout(timer)\n        timers.delete(response)\n      }\n    }\n  }\n)\n\nconst scopedRequests = globalValue(\n  \"@effect/platform/HttpClient/scopedRequests\",\n  () => new WeakMap<ClientRequest.HttpClientRequest, AbortController>()\n)\n\n/** @internal */\nexport const make = (\n  f: (\n    request: ClientRequest.HttpClientRequest,\n    url: URL,\n    signal: AbortSignal,\n    fiber: Fiber.RuntimeFiber<ClientResponse.HttpClientResponse, Error.HttpClientError>\n  ) => Effect.Effect<ClientResponse.HttpClientResponse, Error.HttpClientError>\n): Client.HttpClient =>\n  makeWith((effect) =>\n    Effect.flatMap(effect, (request) =>\n      Effect.withFiberRuntime((fiber) => {\n        const scopedController = scopedRequests.get(request)\n        const controller = scopedController ?? new AbortController()\n        const urlResult = UrlParams.makeUrl(request.url, request.urlParams, request.hash)\n        if (urlResult._tag === \"Left\") {\n          return Effect.fail(new Error.RequestError({ request, reason: \"InvalidUrl\", cause: urlResult.left }))\n        }\n        const url = urlResult.right\n        const tracerDisabled = !fiber.getFiberRef(FiberRef.currentTracerEnabled) ||\n          fiber.getFiberRef(currentTracerDisabledWhen)(request)\n        if (tracerDisabled) {\n          const effect = f(request, url, controller.signal, fiber)\n          if (scopedController) return effect\n          return Effect.uninterruptibleMask((restore) =>\n            Effect.matchCauseEffect(restore(effect), {\n              onSuccess(response) {\n                responseRegistry.register(response, controller)\n                return Effect.succeed(new InterruptibleResponse(response, controller))\n              },\n              onFailure(cause) {\n                if (Cause.isInterrupted(cause)) {\n                  controller.abort()\n                }\n                return Effect.failCause(cause)\n              }\n            })\n          )\n        }\n        const nameGenerator = Context.get(fiber.currentContext, SpanNameGenerator)\n        return Effect.useSpan(\n          nameGenerator(request),\n          { kind: \"client\", captureStackTrace: false },\n          (span) => {\n            span.attribute(\"http.request.method\", request.method)\n            span.attribute(\"server.address\", url.origin)\n            if (url.port !== \"\") {\n              span.attribute(\"server.port\", +url.port)\n            }\n            span.attribute(\"url.full\", url.toString())\n            span.attribute(\"url.path\", url.pathname)\n            span.attribute(\"url.scheme\", url.protocol.slice(0, -1))\n            const query = url.search.slice(1)\n            if (query !== \"\") {\n              span.attribute(\"url.query\", query)\n            }\n            const redactedHeaderNames = fiber.getFiberRef(Headers.currentRedactedNames)\n            const redactedHeaders = Headers.redact(request.headers, redactedHeaderNames)\n            for (const name in redactedHeaders) {\n              span.attribute(`http.request.header.${name}`, String(redactedHeaders[name]))\n            }\n            request = fiber.getFiberRef(currentTracerPropagation)\n              ? internalRequest.setHeaders(request, TraceContext.toHeaders(span))\n              : request\n            return Effect.uninterruptibleMask((restore) =>\n              restore(f(request, url, controller.signal, fiber)).pipe(\n                Effect.withParentSpan(span),\n                Effect.matchCauseEffect({\n                  onSuccess: (response) => {\n                    span.attribute(\"http.response.status_code\", response.status)\n                    const redactedHeaders = Headers.redact(response.headers, redactedHeaderNames)\n                    for (const name in redactedHeaders) {\n                      span.attribute(`http.response.header.${name}`, String(redactedHeaders[name]))\n                    }\n                    if (scopedController) return Effect.succeed(response)\n                    responseRegistry.register(response, controller)\n                    return Effect.succeed(new InterruptibleResponse(response, controller))\n                  },\n                  onFailure(cause) {\n                    if (!scopedController && Cause.isInterrupted(cause)) {\n                      controller.abort()\n                    }\n                    return Effect.failCause(cause)\n                  }\n                })\n              )\n            )\n          }\n        )\n      })), Effect.succeed as Client.HttpClient.Preprocess<never, never>)\n\nclass InterruptibleResponse implements ClientResponse.HttpClientResponse {\n  constructor(\n    readonly original: ClientResponse.HttpClientResponse,\n    readonly controller: AbortController\n  ) {}\n\n  readonly [internalResponse.TypeId]: ClientResponse.TypeId = internalResponse.TypeId\n  readonly [IncomingMessage.TypeId]: IncomingMessage.TypeId = IncomingMessage.TypeId\n\n  private applyInterrupt<A, E, R>(effect: Effect.Effect<A, E, R>) {\n    return Effect.suspend(() => {\n      responseRegistry.unregister(this.original)\n      return Effect.onInterrupt(effect, () =>\n        Effect.sync(() => {\n          this.controller.abort()\n        }))\n    })\n  }\n\n  get request() {\n    return this.original.request\n  }\n\n  get status() {\n    return this.original.status\n  }\n\n  get headers() {\n    return this.original.headers\n  }\n\n  get cookies() {\n    return this.original.cookies\n  }\n\n  get remoteAddress() {\n    return this.original.remoteAddress\n  }\n\n  get formData() {\n    return this.applyInterrupt(this.original.formData)\n  }\n\n  get text() {\n    return this.applyInterrupt(this.original.text)\n  }\n\n  get json() {\n    return this.applyInterrupt(this.original.json)\n  }\n\n  get urlParamsBody() {\n    return this.applyInterrupt(this.original.urlParamsBody)\n  }\n\n  get arrayBuffer() {\n    return this.applyInterrupt(this.original.arrayBuffer)\n  }\n\n  get stream() {\n    return Stream.suspend(() => {\n      responseRegistry.unregister(this.original)\n      return Stream.ensuringWith(this.original.stream, (exit) => {\n        if (Exit.isInterrupted(exit)) {\n          this.controller.abort()\n        }\n        return Effect.void\n      })\n    })\n  }\n\n  toJSON() {\n    return this.original.toJSON()\n  }\n\n  [Inspectable.NodeInspectSymbol]() {\n    return this.original[Inspectable.NodeInspectSymbol]()\n  }\n}\n\n/** @internal */\nexport const withScope = <E, R>(\n  self: Client.HttpClient.With<E, R>\n): Client.HttpClient.With<E, R | Scope.Scope> =>\n  transform(\n    self,\n    (effect, request) => {\n      const controller = new AbortController()\n      scopedRequests.set(request, controller)\n      return Effect.zipRight(\n        Effect.scopeWith((scope) => Scope.addFinalizer(scope, Effect.sync(() => controller.abort()))),\n        effect\n      )\n    }\n  )\n\nexport const {\n  /** @internal */\n  del,\n  /** @internal */\n  execute,\n  /** @internal */\n  get,\n  /** @internal */\n  head,\n  /** @internal */\n  options,\n  /** @internal */\n  patch,\n  /** @internal */\n  post,\n  /** @internal */\n  put\n} = Effect.serviceFunctions(tag)\n\n/** @internal */\nexport const transform = dual<\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => (self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E1, R | R1>,\n  <E, R, E1, R1>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>,\n      request: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => Client.HttpClient.With<E | E1, R | R1>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(\n    Effect.flatMap((request) => f(client.postprocess(Effect.succeed(request)), request)),\n    client.preprocess\n  )\n})\n\n/** @internal */\nexport const filterStatus = dual<\n  (\n    f: (status: number) => boolean\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | Error.ResponseError, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (status: number) => boolean\n  ) => Client.HttpClient.With<E | Error.ResponseError, R>\n>(2, (self, f) => transformResponse(self, Effect.flatMap(internalResponse.filterStatus(f))))\n\n/** @internal */\nexport const filterStatusOk = <E, R>(\n  self: Client.HttpClient.With<E, R>\n): Client.HttpClient.With<E | Error.ResponseError, R> =>\n  transformResponse(self, Effect.flatMap(internalResponse.filterStatusOk))\n\n/** @internal */\nexport const transformResponse = dual<\n  <E, R, E1, R1>(\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => (self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E1, R1>,\n  <E, R, E1, R1>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      effect: Effect.Effect<ClientResponse.HttpClientResponse, E, R>\n    ) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ) => Client.HttpClient.With<E1, R1>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith((request) => f(client.postprocess(request)), client.preprocess)\n})\n\n/** @internal */\nexport const catchTag: {\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, E1, R1>(\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n  <\n    R,\n    E,\n    K extends E extends { _tag: string } ? E[\"_tag\"] : never,\n    R1,\n    E1\n  >(\n    self: Client.HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R>\n} = dual(\n  3,\n  <\n    R,\n    E,\n    K extends E extends { _tag: string } ? E[\"_tag\"] : never,\n    R1,\n    E1\n  >(\n    self: Client.HttpClient.With<E, R>,\n    tag: K,\n    f: (e: Extract<E, { _tag: K }>) => Effect.Effect<ClientResponse.HttpClientResponse, E1, R1>\n  ): Client.HttpClient.With<E1 | Exclude<E, { _tag: K }>, R1 | R> => transformResponse(self, Effect.catchTag(tag, f))\n)\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    cases: Cases\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  >\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    self: Client.HttpClient.With<E, R>,\n    cases: Cases\n  ): Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  >\n} = dual(\n  2,\n  <\n    E extends { _tag: string },\n    R,\n    Cases extends\n      & {\n        [K in Extract<E, { _tag: string }>[\"_tag\"]]+?: (\n          error: Extract<E, { _tag: K }>\n        ) => Effect.Effect<ClientResponse.HttpClientResponse, any, any>\n      }\n      & (unknown extends E ? {}\n        : {\n          [\n            K in Exclude<\n              keyof Cases,\n              Extract<E, { _tag: string }>[\"_tag\"]\n            >\n          ]: never\n        })\n  >(\n    self: Client.HttpClient.With<E, R>,\n    cases: Cases\n  ): Client.HttpClient.With<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, infer E, any> ? E\n        : never\n    }[keyof Cases],\n    | R\n    | {\n      [K in keyof Cases]: Cases[K] extends (\n        ...args: Array<any>\n      ) => Effect.Effect<any, any, infer R> ? R\n        : never\n    }[keyof Cases]\n  > => transformResponse(self, Effect.catchTags(cases) as any)\n)\n\n/** @internal */\nexport const catchAll: {\n  <E, E2, R2>(\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E2, R | R2>\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2, R | R2>\n} = dual(\n  2,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: E) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2, R | R2> => transformResponse(self, Effect.catchAll(f))\n)\n\n/** @internal */\nexport const filterOrElse: {\n  <E2, R2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E2 | E, R2 | R>\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>\n  ): Client.HttpClient.With<E2 | E, R2 | R>\n} = dual(3, (self, f, orElse) => transformResponse(self, Effect.filterOrElse(f, orElse)))\n\n/** @internal */\nexport const filterOrFail: {\n  <E2>(\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E2 | E, R>\n  <E, R, E2>(\n    self: Client.HttpClient.With<E, R>,\n    predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>,\n    orFailWith: (response: ClientResponse.HttpClientResponse) => E2\n  ): Client.HttpClient.With<E2 | E, R>\n} = dual(3, (self, f, orFailWith) => transformResponse(self, Effect.filterOrFail(f, orFailWith)))\n\n/** @internal */\nexport const mapRequest = dual<\n  (\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess, (request) => Effect.map(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const mapRequestEffect = dual<\n  <E2, R2>(\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.flatMap(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const mapRequestInput = dual<\n  (\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest\n  ) => Client.HttpClient.With<E, R>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess, (request) => client.preprocess(f(request)))\n})\n\n/** @internal */\nexport const mapRequestInputEffect = dual<\n  <E2, R2>(\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (\n      a: ClientRequest.HttpClientRequest\n    ) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.flatMap(f(request), client.preprocess))\n})\n\n/** @internal */\nexport const retry: {\n  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    options: O\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.Retry.Return<R, E, O>\n  <B, E, R1>(\n    policy: Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R1 | R>\n  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(\n    self: Client.HttpClient.With<E, R>,\n    options: O\n  ): Client.Retry.Return<R, E, O>\n  <E, R, B, R1>(\n    self: Client.HttpClient.With<E, R>,\n    policy: Schedule.Schedule<B, E, R1>\n  ): Client.HttpClient.With<E, R1 | R>\n} = dual(\n  2,\n  <E extends E0, E0, R, R1, B>(\n    self: Client.HttpClient.With<E, R>,\n    policy: Schedule.Schedule<B, E0, R1>\n  ): Client.HttpClient.With<E, R | R1> => transformResponse(self, Effect.retry(policy))\n)\n\n/** @internal */\nexport const retryTransient: {\n  <B, E, R1 = never>(\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R1 | R>\n  <E, R, B, R1 = never>(\n    self: Client.HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): Client.HttpClient.With<E, R1 | R>\n} = dual(\n  2,\n  <E extends E0, E0, R, B, R1 = never>(\n    self: Client.HttpClient.With<E, R>,\n    options: {\n      readonly while?: Predicate.Predicate<NoInfer<E>>\n      readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>\n      readonly times?: number\n    } | Schedule.Schedule<B, NoInfer<E>, R1>\n  ): Client.HttpClient.With<E, R | R1> =>\n    transformResponse(\n      self,\n      Effect.retry({\n        while: Schedule.ScheduleTypeId in options || options.while === undefined\n          ? isTransientError\n          : Predicate.or(isTransientError, options.while),\n        schedule: Schedule.ScheduleTypeId in options ? options : options.schedule,\n        times: Schedule.ScheduleTypeId in options ? undefined : options.times\n      })\n    )\n)\n\nconst isTransientError = (error: unknown) =>\n  Predicate.hasProperty(error, Cause.TimeoutExceptionTypeId) || isTransientHttpError(error)\n\nconst isTransientHttpError = (error: unknown) =>\n  Error.isHttpClientError(error) &&\n  ((error._tag === \"RequestError\" && error.reason === \"Transport\") ||\n    (error._tag === \"ResponseError\" && error.response.status >= 429))\n\n/** @internal */\nexport const tap = dual<\n  <_, E2, R2>(\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => transformResponse(self, Effect.tap(f)))\n\n/** @internal */\nexport const tapError = dual<\n  <_, E, E2, R2>(\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ) => <R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => transformResponse(self, Effect.tapError(f)))\n\n/** @internal */\nexport const tapRequest = dual<\n  <_, E2, R2>(\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ) => <E, R>(\n    self: Client.HttpClient.With<E, R>\n  ) => Client.HttpClient.With<E | E2, R | R2>,\n  <E, R, _, E2, R2>(\n    self: Client.HttpClient.With<E, R>,\n    f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>\n  ) => Client.HttpClient.With<E | E2, R | R2>\n>(2, (self, f) => {\n  const client = self as HttpClientImpl<any, any>\n  return makeWith(client.postprocess as any, (request) => Effect.tap(client.preprocess(request), f))\n})\n\n/** @internal */\nexport const withCookiesRef = dual<\n  (\n    ref: Ref.Ref<Cookies.Cookies>\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    ref: Ref.Ref<Cookies.Cookies>\n  ) => Client.HttpClient.With<E, R>\n>(\n  2,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    ref: Ref.Ref<Cookies.Cookies>\n  ): Client.HttpClient.With<E, R> => {\n    const client = self as HttpClientImpl<E, R>\n    return makeWith(\n      (request: Effect.Effect<ClientRequest.HttpClientRequest, E, R>) =>\n        Effect.tap(\n          client.postprocess(request),\n          (response) => Ref.update(ref, (cookies) => Cookies.merge(cookies, response.cookies))\n        ),\n      (request) =>\n        Effect.flatMap(client.preprocess(request), (request) =>\n          Effect.map(\n            Ref.get(ref),\n            (cookies) =>\n              Cookies.isEmpty(cookies)\n                ? request\n                : internalRequest.setHeader(request, \"cookie\", Cookies.toCookieHeader(cookies))\n          ))\n    )\n  }\n)\n\n/** @internal */\nexport const followRedirects = dual<\n  (\n    maxRedirects?: number | undefined\n  ) => <E, R>(self: Client.HttpClient.With<E, R>) => Client.HttpClient.With<E, R>,\n  <E, R>(\n    self: Client.HttpClient.With<E, R>,\n    maxRedirects?: number | undefined\n  ) => Client.HttpClient.With<E, R>\n>((args) => isClient(args[0]), <E, R>(\n  self: Client.HttpClient.With<E, R>,\n  maxRedirects?: number | undefined\n): Client.HttpClient.With<E, R> => {\n  const client = self as HttpClientImpl<E, R>\n  return makeWith(\n    (request) => {\n      const loop = (\n        request: ClientRequest.HttpClientRequest,\n        redirects: number\n      ): Effect.Effect<ClientResponse.HttpClientResponse, E, R> =>\n        Effect.flatMap(\n          client.postprocess(Effect.succeed(request)),\n          (response) =>\n            response.status >= 300 && response.status < 400 && response.headers.location &&\n              redirects < (maxRedirects ?? 10)\n              ? loop(\n                internalRequest.setUrl(\n                  request,\n                  new URL(response.headers.location, response.request.url)\n                ),\n                redirects + 1\n              )\n              : Effect.succeed(response)\n        )\n      return Effect.flatMap(request, (request) => loop(request, 0))\n    },\n    client.preprocess\n  )\n})\n\n/** @internal */\nexport const layerMergedContext = <E, R>(\n  effect: Effect.Effect<Client.HttpClient, E, R>\n): Layer.Layer<Client.HttpClient, E, R> =>\n  Layer.effect(\n    tag,\n    Effect.flatMap(Effect.context<never>(), (context) =>\n      Effect.map(effect, (client) =>\n        transformResponse(\n          client,\n          Effect.mapInputContext((input: Context.Context<never>) => Context.merge(context, input))\n        )))\n  )\n", "/**\n * @since 1.0.0\n */\nimport type * as Effect from \"effect/Effect\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as Option from \"effect/Option\"\nimport type { Pipeable } from \"effect/Pipeable\"\nimport type { Redacted } from \"effect/Redacted\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Stream from \"effect/Stream\"\nimport type * as PlatformError from \"./Error.js\"\nimport type * as FileSystem from \"./FileSystem.js\"\nimport type * as Headers from \"./Headers.js\"\nimport type * as Body from \"./HttpBody.js\"\nimport type { HttpMethod } from \"./HttpMethod.js\"\nimport * as internal from \"./internal/httpClientRequest.js\"\nimport type * as UrlParams from \"./UrlParams.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpClientRequest\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpClientRequest extends Inspectable, Pipeable {\n  readonly [TypeId]: TypeId\n  readonly method: HttpMethod\n  readonly url: string\n  readonly urlParams: UrlParams.UrlParams\n  readonly hash: Option.Option<string>\n  readonly headers: Headers.Headers\n  readonly body: Body.HttpBody\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Options {\n  readonly method?: HttpMethod | undefined\n  readonly url?: string | URL | undefined\n  readonly urlParams?: UrlParams.Input | undefined\n  readonly hash?: string | undefined\n  readonly headers?: Headers.Input | undefined\n  readonly body?: Body.HttpBody | undefined\n  readonly accept?: string | undefined\n  readonly acceptJson?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Options {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface NoBody extends Omit<Options, \"method\" | \"url\" | \"body\"> {}\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface NoUrl extends Omit<Options, \"method\" | \"url\"> {}\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: <M extends HttpMethod>(\n  method: M\n) => (\n  url: string | URL,\n  options?: (M extends \"GET\" | \"HEAD\" ? Options.NoBody : Options.NoUrl) | undefined\n) => HttpClientRequest = internal.make\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const get: (url: string | URL, options?: Options.NoBody) => HttpClientRequest = internal.get\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const post: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.post\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const patch: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.patch\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const put: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.put\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const del: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.del\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const head: (url: string | URL, options?: Options.NoBody) => HttpClientRequest = internal.head\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const options: (url: string | URL, options?: Options.NoUrl) => HttpClientRequest = internal.options\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const modify: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (options: Options): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, options: Options): HttpClientRequest\n} = internal.modify\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setMethod: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (method: HttpMethod): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, method: HttpMethod): HttpClientRequest\n} = internal.setMethod\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeader: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.setHeader\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHeaders: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: Headers.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: Headers.Input): HttpClientRequest\n} = internal.setHeaders\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const basicAuth: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (username: string | Redacted, password: string | Redacted): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   username: string | Redacted,\n   password: string | Redacted\n  ): HttpClientRequest\n} = internal.basicAuth\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bearerToken: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (token: string | Redacted): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, token: string | Redacted): HttpClientRequest\n} = internal.bearerToken\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const accept: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (mediaType: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, mediaType: string): HttpClientRequest\n} = internal.accept\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const acceptJson: (self: HttpClientRequest) => HttpClientRequest = internal.acceptJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (url: string | URL): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, url: string | URL): HttpClientRequest\n} = internal.setUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const prependUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (path: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, path: string): HttpClientRequest\n} = internal.prependUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (path: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, path: string): HttpClientRequest\n} = internal.appendUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const updateUrl: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (f: (url: string) => string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, f: (url: string) => string): HttpClientRequest\n} = internal.updateUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrlParam: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.setUrlParam\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.setUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrlParam: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (key: string, value: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, key: string, value: string): HttpClientRequest\n} = internal.appendUrlParam\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const appendUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.appendUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setHash: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (hash: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, hash: string): HttpClientRequest\n} = internal.setHash\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const removeHash: (self: HttpClientRequest) => HttpClientRequest = internal.removeHash\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const toUrl: (self: HttpClientRequest) => Option.Option<URL> = internal.toUrl\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const setBody: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: Body.HttpBody): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: Body.HttpBody): HttpClientRequest\n} = internal.setBody\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUint8Array: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: Uint8Array, contentType?: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: Uint8Array, contentType?: string): HttpClientRequest\n} = internal.bodyUint8Array\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyText: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: string, contentType?: string): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: string, contentType?: string): HttpClientRequest\n} = internal.bodyText\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyJson: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: unknown): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, Body.HttpBodyError>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: unknown): Effect.Effect<HttpClientRequest, Body.HttpBodyError>\n} = internal.bodyJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUnsafeJson: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: unknown): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: unknown): HttpClientRequest\n} = internal.bodyUnsafeJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const schemaBodyJson: <A, I, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  (body: A): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, Body.HttpBodyError, R>\n  (self: HttpClientRequest, body: A): Effect.Effect<HttpClientRequest, Body.HttpBodyError, R>\n} = internal.schemaBodyJson\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyUrlParams: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (input: UrlParams.Input): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, input: UrlParams.Input): HttpClientRequest\n} = internal.bodyUrlParams\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFormData: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (body: FormData): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, body: FormData): HttpClientRequest\n} = internal.bodyFormData\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFormDataRecord: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (entries: Body.FormDataInput): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, entries: Body.FormDataInput): HttpClientRequest\n} = internal.bodyFormDataRecord\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyStream: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   body: Stream.Stream<Uint8Array, unknown>,\n   options?: { readonly contentType?: string | undefined; readonly contentLength?: number | undefined } | undefined\n  ): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   body: Stream.Stream<Uint8Array, unknown>,\n   options?: { readonly contentType?: string | undefined; readonly contentLength?: number | undefined } | undefined\n  ): HttpClientRequest\n} = internal.bodyStream\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFile: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   path: string,\n   options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ): (self: HttpClientRequest) => Effect.Effect<HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (\n   self: HttpClientRequest,\n   path: string,\n   options?: FileSystem.StreamOptions & { readonly contentType?: string }\n  ): Effect.Effect<HttpClientRequest, PlatformError.PlatformError, FileSystem.FileSystem>\n} = internal.bodyFile\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const bodyFileWeb: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (file: Body.HttpBody.FileLike): (self: HttpClientRequest) => HttpClientRequest\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (self: HttpClientRequest, file: Body.HttpBody.FileLike): HttpClientRequest\n} = internal.bodyFileWeb\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as Scope from \"effect/Scope\"\nimport type { Generator } from \"./Etag.js\"\nimport type { FileSystem } from \"./FileSystem.js\"\nimport type * as App from \"./HttpApp.js\"\nimport type * as Client from \"./HttpClient.js\"\nimport type * as Middleware from \"./HttpMiddleware.js\"\nimport type { HttpPlatform } from \"./HttpPlatform.js\"\nimport type * as ServerRequest from \"./HttpServerRequest.js\"\nimport * as internal from \"./internal/httpServer.js\"\nimport type { Path } from \"./Path.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpServer {\n  readonly [TypeId]: TypeId\n  readonly serve: {\n    <E, R>(httpApp: App.Default<E, R>): Effect.Effect<\n      void,\n      never,\n      Exclude<R, ServerRequest.HttpServerRequest> | Scope.Scope\n    >\n    <E, R, App extends App.Default<any, any>>(\n      httpApp: App.Default<E, R>,\n      middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n    ): Effect.Effect<\n      void,\n      never,\n      Exclude<R, ServerRequest.HttpServerRequest> | Scope.Scope\n    >\n  }\n  readonly address: Address\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface ServeOptions {\n  readonly respond: boolean\n}\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport type Address = UnixAddress | TcpAddress\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport interface TcpAddress {\n  readonly _tag: \"TcpAddress\"\n  readonly hostname: string\n  readonly port: number\n}\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport interface UnixAddress {\n  readonly _tag: \"UnixAddress\"\n  readonly path: string\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const HttpServer: Context.Tag<HttpServer, HttpServer> = internal.serverTag\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: (\n  options: {\n    readonly serve: (\n      httpApp: App.Default<unknown>,\n      middleware?: Middleware.HttpMiddleware\n    ) => Effect.Effect<void, never, Scope.Scope>\n    readonly address: Address\n  }\n) => HttpServer = internal.make\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const serve: {\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  (): <E, R>(\n    httpApp: App.Default<E, R>\n  ) => Layer.Layer<never, never, HttpServer | Exclude<R, ServerRequest.HttpServerRequest | Scope.Scope>>\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R, App extends App.Default<any, any>>(middleware: Middleware.HttpMiddleware.Applied<App, E, R>): (\n    httpApp: App.Default<E, R>\n  ) => Layer.Layer<\n    never,\n    never,\n    HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest | Scope.Scope>\n  >\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R>(httpApp: App.Default<E, R>): Layer.Layer<never, never, HttpServer | Exclude<R, ServerRequest.HttpServerRequest | Scope.Scope>>\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R, App extends App.Default<any, any>>(\n    httpApp: App.Default<E, R>,\n    middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n  ): Layer.Layer<\n    never,\n    never,\n    HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest | Scope.Scope>\n  >\n} = internal.serve\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const serveEffect: {\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  (): <E, R>(\n    httpApp: App.Default<E, R>\n  ) => Effect.Effect<void, never, Scope.Scope | HttpServer | Exclude<R, ServerRequest.HttpServerRequest>>\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R, App extends App.Default<any, any>>(middleware: Middleware.HttpMiddleware.Applied<App, E, R>): (\n    httpApp: App.Default<E, R>\n  ) => Effect.Effect<\n    void,\n    never,\n    Scope.Scope | HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest>\n  >\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R>(httpApp: App.Default<E, R>): Effect.Effect<void, never, Scope.Scope | HttpServer | Exclude<R, ServerRequest.HttpServerRequest>>\n  /**\n   * @since 1.0.0\n   * @category accessors\n   */\n  <E, R, App extends App.Default<any, any>>(\n    httpApp: App.Default<E, R>,\n    middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n  ): Effect.Effect<\n    void,\n    never,\n    Scope.Scope | HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest>\n  >\n} = internal.serveEffect\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport const formatAddress: (address: Address) => string = internal.formatAddress\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport const addressWith: <A, E, R>(\n  effect: (address: Address) => Effect.Effect<A, E, R>\n) => Effect.Effect<A, E, HttpServer | R> = internal.addressWith\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport const addressFormattedWith: <A, E, R>(\n  effect: (address: string) => Effect.Effect<A, E, R>\n) => Effect.Effect<A, E, HttpServer | R> = internal.addressFormattedWith\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport const logAddress: Effect.Effect<void, never, HttpServer> = internal.logAddress\n\n/**\n * @since 1.0.0\n * @category address\n */\nexport const withLogAddress: <A, E, R>(layer: Layer.Layer<A, E, R>) => Layer.Layer<A, E, R | Exclude<HttpServer, A>> =\n  internal.withLogAddress\n\n/**\n * Layer producing an `HttpClient` with prepended url of the running http server.\n *\n * @since 1.0.0\n * @category layers\n */\nexport const layerTestClient: Layer.Layer<Client.HttpClient, never, Client.HttpClient | HttpServer> =\n  internal.layerTestClient\n\n/**\n * A Layer providing the `HttpPlatform`, `FileSystem`, `Etag.Generator`, and `Path`\n * services.\n *\n * The `FileSystem` service is a no-op implementation, so this layer is only\n * useful for platforms that have no file system.\n *\n * @since 1.0.0\n * @category layers\n */\nexport const layerContext: Layer.Layer<\n  | HttpPlatform\n  | FileSystem\n  | Generator\n  | Path\n> = internal.layerContext\n", "import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Stream from \"effect/Stream\"\nimport * as Etag from \"../Etag.js\"\nimport * as FileSystem from \"../FileSystem.js\"\nimport * as Headers from \"../Headers.js\"\nimport type * as Body from \"../HttpBody.js\"\nimport type * as Platform from \"../HttpPlatform.js\"\nimport type * as ServerResponse from \"../HttpServerResponse.js\"\nimport * as serverResponse from \"./httpServerResponse.js\"\n\n/** @internal */\nexport const TypeId: Platform.TypeId = Symbol.for(\"@effect/platform/HttpPlatform\") as Platform.TypeId\n\n/** @internal */\nexport const tag = Context.GenericTag<Platform.HttpPlatform>(\"@effect/platform/HttpPlatform\")\n\n/** @internal */\nexport const make = (impl: {\n  readonly fileResponse: (\n    path: string,\n    status: number,\n    statusText: string | undefined,\n    headers: Headers.Headers,\n    start: number,\n    end: number | undefined,\n    contentLength: number\n  ) => ServerResponse.HttpServerResponse\n  readonly fileWebResponse: (\n    file: Body.HttpBody.FileLike,\n    status: number,\n    statusText: string | undefined,\n    headers: Headers.Headers,\n    options?: FileSystem.StreamOptions\n  ) => ServerResponse.HttpServerResponse\n}): Effect.Effect<Platform.HttpPlatform, never, FileSystem.FileSystem | Etag.Generator> =>\n  Effect.gen(function*() {\n    const fs = yield* FileSystem.FileSystem\n    const etagGen = yield* Etag.Generator\n\n    return tag.of({\n      [TypeId]: TypeId,\n      fileResponse(path, options) {\n        return pipe(\n          Effect.bindTo(fs.stat(path), \"info\"),\n          Effect.bind(\"etag\", ({ info }) => etagGen.fromFileInfo(info)),\n          Effect.map(({ etag, info }) => {\n            const start = Number(options?.offset ?? 0)\n            const end = options?.bytesToRead !== undefined ? start + Number(options.bytesToRead) : undefined\n            const headers = Headers.set(\n              options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n              \"etag\",\n              Etag.toString(etag)\n            )\n            if (info.mtime._tag === \"Some\") {\n              ;(headers as any)[\"last-modified\"] = info.mtime.value.toUTCString()\n            }\n            const contentLength = end !== undefined ? end - start : Number(info.size) - start\n            return impl.fileResponse(\n              path,\n              options?.status ?? 200,\n              options?.statusText,\n              headers,\n              start,\n              end,\n              contentLength\n            )\n          })\n        )\n      },\n      fileWebResponse(file, options) {\n        return Effect.map(etagGen.fromFileWeb(file), (etag) => {\n          const headers = Headers.merge(\n            options?.headers ? Headers.fromInput(options.headers) : Headers.empty,\n            Headers.unsafeFromRecord({\n              etag: Etag.toString(etag),\n              \"last-modified\": new Date(file.lastModified).toUTCString()\n            })\n          )\n          return impl.fileWebResponse(\n            file,\n            options?.status ?? 200,\n            options?.statusText,\n            headers,\n            options\n          )\n        })\n      }\n    })\n  })\n\n/** @internal */\nexport const layer = Layer.effect(\n  tag,\n  Effect.flatMap(FileSystem.FileSystem, (fs) =>\n    make({\n      fileResponse(path, status, statusText, headers, start, end, contentLength) {\n        return serverResponse.stream(\n          fs.stream(path, {\n            offset: start,\n            bytesToRead: end !== undefined ? end - start : undefined\n          }),\n          { contentLength, headers, status, statusText }\n        )\n      },\n      fileWebResponse(file, status, statusText, headers, _options) {\n        return serverResponse.stream(\n          Stream.fromReadableStream(() => file.stream() as ReadableStream<Uint8Array>, identity),\n          { headers, status, statusText }\n        )\n      }\n    }))\n).pipe(\n  Layer.provide(Etag.layerWeak)\n)\n", "import * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as App from \"../HttpApp.js\"\nimport * as Client from \"../HttpClient.js\"\nimport * as ClientRequest from \"../HttpClientRequest.js\"\nimport type * as Middleware from \"../HttpMiddleware.js\"\nimport type * as Server from \"../HttpServer.js\"\nimport type * as ServerRequest from \"../HttpServerRequest.js\"\nimport * as internalEtag from \"./etag.js\"\nimport * as internalFileSystem from \"./fileSystem.js\"\nimport * as internalPlatform from \"./httpPlatform.js\"\nimport * as internalPath from \"./path.js\"\n\n/** @internal */\nexport const TypeId: Server.TypeId = Symbol.for(\"@effect/platform/HttpServer\") as Server.TypeId\n\n/** @internal */\nexport const serverTag = Context.GenericTag<Server.HttpServer>(\"@effect/platform/HttpServer\")\n\nconst serverProto = {\n  [TypeId]: TypeId\n}\n\n/** @internal */\nexport const isServer = (u: unknown): u is Server.HttpServer => typeof u === \"object\" && u !== null && TypeId in u\n\n/** @internal */\nexport const make = (\n  options: {\n    readonly serve: (\n      httpApp: App.Default<unknown>,\n      middleware?: Middleware.HttpMiddleware\n    ) => Effect.Effect<void, never, Scope.Scope>\n    readonly address: Server.Address\n  }\n): Server.HttpServer => Object.assign(Object.create(serverProto), options)\n\n/** @internal */\nexport const serve = dual<\n  {\n    (): <E, R>(\n      httpApp: App.Default<E, R>\n    ) => Layer.Layer<never, never, Server.HttpServer | Exclude<R, ServerRequest.HttpServerRequest | Scope.Scope>>\n    <E, R, App extends App.Default<any, any>>(middleware: Middleware.HttpMiddleware.Applied<App, E, R>): (\n      httpApp: App.Default<E, R>\n    ) => Layer.Layer<\n      never,\n      never,\n      Server.HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest | Scope.Scope>\n    >\n  },\n  {\n    <E, R>(\n      httpApp: App.Default<E, R>\n    ): Layer.Layer<never, never, Server.HttpServer | Exclude<R, ServerRequest.HttpServerRequest | Scope.Scope>>\n    <E, R, App extends App.Default<any, any>>(\n      httpApp: App.Default<E, R>,\n      middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n    ): Layer.Layer<\n      never,\n      never,\n      Server.HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest | Scope.Scope>\n    >\n  }\n>(\n  (args) => Effect.isEffect(args[0]),\n  <E, R, App extends App.Default<any, any>>(\n    httpApp: App.Default<E, R>,\n    middleware?: Middleware.HttpMiddleware.Applied<App, E, R>\n  ): Layer.Layer<\n    never,\n    never,\n    Server.HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest | Scope.Scope>\n  > =>\n    Layer.scopedDiscard(\n      Effect.flatMap(\n        serverTag,\n        (server) => server.serve(httpApp, middleware!)\n      )\n    ) as any\n)\n\n/** @internal */\nexport const serveEffect = dual<\n  {\n    (): <E, R>(\n      httpApp: App.Default<E, R>\n    ) => Effect.Effect<\n      void,\n      never,\n      Server.HttpServer | Scope.Scope | Exclude<R, ServerRequest.HttpServerRequest>\n    >\n    <E, R, App extends App.Default<any, any>>(middleware: Middleware.HttpMiddleware.Applied<App, E, R>): (\n      httpApp: App.Default<E, R>\n    ) => Effect.Effect<\n      void,\n      never,\n      Server.HttpServer | Scope.Scope | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest>\n    >\n  },\n  {\n    <E, R>(\n      httpApp: App.Default<E, R>\n    ): Effect.Effect<void, never, Server.HttpServer | Scope.Scope | Exclude<R, ServerRequest.HttpServerRequest>>\n    <E, R, App extends App.Default<any, any>>(\n      httpApp: App.Default<E, R>,\n      middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n    ): Effect.Effect<\n      void,\n      never,\n      Server.HttpServer | Exclude<Effect.Effect.Context<App>, ServerRequest.HttpServerRequest> | Scope.Scope\n    >\n  }\n>(\n  (args) => Effect.isEffect(args[0]),\n  (<E, R, App extends App.Default<any, any>>(\n    httpApp: App.Default<E, R>,\n    middleware: Middleware.HttpMiddleware.Applied<App, E, R>\n  ): Effect.Effect<\n    void,\n    never,\n    Server.HttpServer | Exclude<R, ServerRequest.HttpServerRequest> | Scope.Scope\n  > =>\n    Effect.flatMap(\n      serverTag,\n      (server) => server.serve(httpApp, middleware)\n    )) as any\n)\n\n/** @internal */\nexport const formatAddress = (address: Server.Address): string => {\n  switch (address._tag) {\n    case \"UnixAddress\":\n      return `unix://${address.path}`\n    case \"TcpAddress\":\n      return `http://${address.hostname}:${address.port}`\n  }\n}\n\n/** @internal */\nexport const addressWith = <A, E, R>(\n  effect: (address: Server.Address) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, Server.HttpServer | R> =>\n  Effect.flatMap(\n    serverTag,\n    (server) => effect(server.address)\n  )\n\n/** @internal */\nexport const addressFormattedWith = <A, E, R>(\n  effect: (address: string) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, Server.HttpServer | R> =>\n  Effect.flatMap(\n    serverTag,\n    (server) => effect(formatAddress(server.address))\n  )\n\n/** @internal */\nexport const logAddress: Effect.Effect<void, never, Server.HttpServer> = addressFormattedWith((_) =>\n  Effect.log(`Listening on ${_}`)\n)\n\n/** @internal */\nexport const withLogAddress = <A, E, R>(\n  layer: Layer.Layer<A, E, R>\n): Layer.Layer<A, E, R | Exclude<Server.HttpServer, A>> =>\n  Layer.effectDiscard(logAddress).pipe(\n    Layer.provideMerge(layer)\n  )\n\n/** @internal */\nexport const makeTestClient = addressWith((address) =>\n  Effect.flatMap(Client.HttpClient, (client) => {\n    if (address._tag === \"UnixAddress\") {\n      return Effect.die(new Error(\"HttpServer.layerTestClient: UnixAddress not supported\"))\n    }\n    const host = address.hostname === \"0.0.0.0\" ? \"127.0.0.1\" : address.hostname\n    const url = `http://${host}:${address.port}`\n    return Effect.succeed(Client.mapRequest(client, ClientRequest.prependUrl(url)))\n  })\n)\n\n/** @internal */\nexport const layerTestClient = Layer.effect(Client.HttpClient, makeTestClient)\n\n/** @internal */\nexport const layerContext = Layer.mergeAll(\n  internalPlatform.layer,\n  internalPath.layer,\n  internalEtag.layerWeak\n).pipe(\n  Layer.provideMerge(internalFileSystem.layerNoop({}))\n)\n", "/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport type * as Chunk from \"effect/Chunk\"\nimport type * as Context from \"effect/Context\"\nimport type * as Effect from \"effect/Effect\"\nimport type { FiberRef } from \"effect/FiberRef\"\nimport type { Inspectable } from \"effect/Inspectable\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as Option from \"effect/Option\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport type * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport type * as Scope from \"effect/Scope\"\nimport type { RouterConfig } from \"find-my-way-ts\"\nimport type * as Etag from \"./Etag.js\"\nimport type { FileSystem } from \"./FileSystem.js\"\nimport type * as App from \"./HttpApp.js\"\nimport type * as Method from \"./HttpMethod.js\"\nimport type * as Middleware from \"./HttpMiddleware.js\"\nimport type * as Platform from \"./HttpPlatform.js\"\nimport type * as HttpServer from \"./HttpServer.js\"\nimport type * as Error from \"./HttpServerError.js\"\nimport type * as ServerRequest from \"./HttpServerRequest.js\"\nimport type * as Respondable from \"./HttpServerRespondable.js\"\nimport type * as ServerResponse from \"./HttpServerResponse.js\"\nimport * as internal from \"./internal/httpRouter.js\"\nimport type { Path } from \"./Path.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface HttpRouter<E = never, R = never>\n  extends App.Default<E | Error.RouteNotFound, Exclude<R, RouteContext>>, Inspectable\n{\n  readonly [TypeId]: TypeId\n  readonly routes: Chunk.Chunk<Route<E, R>>\n  readonly mounts: Chunk.Chunk<\n    readonly [\n      prefix: string,\n      httpApp: App.Default<E, R>,\n      options?: { readonly includePrefix?: boolean | undefined } | undefined\n    ]\n  >\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace HttpRouter {\n  /**\n   * @since 1.0.0\n   */\n  export type Provided = RouteContext | ServerRequest.HttpServerRequest | ServerRequest.ParsedSearchParams | Scope.Scope\n\n  /**\n   * @since 1.0.0\n   */\n  export type ExcludeProvided<A> = Exclude<A, Provided>\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Service<E, R> {\n    readonly router: Effect.Effect<HttpRouter<E, R>>\n    readonly addRoute: (route: Route<E, R>) => Effect.Effect<void>\n    readonly all: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly get: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly post: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly put: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly patch: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly del: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly head: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly options: (\n      path: PathInput,\n      handler: Route.Handler<E, R | Provided>,\n      options?: { readonly uninterruptible?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly mount: (\n      path: `/${string}`,\n      router: HttpRouter<E, R>\n    ) => Effect.Effect<void>\n    readonly mountApp: (\n      path: `/${string}`,\n      router: App.Default<E, R>,\n      options?: { readonly includePrefix?: boolean | undefined } | undefined\n    ) => Effect.Effect<void>\n    readonly concat: (router: HttpRouter<E, R>) => Effect.Effect<void>\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type DefaultServices = Platform.HttpPlatform | Etag.Generator | FileSystem | Path\n\n  /**\n   * @since 1.0.0\n   */\n  export interface TagClass<Self, Name extends string, E, R> extends Context.Tag<Self, Service<E, R>> {\n    new(_: never): Context.TagClassShape<Name, Service<E, R>>\n    readonly Live: Layer.Layer<Self>\n    readonly router: Effect.Effect<HttpRouter<E, R>, never, Self>\n    readonly use: <XA, XE, XR>(\n      f: (router: Service<E, R>) => Effect.Effect<XA, XE, XR>\n    ) => Layer.Layer<never, XE, Exclude<XR, Scope.Scope>>\n    readonly unwrap: <XA, XE, XR>(f: (router: HttpRouter<E, R>) => Layer.Layer<XA, XE, XR>) => Layer.Layer<XA, XE, XR>\n    readonly serve: <E = never, R = never>(\n      middleware?: Middleware.HttpMiddleware.Applied<App.Default, E, R>\n    ) => Layer.Layer<\n      never,\n      never,\n      HttpServer.HttpServer | Exclude<R, ServerRequest.HttpServerRequest | Scope.Scope>\n    >\n  }\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const RouteTypeId: unique symbol = internal.RouteTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type RouteTypeId = typeof RouteTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PathInput = `/${string}` | \"*\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Route<E = never, R = never> extends Inspectable {\n  readonly [RouteTypeId]: RouteTypeId\n  readonly method: Method.HttpMethod | \"*\"\n  readonly path: PathInput\n  readonly handler: Route.Handler<E, R>\n  readonly prefix: Option.Option<string>\n  readonly uninterruptible: boolean\n}\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Route {\n  /**\n   * @since 1.0.0\n   */\n  export type Handler<E, R> = App.HttpApp<\n    Respondable.Respondable,\n    E,\n    R | RouteContext | ServerRequest.ParsedSearchParams\n  >\n\n  /**\n   * @since 1.0.0\n   */\n  export type Middleware<E, R> = App.HttpApp<\n    ServerResponse.HttpServerResponse,\n    E,\n    R | RouteContext | ServerRequest.ParsedSearchParams\n  >\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const RouteContextTypeId: unique symbol = internal.RouteContextTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type RouteContextTypeId = typeof RouteContextTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RouteContext {\n  readonly [RouteContextTypeId]: RouteContextTypeId\n  readonly params: Readonly<Record<string, string | undefined>>\n  readonly route: Route<unknown, unknown>\n}\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const RouteContext: Context.Tag<RouteContext, RouteContext> = internal.RouteContext\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const params: Effect.Effect<\n  Readonly<Record<string, string | undefined>>,\n  never,\n  RouteContext\n> = internal.params\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const schemaJson: <\n  R,\n  I extends Partial<{\n    readonly method: Method.HttpMethod\n    readonly url: string\n    readonly cookies: Readonly<Record<string, string | undefined>>\n    readonly headers: Readonly<Record<string, string | undefined>>\n    readonly pathParams: Readonly<Record<string, string | undefined>>\n    readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>\n    readonly body: any\n  }>,\n  A\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<\n  A,\n  Error.RequestError | ParseResult.ParseError,\n  RouteContext | R | ServerRequest.HttpServerRequest | ServerRequest.ParsedSearchParams\n> = internal.schemaJson\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const schemaNoBody: <\n  R,\n  I extends Partial<\n    {\n      readonly method: Method.HttpMethod\n      readonly url: string\n      readonly cookies: Readonly<Record<string, string | undefined>>\n      readonly headers: Readonly<Record<string, string | undefined>>\n      readonly pathParams: Readonly<Record<string, string | undefined>>\n      readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>\n    }\n  >,\n  A\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<\n  A,\n  ParseResult.ParseError,\n  R | RouteContext | ServerRequest.HttpServerRequest | ServerRequest.ParsedSearchParams\n> = internal.schemaNoBody\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const schemaParams: <A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError, R | RouteContext | ServerRequest.ParsedSearchParams> =\n  internal.schemaParams\n\n/**\n * @since 1.0.0\n * @category route context\n */\nexport const schemaPathParams: <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => Effect.Effect<A, ParseResult.ParseError, R | RouteContext> = internal.schemaPathParams\n\n/**\n * @since 1.0.0\n * @category router config\n */\nexport const currentRouterConfig: FiberRef<Partial<RouterConfig>> = internal.currentRouterConfig\n\n/**\n * @since 1.0.0\n * @category router config\n */\nexport const withRouterConfig: {\n  /**\n   * @since 1.0.0\n   * @category router config\n   */\n  (config: Partial<RouterConfig>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category router config\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, config: Partial<RouterConfig>): Effect.Effect<A, E, R>\n} = internal.withRouterConfig\n\n/**\n * @since 1.0.0\n * @category router config\n */\nexport const setRouterConfig: (config: Partial<RouterConfig>) => Layer.Layer<never> = internal.setRouterConfig\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const empty: HttpRouter = internal.empty\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromIterable: <R extends Route<any, any>>(\n  routes: Iterable<R>\n) => HttpRouter<R extends Route<infer E, infer _> ? E : never, R extends Route<infer _, infer Env> ? Env : never> =\n  internal.fromIterable\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeRoute: <E, R>(\n  method: Method.HttpMethod | \"*\",\n  path: PathInput,\n  handler: Route.Handler<E, R>,\n  options?: { readonly prefix?: string | undefined; readonly uninterruptible?: boolean | undefined } | undefined\n) => Route<E, HttpRouter.ExcludeProvided<R>> = internal.makeRoute\n\n/**\n * @since 1.0.0\n * @category utils\n */\nexport const prefixPath: {\n  /**\n   * @since 1.0.0\n   * @category utils\n   */\n  (prefix: string): (self: string) => string\n  /**\n   * @since 1.0.0\n   * @category utils\n   */\n  (self: string, prefix: string): string\n} = internal.prefixPath\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const prefixAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  (prefix: PathInput): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E, R>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R>(self: HttpRouter<E, R>, prefix: PathInput): HttpRouter<E, R>\n} = internal.prefixAll\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const append: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R1, E1>(route: Route<E1, R1>): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<\n    E1 | E,\n    R | HttpRouter.ExcludeProvided<R1>\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, E1, R1>(self: HttpRouter<E, R>, route: Route<E1, R1>): HttpRouter<\n    E | E1,\n    R | HttpRouter.ExcludeProvided<R1>\n  >\n} = internal.append\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const concat: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R1, E1>(that: HttpRouter<E1, R1>): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R1 | R>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, R1, E1>(self: HttpRouter<E, R>, that: HttpRouter<E1, R1>): HttpRouter<\n    E | E1,\n    R | R1\n  >\n} = internal.concat\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const concatAll: <Routers extends ReadonlyArray<HttpRouter<unknown, unknown>>>(\n  ...routers: Routers\n) => [Routers[number]] extends [HttpRouter<infer E, infer R>] ? HttpRouter<E, R> : never = internal.concatAll\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const mount: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(path: `/${string}`, that: HttpRouter<E1, R1>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E1 | E, R1 | R>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(self: HttpRouter<E, R>, path: `/${string}`, that: HttpRouter<E1, R1>): HttpRouter<E | E1, R | R1>\n} = internal.mount\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const mountApp: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: `/${string}`,\n    that: App.Default<E1, R1>,\n    options?: { readonly includePrefix?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<\n    E1 | E,\n    | HttpRouter.ExcludeProvided<R1>\n    | HttpRouter.ExcludeProvided<R>\n  >\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: `/${string}`,\n    that: App.Default<E1, R1>,\n    options?: { readonly includePrefix?: boolean | undefined } | undefined\n  ): HttpRouter<\n    E | E1,\n    | HttpRouter.ExcludeProvided<R>\n    | HttpRouter.ExcludeProvided<R1>\n  >\n} = internal.mountApp\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const route: (\n  method: Method.HttpMethod | \"*\"\n) => {\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | Exclude<R1, ServerRequest.HttpServerRequest | RouteContext | Scope.Scope>>\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | Exclude<R1, ServerRequest.HttpServerRequest | RouteContext | Scope.Scope>>\n} = internal.route\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const all: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<\n    E1 | E,\n    R | HttpRouter.ExcludeProvided<R1>\n  >\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<\n    E | E1,\n    R | HttpRouter.ExcludeProvided<R1>\n  >\n} = internal.all\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const get: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.get\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const post: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.post\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const patch: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.patch\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const put: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.put\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const del: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.del\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const head: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.head\n\n/**\n * @since 1.0.0\n * @category routing\n */\nexport const options: {\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <R1, E1>(\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | E, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category routing\n   */\n  <E, R, E1, R1>(\n    self: HttpRouter<E, R>,\n    path: PathInput,\n    handler: Route.Handler<E1, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): HttpRouter<E | E1, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.options\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const use: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, R1, E1>(f: (self: Route.Middleware<E, R>) => App.Default<E1, R1>): (self: HttpRouter<E, R>) => HttpRouter<E1, HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, R1, E1>(\n    self: HttpRouter<E, R>,\n    f: (self: Route.Middleware<E, R>) => App.Default<E1, R1>\n  ): HttpRouter<E1, HttpRouter.ExcludeProvided<R1>>\n} = internal.use\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const transform: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, R1, E1>(\n    f: (self: Route.Handler<E, R>) => App.HttpApp<Respondable.Respondable, E1, R1>\n  ): (self: HttpRouter<E, R>) => HttpRouter<E1, HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, R1, E1>(\n    self: HttpRouter<E, R>,\n    f: (self: Route.Handler<E, R>) => App.HttpApp<Respondable.Respondable, E1, R1>\n  ): HttpRouter<E1, HttpRouter.ExcludeProvided<R1>>\n} = internal.transform\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const catchAll: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, E2, R2>(f: (e: E) => Route.Handler<E2, R2>): <R>(self: HttpRouter<E, R>) => HttpRouter<E2, R | HttpRouter.ExcludeProvided<R2>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, E2, R2>(self: HttpRouter<E, R>, f: (e: E) => Route.Handler<E2, R2>): HttpRouter<E2, R | HttpRouter.ExcludeProvided<R2>>\n} = internal.catchAll\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const catchAllCause: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, E2, R2>(f: (e: Cause.Cause<E>) => Route.Handler<E2, R2>): <R>(self: HttpRouter<E, R>) => HttpRouter<E2, R | HttpRouter.ExcludeProvided<R2>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, E2, R2>(self: HttpRouter<E, R>, f: (e: Cause.Cause<E>) => Route.Handler<E2, R2>): HttpRouter<E2, R | HttpRouter.ExcludeProvided<R2>>\n} = internal.catchAllCause\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const catchTag: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <K extends E extends { _tag: string } ? E[\"_tag\"] : never, E, E1, R1>(k: K, f: (e: Extract<E, { _tag: K }>) => Route.Handler<E1, R1>): <R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<E1 | Exclude<E, { _tag: K }>, R | HttpRouter.ExcludeProvided<R1>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, K extends E extends { _tag: string } ? E[\"_tag\"] : never, E1, R1>(\n    self: HttpRouter<E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Route.Handler<E1, R1>\n  ): HttpRouter<E1 | Exclude<E, { _tag: K }>, R | HttpRouter.ExcludeProvided<R1>>\n} = internal.catchTag\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const catchTags: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <\n    E,\n    Cases extends E extends { _tag: string }\n      ? { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => Route.Handler<any, any>) | undefined }\n      : {}\n  >(cases: Cases): <R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | HttpRouter.ExcludeProvided<\n      {\n        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n      }[keyof Cases]\n    >\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <\n    R,\n    E,\n    Cases extends E extends { _tag: string }\n      ? { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => Route.Handler<any, any>) | undefined } :\n      {}\n  >(self: HttpRouter<E, R>, cases: Cases): HttpRouter<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, infer E, any> ? E : never\n    }[keyof Cases],\n    | R\n    | HttpRouter.ExcludeProvided<\n      {\n        [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect.Effect<any, any, infer R> ? R : never\n      }[keyof Cases]\n    >\n  >\n} = internal.catchTags\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const provideService: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <T extends Context.Tag<any, any>>(tag: T, service: Context.Tag.Service<T>): <E, R>(self: HttpRouter<E, R>) => HttpRouter<E, Exclude<R, Context.Tag.Identifier<T>>>\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, T extends Context.Tag<any, any>>(self: HttpRouter<E, R>, tag: T, service: Context.Tag.Service<T>): HttpRouter<E, Exclude<R, Context.Tag.Identifier<T>>>\n} = internal.provideService\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const provideServiceEffect: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <T extends Context.Tag<any, any>, R1, E1>(tag: T, effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>): <E, R>(\n    self: HttpRouter<E, R>\n  ) => HttpRouter<\n    E1 | E,\n    | Exclude<R, Context.Tag.Identifier<T>>\n    | Exclude<HttpRouter.ExcludeProvided<R1>, Context.Tag.Identifier<T>>\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <E, R, T extends Context.Tag<any, any>, R1, E1>(\n    self: HttpRouter<E, R>,\n    tag: T,\n    effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n  ): HttpRouter<\n    E | E1,\n    | Exclude<R, Context.Tag.Identifier<T>>\n    | Exclude<HttpRouter.ExcludeProvided<R1>, Context.Tag.Identifier<T>>\n  >\n} = internal.provideServiceEffect\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Tag: <const Name extends string>(\n  id: Name\n) => <Self, R = never, E = unknown>() => HttpRouter.TagClass<Self, Name, E, R | HttpRouter.DefaultServices> =\n  internal.Tag\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class Default extends Tag(\"@effect/platform/HttpRouter/Default\")<Default>() {}\n", "/**\n * @since 1.0.0\n */\nimport * as internal from \"./internal/router.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RouterConfig {\n  readonly ignoreTrailingSlash: boolean\n  readonly ignoreDuplicateSlashes: boolean\n  readonly caseSensitive: boolean\n  readonly maxParamLength: number\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PathInput = `/${string}` | \"*\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Router<A> {\n  readonly on: (\n    method: string | Iterable<string>,\n    path: PathInput,\n    handler: A,\n  ) => void\n  readonly all: (path: PathInput, handler: A) => void\n  readonly find: (method: string, url: string) => FindResult<A> | undefined\n  readonly has: (method: string, url: string) => boolean\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface FindResult<A> {\n  readonly handler: A\n  readonly params: Record<string, string | undefined>\n  readonly searchParams: Record<string, string | Array<string>>\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: <A>(options?: Partial<RouterConfig>) => Router<A> =\n  internal.make\n", "/**\n * @since 1.0.0\n */\n// Taken from https://github.com/anonrig/fast-querystring under MIT License\nconst plusRegex = /\\+/g\nconst Empty: new () => Record<string, any> = function () {} as any\nEmpty.prototype = Object.create(null)\n\n/**\n * @category parsing\n * @since 1.0.0\n */\nexport function parse(input: string) {\n  // Optimization: Use new Empty() instead of Object.create(null) for performance\n  // v8 has a better optimization for initializing functions compared to Object\n  const result = new Empty()\n\n  if (typeof input !== \"string\") {\n    return result\n  }\n\n  const inputLength = input.length\n  let key = \"\"\n  let value = \"\"\n  let startingIndex = -1\n  let equalityIndex = -1\n  let shouldDecodeKey = false\n  let shouldDecodeValue = false\n  let keyHasPlus = false\n  let valueHasPlus = false\n  let hasBothKeyValuePair = false\n  let c = 0\n\n  // Have a boundary of input.length + 1 to access last pair inside the loop.\n  for (let i = 0; i < inputLength + 1; i++) {\n    c = i !== inputLength ? input.charCodeAt(i) : 38\n\n    // Handle '&' and end of line to pass the current values to result\n    if (c === 38) {\n      hasBothKeyValuePair = equalityIndex > startingIndex\n\n      // Optimization: Reuse equality index to store the end of key\n      if (!hasBothKeyValuePair) {\n        equalityIndex = i\n      }\n\n      key = input.slice(startingIndex + 1, equalityIndex)\n\n      // Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n      if (hasBothKeyValuePair || key.length > 0) {\n        // Optimization: Replace '+' with space\n        if (keyHasPlus) {\n          key = key.replace(plusRegex, \" \")\n        }\n\n        // Optimization: Do not decode if it's not necessary.\n        if (shouldDecodeKey) {\n          try {\n            key = decodeURIComponent(key) || key\n          } catch {}\n        }\n\n        if (hasBothKeyValuePair) {\n          value = input.slice(equalityIndex + 1, i)\n\n          if (valueHasPlus) {\n            value = value.replace(plusRegex, \" \")\n          }\n\n          if (shouldDecodeValue) {\n            try {\n              value = decodeURIComponent(value) || value\n            } catch {}\n          }\n        }\n        const currentValue = result[key]\n\n        if (currentValue === undefined) {\n          result[key] = value\n        } else {\n          // Optimization: value.pop is faster than Array.isArray(value)\n          if (currentValue.pop) {\n            currentValue.push(value)\n          } else {\n            result[key] = [currentValue, value]\n          }\n        }\n      }\n\n      // Reset reading key value pairs\n      value = \"\"\n      startingIndex = i\n      equalityIndex = i\n      shouldDecodeKey = false\n      shouldDecodeValue = false\n      keyHasPlus = false\n      valueHasPlus = false\n    }\n    // Check '='\n    else if (c === 61) {\n      if (equalityIndex <= startingIndex) {\n        equalityIndex = i\n      }\n      // If '=' character occurs again, we should decode the input.\n      else {\n        shouldDecodeValue = true\n      }\n    }\n    // Check '+', and remember to replace it with empty space.\n    else if (c === 43) {\n      if (equalityIndex > startingIndex) {\n        valueHasPlus = true\n      } else {\n        keyHasPlus = true\n      }\n    }\n    // Check '%' character for encoding\n    else if (c === 37) {\n      if (equalityIndex > startingIndex) {\n        shouldDecodeValue = true\n      } else {\n        shouldDecodeKey = true\n      }\n    }\n  }\n\n  return result\n}\n\nfunction getAsPrimitive(value: any) {\n  const type = typeof value\n\n  if (type === \"string\") {\n    // Length check is handled inside encodeString function\n    return encodeString(value)\n  } else if (type === \"bigint\" || type === \"boolean\") {\n    return \"\" + value\n  } else if (type === \"number\" && Number.isFinite(value)) {\n    return value < 1e21 ? \"\" + value : encodeString(\"\" + value)\n  }\n\n  return \"\"\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport function stringify(input: Record<string, any>): string {\n  let result = \"\"\n\n  if (input === null || typeof input !== \"object\") {\n    return result\n  }\n\n  const separator = \"&\"\n  const keys = Object.keys(input)\n  const keyLength = keys.length\n  let valueLength = 0\n\n  for (let i = 0; i < keyLength; i++) {\n    const key = keys[i]\n    const value = input[key]\n    const encodedKey = encodeString(key) + \"=\"\n\n    if (i) {\n      result += separator\n    }\n\n    if (Array.isArray(value)) {\n      valueLength = value.length\n      for (let j = 0; j < valueLength; j++) {\n        if (j) {\n          result += separator\n        }\n\n        // Optimization: Dividing into multiple lines improves the performance.\n        // Since v8 does not need to care about the '+' character if it was one-liner.\n        result += encodedKey\n        result += getAsPrimitive(value[j])\n      }\n    } else {\n      result += encodedKey\n      result += getAsPrimitive(value)\n    }\n  }\n\n  return result\n}\n\n// -----------------------------------------------------------------------------\n\n// This has been taken from Node.js project.\n// Full implementation can be found from https://github.com/nodejs/node/blob/main/lib/internal/querystring.js\n\nconst hexTable = Array.from(\n  { length: 256 },\n  (_, i) => \"%\" + ((i < 16 ? \"0\" : \"\") + i.toString(16)).toUpperCase(),\n)\n\n// These characters do not need escaping when generating query strings:\n// ! - . _ ~\n// ' ( ) *\n// digits\n// alpha (uppercase)\n// alpha (lowercase)\n// biome-ignore format: the array should not be formatted\nconst noEscape = new Int8Array([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0, // 0 - 15\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0, // 16 - 31\n  0,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  1,\n  1,\n  0, // 32 - 47\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0, // 48 - 63\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1, // 64 - 79\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  0,\n  1, // 80 - 95\n  0,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1, // 96 - 111\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  1,\n  0,\n  0,\n  0,\n  1,\n  0, // 112 - 127\n])\n\nfunction encodeString(str: string) {\n  const len = str.length\n  if (len === 0) return \"\"\n\n  let out = \"\"\n  let lastPos = 0\n  let i = 0\n\n  outer: for (; i < len; i++) {\n    let c = str.charCodeAt(i)\n\n    // ASCII\n    while (c < 0x80) {\n      if (noEscape[c] !== 1) {\n        if (lastPos < i) out += str.slice(lastPos, i)\n        lastPos = i + 1\n        out += hexTable[c]\n      }\n\n      if (++i === len) break outer\n\n      c = str.charCodeAt(i)\n    }\n\n    if (lastPos < i) out += str.slice(lastPos, i)\n\n    // Multi-byte characters ...\n    if (c < 0x800) {\n      lastPos = i + 1\n      out += hexTable[0xc0 | (c >> 6)] + hexTable[0x80 | (c & 0x3f)]\n      continue\n    }\n    if (c < 0xd800 || c >= 0xe000) {\n      lastPos = i + 1\n      out +=\n        hexTable[0xe0 | (c >> 12)] +\n        hexTable[0x80 | ((c >> 6) & 0x3f)] +\n        hexTable[0x80 | (c & 0x3f)]\n      continue\n    }\n    // Surrogate pair\n    ++i\n\n    // This branch should never happen because all URLSearchParams entries\n    // should already be converted to USVString. But, included for\n    // completion's sake anyway.\n    if (i >= len) {\n      throw new Error(\"URI malformed\")\n    }\n\n    const c2 = str.charCodeAt(i) & 0x3ff\n\n    lastPos = i + 1\n    c = 0x10000 + (((c & 0x3ff) << 10) | c2)\n    out +=\n      hexTable[0xf0 | (c >> 18)] +\n      hexTable[0x80 | ((c >> 12) & 0x3f)] +\n      hexTable[0x80 | ((c >> 6) & 0x3f)] +\n      hexTable[0x80 | (c & 0x3f)]\n  }\n  if (lastPos === 0) return str\n  if (lastPos < len) return out + str.slice(lastPos)\n  return out\n}\n", "import * as Router from \"../index.js\"\nimport * as QS from \"../QueryString.js\"\n\nconst FULL_PATH_REGEXP = /^https?:\\/\\/.*?\\//\nconst OPTIONAL_PARAM_REGEXP = /(\\/:[^/()]*?)\\?(\\/?)/\n\ninterface Route<A = unknown> {\n  readonly method: string\n  readonly path: Router.PathInput\n  readonly pattern: string\n  readonly handler: A\n  readonly params: ReadonlyArray<string>\n}\n\n/** @internal */\nexport const make = <A>(\n  options: Partial<Router.RouterConfig> = {},\n): Router.Router<A> => new RouterImpl(options)\n\nclass RouterImpl<A> implements Router.Router<A> {\n  constructor(options: Partial<Router.RouterConfig> = {}) {\n    this.options = {\n      ignoreTrailingSlash: true,\n      ignoreDuplicateSlashes: true,\n      caseSensitive: false,\n      maxParamLength: 100,\n      ...options,\n    }\n  }\n\n  readonly options: Router.RouterConfig\n  routes: Array<Route> = []\n  trees: Record<string, StaticNode> = {}\n\n  on(\n    method: string | Iterable<string>,\n    path: Router.PathInput,\n    handler: A,\n  ): void {\n    const optionalParamMatch = path.match(OPTIONAL_PARAM_REGEXP)\n    if (optionalParamMatch && optionalParamMatch.index !== undefined) {\n      assert(\n        path.length === optionalParamMatch.index + optionalParamMatch[0].length,\n        \"Optional Parameter needs to be the last parameter of the path\",\n      )\n\n      const pathFull = path.replace(\n        OPTIONAL_PARAM_REGEXP,\n        \"$1$2\",\n      ) as Router.PathInput\n      const pathOptional = path.replace(\n        OPTIONAL_PARAM_REGEXP,\n        \"$2\",\n      ) as Router.PathInput\n\n      this.on(method, pathFull, handler)\n      this.on(method, pathOptional, handler)\n      return\n    }\n\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path)\n    }\n\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path)\n    }\n\n    const methods = typeof method === \"string\" ? [method] : method\n    for (const method of methods) {\n      this._on(method, path, handler)\n    }\n  }\n\n  all(path: Router.PathInput, handler: A) {\n    this.on(httpMethods, path, handler)\n  }\n\n  private _on(method: string, path: Router.PathInput, handler: A): void {\n    if (this.trees[method] === undefined) {\n      this.trees[method] = new StaticNode(\"/\")\n    }\n\n    let pattern = path\n    if (pattern === \"*\" && this.trees[method].prefix.length !== 0) {\n      const currentRoot = this.trees[method]\n      this.trees[method] = new StaticNode(\"\")\n      this.trees[method].staticChildren[\"/\"] = currentRoot\n    }\n\n    let parentNodePathIndex = this.trees[method].prefix.length\n    let currentNode: Node = this.trees[method]\n\n    const params = []\n    for (let i = 0; i <= pattern.length; i++) {\n      if (pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) === 58) {\n        // It's a double colon\n        i++\n        continue\n      }\n\n      const isParametricNode =\n        pattern.charCodeAt(i) === 58 && pattern.charCodeAt(i + 1) !== 58\n      const isWildcardNode = pattern.charCodeAt(i) === 42\n\n      if (\n        isParametricNode ||\n        isWildcardNode ||\n        (i === pattern.length && i !== parentNodePathIndex)\n      ) {\n        let staticNodePath = pattern.slice(parentNodePathIndex, i)\n        if (!this.options.caseSensitive) {\n          staticNodePath = staticNodePath.toLowerCase()\n        }\n        staticNodePath = staticNodePath.split(\"::\").join(\":\")\n        staticNodePath = staticNodePath.split(\"%\").join(\"%25\")\n        // add the static part of the route to the tree\n        currentNode = (currentNode as StaticNode).createStaticChild(\n          staticNodePath,\n        )\n      }\n\n      if (isParametricNode) {\n        let isRegexNode = false\n        const regexps = []\n\n        let lastParamStartIndex = i + 1\n        for (let j = lastParamStartIndex; ; j++) {\n          const charCode = pattern.charCodeAt(j)\n\n          const isRegexParam = charCode === 40\n          const isStaticPart = charCode === 45 || charCode === 46\n          const isEndOfNode = charCode === 47 || j === pattern.length\n\n          if (isRegexParam || isStaticPart || isEndOfNode) {\n            const paramName = pattern.slice(lastParamStartIndex, j)\n            params.push(paramName)\n\n            isRegexNode = isRegexNode || isRegexParam || isStaticPart\n\n            if (isRegexParam) {\n              const endOfRegexIndex = getClosingParenthensePosition(pattern, j)\n              const regexString = pattern.slice(j, endOfRegexIndex + 1)\n\n              regexps.push(trimRegExpStartAndEnd(regexString))\n\n              j = endOfRegexIndex + 1\n            } else {\n              regexps.push(\"(.*?)\")\n            }\n\n            const staticPartStartIndex = j\n            for (; j < pattern.length; j++) {\n              const charCode = pattern.charCodeAt(j)\n              if (charCode === 47) break\n              if (charCode === 58) {\n                const nextCharCode = pattern.charCodeAt(j + 1)\n                if (nextCharCode === 58) j++\n                else break\n              }\n            }\n\n            let staticPart = pattern.slice(staticPartStartIndex, j)\n            if (staticPart) {\n              staticPart = staticPart.split(\"::\").join(\":\")\n              staticPart = staticPart.split(\"%\").join(\"%25\")\n              regexps.push(escapeRegExp(staticPart))\n            }\n\n            lastParamStartIndex = j + 1\n\n            if (\n              isEndOfNode ||\n              pattern.charCodeAt(j) === 47 ||\n              j === pattern.length\n            ) {\n              const nodePattern = isRegexNode ? \"()\" + staticPart : staticPart\n              const nodePath = pattern.slice(i, j)\n\n              pattern = pattern.slice(0, i + 1) + nodePattern + pattern.slice(j)\n              i += nodePattern.length\n\n              const regex = isRegexNode\n                ? new RegExp(\"^\" + regexps.join(\"\") + \"$\")\n                : undefined\n              currentNode = (currentNode as StaticNode).createParametricChild(\n                regex,\n                staticPart,\n                nodePath,\n              )\n              parentNodePathIndex = i + 1\n              break\n            }\n          }\n        }\n      } else if (isWildcardNode) {\n        // add the wildcard parameter\n        params.push(\"*\")\n        currentNode = (currentNode as StaticNode).createWildcardChild()\n        parentNodePathIndex = i + 1\n\n        if (i !== pattern.length - 1) {\n          throw new Error(\"Wildcard must be the last character in the route\")\n        }\n      }\n    }\n\n    if (!this.options.caseSensitive) {\n      pattern = pattern.toLowerCase() as Router.PathInput\n    }\n\n    if (pattern === \"*\") {\n      pattern = \"/*\"\n    }\n\n    for (const existRoute of this.routes) {\n      if (existRoute.method === method && existRoute.pattern === pattern) {\n        throw new Error(\n          `Method '${method}' already declared for route '${pattern}'`,\n        )\n      }\n    }\n\n    const route = { method, path, pattern, params, handler }\n    this.routes.push(route)\n    currentNode.addRoute(route)\n  }\n\n  has(method: string, path: string): boolean {\n    const node = this.trees[method]\n    if (node === undefined) {\n      return false\n    }\n\n    const staticNode = node.getStaticChild(path)\n    if (staticNode === undefined) {\n      return false\n    }\n\n    return staticNode.isLeafNode\n  }\n\n  find(method: string, path: string): Router.FindResult<A> | undefined {\n    let currentNode: Node | undefined = this.trees[method]\n    if (currentNode === undefined) return undefined\n\n    if (path.charCodeAt(0) !== 47) {\n      // 47 is '/'\n      path = path.replace(FULL_PATH_REGEXP, \"/\")\n    }\n\n    // This must be run before sanitizeUrl as the resulting function\n    // .sliceParameter must be constructed with same URL string used\n    // throughout the rest of this function.\n    if (this.options.ignoreDuplicateSlashes) {\n      path = removeDuplicateSlashes(path)\n    }\n\n    let sanitizedUrl\n    let querystring\n    let shouldDecodeParam\n\n    try {\n      sanitizedUrl = safeDecodeURI(path)\n      path = sanitizedUrl.path\n      querystring = sanitizedUrl.querystring\n      shouldDecodeParam = sanitizedUrl.shouldDecodeParam\n    } catch (error) {\n      return undefined\n    }\n\n    if (this.options.ignoreTrailingSlash) {\n      path = trimLastSlash(path)\n    }\n\n    const originPath = path\n\n    if (this.options.caseSensitive === false) {\n      path = path.toLowerCase()\n    }\n\n    const maxParamLength = this.options.maxParamLength\n\n    let pathIndex = (currentNode as StaticNode).prefix.length\n    const params = []\n    const pathLen = path.length\n\n    const brothersNodesStack: Array<BrotherNode> = []\n\n    while (true) {\n      if (pathIndex === pathLen && currentNode.isLeafNode) {\n        const handle = currentNode.handlerStorage?.find()\n        if (handle !== undefined) {\n          return {\n            handler: handle.handler as A,\n            params: handle.createParams(params),\n            searchParams: QS.parse(querystring),\n          } as const\n        }\n      }\n\n      let node: Node | undefined = currentNode.getNextNode(\n        path,\n        pathIndex,\n        brothersNodesStack,\n        params.length,\n      )\n\n      if (node === undefined) {\n        if (brothersNodesStack.length === 0) {\n          return undefined\n        }\n\n        const brotherNodeState = brothersNodesStack.pop()!\n        pathIndex = brotherNodeState.brotherPathIndex\n        params.splice(brotherNodeState.paramsCount)\n        node = brotherNodeState.brotherNode\n      }\n\n      currentNode = node\n\n      // static route\n      if (currentNode._tag === \"StaticNode\") {\n        pathIndex += currentNode.prefix.length\n        continue\n      }\n\n      if (currentNode._tag === \"WildcardNode\") {\n        let param = originPath.slice(pathIndex)\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param)\n        }\n\n        params.push(param)\n        pathIndex = pathLen\n        continue\n      }\n\n      if (currentNode._tag === \"ParametricNode\") {\n        let paramEndIndex = originPath.indexOf(\"/\", pathIndex)\n        if (paramEndIndex === -1) {\n          paramEndIndex = pathLen\n        }\n\n        let param = originPath.slice(pathIndex, paramEndIndex)\n        if (shouldDecodeParam) {\n          param = safeDecodeURIComponent(param)\n        }\n\n        if (currentNode.regex !== undefined) {\n          const matchedParameters: RegExpExecArray | null =\n            currentNode.regex.exec(param)\n          if (matchedParameters === null) continue\n\n          for (let i = 1; i < matchedParameters.length; i++) {\n            const matchedParam: string = matchedParameters[i]\n            if (matchedParam.length > maxParamLength) {\n              return undefined\n            }\n            params.push(matchedParam)\n          }\n        } else {\n          if (param.length > maxParamLength) {\n            return undefined\n          }\n          params.push(param)\n        }\n\n        pathIndex = paramEndIndex\n      }\n    }\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Handler storage\n// ----------------------------------------------------------------------------\n\ninterface Handler {\n  readonly params: ReadonlyArray<string>\n  readonly handler: unknown\n  readonly createParams: (\n    paramsArray: ReadonlyArray<string>,\n  ) => Record<string, string>\n}\n\nclass HandlerStorage {\n  readonly handlers: Array<Handler> = []\n  unconstrainedHandler: Handler | undefined\n\n  find() {\n    return this.unconstrainedHandler\n  }\n\n  add(route: Route) {\n    const handler: Handler = {\n      params: route.params,\n      handler: route.handler,\n      createParams: compileCreateParams(route.params),\n    }\n    this.handlers.push(handler)\n    this.unconstrainedHandler = this.handlers[0]\n  }\n}\n\n// ----------------------------------------------------------------------------\n// Nodes\n// ----------------------------------------------------------------------------\n\ninterface BrotherNode {\n  readonly paramsCount: number\n  readonly brotherPathIndex: number\n  readonly brotherNode: Node\n}\n\ntype Node = StaticNode | ParametricNode | WildcardNode\n\nabstract class NodeBase {\n  isLeafNode = false\n  routes: Array<Route> | undefined\n  handlerStorage: HandlerStorage | undefined\n\n  addRoute(route: Route) {\n    if (this.routes === undefined) {\n      this.routes = [route]\n    } else {\n      this.routes.push(route)\n    }\n\n    if (this.handlerStorage === undefined) {\n      this.handlerStorage = new HandlerStorage()\n    }\n    this.isLeafNode = true\n    this.handlerStorage.add(route)\n  }\n\n  abstract getNextNode(\n    path: string,\n    pathIndex: number,\n    nodeStack: any,\n    paramsCount: number,\n  ): Node | undefined\n}\n\nabstract class ParentNode extends NodeBase {\n  readonly staticChildren: Record<string, StaticNode> = {}\n\n  findStaticMatchingChild(\n    path: string,\n    pathIndex: number,\n  ): StaticNode | undefined {\n    const staticChild = this.staticChildren[path.charAt(pathIndex)]\n    if (\n      staticChild === undefined ||\n      !staticChild.matchPrefix(path, pathIndex)\n    ) {\n      return undefined\n    }\n    return staticChild\n  }\n\n  getStaticChild(path: string, pathIndex = 0): StaticNode | undefined {\n    if (path.length === pathIndex) {\n      return this as any\n    }\n\n    const staticChild = this.findStaticMatchingChild(path, pathIndex)\n    if (staticChild === undefined) {\n      return undefined\n    }\n\n    return staticChild.getStaticChild(\n      path,\n      pathIndex + staticChild.prefix.length,\n    )\n  }\n\n  createStaticChild(path: string): StaticNode {\n    if (path.length === 0) {\n      return this as any\n    }\n\n    let staticChild = this.staticChildren[path.charAt(0)]\n    if (staticChild) {\n      let i = 1\n      for (; i < staticChild.prefix.length; i++) {\n        if (path.charCodeAt(i) !== staticChild.prefix.charCodeAt(i)) {\n          staticChild = staticChild.split(this, i)\n          break\n        }\n      }\n      return staticChild.createStaticChild(path.slice(i))\n    }\n\n    const label = path.charAt(0)\n    this.staticChildren[label] = new StaticNode(path)\n    return this.staticChildren[label]\n  }\n}\n\nclass StaticNode extends ParentNode {\n  readonly _tag = \"StaticNode\"\n  constructor(prefix: string) {\n    super()\n    this.setPrefix(prefix)\n  }\n\n  prefix!: string\n  matchPrefix!: (path: string, pathIndex: number) => boolean\n  readonly parametricChildren: Array<ParametricNode> = []\n\n  wildcardChild: WildcardNode | undefined\n\n  private setPrefix(prefix: string) {\n    this.prefix = prefix\n\n    if (prefix.length === 1) {\n      this.matchPrefix = (_path, _pathIndex) => true\n    } else {\n      const len = prefix.length\n      this.matchPrefix = function (path, pathIndex) {\n        for (let i = 1; i < len; i++) {\n          if (path.charCodeAt(pathIndex + i) !== this.prefix.charCodeAt(i)) {\n            return false\n          }\n        }\n        return true\n      }\n    }\n  }\n\n  getParametricChild(regex: RegExp | undefined): ParametricNode | undefined {\n    if (regex === undefined) {\n      return this.parametricChildren.find(child => child.isRegex === false)\n    }\n\n    const source = regex.source\n    return this.parametricChildren.find(child => {\n      if (child.regex === undefined) {\n        return false\n      }\n      return child.regex.source === source\n    })\n  }\n\n  createParametricChild(\n    regex: RegExp | undefined,\n    staticSuffix: string | undefined,\n    nodePath: string,\n  ) {\n    let child = this.getParametricChild(regex)\n    if (child !== undefined) {\n      child.nodePaths.add(nodePath)\n      return child\n    }\n\n    child = new ParametricNode(regex, staticSuffix, nodePath)\n    this.parametricChildren.push(child)\n    this.parametricChildren.sort((child1, child2) => {\n      if (!child1.isRegex) return 1\n      if (!child2.isRegex) return -1\n\n      if (child1.staticSuffix === undefined) return 1\n      if (child2.staticSuffix === undefined) return -1\n\n      if (child2.staticSuffix.endsWith(child1.staticSuffix)) return 1\n      if (child1.staticSuffix.endsWith(child2.staticSuffix)) return -1\n\n      return 0\n    })\n\n    return child\n  }\n\n  createWildcardChild() {\n    if (this.wildcardChild === undefined) {\n      this.wildcardChild = new WildcardNode()\n    }\n    return this.wildcardChild\n  }\n\n  split(parentNode: ParentNode, length: number) {\n    const parentPrefix = this.prefix.slice(0, length)\n    const childPrefix = this.prefix.slice(length)\n\n    this.setPrefix(childPrefix)\n\n    const staticNode = new StaticNode(parentPrefix)\n    staticNode.staticChildren[childPrefix.charAt(0)] = this\n    parentNode.staticChildren[parentPrefix.charAt(0)] = staticNode\n\n    return staticNode\n  }\n\n  getNextNode(\n    path: string,\n    pathIndex: number,\n    nodeStack: Array<BrotherNode>,\n    paramsCount: number,\n  ): Node | undefined {\n    let node: Node | undefined = this.findStaticMatchingChild(path, pathIndex)\n    let parametricBrotherNodeIndex = 0\n\n    if (node === undefined) {\n      if (this.parametricChildren.length === 0) {\n        return this.wildcardChild\n      }\n\n      node = this.parametricChildren[0]\n      parametricBrotherNodeIndex = 1\n    }\n\n    if (this.wildcardChild !== undefined) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.wildcardChild,\n      })\n    }\n\n    for (\n      let i = this.parametricChildren.length - 1;\n      i >= parametricBrotherNodeIndex;\n      i--\n    ) {\n      nodeStack.push({\n        paramsCount,\n        brotherPathIndex: pathIndex,\n        brotherNode: this.parametricChildren[i],\n      })\n    }\n\n    return node\n  }\n}\n\nclass ParametricNode extends ParentNode {\n  readonly _tag = \"ParametricNode\"\n  constructor(\n    readonly regex: RegExp | undefined,\n    readonly staticSuffix: string | undefined,\n    nodePath: string,\n  ) {\n    super()\n    this.isRegex = !!regex\n    this.nodePaths = new Set([nodePath])\n  }\n\n  readonly isRegex: boolean\n  readonly nodePaths: Set<string>\n\n  getNextNode(path: string, pathIndex: number) {\n    return this.findStaticMatchingChild(path, pathIndex)\n  }\n}\n\nclass WildcardNode extends NodeBase {\n  readonly _tag = \"WildcardNode\"\n  getNextNode(\n    _path: string,\n    _pathIndex: number,\n    _nodeStack: any,\n    _paramsCount: number,\n  ): Node | undefined {\n    return undefined\n  }\n}\n\n// --\n\ninterface Assert {\n  (condition: any, message?: string): asserts condition\n}\nconst assert: Assert = (condition, message) => {\n  if (!condition) {\n    throw new Error(message)\n  }\n}\n\nfunction removeDuplicateSlashes(path: string): Router.PathInput {\n  return path.replace(/\\/\\/+/g, \"/\") as Router.PathInput\n}\n\nfunction trimLastSlash(path: string): Router.PathInput {\n  if (path.length > 1 && path.charCodeAt(path.length - 1) === 47) {\n    return path.slice(0, -1) as Router.PathInput\n  }\n  return path as Router.PathInput\n}\n\nfunction compileCreateParams(\n  params: ReadonlyArray<string>,\n): (paramsArray: ReadonlyArray<string>) => Record<string, string> {\n  const len = params.length\n  return function (paramsArray) {\n    const paramsObject: Record<string, string> = {}\n    for (let i = 0; i < len; i++) {\n      paramsObject[params[i]] = paramsArray[i]\n    }\n    return paramsObject\n  }\n}\n\nfunction getClosingParenthensePosition(path: string, idx: number) {\n  // `path.indexOf()` will always return the first position of the closing parenthese,\n  // but it's inefficient for grouped or wrong regexp expressions.\n  // see issues #62 and #63 for more info\n\n  let parentheses = 1\n\n  while (idx < path.length) {\n    idx++\n\n    // ignore skipped chars\n    if (path[idx] === \"\\\\\") {\n      idx++\n      continue\n    }\n\n    if (path[idx] === \")\") {\n      parentheses--\n    } else if (path[idx] === \"(\") {\n      parentheses++\n    }\n\n    if (!parentheses) return idx\n  }\n\n  throw new TypeError('Invalid regexp expression in \"' + path + '\"')\n}\n\nfunction trimRegExpStartAndEnd(regexString: string) {\n  // removes chars that marks start \"^\" and end \"$\" of regexp\n  if (regexString.charCodeAt(1) === 94) {\n    regexString = regexString.slice(0, 1) + regexString.slice(2)\n  }\n\n  if (regexString.charCodeAt(regexString.length - 2) === 36) {\n    regexString =\n      regexString.slice(0, regexString.length - 2) +\n      regexString.slice(regexString.length - 1)\n  }\n\n  return regexString\n}\n\nfunction escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\")\n}\n\n// It must spot all the chars where decodeURIComponent(x) !== decodeURI(x)\n// The chars are: # $ & + , / : ; = ? @\nfunction decodeComponentChar(highCharCode: number, lowCharCode: number) {\n  if (highCharCode === 50) {\n    if (lowCharCode === 53) return \"%\"\n\n    if (lowCharCode === 51) return \"#\"\n    if (lowCharCode === 52) return \"$\"\n    if (lowCharCode === 54) return \"&\"\n    if (lowCharCode === 66) return \"+\"\n    if (lowCharCode === 98) return \"+\"\n    if (lowCharCode === 67) return \",\"\n    if (lowCharCode === 99) return \",\"\n    if (lowCharCode === 70) return \"/\"\n    if (lowCharCode === 102) return \"/\"\n    return undefined\n  }\n  if (highCharCode === 51) {\n    if (lowCharCode === 65) return \":\"\n    if (lowCharCode === 97) return \":\"\n    if (lowCharCode === 66) return \";\"\n    if (lowCharCode === 98) return \";\"\n    if (lowCharCode === 68) return \"=\"\n    if (lowCharCode === 100) return \"=\"\n    if (lowCharCode === 70) return \"?\"\n    if (lowCharCode === 102) return \"?\"\n    return undefined\n  }\n  if (highCharCode === 52 && lowCharCode === 48) {\n    return \"@\"\n  }\n  return undefined\n}\n\nfunction safeDecodeURI(path: string) {\n  let shouldDecode = false\n  let shouldDecodeParam = false\n\n  let querystring = \"\"\n\n  for (let i = 1; i < path.length; i++) {\n    const charCode = path.charCodeAt(i)\n\n    if (charCode === 37) {\n      const highCharCode = path.charCodeAt(i + 1)\n      const lowCharCode = path.charCodeAt(i + 2)\n\n      if (decodeComponentChar(highCharCode, lowCharCode) === undefined) {\n        shouldDecode = true\n      } else {\n        shouldDecodeParam = true\n        // %25 - encoded % char. We need to encode one more time to prevent double decoding\n        if (highCharCode === 50 && lowCharCode === 53) {\n          shouldDecode = true\n          path = path.slice(0, i + 1) + \"25\" + path.slice(i + 1)\n          i += 2\n        }\n        i += 2\n      }\n      // Some systems do not follow RFC and separate the path and query\n      // string with a `;` character (code 59), e.g. `/foo;jsessionid=123456`.\n      // Thus, we need to split on `;` as well as `?` and `#`.\n    } else if (charCode === 63 || charCode === 59 || charCode === 35) {\n      querystring = path.slice(i + 1)\n      path = path.slice(0, i)\n      break\n    }\n  }\n  const decodedPath = shouldDecode ? decodeURI(path) : path\n  return { path: decodedPath, querystring, shouldDecodeParam } as const\n}\n\nfunction safeDecodeURIComponent(uriComponent: string) {\n  const startIndex = uriComponent.indexOf(\"%\")\n  if (startIndex === -1) return uriComponent\n\n  let decoded = \"\"\n  let lastIndex = startIndex\n\n  for (let i = startIndex; i < uriComponent.length; i++) {\n    if (uriComponent.charCodeAt(i) === 37) {\n      const highCharCode = uriComponent.charCodeAt(i + 1)\n      const lowCharCode = uriComponent.charCodeAt(i + 2)\n\n      const decodedChar = decodeComponentChar(highCharCode, lowCharCode)\n      decoded += uriComponent.slice(lastIndex, i) + decodedChar\n\n      lastIndex = i + 3\n    }\n  }\n  return (\n    uriComponent.slice(0, startIndex) + decoded + uriComponent.slice(lastIndex)\n  )\n}\n\nconst httpMethods = [\n  \"ACL\",\n  \"BIND\",\n  \"CHECKOUT\",\n  \"CONNECT\",\n  \"COPY\",\n  \"DELETE\",\n  \"GET\",\n  \"HEAD\",\n  \"LINK\",\n  \"LOCK\",\n  \"M-SEARCH\",\n  \"MERGE\",\n  \"MKACTIVITY\",\n  \"MKCALENDAR\",\n  \"MKCOL\",\n  \"MOVE\",\n  \"NOTIFY\",\n  \"OPTIONS\",\n  \"PATCH\",\n  \"POST\",\n  \"PROPFIND\",\n  \"PROPPATCH\",\n  \"PURGE\",\n  \"PUT\",\n  \"REBIND\",\n  \"REPORT\",\n  \"SEARCH\",\n  \"SOURCE\",\n  \"SUBSCRIBE\",\n  \"TRACE\",\n  \"UNBIND\",\n  \"UNLINK\",\n  \"UNLOCK\",\n  \"UNSUBSCRIBE\",\n] as const\n", "import type * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Effectable from \"effect/Effectable\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { dual } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Inspectable from \"effect/Inspectable\"\nimport * as Layer from \"effect/Layer\"\nimport * as Option from \"effect/Option\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport type { ParseOptions } from \"effect/SchemaAST\"\nimport * as Tracer from \"effect/Tracer\"\nimport type { Mutable } from \"effect/Types\"\nimport * as FindMyWay from \"find-my-way-ts\"\nimport type * as App from \"../HttpApp.js\"\nimport type * as Method from \"../HttpMethod.js\"\nimport type * as Router from \"../HttpRouter.js\"\nimport * as HttpServer from \"../HttpServer.js\"\nimport * as Error from \"../HttpServerError.js\"\nimport * as ServerRequest from \"../HttpServerRequest.js\"\nimport * as Respondable from \"../HttpServerRespondable.js\"\nimport type * as ServerResponse from \"../HttpServerResponse.js\"\n\n/** @internal */\nexport const TypeId: Router.TypeId = Symbol.for(\"@effect/platform/HttpRouter\") as Router.TypeId\n\n/** @internal */\nexport const RouteTypeId: Router.RouteTypeId = Symbol.for(\"@effect/platform/HttpRouter/Route\") as Router.RouteTypeId\n\n/** @internal */\nexport const RouteContextTypeId: Router.RouteContextTypeId = Symbol.for(\n  \"@effect/platform/HttpRouter/RouteContext\"\n) as Router.RouteContextTypeId\n\n/** @internal */\nexport const RouteContext = Context.GenericTag<Router.RouteContext>(\"@effect/platform/HttpRouter/RouteContext\")\n\nconst isRouter = (u: unknown): u is Router.HttpRouter<unknown, unknown> => Predicate.hasProperty(u, TypeId)\n\n/** @internal */\nexport const params = Effect.map(RouteContext, (_) => _.params)\n\n/** @internal */\nexport const schemaJson = <\n  R,\n  I extends Partial<{\n    readonly method: Method.HttpMethod\n    readonly url: string\n    readonly cookies: Readonly<Record<string, string | undefined>>\n    readonly headers: Readonly<Record<string, string | undefined>>\n    readonly pathParams: Readonly<Record<string, string | undefined>>\n    readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>\n    readonly body: any\n  }>,\n  A\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(\n    Effect.context<ServerRequest.HttpServerRequest | ServerRequest.ParsedSearchParams | Router.RouteContext>(),\n    (context) => {\n      const request = Context.get(context, ServerRequest.HttpServerRequest)\n      const searchParams = Context.get(context, ServerRequest.ParsedSearchParams)\n      const routeContext = Context.get(context, RouteContext)\n      return Effect.flatMap(request.json, (body) =>\n        parse({\n          method: request.method,\n          url: request.url,\n          headers: request.headers,\n          cookies: request.cookies,\n          pathParams: routeContext.params,\n          searchParams,\n          body\n        }))\n    }\n  )\n}\n\n/** @internal */\nexport const schemaNoBody = <\n  R,\n  I extends Partial<{\n    readonly method: Method.HttpMethod\n    readonly url: string\n    readonly cookies: Readonly<Record<string, string | undefined>>\n    readonly headers: Readonly<Record<string, string | undefined>>\n    readonly pathParams: Readonly<Record<string, string | undefined>>\n    readonly searchParams: Readonly<Record<string, string | ReadonlyArray<string> | undefined>>\n  }>,\n  A\n>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(\n    Effect.context<ServerRequest.HttpServerRequest | ServerRequest.ParsedSearchParams | Router.RouteContext>(),\n    (context) => {\n      const request = Context.get(context, ServerRequest.HttpServerRequest)\n      const searchParams = Context.get(context, ServerRequest.ParsedSearchParams)\n      const routeContext = Context.get(context, RouteContext)\n      return parse({\n        method: request.method,\n        url: request.url,\n        headers: request.headers,\n        cookies: request.cookies,\n        pathParams: routeContext.params,\n        searchParams\n      })\n    }\n  )\n}\n\n/** @internal */\nexport const schemaParams = <A, I extends Readonly<Record<string, string | ReadonlyArray<string> | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(\n    Effect.context<ServerRequest.ParsedSearchParams | Router.RouteContext>(),\n    (context) => {\n      const searchParams = Context.get(context, ServerRequest.ParsedSearchParams)\n      const routeContext = Context.get(context, RouteContext)\n      return parse({ ...searchParams, ...routeContext.params })\n    }\n  )\n}\n\n/** @internal */\nexport const schemaPathParams = <A, I extends Readonly<Record<string, string | undefined>>, R>(\n  schema: Schema.Schema<A, I, R>,\n  options?: ParseOptions | undefined\n) => {\n  const parse = Schema.decodeUnknown(schema, options)\n  return Effect.flatMap(RouteContext, (_) => parse(_.params))\n}\n\n/** @internal */\nexport const currentRouterConfig = globalValue(\n  \"@effect/platform/HttpRouter/currentRouterConfig\",\n  () => FiberRef.unsafeMake<Partial<FindMyWay.RouterConfig>>({})\n)\n\n/** @internal */\nexport const withRouterConfig: {\n  (config: Partial<FindMyWay.RouterConfig>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  <A, E, R>(effect: Effect.Effect<A, E, R>, config: Partial<FindMyWay.RouterConfig>): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, config: Partial<FindMyWay.RouterConfig>): Effect.Effect<A, E, R> =>\n    Effect.locally(effect, currentRouterConfig, config)\n)\n\n/** @internal */\nexport const setRouterConfig = (config: Partial<FindMyWay.RouterConfig>) =>\n  Layer.locallyScoped(currentRouterConfig, config)\n\nclass RouterImpl<E = never, R = never> extends Effectable.StructuralClass<\n  ServerResponse.HttpServerResponse,\n  E | Error.RouteNotFound,\n  Exclude<R, Router.RouteContext>\n> implements Router.HttpRouter<E, R> {\n  readonly [TypeId]: Router.TypeId\n  constructor(\n    readonly routes: Chunk.Chunk<Router.Route<E, R>>,\n    readonly mounts: Chunk.Chunk<\n      readonly [\n        prefix: string,\n        httpApp: App.Default<E, R>,\n        options?: { readonly includePrefix?: boolean | undefined } | undefined\n      ]\n    >\n  ) {\n    super()\n    this[TypeId] = TypeId\n    this.httpApp = FiberRef.get(currentRouterConfig).pipe(\n      Effect.flatMap((config) => this.httpApp = toHttpApp(this, config) as any)\n    ) as any\n  }\n  private httpApp: Effect.Effect<\n    ServerResponse.HttpServerResponse,\n    E | Error.RouteNotFound,\n    Exclude<R, Router.RouteContext>\n  >\n  commit() {\n    return this.httpApp\n  }\n  toJSON() {\n    return {\n      _id: \"Router\",\n      routes: this.routes.toJSON(),\n      mounts: this.mounts.toJSON()\n    }\n  }\n  toString() {\n    return Inspectable.format(this)\n  }\n  [Inspectable.NodeInspectSymbol]() {\n    return this.toJSON()\n  }\n}\n\nconst toHttpApp = <E, R>(\n  self: Router.HttpRouter<E, R>,\n  config: Partial<FindMyWay.RouterConfig>\n): App.Default<E | Error.RouteNotFound, R> => {\n  const router = FindMyWay.make<Router.Route<E, R>>(config)\n  const mounts = Chunk.toReadonlyArray(self.mounts).map(([path, app, options]) =>\n    [\n      path,\n      new RouteContextImpl(\n        new RouteImpl(\n          \"*\",\n          options?.includePrefix ? `${path}/*` as Router.PathInput : \"/*\",\n          app,\n          options?.includePrefix ? Option.none() : Option.some(path),\n          false\n        ),\n        {}\n      ),\n      options\n    ] as const\n  )\n  const mountsLen = mounts.length\n  Chunk.forEach(self.routes, (route) => {\n    if (route.method === \"*\") {\n      router.all(route.path, route)\n    } else {\n      router.on(route.method, route.path, route)\n    }\n  })\n  return Effect.withFiberRuntime<\n    ServerResponse.HttpServerResponse,\n    E | Error.RouteNotFound,\n    R | ServerRequest.HttpServerRequest\n  >((fiber) => {\n    const context = Context.unsafeMake(new Map(fiber.getFiberRef(FiberRef.currentContext).unsafeMap))\n    const request = Context.unsafeGet(context, ServerRequest.HttpServerRequest)\n    if (mountsLen > 0) {\n      const searchIndex = request.url.indexOf(\"?\")\n      const pathname = searchIndex === -1 ? request.url : request.url.slice(0, searchIndex)\n\n      for (let i = 0; i < mountsLen; i++) {\n        const [path, routeContext, options] = mounts[i]\n        if (pathname === path || pathname.startsWith(path + \"/\")) {\n          context.unsafeMap.set(RouteContext.key, routeContext)\n          if (options?.includePrefix !== true) {\n            context.unsafeMap.set(ServerRequest.HttpServerRequest.key, sliceRequestUrl(request, path))\n          }\n          return Effect.locally(\n            Effect.flatMap(routeContext.route.handler, Respondable.toResponse) as App.Default<E, R>,\n            FiberRef.currentContext,\n            context\n          )\n        }\n      }\n    }\n\n    let result = router.find(request.method, request.url)\n    if (result === undefined && request.method === \"HEAD\") {\n      result = router.find(\"GET\", request.url)\n    }\n    if (result === undefined) {\n      return Effect.fail(new Error.RouteNotFound({ request }))\n    }\n    const route = result.handler\n    if (route.prefix._tag === \"Some\") {\n      context.unsafeMap.set(ServerRequest.HttpServerRequest.key, sliceRequestUrl(request, route.prefix.value))\n    }\n    context.unsafeMap.set(ServerRequest.ParsedSearchParams.key, result.searchParams)\n    context.unsafeMap.set(RouteContext.key, new RouteContextImpl(route, result.params))\n\n    const span = Context.getOption(context, Tracer.ParentSpan)\n    if (span._tag === \"Some\" && span.value._tag === \"Span\") {\n      span.value.attribute(\"http.route\", route.path)\n    }\n\n    const handlerResponse = Effect.flatMap(route.handler, Respondable.toResponse)\n    return Effect.locally(\n      (route.uninterruptible ?\n        handlerResponse :\n        Effect.interruptible(handlerResponse)) as Effect.Effect<\n          ServerResponse.HttpServerResponse,\n          E,\n          Router.HttpRouter.ExcludeProvided<R>\n        >,\n      FiberRef.currentContext,\n      context\n    )\n  })\n}\n\nfunction sliceRequestUrl(request: ServerRequest.HttpServerRequest, prefix: string) {\n  const prefexLen = prefix.length\n  return request.modify({ url: request.url.length <= prefexLen ? \"/\" : request.url.slice(prefexLen) })\n}\n\nclass RouteImpl<E = never, R = never> extends Inspectable.Class implements Router.Route<E, R> {\n  readonly [RouteTypeId]: Router.RouteTypeId\n  constructor(\n    readonly method: Method.HttpMethod | \"*\",\n    readonly path: Router.PathInput,\n    readonly handler: Router.Route.Handler<E, R>,\n    readonly prefix = Option.none<string>(),\n    readonly uninterruptible = false\n  ) {\n    super()\n    this[RouteTypeId] = RouteTypeId\n  }\n  toJSON(): unknown {\n    return {\n      _id: \"@effect/platform/HttpRouter/Route\",\n      method: this.method,\n      path: this.path,\n      prefix: this.prefix.toJSON()\n    }\n  }\n}\n\nclass RouteContextImpl implements Router.RouteContext {\n  readonly [RouteContextTypeId]: Router.RouteContextTypeId\n  constructor(\n    readonly route: Router.Route<unknown, unknown>,\n    readonly params: Readonly<Record<string, string | undefined>>\n  ) {\n    this[RouteContextTypeId] = RouteContextTypeId\n  }\n}\n\n/** @internal */\nexport const empty: Router.HttpRouter<never> = new RouterImpl(Chunk.empty(), Chunk.empty())\n\n/** @internal */\nexport const fromIterable = <R extends Router.Route<any, any>>(\n  routes: Iterable<R>\n): Router.HttpRouter<\n  R extends Router.Route<infer E, infer _> ? E : never,\n  R extends Router.Route<infer _, infer Env> ? Env : never\n> => new RouterImpl(Chunk.fromIterable(routes), Chunk.empty()) as any\n\n/** @internal */\nexport const makeRoute = <E, R>(\n  method: Method.HttpMethod | \"*\",\n  path: Router.PathInput,\n  handler: Router.Route.Handler<E, R>,\n  options?: {\n    readonly prefix?: string | undefined\n    readonly uninterruptible?: boolean | undefined\n  } | undefined\n): Router.Route<E, Router.HttpRouter.ExcludeProvided<R>> =>\n  new RouteImpl(\n    method,\n    path,\n    handler,\n    options?.prefix ? Option.some(options.prefix) : Option.none(),\n    options?.uninterruptible ?? false\n  ) as any\n\n/** @internal */\nexport const append = dual<\n  <R1, E1>(\n    route: Router.Route<E1, R1>\n  ) => <E, R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>,\n  <E, R, E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    route: Router.Route<E1, R1>\n  ) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>\n>(2, (self, route) => new RouterImpl(Chunk.append(self.routes, route) as any, self.mounts))\n\n/** @internal */\nexport const concat = dual<\n  <R1, E1>(\n    that: Router.HttpRouter<E1, R1>\n  ) => <E, R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E | E1, R | R1>,\n  <E, R, E1, R1>(self: Router.HttpRouter<E, R>, that: Router.HttpRouter<E1, R1>) => Router.HttpRouter<E | E1, R | R1>\n>(2, (self, that) => concatAll(self, that))\n\n/** @internal */\nexport const concatAll = <Routers extends ReadonlyArray<Router.HttpRouter<E, R>>, E, R>(\n  ...routers: Routers\n) =>\n  new RouterImpl(\n    routers.reduce((cur, acc) => Chunk.appendAll(cur, acc.routes), Chunk.empty<Router.Route<E, R>>()),\n    routers.reduce(\n      (cur, acc) => Chunk.appendAll(cur, acc.mounts),\n      Chunk.empty<\n        readonly [\n          prefix: string,\n          httpApp: App.Default<E, R>,\n          options?: { readonly includePrefix?: boolean | undefined } | undefined\n        ]\n      >()\n    )\n  ) as any\n\nconst removeTrailingSlash = (\n  path: Router.PathInput\n): Router.PathInput => (path.endsWith(\"/\") ? path.slice(0, -1) : path) as any\n\n/** @internal */\nexport const prefixPath: {\n  (prefix: string): (self: string) => string\n  (self: string, prefix: string): string\n} = dual(2, (self, prefix) => {\n  prefix = removeTrailingSlash(prefix)\n  return self === \"/\" ? prefix : prefix + self\n})\n\n/** @internal */\nexport const prefixAll = dual<\n  (prefix: Router.PathInput) => <E, R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E, R>,\n  <E, R>(self: Router.HttpRouter<E, R>, prefix: Router.PathInput) => Router.HttpRouter<E, R>\n>(\n  2,\n  (self, prefix) => {\n    prefix = removeTrailingSlash(prefix)\n    return new RouterImpl(\n      Chunk.map(self.routes, (route) =>\n        new RouteImpl(\n          route.method,\n          route.path === \"/\" ? prefix : prefix + route.path as Router.PathInput,\n          route.handler,\n          Option.orElse(\n            Option.map(route.prefix, (_) => prefix + _),\n            () => Option.some(prefix)\n          ),\n          route.uninterruptible\n        )),\n      Chunk.map(self.mounts, ([path, app]) => [path === \"/\" ? prefix : prefix + path, app])\n    )\n  }\n)\n\n/** @internal */\nexport const mount = dual<\n  <R1, E1>(\n    path: `/${string}`,\n    that: Router.HttpRouter<E1, R1>\n  ) => <E, R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E | E1, R | R1>,\n  <E, R, E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    path: `/${string}`,\n    that: Router.HttpRouter<E1, R1>\n  ) => Router.HttpRouter<E | E1, R | R1>\n>(\n  3,\n  (self, path, that) => concat(self, prefixAll(that, path))\n)\n\n/** @internal */\nexport const mountApp = dual<\n  <R1, E1>(\n    path: `/${string}`,\n    that: App.Default<E1, R1>,\n    options?: {\n      readonly includePrefix?: boolean | undefined\n    } | undefined\n  ) => <E, R>(\n    self: Router.HttpRouter<E, R>\n  ) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>,\n  <E, R, E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    path: `/${string}`,\n    that: App.Default<E1, R1>,\n    options?: {\n      readonly includePrefix?: boolean | undefined\n    } | undefined\n  ) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>\n>(\n  (args) => Predicate.hasProperty(args[0], TypeId),\n  <E, R, E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    path: `/${string}`,\n    that: App.Default<E1, R1>,\n    options?: {\n      readonly includePrefix?: boolean | undefined\n    } | undefined\n  ): Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>> =>\n    new RouterImpl<any, any>(self.routes, Chunk.append(self.mounts, [removeTrailingSlash(path), that, options])) as any\n)\n\n/** @internal */\nexport const route = (method: Method.HttpMethod | \"*\"): {\n  <R1, E1>(\n    path: Router.PathInput,\n    handler: Router.Route.Handler<E1, R1>,\n    options?: {\n      readonly uninterruptible?: boolean | undefined\n    } | undefined\n  ): <E, R>(\n    self: Router.HttpRouter<E, R>\n  ) => Router.HttpRouter<E1 | E, R | Router.HttpRouter.ExcludeProvided<R1>>\n  <E, R, E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    path: Router.PathInput,\n    handler: Router.Route.Handler<E1, R1>,\n    options?: {\n      readonly uninterruptible?: boolean | undefined\n    } | undefined\n  ): Router.HttpRouter<E1 | E, R | Router.HttpRouter.ExcludeProvided<R1>>\n} =>\n  dual<\n    <R1, E1>(\n      path: Router.PathInput,\n      handler: Router.Route.Handler<R1, E1>\n    ) => <E, R>(\n      self: Router.HttpRouter<E, R>\n    ) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>,\n    <E, R, E1, R1>(\n      self: Router.HttpRouter<E, R>,\n      path: Router.PathInput,\n      handler: Router.Route.Handler<E1, R1>,\n      options?: {\n        readonly uninterruptible?: boolean | undefined\n      } | undefined\n    ) => Router.HttpRouter<E | E1, R | Router.HttpRouter.ExcludeProvided<R1>>\n  >((args) => isRouter(args[0]), (self, path, handler, options) =>\n    new RouterImpl<any, any>(\n      Chunk.append(\n        self.routes,\n        new RouteImpl(\n          method,\n          path,\n          handler,\n          Option.none(),\n          options?.uninterruptible ?? false\n        )\n      ),\n      self.mounts\n    ))\n\n/** @internal */\nexport const all = route(\"*\")\n\n/** @internal */\nexport const get = route(\"GET\")\n\n/** @internal */\nexport const post = route(\"POST\")\n\n/** @internal */\nexport const put = route(\"PUT\")\n\n/** @internal */\nexport const patch = route(\"PATCH\")\n\n/** @internal */\nexport const del = route(\"DELETE\")\n\n/** @internal */\nexport const head = route(\"HEAD\")\n\n/** @internal */\nexport const options = route(\"OPTIONS\")\n\n/** @internal */\nexport const use = dual<\n  <E, R, R1, E1>(\n    f: (self: Router.Route.Middleware<E, R>) => App.Default<E1, R1>\n  ) => (self: Router.HttpRouter<E, R>) => Router.HttpRouter<E1, Router.HttpRouter.ExcludeProvided<R1>>,\n  <E, R, R1, E1>(\n    self: Router.HttpRouter<E, R>,\n    f: (self: Router.Route.Middleware<E, R>) => App.Default<E1, R1>\n  ) => Router.HttpRouter<E1, Router.HttpRouter.ExcludeProvided<R1>>\n>(2, (self, f) =>\n  new RouterImpl<any, any>(\n    Chunk.map(\n      self.routes,\n      (route) =>\n        new RouteImpl(\n          route.method,\n          route.path,\n          f(Effect.flatMap(route.handler, Respondable.toResponse)) as any,\n          route.prefix,\n          route.uninterruptible\n        )\n    ),\n    Chunk.map(\n      self.mounts,\n      ([path, app]) => [path, f(app as any)]\n    )\n  ))\n\n/** @internal */\nexport const transform = dual<\n  <E, R, R1, E1>(\n    f: (self: Router.Route.Handler<E, R>) => App.HttpApp<Respondable.Respondable, E1, R1>\n  ) => (self: Router.HttpRouter<E, R>) => Router.HttpRouter<E1, Router.HttpRouter.ExcludeProvided<R1>>,\n  <E, R, R1, E1>(\n    self: Router.HttpRouter<E, R>,\n    f: (self: Router.Route.Handler<E, R>) => App.HttpApp<Respondable.Respondable, E1, R1>\n  ) => Router.HttpRouter<E1, Router.HttpRouter.ExcludeProvided<R1>>\n>(2, (self, f) =>\n  new RouterImpl<any, any>(\n    Chunk.map(\n      self.routes,\n      (route) =>\n        new RouteImpl(\n          route.method,\n          route.path,\n          f(route.handler) as any,\n          route.prefix,\n          route.uninterruptible\n        )\n    ),\n    Chunk.map(\n      self.mounts,\n      ([path, app]) => [path, Effect.flatMap(f(app as any), Respondable.toResponse)]\n    )\n  ))\n\n/** @internal */\nexport const catchAll = dual<\n  <E, E2, R2>(\n    f: (e: E) => Router.Route.Handler<E2, R2>\n  ) => <R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E2, R | Router.HttpRouter.ExcludeProvided<R2>>,\n  <E, R, E2, R2>(\n    self: Router.HttpRouter<E, R>,\n    f: (e: E) => Router.Route.Handler<E2, R2>\n  ) => Router.HttpRouter<E2, R | Router.HttpRouter.ExcludeProvided<R2>>\n>(2, (self, f) => transform(self, Effect.catchAll(f)))\n\n/** @internal */\nexport const catchAllCause = dual<\n  <E, E2, R2>(\n    f: (e: Cause.Cause<E>) => Router.Route.Handler<E2, R2>\n  ) => <R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<E2, R | Router.HttpRouter.ExcludeProvided<R2>>,\n  <E, R, E2, R2>(\n    self: Router.HttpRouter<E, R>,\n    f: (e: Cause.Cause<E>) => Router.Route.Handler<E2, R2>\n  ) => Router.HttpRouter<E2, R | Router.HttpRouter.ExcludeProvided<R2>>\n>(2, (self, f) => transform(self, Effect.catchAllCause(f)))\n\n/** @internal */\nexport const catchTag = dual<\n  <K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E, E1, R1>(\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Router.Route.Handler<E1, R1>\n  ) => <R>(\n    self: Router.HttpRouter<E, R>\n  ) => Router.HttpRouter<Exclude<E, { _tag: K }> | E1, R | Router.HttpRouter.ExcludeProvided<R1>>,\n  <E, R, K extends (E extends { _tag: string } ? E[\"_tag\"] : never), E1, R1>(\n    self: Router.HttpRouter<E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => Router.Route.Handler<E1, R1>\n  ) => Router.HttpRouter<Exclude<E, { _tag: K }> | E1, R | Router.HttpRouter.ExcludeProvided<R1>>\n>(3, (self, k, f) => transform(self, Effect.catchTag(k, f)))\n\n/** @internal */\nexport const catchTags: {\n  <\n    E,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Router.Route.Handler<any, any>\n      } :\n      {})\n  >(\n    cases: Cases\n  ): <R>(self: Router.HttpRouter<E, R>) => Router.HttpRouter<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | Router.HttpRouter.ExcludeProvided<\n      {\n        [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n      }[keyof Cases]\n    >\n  >\n  <\n    R,\n    E,\n    Cases extends (E extends { _tag: string } ? {\n        [K in E[\"_tag\"]]+?: (error: Extract<E, { _tag: K }>) => Router.Route.Handler<any, any>\n      } :\n      {})\n  >(\n    self: Router.HttpRouter<E, R>,\n    cases: Cases\n  ): Router.HttpRouter<\n    | Exclude<E, { _tag: keyof Cases }>\n    | {\n      [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, infer E, any>) ? E : never\n    }[keyof Cases],\n    | R\n    | Router.HttpRouter.ExcludeProvided<\n      {\n        [K in keyof Cases]: Cases[K] extends ((...args: Array<any>) => Effect.Effect<any, any, infer R>) ? R : never\n      }[keyof Cases]\n    >\n  >\n} = dual(2, (self: Router.HttpRouter<any, any>, cases: {}) => use(self, Effect.catchTags(cases)))\n\nexport const provideService = dual<\n  <T extends Context.Tag<any, any>>(\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => <E, R>(\n    self: Router.HttpRouter<E, R>\n  ) => Router.HttpRouter<E, Exclude<R, Context.Tag.Identifier<T>>>,\n  <E, R, T extends Context.Tag<any, any>>(\n    self: Router.HttpRouter<E, R>,\n    tag: T,\n    service: Context.Tag.Service<T>\n  ) => Router.HttpRouter<E, Exclude<R, Context.Tag.Identifier<T>>>\n>(3, <E, R, T extends Context.Tag<any, any>>(\n  self: Router.HttpRouter<E, R>,\n  tag: T,\n  service: Context.Tag.Service<T>\n): Router.HttpRouter<E, Exclude<R, Context.Tag.Identifier<T>>> => use(self, Effect.provideService(tag, service)))\n\n/* @internal */\nexport const provideServiceEffect = dual<\n  <T extends Context.Tag<any, any>, R1, E1>(\n    tag: T,\n    effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n  ) => <E, R>(\n    self: Router.HttpRouter<E, R>\n  ) => Router.HttpRouter<\n    E | E1,\n    Exclude<\n      R | Router.HttpRouter.ExcludeProvided<R1>,\n      Context.Tag.Identifier<T>\n    >\n  >,\n  <E, R, T extends Context.Tag<any, any>, R1, E1>(\n    self: Router.HttpRouter<E, R>,\n    tag: T,\n    effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n  ) => Router.HttpRouter<\n    E | E1,\n    Exclude<\n      R | Router.HttpRouter.ExcludeProvided<R1>,\n      Context.Tag.Identifier<T>\n    >\n  >\n>(3, <E, R, T extends Context.Tag<any, any>, R1, E1>(\n  self: Router.HttpRouter<E, R>,\n  tag: T,\n  effect: Effect.Effect<Context.Tag.Service<T>, E1, R1>\n): Router.HttpRouter<\n  E | E1,\n  Exclude<\n    R | Router.HttpRouter.ExcludeProvided<R1>,\n    Context.Tag.Identifier<T>\n  >\n> => use(self, Effect.provideServiceEffect(tag, effect)) as any)\n\nconst makeService = <E, R>(): Router.HttpRouter.Service<E, R> => {\n  let router = empty as Router.HttpRouter<E, R>\n  return {\n    addRoute(route) {\n      return Effect.sync(() => {\n        router = append(router, route)\n      })\n    },\n    all(path, handler, options) {\n      return Effect.sync(() => {\n        router = all(router, path, handler, options)\n      })\n    },\n    get(path, handler, options) {\n      return Effect.sync(() => {\n        router = get(router, path, handler, options)\n      })\n    },\n    post(path, handler, options) {\n      return Effect.sync(() => {\n        router = post(router, path, handler, options)\n      })\n    },\n    put(path, handler, options) {\n      return Effect.sync(() => {\n        router = put(router, path, handler, options)\n      })\n    },\n    patch(path, handler, options) {\n      return Effect.sync(() => {\n        router = patch(router, path, handler, options)\n      })\n    },\n    del(path, handler, options) {\n      return Effect.sync(() => {\n        router = del(router, path, handler, options)\n      })\n    },\n    head(path, handler, options) {\n      return Effect.sync(() => {\n        router = head(router, path, handler, options)\n      })\n    },\n    options(path, handler, opts) {\n      return Effect.sync(() => {\n        router = options(router, path, handler, opts)\n      })\n    },\n    router: Effect.sync(() => router),\n    mount(path, that) {\n      return Effect.sync(() => {\n        router = mount(router, path, that)\n      })\n    },\n    mountApp(path, app, options) {\n      return Effect.sync(() => {\n        router = mountApp(router, path, app, options)\n      })\n    },\n    concat(that) {\n      return Effect.sync(() => {\n        router = concat(router, that)\n      })\n    }\n  }\n}\n\n/* @internal */\nexport const Tag =\n  <const Name extends string>(id: Name) =>\n  <Self, R = never, E = unknown>(): Router.HttpRouter.TagClass<\n    Self,\n    Name,\n    E,\n    R | Router.HttpRouter.DefaultServices\n  > => {\n    const Err = globalThis.Error as any\n    const limit = Err.stackTraceLimit\n    Err.stackTraceLimit = 2\n    const creationError = new Err()\n    Err.stackTraceLimit = limit\n\n    function TagClass() {}\n    const TagClass_ = TagClass as any as Mutable<Router.HttpRouter.TagClass<Self, Name, E, R>>\n    Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))\n    TagClass.key = id\n    Object.defineProperty(TagClass, \"stack\", {\n      get() {\n        return creationError.stack\n      }\n    })\n    TagClass_.Live = Layer.sync(TagClass_, makeService)\n    TagClass_.router = Effect.flatMap(TagClass_, (_) => _.router)\n    TagClass_.use = (f) =>\n      TagClass_.pipe(\n        Effect.flatMap(f),\n        Layer.scopedDiscard,\n        Layer.provide(TagClass_.Live)\n      )\n    TagClass_.unwrap = (f) =>\n      TagClass_.pipe(\n        Effect.flatMap((_) => _.router),\n        Effect.map(f),\n        Layer.unwrapEffect,\n        Layer.provide(TagClass_.Live)\n      )\n    TagClass_.serve = (middleware) => TagClass_.unwrap(HttpServer.serve(middleware as any))\n    return TagClass as any\n  }\n", "/**\n * @since 1.0.0\n */\nimport * as JSONSchema from \"effect/JSONSchema\"\nimport * as Record from \"effect/Record\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Annotations {\n  title?: string\n  description?: string\n  default?: unknown\n  examples?: globalThis.Array<unknown>\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Never extends Annotations {\n  $id: \"/schemas/never\"\n  not: {}\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Any extends Annotations {\n  $id: \"/schemas/any\"\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Unknown extends Annotations {\n  $id: \"/schemas/unknown\"\n}\n\n/**\n * @category model\n * @since 0.69.0\n */\nexport interface Void extends Annotations {\n  $id: \"/schemas/void\"\n}\n\n/**\n * @category model\n * @since 0.71.0\n */\nexport interface AnyObject extends Annotations {\n  $id: \"/schemas/object\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 0.71.0\n */\nexport interface Empty extends Annotations {\n  $id: \"/schemas/%7B%7D\"\n  anyOf: [\n    { type: \"object\" },\n    { type: \"array\" }\n  ]\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Ref extends Annotations {\n  $ref: string\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface String extends Annotations {\n  type: \"string\"\n  minLength?: number\n  maxLength?: number\n  pattern?: string\n  format?: string\n  contentMediaType?: string\n  contentSchema?: JsonSchema\n  allOf?: globalThis.Array<{\n    minLength?: number\n    maxLength?: number\n    pattern?: string\n  }>\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Numeric extends Annotations {\n  minimum?: number\n  exclusiveMinimum?: number\n  maximum?: number\n  exclusiveMaximum?: number\n  multipleOf?: number\n  format?: string\n  allOf?: globalThis.Array<{\n    minimum?: number\n    exclusiveMinimum?: number\n    maximum?: number\n    exclusiveMaximum?: number\n    multipleOf?: number\n  }>\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Number extends Numeric {\n  type: \"number\"\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Integer extends Numeric {\n  type: \"integer\"\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Boolean extends Annotations {\n  type: \"boolean\"\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Array extends Annotations {\n  type: \"array\"\n  items?: JsonSchema | globalThis.Array<JsonSchema>\n  minItems?: number\n  maxItems?: number\n  additionalItems?: JsonSchema | boolean\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Enum extends Annotations {\n  type?: \"string\" | \"number\" | \"boolean\"\n  enum: globalThis.Array<string | number | boolean | null>\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 0.71.0\n */\nexport interface Enums extends Annotations {\n  $comment: \"/schemas/enums\"\n  anyOf: globalThis.Array<{\n    type: \"string\" | \"number\"\n    title: string\n    enum: [string | number]\n  }>\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface AnyOf extends Annotations {\n  anyOf: globalThis.Array<JsonSchema>\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport interface Object extends Annotations {\n  type: \"object\"\n  required: globalThis.Array<string>\n  properties: Record<string, JsonSchema>\n  additionalProperties?: boolean | JsonSchema\n  patternProperties?: Record<string, JsonSchema>\n  propertyNames?: JsonSchema\n  nullable?: boolean\n}\n\n/**\n * @category model\n * @since 0.71.0\n */\nexport type JsonSchema =\n  | Never\n  | Any\n  | Unknown\n  | Void\n  | AnyObject\n  | Empty\n  | Ref\n  | String\n  | Number\n  | Integer\n  | Boolean\n  | Array\n  | Enum\n  | Enums\n  | AnyOf\n  | Object\n\n/**\n * @category model\n * @since 1.0.0\n */\nexport type Root = JsonSchema & {\n  $defs?: Record<string, JsonSchema>\n}\n\n/**\n * @category encoding\n * @since 1.0.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): Root => {\n  const defs: Record<string, JsonSchema> = {}\n  const out: Root = makeWithDefs(schema, { defs })\n  if (!Record.isEmptyRecord(defs)) {\n    out.$defs = defs\n  }\n  return out\n}\n\ntype TopLevelReferenceStrategy = \"skip\" | \"keep\"\n\ntype AdditionalPropertiesStrategy = \"allow\" | \"strict\"\n\n/**\n * Creates a schema with additional options and definitions.\n *\n * **Options**\n *\n * - `defs`: A record of definitions that are included in the schema.\n * - `defsPath`: The path to the definitions within the schema (defaults to \"#/$defs/\").\n * - `topLevelReferenceStrategy`: Controls the handling of the top-level reference. Possible values are:\n *   - `\"keep\"`: Keep the top-level reference (default behavior).\n *   - `\"skip\"`: Skip the top-level reference.\n * - `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n *   - `\"strict\"`: Disallow additional properties (default behavior).\n *   - `\"allow\"`: Allow additional properties.\n *\n * @category encoding\n * @since 1.0.0\n */\nexport const makeWithDefs = <A, I, R>(schema: Schema.Schema<A, I, R>, options: {\n  readonly defs: Record<string, any>\n  readonly defsPath?: string | undefined\n  readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined\n  readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined\n}): JsonSchema => fromAST(schema.ast, options)\n\n/** @internal */\nexport const fromAST = (ast: AST.AST, options: {\n  readonly defs: Record<string, any>\n  readonly defsPath?: string | undefined\n  readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined\n  readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined\n}): JsonSchema => {\n  const jsonSchema = JSONSchema.fromAST(ast, {\n    definitions: options.defs,\n    definitionPath: options.defsPath ?? \"#/components/schemas/\",\n    target: \"openApi3.1\",\n    topLevelReferenceStrategy: options.topLevelReferenceStrategy,\n    additionalPropertiesStrategy: options.additionalPropertiesStrategy\n  })\n  return jsonSchema as JsonSchema\n}\n", "/**\n * @since 1.0.0\n */\nimport type { NonEmptyArray } from \"effect/Array\"\nimport * as Context from \"effect/Context\"\nimport { constFalse } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Option from \"effect/Option\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\nimport * as HttpApi from \"./HttpApi.js\"\nimport type { HttpApiGroup } from \"./HttpApiGroup.js\"\nimport * as HttpApiMiddleware from \"./HttpApiMiddleware.js\"\nimport * as HttpApiSchema from \"./HttpApiSchema.js\"\nimport type { HttpApiSecurity } from \"./HttpApiSecurity.js\"\nimport * as HttpMethod from \"./HttpMethod.js\"\nimport * as JsonSchema from \"./OpenApiJsonSchema.js\"\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Identifier extends Context.Tag(\"@effect/platform/OpenApi/Identifier\")<Identifier, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Title extends Context.Tag(\"@effect/platform/OpenApi/Title\")<Title, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Version extends Context.Tag(\"@effect/platform/OpenApi/Version\")<Version, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Description extends Context.Tag(\"@effect/platform/OpenApi/Description\")<Description, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class License extends Context.Tag(\"@effect/platform/OpenApi/License\")<License, OpenAPISpecLicense>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class ExternalDocs\n  extends Context.Tag(\"@effect/platform/OpenApi/ExternalDocs\")<ExternalDocs, OpenAPISpecExternalDocs>()\n{}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Servers\n  extends Context.Tag(\"@effect/platform/OpenApi/Servers\")<Servers, ReadonlyArray<OpenAPISpecServer>>()\n{}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Format extends Context.Tag(\"@effect/platform/OpenApi/Format\")<Format, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Summary extends Context.Tag(\"@effect/platform/OpenApi/Summary\")<Summary, string>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Deprecated extends Context.Tag(\"@effect/platform/OpenApi/Deprecated\")<Deprecated, boolean>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Override extends Context.Tag(\"@effect/platform/OpenApi/Override\")<Override, Record<string, unknown>>() {}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport class Exclude extends Context.Reference<Exclude>()(\"@effect/platform/OpenApi/Exclude\", {\n  defaultValue: constFalse\n}) {}\n\n/**\n * Transforms the generated OpenAPI specification\n * @since 1.0.0\n * @category annotations\n */\nexport class Transform extends Context.Tag(\"@effect/platform/OpenApi/Transform\")<\n  Transform,\n  (openApiSpec: Record<string, any>) => Record<string, any>\n>() {}\n\nconst contextPartial = <Tags extends Record<string, Context.Tag<any, any>>>(tags: Tags): (\n  options: {\n    readonly [K in keyof Tags]?: Context.Tag.Service<Tags[K]> | undefined\n  }\n) => Context.Context<never> => {\n  const entries = Object.entries(tags)\n  return (options) => {\n    let context = Context.empty()\n    for (const [key, tag] of entries) {\n      if (options[key] !== undefined) {\n        context = Context.add(context, tag, options[key]!)\n      }\n    }\n    return context\n  }\n}\n\n/**\n * @since 1.0.0\n * @category annotations\n */\nexport const annotations: (\n  options: {\n    readonly identifier?: string | undefined\n    readonly title?: string | undefined\n    readonly version?: string | undefined\n    readonly description?: string | undefined\n    readonly license?: OpenAPISpecLicense | undefined\n    readonly summary?: string | undefined\n    readonly deprecated?: boolean | undefined\n    readonly externalDocs?: OpenAPISpecExternalDocs | undefined\n    readonly servers?: ReadonlyArray<OpenAPISpecServer> | undefined\n    readonly format?: string | undefined\n    readonly override?: Record<string, unknown> | undefined\n    readonly exclude?: boolean | undefined\n    readonly transform?: ((openApiSpec: Record<string, any>) => Record<string, any>) | undefined\n  }\n) => Context.Context<never> = contextPartial({\n  identifier: Identifier,\n  title: Title,\n  version: Version,\n  description: Description,\n  license: License,\n  summary: Summary,\n  deprecated: Deprecated,\n  externalDocs: ExternalDocs,\n  servers: Servers,\n  format: Format,\n  override: Override,\n  exclude: Exclude,\n  transform: Transform\n})\n\nconst apiCache = globalValue(\"@effect/platform/OpenApi/apiCache\", () => new WeakMap<HttpApi.HttpApi.Any, OpenAPISpec>())\n\n/**\n * This function checks if a given tag exists within the provided context. If\n * the tag is present, it retrieves the associated value and applies the given\n * callback function to it. If the tag is not found, the function does nothing.\n */\nfunction processAnnotation<Services, S, I>(\n  ctx: Context.Context<Services>,\n  tag: Context.Tag<I, S>,\n  f: (s: S) => void\n) {\n  const o = Context.getOption(ctx, tag)\n  if (Option.isSome(o)) {\n    f(o.value)\n  }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type AdditionalPropertiesStrategy = \"allow\" | \"strict\"\n\n/**\n * Converts an `HttpApi` instance into an OpenAPI Specification object.\n *\n * **Details**\n *\n * This function takes an `HttpApi` instance, which defines a structured API,\n * and generates an OpenAPI Specification (`OpenAPISpec`). The resulting spec\n * adheres to the OpenAPI 3.1.0 standard and includes detailed metadata such as\n * paths, operations, security schemes, and components. The function processes\n * the API's annotations, middleware, groups, and endpoints to build a complete\n * and accurate representation of the API in OpenAPI format.\n *\n * The function also deduplicates schemas, applies transformations, and\n * integrates annotations like descriptions, summaries, external documentation,\n * and overrides. Cached results are used for better performance when the same\n * `HttpApi` instance is processed multiple times.\n *\n * **Options**\n *\n * - `additionalPropertiesStrategy`: Controls the handling of additional properties. Possible values are:\n *   - `\"strict\"`: Disallow additional properties (default behavior).\n *   - `\"allow\"`: Allow additional properties.\n *\n * **Example**\n *\n * ```ts\n * import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from \"@effect/platform\"\n * import { Schema } from \"effect\"\n *\n * const api = HttpApi.make(\"api\").add(\n *   HttpApiGroup.make(\"group\").add(\n *     HttpApiEndpoint.get(\"get\", \"/items\")\n *       .addSuccess(Schema.Array(Schema.String))\n *   )\n * )\n *\n * const spec = OpenApi.fromApi(api)\n *\n * console.log(JSON.stringify(spec, null, 2))\n * // Output: OpenAPI specification in JSON format\n * ```\n *\n * @category constructors\n * @since 1.0.0\n */\nexport const fromApi = <Id extends string, Groups extends HttpApiGroup.Any, E, R>(\n  api: HttpApi.HttpApi<Id, Groups, E, R>,\n  options?: {\n    readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined\n  } | undefined\n): OpenAPISpec => {\n  const cached = apiCache.get(api)\n  if (cached !== undefined) {\n    return cached\n  }\n  const jsonSchemaDefs: Record<string, JsonSchema.JsonSchema> = {}\n  let spec: OpenAPISpec = {\n    openapi: \"3.1.0\",\n    info: {\n      title: Context.getOrElse(api.annotations, Title, () => \"Api\"),\n      version: Context.getOrElse(api.annotations, Version, () => \"0.0.1\")\n    },\n    paths: {},\n    components: {\n      schemas: jsonSchemaDefs,\n      securitySchemes: {}\n    },\n    security: [],\n    tags: []\n  }\n\n  function processAST(ast: AST.AST): JsonSchema.JsonSchema {\n    return JsonSchema.fromAST(ast, {\n      defs: jsonSchemaDefs,\n      additionalPropertiesStrategy: options?.additionalPropertiesStrategy\n    })\n  }\n\n  function processHttpApiSecurity(\n    name: string,\n    security: HttpApiSecurity\n  ) {\n    if (spec.components.securitySchemes[name] !== undefined) {\n      return\n    }\n    spec.components.securitySchemes[name] = makeSecurityScheme(security)\n  }\n\n  processAnnotation(api.annotations, HttpApi.AdditionalSchemas, (componentSchemas) => {\n    componentSchemas.forEach((componentSchema) => processAST(componentSchema.ast))\n  })\n  processAnnotation(api.annotations, Description, (description) => {\n    spec.info.description = description\n  })\n  processAnnotation(api.annotations, License, (license) => {\n    spec.info.license = license\n  })\n  processAnnotation(api.annotations, Summary, (summary) => {\n    spec.info.summary = summary\n  })\n  processAnnotation(api.annotations, Servers, (servers) => {\n    spec.servers = [...servers]\n  })\n\n  api.middlewares.forEach((middleware) => {\n    if (!HttpApiMiddleware.isSecurity(middleware)) {\n      return\n    }\n    for (const [name, security] of Object.entries(middleware.security)) {\n      processHttpApiSecurity(name, security)\n      spec.security.push({ [name]: [] })\n    }\n  })\n  HttpApi.reflect(api, {\n    onGroup({ group }) {\n      if (Context.get(group.annotations, Exclude)) {\n        return\n      }\n      let tag: OpenAPISpecTag = {\n        name: Context.getOrElse(group.annotations, Title, () => group.identifier)\n      }\n\n      processAnnotation(group.annotations, Description, (description) => {\n        tag.description = description\n      })\n      processAnnotation(group.annotations, ExternalDocs, (externalDocs) => {\n        tag.externalDocs = externalDocs\n      })\n      processAnnotation(group.annotations, Override, (override) => {\n        Object.assign(tag, override)\n      })\n      processAnnotation(group.annotations, Transform, (transformFn) => {\n        tag = transformFn(tag) as OpenAPISpecTag\n      })\n\n      spec.tags.push(tag)\n    },\n    onEndpoint({ endpoint, errors, group, mergedAnnotations, middleware, payloads, successes }) {\n      if (Context.get(mergedAnnotations, Exclude)) {\n        return\n      }\n      let op: OpenAPISpecOperation = {\n        tags: [Context.getOrElse(group.annotations, Title, () => group.identifier)],\n        operationId: Context.getOrElse(\n          endpoint.annotations,\n          Identifier,\n          () => group.topLevel ? endpoint.name : `${group.identifier}.${endpoint.name}`\n        ),\n        parameters: [],\n        security: [],\n        responses: {}\n      }\n\n      function processResponseMap(\n        map: ReadonlyMap<number, {\n          readonly ast: Option.Option<AST.AST>\n          readonly description: Option.Option<string>\n        }>,\n        defaultDescription: () => string\n      ) {\n        for (const [status, { ast, description }] of map) {\n          if (op.responses[status]) continue\n          op.responses[status] = {\n            description: Option.getOrElse(description, defaultDescription)\n          }\n          ast.pipe(\n            Option.filter((ast) => !HttpApiSchema.getEmptyDecodeable(ast)),\n            Option.map((ast) => {\n              const encoding = HttpApiSchema.getEncoding(ast)\n              op.responses[status].content = {\n                [encoding.contentType]: {\n                  schema: processAST(ast)\n                }\n              }\n            })\n          )\n        }\n      }\n\n      function processParameters(schema: Option.Option<Schema.Schema.All>, i: OpenAPISpecParameter[\"in\"]) {\n        if (Option.isSome(schema)) {\n          const jsonSchema = processAST(schema.value.ast)\n          if (\"properties\" in jsonSchema) {\n            Object.entries(jsonSchema.properties).forEach(([name, psJsonSchema]) => {\n              op.parameters.push({\n                name,\n                in: i,\n                schema: psJsonSchema,\n                required: jsonSchema.required.includes(name),\n                ...(psJsonSchema.description !== undefined ? { description: psJsonSchema.description } : undefined)\n              })\n            })\n          }\n        }\n      }\n\n      processAnnotation(endpoint.annotations, Description, (description) => {\n        op.description = description\n      })\n      processAnnotation(endpoint.annotations, Summary, (summary) => {\n        op.summary = summary\n      })\n      processAnnotation(endpoint.annotations, Deprecated, (deprecated) => {\n        op.deprecated = deprecated\n      })\n      processAnnotation(endpoint.annotations, ExternalDocs, (externalDocs) => {\n        op.externalDocs = externalDocs\n      })\n\n      middleware.forEach((middleware) => {\n        if (!HttpApiMiddleware.isSecurity(middleware)) {\n          return\n        }\n        for (const [name, security] of Object.entries(middleware.security)) {\n          processHttpApiSecurity(name, security)\n          op.security.push({ [name]: [] })\n        }\n      })\n      const hasBody = HttpMethod.hasBody(endpoint.method)\n      if (hasBody && payloads.size > 0) {\n        const content: OpenApiSpecContent = {}\n        payloads.forEach(({ ast }, contentType) => {\n          content[contentType as OpenApiSpecContentType] = {\n            schema: processAST(ast)\n          }\n        })\n        op.requestBody = { content, required: true }\n      }\n\n      processParameters(endpoint.pathSchema, \"path\")\n      if (!hasBody) {\n        processParameters(endpoint.payloadSchema, \"query\")\n      }\n      processParameters(endpoint.headersSchema, \"header\")\n      processParameters(endpoint.urlParamsSchema, \"query\")\n\n      processResponseMap(successes, () => \"Success\")\n      processResponseMap(errors, () => \"Error\")\n\n      const path = endpoint.path.replace(/:(\\w+)\\??/g, \"{$1}\")\n      const method = endpoint.method.toLowerCase() as OpenAPISpecMethodName\n      if (!spec.paths[path]) {\n        spec.paths[path] = {}\n      }\n\n      processAnnotation(endpoint.annotations, Override, (override) => {\n        Object.assign(op, override)\n      })\n      processAnnotation(endpoint.annotations, Transform, (transformFn) => {\n        op = transformFn(op) as OpenAPISpecOperation\n      })\n\n      spec.paths[path][method] = op\n    }\n  })\n\n  processAnnotation(api.annotations, Override, (override) => {\n    Object.assign(spec, override)\n  })\n  processAnnotation(api.annotations, Transform, (transformFn) => {\n    spec = transformFn(spec) as OpenAPISpec\n  })\n\n  apiCache.set(api, spec)\n\n  return spec\n}\n\nconst makeSecurityScheme = (security: HttpApiSecurity): OpenAPISecurityScheme => {\n  const meta: Partial<OpenAPISecurityScheme> = {}\n  processAnnotation(security.annotations, Description, (description) => {\n    meta.description = description\n  })\n  switch (security._tag) {\n    case \"Basic\": {\n      return {\n        ...meta,\n        type: \"http\",\n        scheme: \"basic\"\n      }\n    }\n    case \"Bearer\": {\n      const format = Context.getOption(security.annotations, Format).pipe(\n        Option.map((format) => ({ bearerFormat: format })),\n        Option.getOrUndefined\n      )\n      return {\n        ...meta,\n        type: \"http\",\n        scheme: \"bearer\",\n        ...format\n      }\n    }\n    case \"ApiKey\": {\n      return {\n        ...meta,\n        type: \"apiKey\",\n        name: security.key,\n        in: security.in\n      }\n    }\n  }\n}\n\n/**\n * This model describes the OpenAPI specification (version 3.1.0) returned by\n * {@link fromApi}. It is not intended to describe the entire OpenAPI\n * specification, only the output of `fromApi`.\n *\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpec {\n  openapi: \"3.1.0\"\n  info: OpenAPISpecInfo\n  paths: OpenAPISpecPaths\n  components: OpenAPIComponents\n  security: Array<OpenAPISecurityRequirement>\n  tags: Array<OpenAPISpecTag>\n  servers?: Array<OpenAPISpecServer>\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecInfo {\n  title: string\n  version: string\n  description?: string\n  license?: OpenAPISpecLicense\n  summary?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecTag {\n  name: string\n  description?: string\n  externalDocs?: OpenAPISpecExternalDocs\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecExternalDocs {\n  url: string\n  description?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecLicense {\n  name: string\n  url?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecServer {\n  url: string\n  description?: string\n  variables?: Record<string, OpenAPISpecServerVariable>\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecServerVariable {\n  default: string\n  enum?: NonEmptyArray<string>\n  description?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISpecPaths = Record<string, OpenAPISpecPathItem>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISpecMethodName =\n  | \"get\"\n  | \"put\"\n  | \"post\"\n  | \"delete\"\n  | \"options\"\n  | \"head\"\n  | \"patch\"\n  | \"trace\"\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISpecPathItem = {\n  [K in OpenAPISpecMethodName]?: OpenAPISpecOperation\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecParameter {\n  name: string\n  in: \"query\" | \"header\" | \"path\" | \"cookie\"\n  schema: JsonSchema.JsonSchema\n  required: boolean\n  description?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISpecResponses = Record<number, OpenApiSpecResponse>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenApiSpecContentType =\n  | \"application/json\"\n  | \"application/xml\"\n  | \"application/x-www-form-urlencoded\"\n  | \"multipart/form-data\"\n  | \"text/plain\"\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenApiSpecContent = {\n  [K in OpenApiSpecContentType]?: OpenApiSpecMediaType\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenApiSpecResponse {\n  description: string\n  content?: OpenApiSpecContent\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenApiSpecMediaType {\n  schema: JsonSchema.JsonSchema\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecRequestBody {\n  content: OpenApiSpecContent\n  required: true\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPIComponents {\n  schemas: Record<string, JsonSchema.JsonSchema>\n  securitySchemes: Record<string, OpenAPISecurityScheme>\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPIHTTPSecurityScheme {\n  readonly type: \"http\"\n  scheme: \"bearer\" | \"basic\" | string\n  description?: string\n  /* only for scheme: 'bearer' */\n  bearerFormat?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPIApiKeySecurityScheme {\n  readonly type: \"apiKey\"\n  name: string\n  in: \"query\" | \"header\" | \"cookie\"\n  description?: string\n}\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISecurityScheme =\n  | OpenAPIHTTPSecurityScheme\n  | OpenAPIApiKeySecurityScheme\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport type OpenAPISecurityRequirement = Record<string, Array<string>>\n\n/**\n * @category models\n * @since 1.0.0\n */\nexport interface OpenAPISpecOperation {\n  operationId: string\n  parameters: Array<OpenAPISpecParameter>\n  responses: OpenAPISpecResponses\n  /** Always contains at least the title annotation or the group identifier */\n  tags: NonEmptyArray<string>\n  security: Array<OpenAPISecurityRequirement>\n  requestBody?: OpenAPISpecRequestBody\n  description?: string\n  summary?: string\n  deprecated?: boolean\n  externalDocs?: OpenAPISpecExternalDocs\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Encoding from \"effect/Encoding\"\nimport * as Fiber from \"effect/Fiber\"\nimport { constFalse, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as ManagedRuntime from \"effect/ManagedRuntime\"\nimport * as Option from \"effect/Option\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport type { ReadonlyRecord } from \"effect/Record\"\nimport * as Redacted from \"effect/Redacted\"\nimport * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\nimport type { Scope } from \"effect/Scope\"\nimport type { Covariant, NoInfer } from \"effect/Types\"\nimport { unify } from \"effect/Unify\"\nimport type { Cookie } from \"./Cookies.js\"\nimport type { FileSystem } from \"./FileSystem.js\"\nimport * as HttpApi from \"./HttpApi.js\"\nimport type * as HttpApiEndpoint from \"./HttpApiEndpoint.js\"\nimport { HttpApiDecodeError } from \"./HttpApiError.js\"\nimport type * as HttpApiGroup from \"./HttpApiGroup.js\"\nimport * as HttpApiMiddleware from \"./HttpApiMiddleware.js\"\nimport * as HttpApiSchema from \"./HttpApiSchema.js\"\nimport type * as HttpApiSecurity from \"./HttpApiSecurity.js\"\nimport * as HttpApp from \"./HttpApp.js\"\nimport * as HttpMethod from \"./HttpMethod.js\"\nimport * as HttpMiddleware from \"./HttpMiddleware.js\"\nimport * as HttpRouter from \"./HttpRouter.js\"\nimport * as HttpServer from \"./HttpServer.js\"\nimport * as HttpServerRequest from \"./HttpServerRequest.js\"\nimport * as HttpServerResponse from \"./HttpServerResponse.js\"\nimport * as Multipart from \"./Multipart.js\"\nimport * as OpenApi from \"./OpenApi.js\"\nimport type { Path } from \"./Path.js\"\nimport * as UrlParams from \"./UrlParams.js\"\n\n/**\n * The router that the API endpoints are attached to.\n *\n * @since 1.0.0\n * @category router\n */\nexport class Router extends HttpRouter.Tag(\"@effect/platform/HttpApiBuilder/Router\")<Router>() {}\n\n/**\n * Create a top-level `HttpApi` layer.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const api = <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(\n  api: HttpApi.HttpApi<Id, Groups, E, R>\n): Layer.Layer<\n  HttpApi.Api,\n  never,\n  HttpApiGroup.HttpApiGroup.ToService<Id, Groups> | R | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>\n> =>\n  Layer.effect(\n    HttpApi.Api,\n    Effect.map(Effect.context(), (context) => ({ api: api as any, context }))\n  )\n\n/**\n * Build an `HttpApp` from an `HttpApi` instance, and serve it using an\n * `HttpServer`.\n *\n * Optionally, you can provide a middleware function that will be applied to\n * the `HttpApp` before serving.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const serve = <R = never>(\n  middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, R>\n): Layer.Layer<\n  never,\n  never,\n  | HttpServer.HttpServer\n  | HttpRouter.HttpRouter.DefaultServices\n  | Exclude<R, Scope | HttpServerRequest.HttpServerRequest>\n  | HttpApi.Api\n> =>\n  httpApp.pipe(\n    Effect.map((app) => HttpServer.serve(app as any, middleware!)),\n    Layer.unwrapEffect,\n    Layer.provide([Router.Live, Middleware.layer])\n  )\n\n/**\n * Construct an `HttpApp` from an `HttpApi` instance.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const httpApp: Effect.Effect<\n  HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>,\n  never,\n  Router | HttpApi.Api | Middleware\n> = Effect.gen(function*() {\n  const { api, context } = yield* HttpApi.Api\n  const middleware = makeMiddlewareMap(api.middlewares, context)\n  const router = applyMiddleware(middleware, yield* Router.router)\n  const apiMiddlewareService = yield* Middleware\n  const apiMiddleware = yield* apiMiddlewareService.retrieve\n  const errorSchema = makeErrorSchema(api as any)\n  const encodeError = Schema.encodeUnknown(errorSchema)\n  return router.pipe(\n    apiMiddleware,\n    Effect.catchAllCause((cause) =>\n      Effect.matchEffect(Effect.provide(encodeError(Cause.squash(cause)), context), {\n        onFailure: () => Effect.failCause(cause),\n        onSuccess: Effect.succeed\n      })\n    )\n  ) as any\n})\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const buildMiddleware: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(\n  api: HttpApi.HttpApi<Id, Groups, E, R>\n) => Effect.Effect<\n  (\n    effect: Effect.Effect<HttpServerResponse.HttpServerResponse, unknown>\n  ) => Effect.Effect<HttpServerResponse.HttpServerResponse, unknown, never>\n> = Effect.fnUntraced(\n  function*<Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(\n    api: HttpApi.HttpApi<Id, Groups, E, R>\n  ) {\n    const context = yield* Effect.context<never>()\n    const middlewareMap = makeMiddlewareMap(api.middlewares, context)\n    const errorSchema = makeErrorSchema(api as any)\n    const encodeError = Schema.encodeUnknown(errorSchema)\n    return (effect: Effect.Effect<HttpServerResponse.HttpServerResponse, unknown>) =>\n      Effect.catchAllCause(\n        applyMiddleware(middlewareMap, effect),\n        (cause) =>\n          Effect.matchEffect(Effect.provide(encodeError(Cause.squash(cause)), context), {\n            onFailure: () => Effect.failCause(cause),\n            onSuccess: Effect.succeed\n          })\n      )\n  }\n)\n\n/**\n * Construct an http web handler from an `HttpApi` instance.\n *\n * **Example**\n *\n * ```ts\n * import { HttpApi, HttpApiBuilder, HttpServer } from \"@effect/platform\"\n * import { Layer } from \"effect\"\n *\n * class MyApi extends HttpApi.make(\"api\") {}\n *\n * const MyApiLive = HttpApiBuilder.api(MyApi)\n *\n * const { dispose, handler } = HttpApiBuilder.toWebHandler(\n *   Layer.mergeAll(\n *     MyApiLive,\n *     // you could also use NodeHttpServer.layerContext, depending on your\n *     // server's platform\n *     HttpServer.layerContext\n *   )\n * )\n * ```\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const toWebHandler = <LA, LE>(\n  layer: Layer.Layer<LA | HttpApi.Api | HttpRouter.HttpRouter.DefaultServices, LE>,\n  options?: {\n    readonly middleware?: (\n      httpApp: HttpApp.Default\n    ) => HttpApp.Default<\n      never,\n      HttpApi.Api | Router | HttpRouter.HttpRouter.DefaultServices\n    >\n    readonly memoMap?: Layer.MemoMap\n  }\n): {\n  readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>\n  readonly dispose: () => Promise<void>\n} => {\n  const runtime = ManagedRuntime.make(\n    Layer.mergeAll(layer, Router.Live, Middleware.layer),\n    options?.memoMap\n  )\n  let handlerCached: ((request: Request, context?: Context.Context<never> | undefined) => Promise<Response>) | undefined\n  const handlerPromise = Effect.gen(function*() {\n    const app = yield* httpApp\n    const rt = yield* runtime.runtimeEffect\n    const handler = HttpApp.toWebHandlerRuntime(rt)(options?.middleware ? options.middleware(app as any) as any : app)\n    handlerCached = handler\n    return handler\n  }).pipe(runtime.runPromise)\n  function handler(request: Request, context?: Context.Context<never> | undefined): Promise<Response> {\n    if (handlerCached !== undefined) {\n      return handlerCached(request, context)\n    }\n    return handlerPromise.then((handler) => handler(request, context))\n  }\n  return { handler, dispose: runtime.dispose } as const\n}\n\n/**\n * @since 1.0.0\n * @category handlers\n */\nexport const HandlersTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpApiBuilder/Handlers\")\n\n/**\n * @since 1.0.0\n * @category handlers\n */\nexport type HandlersTypeId = typeof HandlersTypeId\n\n/**\n * Represents a handled `HttpApi`.\n *\n * @since 1.0.0\n * @category handlers\n */\nexport interface Handlers<\n  E,\n  Provides,\n  R,\n  Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never\n> extends Pipeable {\n  readonly [HandlersTypeId]: {\n    _Endpoints: Covariant<Endpoints>\n  }\n  readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps\n  readonly handlers: Chunk.Chunk<Handlers.Item<E, R>>\n\n  /**\n   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.\n   */\n  handle<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(\n    name: Name,\n    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<Endpoints, Name, E, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): Handlers<\n    E,\n    Provides,\n    | R\n    | Exclude<\n      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<\n        Endpoints,\n        Name,\n        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>\n      >,\n      Provides\n    >,\n    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>\n  >\n\n  /**\n   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.\n   * This version of the api allows you to return the full response object.\n   */\n  handleRaw<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(\n    name: Name,\n    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerRawWithName<Endpoints, Name, E, R1>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ): Handlers<\n    E,\n    Provides,\n    | R\n    | Exclude<\n      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<\n        Endpoints,\n        Name,\n        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>\n      >,\n      Provides\n    >,\n    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>\n  >\n}\n\n/**\n * @since 1.0.0\n * @category handlers\n */\nexport declare namespace Handlers {\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export interface Any {\n    readonly [HandlersTypeId]: any\n  }\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type Middleware<E, R, E1, R1> = (self: HttpRouter.Route.Middleware<E, R>) => HttpApp.Default<E1, R1>\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type Item<E, R> = {\n    readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.Any\n    readonly handler: HttpApiEndpoint.HttpApiEndpoint.Handler<any, E, R>\n    readonly withFullRequest: boolean\n    readonly uninterruptible: boolean\n  }\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type FromGroup<\n    ApiError,\n    ApiR,\n    Group extends HttpApiGroup.HttpApiGroup.Any\n  > = Handlers<\n    | ApiError\n    | HttpApiGroup.HttpApiGroup.Error<Group>,\n    | HttpApiMiddleware.HttpApiMiddleware.ExtractProvides<ApiR>\n    | HttpApiGroup.HttpApiGroup.Provides<Group>,\n    never,\n    HttpApiGroup.HttpApiGroup.Endpoints<Group>\n  >\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type ValidateReturn<A> = A extends (\n    | Handlers<\n      infer _E,\n      infer _Provides,\n      infer _R,\n      infer _Endpoints\n    >\n    | Effect.Effect<\n      Handlers<\n        infer _E,\n        infer _Provides,\n        infer _R,\n        infer _Endpoints\n      >,\n      infer _EX,\n      infer _RX\n    >\n  ) ? [_Endpoints] extends [never] ? A\n    : `Endpoint not handled: ${HttpApiEndpoint.HttpApiEndpoint.Name<_Endpoints>}` :\n    `Must return the implemented handlers`\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type Error<A> = A extends Effect.Effect<\n    Handlers<\n      infer _E,\n      infer _Provides,\n      infer _R,\n      infer _Endpoints\n    >,\n    infer _EX,\n    infer _RX\n  > ? _EX :\n    never\n\n  /**\n   * @since 1.0.0\n   * @category handlers\n   */\n  export type Context<A> = A extends Handlers<\n    infer _E,\n    infer _Provides,\n    infer _R,\n    infer _Endpoints\n  > ? _R :\n    A extends Effect.Effect<\n      Handlers<\n        infer _E,\n        infer _Provides,\n        infer _R,\n        infer _Endpoints\n      >,\n      infer _EX,\n      infer _RX\n    > ? _R | _RX :\n    never\n}\n\nconst HandlersProto = {\n  [HandlersTypeId]: {\n    _Endpoints: identity\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  handle(\n    this: Handlers<any, any, any, HttpApiEndpoint.HttpApiEndpoint.Any>,\n    name: string,\n    handler: HttpApiEndpoint.HttpApiEndpoint.Handler<any, any, any>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ) {\n    const endpoint = this.group.endpoints[name]\n    return makeHandlers({\n      group: this.group,\n      handlers: Chunk.append(this.handlers, {\n        endpoint,\n        handler,\n        withFullRequest: false,\n        uninterruptible: options?.uninterruptible ?? false\n      }) as any\n    })\n  },\n  handleRaw(\n    this: Handlers<any, any, any, HttpApiEndpoint.HttpApiEndpoint.Any>,\n    name: string,\n    handler: HttpApiEndpoint.HttpApiEndpoint.Handler<any, any, any>,\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ) {\n    const endpoint = this.group.endpoints[name]\n    return makeHandlers({\n      group: this.group,\n      handlers: Chunk.append(this.handlers, {\n        endpoint,\n        handler,\n        withFullRequest: true,\n        uninterruptible: options?.uninterruptible ?? false\n      }) as any\n    })\n  }\n}\n\nconst makeHandlers = <E, Provides, R, Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any>(\n  options: {\n    readonly group: HttpApiGroup.HttpApiGroup.Any\n    readonly handlers: Chunk.Chunk<Handlers.Item<E, R>>\n  }\n): Handlers<E, Provides, R, Endpoints> => {\n  const self = Object.create(HandlersProto)\n  self.group = options.group\n  self.handlers = options.handlers\n  return self\n}\n\n/**\n * Create a `Layer` that will implement all the endpoints in an `HttpApi`.\n *\n * An unimplemented `Handlers` instance is passed to the `build` function, which\n * you can use to add handlers to the group.\n *\n * You can implement endpoints using the `handlers.handle` api.\n *\n * @since 1.0.0\n * @category handlers\n */\nexport const group = <\n  ApiId extends string,\n  Groups extends HttpApiGroup.HttpApiGroup.Any,\n  ApiError,\n  ApiR,\n  const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>,\n  Return\n>(\n  api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>,\n  groupName: Name,\n  build: (\n    handlers: Handlers.FromGroup<ApiError, ApiR, HttpApiGroup.HttpApiGroup.WithName<Groups, Name>>\n  ) => Handlers.ValidateReturn<Return>\n): Layer.Layer<\n  HttpApiGroup.ApiGroup<ApiId, Name>,\n  Handlers.Error<Return>,\n  Exclude<\n    | Handlers.Context<Return>\n    | HttpApiGroup.HttpApiGroup.MiddlewareWithName<Groups, Name>,\n    Scope\n  >\n> =>\n  Router.use((router) =>\n    Effect.gen(function*() {\n      const context = yield* Effect.context<any>()\n      const group = api.groups[groupName]!\n      const result = build(makeHandlers({ group, handlers: Chunk.empty() }))\n      const handlers: Handlers<any, any, any> = Effect.isEffect(result)\n        ? (yield* result as Effect.Effect<any, any, any>)\n        : result\n      const groupMiddleware = makeMiddlewareMap((group as any).middlewares, context)\n      const routes: Array<HttpRouter.Route<any, any>> = []\n      for (const item of handlers.handlers) {\n        const middleware = makeMiddlewareMap((item as any).endpoint.middlewares, context, groupMiddleware)\n        routes.push(handlerToRoute(\n          item.endpoint,\n          middleware,\n          function(request) {\n            return Effect.mapInputContext(\n              item.handler(request),\n              (input) => Context.merge(context, input)\n            )\n          },\n          item.withFullRequest,\n          item.uninterruptible\n        ))\n      }\n      yield* router.concat(HttpRouter.fromIterable(routes))\n    })\n  ) as any\n\n/**\n * Create a `Handler` for a single endpoint.\n *\n * @since 1.0.0\n * @category handlers\n */\nexport const handler = <\n  ApiId extends string,\n  Groups extends HttpApiGroup.HttpApiGroup.Any,\n  ApiError,\n  ApiR,\n  const GroupName extends Groups[\"identifier\"],\n  const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>[\"name\"],\n  R\n>(\n  _api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>,\n  _groupName: GroupName,\n  _name: Name,\n  f: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<\n    HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>,\n    Name,\n    | ApiError\n    | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>,\n    R\n  >\n): HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<\n  HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>,\n  Name,\n  | ApiError\n  | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>,\n  R\n> => f\n\n// internal\n\nconst requestPayload = (\n  request: HttpServerRequest.HttpServerRequest,\n  urlParams: ReadonlyRecord<string, string | Array<string>>,\n  multipartLimits: Option.Option<Multipart.withLimits.Options>\n): Effect.Effect<\n  unknown,\n  never,\n  | FileSystem\n  | Path\n  | Scope\n> => {\n  if (!HttpMethod.hasBody(request.method)) {\n    return Effect.succeed(urlParams)\n  }\n  const contentType = request.headers[\"content-type\"]\n    ? request.headers[\"content-type\"].toLowerCase().trim()\n    : \"application/json\"\n  if (contentType.includes(\"application/json\")) {\n    return Effect.orDie(request.json)\n  } else if (contentType.includes(\"multipart/form-data\")) {\n    return Effect.orDie(Option.match(multipartLimits, {\n      onNone: () => request.multipart,\n      onSome: (limits) => Multipart.withLimits(request.multipart, limits)\n    }))\n  } else if (contentType.includes(\"x-www-form-urlencoded\")) {\n    return Effect.map(Effect.orDie(request.urlParamsBody), UrlParams.toRecord)\n  } else if (contentType.startsWith(\"text/\")) {\n    return Effect.orDie(request.text)\n  }\n  return Effect.map(Effect.orDie(request.arrayBuffer), (buffer) => new Uint8Array(buffer))\n}\n\ntype MiddlewareMap = Map<string, {\n  readonly tag: HttpApiMiddleware.TagClassAny\n  readonly effect: Effect.Effect<any, any, any>\n}>\n\nconst makeMiddlewareMap = (\n  middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>,\n  context: Context.Context<never>,\n  initial?: MiddlewareMap\n): MiddlewareMap => {\n  const map = new Map<string, {\n    readonly tag: HttpApiMiddleware.TagClassAny\n    readonly effect: Effect.Effect<any, any, any>\n  }>(initial)\n  middleware.forEach((tag) => {\n    map.set(tag.key, {\n      tag,\n      effect: Context.unsafeGet(context, tag as any)\n    })\n  })\n  return map\n}\n\nfunction isSingleStringType(ast: AST.AST, key?: PropertyKey): boolean {\n  switch (ast._tag) {\n    case \"StringKeyword\":\n    case \"Literal\":\n    case \"TemplateLiteral\":\n    case \"Enums\":\n      return true\n    case \"TypeLiteral\": {\n      if (key !== undefined) {\n        const ps = ast.propertySignatures.find((ps) => ps.name === key)\n        return ps !== undefined\n          ? isSingleStringType(ps.type, key)\n          : ast.indexSignatures.some((is) => Schema.is(Schema.make(is.parameter))(key) && isSingleStringType(is.type))\n      }\n      return false\n    }\n    case \"Union\":\n      return ast.types.some((type) => isSingleStringType(type, key))\n    case \"Suspend\":\n      return isSingleStringType(ast.f(), key)\n    case \"Refinement\":\n    case \"Transformation\":\n      return isSingleStringType(ast.from, key)\n  }\n  return false\n}\n\n/**\n * Normalizes the url parameters so that if a key is expected to be an array,\n * a single string value is wrapped in an array.\n *\n * @internal\n */\nexport function normalizeUrlParams(\n  params: ReadonlyRecord<string, string | Array<string>>,\n  ast: AST.AST\n): ReadonlyRecord<string, string | Array<string>> {\n  const out: Record<string, string | Array<string>> = {}\n  for (const key in params) {\n    const value = params[key]\n    out[key] = Array.isArray(value) || isSingleStringType(ast, key) ? value : [value]\n  }\n  return out\n}\n\nconst handlerToRoute = (\n  endpoint_: HttpApiEndpoint.HttpApiEndpoint.Any,\n  middleware: MiddlewareMap,\n  handler: HttpApiEndpoint.HttpApiEndpoint.Handler<any, any, any>,\n  isFullRequest: boolean,\n  uninterruptible: boolean\n): HttpRouter.Route<any, any> => {\n  const endpoint = endpoint_ as HttpApiEndpoint.HttpApiEndpoint.AnyWithProps\n  const isMultipartStream = endpoint.payloadSchema.pipe(\n    Option.map(({ ast }) => HttpApiSchema.getMultipartStream(ast) !== undefined),\n    Option.getOrElse(constFalse)\n  )\n  const multipartLimits = endpoint.payloadSchema.pipe(\n    Option.flatMapNullable(({ ast }) => HttpApiSchema.getMultipart(ast) || HttpApiSchema.getMultipartStream(ast))\n  )\n  const decodePath = Option.map(endpoint.pathSchema, Schema.decodeUnknown)\n  const decodePayload = isFullRequest || isMultipartStream\n    ? Option.none()\n    : Option.map(endpoint.payloadSchema, Schema.decodeUnknown)\n  const decodeHeaders = Option.map(endpoint.headersSchema, Schema.decodeUnknown)\n  const encodeSuccess = Schema.encode(makeSuccessSchema(endpoint.successSchema))\n  return HttpRouter.makeRoute(\n    endpoint.method,\n    endpoint.path,\n    applyMiddleware(\n      middleware,\n      Effect.gen(function*() {\n        const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n        const context = fiber.currentContext\n        const httpRequest = Context.unsafeGet(context, HttpServerRequest.HttpServerRequest)\n        const routeContext = Context.unsafeGet(context, HttpRouter.RouteContext)\n        const urlParams = Context.unsafeGet(context, HttpServerRequest.ParsedSearchParams)\n        const request: any = { request: httpRequest }\n        if (decodePath._tag === \"Some\") {\n          request.path = yield* decodePath.value(routeContext.params)\n        }\n        if (decodePayload._tag === \"Some\") {\n          request.payload = yield* Effect.flatMap(\n            requestPayload(httpRequest, urlParams, multipartLimits),\n            decodePayload.value\n          )\n        } else if (isMultipartStream) {\n          request.payload = Option.match(multipartLimits, {\n            onNone: () => httpRequest.multipartStream,\n            onSome: (limits) => Multipart.withLimitsStream(httpRequest.multipartStream, limits)\n          })\n        }\n        if (decodeHeaders._tag === \"Some\") {\n          request.headers = yield* decodeHeaders.value(httpRequest.headers)\n        }\n        if (endpoint.urlParamsSchema._tag === \"Some\") {\n          const schema = endpoint.urlParamsSchema.value\n          request.urlParams = yield* Schema.decodeUnknown(schema)(normalizeUrlParams(urlParams, schema.ast))\n        }\n        const response = yield* handler(request)\n        return HttpServerResponse.isServerResponse(response) ? response : yield* encodeSuccess(response)\n      }).pipe(\n        Effect.catchIf(ParseResult.isParseError, HttpApiDecodeError.refailParseError)\n      )\n    ),\n    { uninterruptible }\n  )\n}\n\nconst applyMiddleware = <A extends Effect.Effect<any, any, any>>(\n  middleware: MiddlewareMap,\n  handler: A\n) => {\n  for (const entry of middleware.values()) {\n    const effect = HttpApiMiddleware.SecurityTypeId in entry.tag ? makeSecurityMiddleware(entry as any) : entry.effect\n    if (entry.tag.optional) {\n      const previous = handler\n      handler = Effect.matchEffect(effect, {\n        onFailure: () => previous,\n        onSuccess: entry.tag.provides !== undefined\n          ? (value) => Effect.provideService(previous, entry.tag.provides as any, value)\n          : (_) => previous\n      }) as any\n    } else {\n      handler = entry.tag.provides !== undefined\n        ? Effect.provideServiceEffect(handler, entry.tag.provides as any, effect) as any\n        : Effect.zipRight(effect, handler) as any\n    }\n  }\n  return handler\n}\n\nconst securityMiddlewareCache = globalValue<WeakMap<any, Effect.Effect<any, any, any>>>(\n  \"securityMiddlewareCache\",\n  () => new WeakMap()\n)\n\nconst makeSecurityMiddleware = (\n  entry: {\n    readonly tag: HttpApiMiddleware.TagClassSecurityAny\n    readonly effect: Record<string, (_: any) => Effect.Effect<any, any>>\n  }\n): Effect.Effect<any, any, any> => {\n  if (securityMiddlewareCache.has(entry)) {\n    return securityMiddlewareCache.get(entry)!\n  }\n\n  let effect: Effect.Effect<any, any, any> | undefined\n  for (const [key, security] of Object.entries(entry.tag.security)) {\n    const decode = securityDecode(security)\n    const handler = entry.effect[key]\n    const middleware = Effect.flatMap(decode, handler)\n    effect = effect === undefined ? middleware : Effect.catchAll(effect, () => middleware)\n  }\n  if (effect === undefined) {\n    effect = Effect.void\n  }\n  securityMiddlewareCache.set(entry, effect)\n  return effect\n}\n\nconst responseSchema = Schema.declare(HttpServerResponse.isServerResponse)\n\nconst makeSuccessSchema = (\n  schema: Schema.Schema.Any\n): Schema.Schema<unknown, HttpServerResponse.HttpServerResponse> => {\n  const schemas = new Set<Schema.Schema.Any>()\n  HttpApiSchema.deunionize(schemas, schema)\n  return Schema.Union(...Array.from(schemas, toResponseSuccess)) as any\n}\n\nconst makeErrorSchema = (\n  api: HttpApi.HttpApi.AnyWithProps\n): Schema.Schema<unknown, HttpServerResponse.HttpServerResponse> => {\n  const schemas = new Set<Schema.Schema.Any>()\n  HttpApiSchema.deunionize(schemas, api.errorSchema)\n  for (const group of Object.values(api.groups)) {\n    for (const endpoint of Object.values(group.endpoints)) {\n      HttpApiSchema.deunionize(schemas, endpoint.errorSchema)\n    }\n    HttpApiSchema.deunionize(schemas, group.errorSchema)\n  }\n  return Schema.Union(...Array.from(schemas, toResponseError)) as any\n}\n\nconst decodeForbidden = <A>(_: A, __: AST.ParseOptions, ast: AST.Transformation) =>\n  ParseResult.fail(new ParseResult.Forbidden(ast, _, \"Encode only schema\"))\n\nconst toResponseSchema = (getStatus: (ast: AST.AST) => number) => {\n  const cache = new WeakMap<AST.AST, Schema.Schema.All>()\n  const schemaToResponse = (\n    data: any,\n    _: AST.ParseOptions,\n    ast: AST.Transformation\n  ): Effect.Effect<HttpServerResponse.HttpServerResponse, ParseResult.ParseIssue> => {\n    const isEmpty = HttpApiSchema.isVoid(ast.to)\n    const status = getStatus(ast.to)\n    if (isEmpty) {\n      return HttpServerResponse.empty({ status })\n    }\n    const encoding = HttpApiSchema.getEncoding(ast.to)\n    switch (encoding.kind) {\n      case \"Json\": {\n        return Effect.mapError(\n          HttpServerResponse.json(data, {\n            status,\n            contentType: encoding.contentType\n          }),\n          (error) => new ParseResult.Type(ast, error, \"Could not encode to JSON\")\n        )\n      }\n      case \"Text\": {\n        return ParseResult.succeed(HttpServerResponse.text(data as any, {\n          status,\n          contentType: encoding.contentType\n        }))\n      }\n      case \"Uint8Array\": {\n        return ParseResult.succeed(HttpServerResponse.uint8Array(data as any, {\n          status,\n          contentType: encoding.contentType\n        }))\n      }\n      case \"UrlParams\": {\n        return ParseResult.succeed(HttpServerResponse.urlParams(data as any, {\n          status,\n          contentType: encoding.contentType\n        }))\n      }\n    }\n  }\n  return <A, I, R>(schema: Schema.Schema<A, I, R>): Schema.Schema<A, HttpServerResponse.HttpServerResponse, R> => {\n    if (cache.has(schema.ast)) {\n      return cache.get(schema.ast)! as any\n    }\n    const transform = Schema.transformOrFail(responseSchema, schema, {\n      decode: decodeForbidden,\n      encode: schemaToResponse\n    })\n    cache.set(transform.ast, transform)\n    return transform\n  }\n}\n\nconst toResponseSuccess = toResponseSchema(HttpApiSchema.getStatusSuccessAST)\nconst toResponseError = toResponseSchema(HttpApiSchema.getStatusErrorAST)\n\n// ----------------------------------------------------------------------------\n// Global middleware\n// ----------------------------------------------------------------------------\n\n/**\n * @since 1.0.0\n * @category middleware\n */\nexport class Middleware extends Context.Tag(\"@effect/platform/HttpApiBuilder/Middleware\")<\n  Middleware,\n  {\n    readonly add: (middleware: HttpMiddleware.HttpMiddleware) => Effect.Effect<void>\n    readonly retrieve: Effect.Effect<HttpMiddleware.HttpMiddleware>\n  }\n>() {\n  /**\n   * @since 1.0.0\n   */\n  static readonly layer = Layer.sync(Middleware, () => {\n    let middleware: HttpMiddleware.HttpMiddleware = identity\n    return Middleware.of({\n      add: (f) =>\n        Effect.sync(() => {\n          const prev = middleware\n          middleware = (app) => f(prev(app))\n        }),\n      retrieve: Effect.sync(() => middleware)\n    })\n  })\n}\n\n/**\n * @since 1.0.0\n * @category global\n */\nexport type MiddlewareFn<Error, R = HttpRouter.HttpRouter.Provided> = (\n  httpApp: HttpApp.Default\n) => HttpApp.Default<Error, R>\n\nconst middlewareAdd = (\n  middleware: HttpMiddleware.HttpMiddleware\n): Effect.Effect<void, never, Middleware> =>\n  Effect.gen(function*() {\n    const context = yield* Effect.context<never>()\n    const service = yield* Middleware\n    yield* service.add((httpApp) =>\n      Effect.mapInputContext(middleware(httpApp), (input) => Context.merge(context, input))\n    )\n  })\n\nconst middlewareAddNoContext = (\n  middleware: HttpMiddleware.HttpMiddleware\n): Effect.Effect<void, never, Middleware> =>\n  Effect.gen(function*() {\n    const service = yield* Middleware\n    yield* service.add(middleware)\n  })\n\n/**\n * Create an `HttpApi` level middleware `Layer`.\n *\n * @since 1.0.0\n * @category middleware\n */\nexport const middleware: {\n  /**\n   * Create an `HttpApi` level middleware `Layer`.\n   *\n   * @since 1.0.0\n   * @category middleware\n   */\n  <EX = never, RX = never>(\n    middleware: MiddlewareFn<never> | Effect.Effect<MiddlewareFn<never>, EX, RX>,\n    options?: {\n      readonly withContext?: false | undefined\n    }\n  ): Layer.Layer<never, EX, Exclude<RX, Scope>>\n  /**\n   * Create an `HttpApi` level middleware `Layer`.\n   *\n   * @since 1.0.0\n   * @category middleware\n   */\n  <R, EX = never, RX = never>(\n    middleware: MiddlewareFn<never, R> | Effect.Effect<MiddlewareFn<never, R>, EX, RX>,\n    options: {\n      readonly withContext: true\n    }\n  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>\n  /**\n   * Create an `HttpApi` level middleware `Layer`.\n   *\n   * @since 1.0.0\n   * @category middleware\n   */\n  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(\n    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,\n    middleware: MiddlewareFn<NoInfer<Error>> | Effect.Effect<MiddlewareFn<NoInfer<Error>>, EX, RX>,\n    options?: {\n      readonly withContext?: false | undefined\n    }\n  ): Layer.Layer<never, EX, Exclude<RX, Scope>>\n  /**\n   * Create an `HttpApi` level middleware `Layer`.\n   *\n   * @since 1.0.0\n   * @category middleware\n   */\n  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(\n    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,\n    middleware: MiddlewareFn<NoInfer<Error>, R> | Effect.Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>,\n    options: {\n      readonly withContext: true\n    }\n  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>\n} = (\n  ...args: [\n    middleware: MiddlewareFn<any, any> | Effect.Effect<MiddlewareFn<any, any>, any, any>,\n    options?: {\n      readonly withContext?: boolean | undefined\n    } | undefined\n  ] | [\n    api: HttpApi.HttpApi.Any,\n    middleware: MiddlewareFn<any, any> | Effect.Effect<MiddlewareFn<any, any>, any, any>,\n    options?: {\n      readonly withContext?: boolean | undefined\n    } | undefined\n  ]\n): any => {\n  const apiFirst = HttpApi.isHttpApi(args[0])\n  const withContext = apiFirst ? args[2]?.withContext === true : (args as any)[1]?.withContext === true\n  const add = withContext ? middlewareAdd : middlewareAddNoContext\n  const middleware = apiFirst ? args[1] : args[0]\n  return (Effect.isEffect(middleware)\n    ? Layer.scopedDiscard(Effect.flatMap(middleware as any, add))\n    : Layer.scopedDiscard(add(middleware as any))).pipe(Layer.provide(Middleware.layer))\n}\n\n/**\n * A CORS middleware layer that can be provided to the `HttpApiBuilder.serve` layer.\n *\n * @since 1.0.0\n * @category middleware\n */\nexport const middlewareCors = (\n  options?: {\n    readonly allowedOrigins?: ReadonlyArray<string> | undefined\n    readonly allowedMethods?: ReadonlyArray<string> | undefined\n    readonly allowedHeaders?: ReadonlyArray<string> | undefined\n    readonly exposedHeaders?: ReadonlyArray<string> | undefined\n    readonly maxAge?: number | undefined\n    readonly credentials?: boolean | undefined\n  } | undefined\n): Layer.Layer<never> => middleware(HttpMiddleware.cors(options))\n\n/**\n * A middleware that adds an openapi.json endpoint to the API.\n *\n * @since 1.0.0\n * @category middleware\n */\nexport const middlewareOpenApi = (\n  options?: {\n    readonly path?: HttpApiEndpoint.PathSegment | undefined\n    readonly additionalPropertiesStrategy?: OpenApi.AdditionalPropertiesStrategy | undefined\n  } | undefined\n): Layer.Layer<never, never, HttpApi.Api> =>\n  Router.use((router) =>\n    Effect.gen(function*() {\n      const { api } = yield* HttpApi.Api\n      const spec = OpenApi.fromApi(api, {\n        additionalPropertiesStrategy: options?.additionalPropertiesStrategy\n      })\n      const response = yield* HttpServerResponse.json(spec).pipe(\n        Effect.orDie\n      )\n      yield* router.get(options?.path ?? \"/openapi.json\", Effect.succeed(response))\n    })\n  )\n\nconst bearerLen = `Bearer `.length\nconst basicLen = `Basic `.length\n\n/**\n * @since 1.0.0\n * @category security\n */\nexport const securityDecode = <Security extends HttpApiSecurity.HttpApiSecurity>(\n  self: Security\n): Effect.Effect<\n  HttpApiSecurity.HttpApiSecurity.Type<Security>,\n  never,\n  HttpServerRequest.HttpServerRequest | HttpServerRequest.ParsedSearchParams\n> => {\n  switch (self._tag) {\n    case \"Bearer\": {\n      return Effect.map(\n        HttpServerRequest.HttpServerRequest,\n        (request) => Redacted.make((request.headers.authorization ?? \"\").slice(bearerLen)) as any\n      )\n    }\n    case \"ApiKey\": {\n      const key = self.in === \"header\" ? self.key.toLowerCase() : self.key\n      const schema = Schema.Struct({\n        [key]: Schema.String\n      })\n      const decode = unify(\n        self.in === \"query\"\n          ? HttpServerRequest.schemaSearchParams(schema)\n          : self.in === \"cookie\"\n          ? HttpServerRequest.schemaCookies(schema)\n          : HttpServerRequest.schemaHeaders(schema)\n      )\n      return Effect.match(decode, {\n        onFailure: () => Redacted.make(\"\") as any,\n        onSuccess: (match) => Redacted.make(match[key])\n      })\n    }\n    case \"Basic\": {\n      const empty: HttpApiSecurity.HttpApiSecurity.Type<Security> = {\n        username: \"\",\n        password: Redacted.make(\"\")\n      } as any\n      return HttpServerRequest.HttpServerRequest.pipe(\n        Effect.flatMap((request) => Encoding.decodeBase64String((request.headers.authorization ?? \"\").slice(basicLen))),\n        Effect.match({\n          onFailure: () => empty,\n          onSuccess: (header) => {\n            const parts = header.split(\":\")\n            if (parts.length !== 2) {\n              return empty\n            }\n            return {\n              username: parts[0],\n              password: Redacted.make(parts[1])\n            } as any\n          }\n        })\n      )\n    }\n  }\n}\n\n/**\n * Set a cookie from an `HttpApiSecurity.HttpApiKey` instance.\n *\n * You can use this api before returning a response from an endpoint handler.\n *\n * ```ts skip-type-checking\n * handlers.handle(\n *   \"authenticate\",\n *   (_) => HttpApiBuilder.securitySetCookie(security, \"secret123\")\n * )\n * ```\n *\n * @since 1.0.0\n * @category middleware\n */\nexport const securitySetCookie = (\n  self: HttpApiSecurity.ApiKey,\n  value: string | Redacted.Redacted,\n  options?: Cookie[\"options\"]\n): Effect.Effect<void> => {\n  const stringValue = typeof value === \"string\" ? value : Redacted.value(value)\n  return HttpApp.appendPreResponseHandler((_req, response) =>\n    Effect.orDie(\n      HttpServerResponse.setCookie(response, self.key, stringValue, {\n        secure: true,\n        httpOnly: true,\n        ...options\n      })\n    )\n  )\n}\n", "/**\n * @since 1.0.0\n */\nimport * as HttpServerRequest from \"@effect/platform/HttpServerRequest\"\nimport * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\nimport * as Arr from \"effect/Array\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { compose, constant, dual, identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as ManagedRuntime from \"effect/ManagedRuntime\"\nimport * as Option from \"effect/Option\"\nimport * as Scope from \"effect/Scope\"\nimport * as Tracer from \"effect/Tracer\"\nimport type * as Types from \"effect/Types\"\nimport * as FindMyWay from \"find-my-way-ts\"\nimport type * as Etag from \"./Etag.js\"\nimport type { FileSystem } from \"./FileSystem.js\"\nimport type * as HttpApi from \"./HttpApi.js\"\nimport * as HttpApiBuilder from \"./HttpApiBuilder.js\"\nimport type * as HttpApiGroup from \"./HttpApiGroup.js\"\nimport * as HttpApp from \"./HttpApp.js\"\nimport type * as HttpMethod from \"./HttpMethod.js\"\nimport * as HttpMiddleware from \"./HttpMiddleware.js\"\nimport type { HttpPlatform } from \"./HttpPlatform.js\"\nimport { RouteContext, RouteContextTypeId } from \"./HttpRouter.js\"\nimport * as HttpServer from \"./HttpServer.js\"\nimport * as HttpServerError from \"./HttpServerError.js\"\nimport * as OpenApi from \"./OpenApi.js\"\nimport type { Path } from \"./Path.js\"\n\n/**\n * @since 1.0.0\n * @category Re-exports\n */\nexport * as FindMyWay from \"find-my-way-ts\"\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/platform/HttpLayerRouter/HttpRouter\")\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport interface HttpRouter {\n  readonly [TypeId]: TypeId\n\n  readonly prefixed: (prefix: string) => HttpRouter\n\n  readonly add: <E, R>(\n    method: \"*\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\",\n    path: PathInput,\n    handler:\n      | Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n      | ((request: HttpServerRequest.HttpServerRequest) => Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>),\n    options?: { readonly uninterruptible?: boolean | undefined } | undefined\n  ) => Effect.Effect<\n    void,\n    never,\n    Request.From<\"Requires\", Exclude<R, Provided>> | Request.From<\"Error\", E>\n  >\n\n  readonly addAll: <const Routes extends ReadonlyArray<Route<any, any>>>(\n    routes: Routes\n  ) => Effect.Effect<\n    void,\n    never,\n    | Request.From<\"Requires\", Exclude<Route.Context<Routes[number]>, Provided>>\n    | Request.From<\"Error\", Route.Error<Routes[number]>>\n  >\n\n  readonly addGlobalMiddleware: <E, R>(\n    middleware:\n      & ((\n        effect: Effect.Effect<HttpServerResponse.HttpServerResponse, unhandled>\n      ) => Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>)\n      & (unhandled extends E ? unknown : \"You cannot handle any errors\")\n  ) => Effect.Effect<\n    void,\n    never,\n    | Request.From<\"GlobalRequires\", Exclude<R, GlobalProvided>>\n    | Request.From<\"GlobalError\", Exclude<E, unhandled>>\n  >\n\n  readonly asHttpEffect: () => Effect.Effect<\n    HttpServerResponse.HttpServerResponse,\n    unknown,\n    HttpServerRequest.HttpServerRequest | Scope.Scope\n  >\n}\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const HttpRouter: Context.Tag<HttpRouter, HttpRouter> = Context.GenericTag<HttpRouter>(\n  \"@effect/platform/HttpLayerRouter\"\n)\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const make = Effect.gen(function*() {\n  const router = FindMyWay.make<Route<any, never>>(yield* RouterConfig)\n  const middleware = new Set<middleware.Fn>()\n\n  const addAll = <const Routes extends ReadonlyArray<Route<any, any>>>(\n    routes: Routes\n  ): Effect.Effect<\n    void,\n    never,\n    | Request.From<\"Requires\", Exclude<Route.Context<Routes[number]>, Provided>>\n    | Request.From<\"Error\", Route.Error<Routes[number]>>\n  > =>\n    Effect.contextWith((context: Context.Context<never>) => {\n      const middleware = getMiddleware(context)\n      const applyMiddleware = (effect: Effect.Effect<HttpServerResponse.HttpServerResponse>) => {\n        for (let i = 0; i < middleware.length; i++) {\n          effect = middleware[i](effect)\n        }\n        return effect\n      }\n      for (let i = 0; i < routes.length; i++) {\n        const route = middleware.length === 0 ? routes[i] : makeRoute({\n          ...routes[i],\n          handler: applyMiddleware(routes[i].handler as Effect.Effect<HttpServerResponse.HttpServerResponse>)\n        })\n        if (route.method === \"*\") {\n          router.all(route.path, route as any)\n        } else {\n          router.on(route.method, route.path, route as any)\n        }\n      }\n    })\n\n  return HttpRouter.of({\n    [TypeId]: TypeId,\n    prefixed(this: HttpRouter, prefix: string) {\n      return HttpRouter.of({\n        ...this,\n        prefixed: (newPrefix: string) => this.prefixed(prefixPath(prefix, newPrefix)),\n        addAll: (routes) => addAll(routes.map(prefixRoute(prefix))) as any,\n        add: (method, path, handler, options) =>\n          addAll([\n            makeRoute({\n              method,\n              path: prefixPath(path, prefix) as PathInput,\n              handler: Effect.isEffect(handler)\n                ? handler\n                : Effect.flatMap(HttpServerRequest.HttpServerRequest, handler),\n              uninterruptible: options?.uninterruptible ?? false,\n              prefix: Option.some(prefix)\n            })\n          ])\n      })\n    },\n    addAll,\n    add: (method, path, handler, options) => addAll([route(method, path, handler, options)]),\n    addGlobalMiddleware: (middleware_) =>\n      Effect.sync(() => {\n        middleware.add(middleware_ as any)\n      }),\n    asHttpEffect() {\n      let handler = Effect.withFiberRuntime<HttpServerResponse.HttpServerResponse, unknown>((fiber) => {\n        const contextMap = new Map(fiber.currentContext.unsafeMap)\n        const request = contextMap.get(HttpServerRequest.HttpServerRequest.key) as HttpServerRequest.HttpServerRequest\n        let result = router.find(request.method, request.url)\n        if (result === undefined && request.method === \"HEAD\") {\n          result = router.find(\"GET\", request.url)\n        }\n        if (result === undefined) {\n          return Effect.fail(new HttpServerError.RouteNotFound({ request }))\n        }\n        const route = result.handler\n        if (route.prefix._tag === \"Some\") {\n          contextMap.set(HttpServerRequest.HttpServerRequest.key, sliceRequestUrl(request, route.prefix.value))\n        }\n        contextMap.set(HttpServerRequest.ParsedSearchParams.key, result.searchParams)\n        contextMap.set(RouteContext.key, {\n          [RouteContextTypeId]: RouteContextTypeId,\n          route,\n          params: result.params\n        })\n\n        const span = contextMap.get(Tracer.ParentSpan.key) as Tracer.Span | undefined\n        if (span && span._tag === \"Span\") {\n          span.attribute(\"http.route\", route.path)\n        }\n        return Effect.locally(\n          (route.uninterruptible ?\n            route.handler :\n            Effect.interruptible(route.handler)) as Effect.Effect<\n              HttpServerResponse.HttpServerResponse,\n              unknown\n            >,\n          FiberRef.currentContext,\n          Context.unsafeMake(contextMap)\n        )\n      })\n      if (middleware.size === 0) return handler\n      for (const fn of Arr.reverse(middleware)) {\n        handler = fn(handler as any)\n      }\n      return handler\n    }\n  })\n})\n\nfunction sliceRequestUrl(request: HttpServerRequest.HttpServerRequest, prefix: string) {\n  const prefexLen = prefix.length\n  return request.modify({ url: request.url.length <= prefexLen ? \"/\" : request.url.slice(prefexLen) })\n}\n\n/**\n * @since 1.0.0\n * @category Configuration\n */\nexport class RouterConfig extends Context.Reference<RouterConfig>()(\"@effect/platform/HttpLayerRouter/RouterConfig\", {\n  defaultValue: constant<Partial<FindMyWay.RouterConfig>>({})\n}) {}\n\nexport {\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  params,\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  RouteContext,\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  schemaJson,\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  schemaNoBody,\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  schemaParams,\n  /**\n   * @since 1.0.0\n   * @category Route context\n   */\n  schemaPathParams\n} from \"./HttpRouter.js\"\n\n/**\n * A helper function that is the equivalent of:\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n *\n * const MyRoute = Layer.scopedDiscard(Effect.gen(function*() {\n *   const router = yield* HttpLayerRouter.HttpRouter\n *\n *   // then use `yield* router.add(...)` to add a route\n * }))\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const use = <A, E, R>(\n  f: (router: HttpRouter) => Effect.Effect<A, E, R>\n): Layer.Layer<never, E, HttpRouter | Exclude<R, Scope.Scope>> => Layer.scopedDiscard(Effect.flatMap(HttpRouter, f))\n\n/**\n * Create a layer that adds a single route to the HTTP router.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n *\n * const Route = HttpLayerRouter.add(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\"))\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const add = <E, R>(\n  method: \"*\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\",\n  path: PathInput,\n  handler:\n    | Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n    | ((request: HttpServerRequest.HttpServerRequest) => Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>),\n  options?: {\n    readonly uninterruptible?: boolean | undefined\n  }\n): Layer.Layer<never, never, HttpRouter | Request.From<\"Requires\", Exclude<R, Provided>> | Request.From<\"Error\", E>> =>\n  use((router) => router.add(method, path, handler, options))\n\n/**\n * Create a layer that adds multiple routes to the HTTP router.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n *\n * const Routes = HttpLayerRouter.addAll([\n *   HttpLayerRouter.route(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\"))\n * ])\n * ```\n *\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const addAll = <Routes extends ReadonlyArray<Route<any, any>>, EX = never, RX = never>(\n  routes: Routes | Effect.Effect<Routes, EX, RX>,\n  options?: {\n    readonly prefix?: string | undefined\n  }\n): Layer.Layer<\n  never,\n  EX,\n  | HttpRouter\n  | Exclude<RX, Scope.Scope>\n  | Request.From<\"Requires\", Exclude<Route.Context<Routes[number]>, Provided>>\n  | Request.From<\"Error\", Route.Error<Routes[number]>>\n> =>\n  Layer.scopedDiscard(Effect.gen(function*() {\n    const toAdd = Effect.isEffect(routes) ? yield* routes : routes\n    let router = yield* HttpRouter\n    if (options?.prefix) {\n      router = router.prefixed(options.prefix)\n    }\n    yield* router.addAll(toAdd)\n  }))\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const layer: Layer.Layer<HttpRouter> = Layer.effect(HttpRouter, make)\n\n/**\n * @since 1.0.0\n * @category HttpRouter\n */\nexport const toHttpEffect = <A, E, R>(\n  appLayer: Layer.Layer<A, E, R>\n): Effect.Effect<\n  Effect.Effect<\n    HttpServerResponse.HttpServerResponse,\n    Request.Only<\"Error\", R> | Request.Only<\"GlobalRequires\", R> | HttpServerError.RouteNotFound,\n    Scope.Scope | HttpServerRequest.HttpServerRequest | Request.Only<\"Requires\", R> | Request.Only<\"GlobalRequires\", R>\n  >,\n  Request.Without<E>,\n  Exclude<Request.Without<R>, HttpRouter> | Scope.Scope\n> =>\n  Effect.gen(function*() {\n    const scope = yield* Effect.scope\n    const memoMap = yield* Layer.CurrentMemoMap\n    const context = yield* Layer.buildWithMemoMap(\n      Layer.provideMerge(appLayer, layer),\n      memoMap,\n      scope\n    )\n    const router = Context.get(context, HttpRouter)\n    return router.asHttpEffect()\n  }) as any\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const RouteTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpLayerRouter/Route\")\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport type RouteTypeId = typeof RouteTypeId\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport interface Route<E = never, R = never> {\n  readonly [RouteTypeId]: RouteTypeId\n  readonly method: HttpMethod.HttpMethod | \"*\"\n  readonly path: PathInput\n  readonly handler: Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n  readonly uninterruptible: boolean\n  readonly prefix: Option.Option<string>\n}\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport declare namespace Route {\n  /**\n   * @since 1.0.0\n   * @category Route\n   */\n  export type Error<R extends Route<any, any>> = R extends Route<infer E, infer _R> ? E : never\n\n  /**\n   * @since 1.0.0\n   * @category Route\n   */\n  export type Context<T extends Route<any, any>> = T extends Route<infer _E, infer R> ? R : never\n}\n\nconst makeRoute = <E, R>(options: {\n  readonly method: HttpMethod.HttpMethod | \"*\"\n  readonly path: PathInput\n  readonly handler: Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n  readonly uninterruptible?: boolean | undefined\n  readonly prefix?: Option.Option<string> | undefined\n}): Route<E, Exclude<R, Provided>> =>\n  (({\n    ...options,\n    uninterruptible: options.uninterruptible ?? false,\n    prefix: options.prefix ?? Option.none(),\n    [RouteTypeId]: RouteTypeId\n  }) as Route<E, Exclude<R, Provided>>)\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const route = <E, R>(\n  method: \"*\" | \"GET\" | \"POST\" | \"PUT\" | \"PATCH\" | \"DELETE\" | \"OPTIONS\",\n  path: PathInput,\n  handler:\n    | Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>\n    | ((request: HttpServerRequest.HttpServerRequest) => Effect.Effect<HttpServerResponse.HttpServerResponse, E, R>),\n  options?: {\n    readonly uninterruptible?: boolean | undefined\n  }\n): Route<E, Exclude<R, Provided>> =>\n  makeRoute({\n    ...options,\n    method,\n    path,\n    handler: Effect.isEffect(handler) ? handler : Effect.flatMap(HttpServerRequest.HttpServerRequest, handler),\n    uninterruptible: options?.uninterruptible ?? false\n  })\n\n/**\n * @since 1.0.0\n * @category PathInput\n */\nexport type PathInput = `/${string}` | \"*\"\n\nconst removeTrailingSlash = (\n  path: PathInput\n): PathInput => (path.endsWith(\"/\") ? path.slice(0, -1) : path) as any\n\n/**\n * @since 1.0.0\n * @category PathInput\n */\nexport const prefixPath: {\n  /**\n   * @since 1.0.0\n   * @category PathInput\n   */\n  (prefix: string): (self: string) => string\n  /**\n   * @since 1.0.0\n   * @category PathInput\n   */\n  (self: string, prefix: string): string\n} = dual(2, (self: string, prefix: string) => {\n  prefix = removeTrailingSlash(prefix as PathInput)\n  return self === \"/\" ? prefix : prefix + self\n})\n\n/**\n * @since 1.0.0\n * @category Route\n */\nexport const prefixRoute: {\n  /**\n   * @since 1.0.0\n   * @category Route\n   */\n  (prefix: string): <E, R>(self: Route<E, R>) => Route<E, R>\n  /**\n   * @since 1.0.0\n   * @category Route\n   */\n  <E, R>(self: Route<E, R>, prefix: string): Route<E, R>\n} = dual(2, <E, R>(self: Route<E, R>, prefix: string): Route<E, R> =>\n  makeRoute({\n    ...self,\n    path: prefixPath(self.path, prefix) as PathInput,\n    prefix: Option.match(self.prefix, {\n      onNone: () => Option.some(prefix as string),\n      onSome: (existingPrefix) => Option.some(prefixPath(existingPrefix, prefix) as string)\n    })\n  }))\n\n/**\n * Represents a request-level dependency, that needs to be provided by\n * middleware.\n *\n * @since 1.0.0\n * @category Request types\n */\nexport interface Request<Kind extends string, T> {\n  readonly _: unique symbol\n  readonly kind: Kind\n  readonly type: T\n}\n\n/**\n * @since 1.0.0\n * @category Request types\n */\nexport declare namespace Request {\n  /**\n   * @since 1.0.0\n   * @category Request types\n   */\n  export type From<Kind extends string, R> = R extends infer T ? Request<Kind, T> : never\n\n  /**\n   * @since 1.0.0\n   * @category Request types\n   */\n  export type Only<Kind extends string, A> = A extends Request<Kind, infer T> ? T : never\n\n  /**\n   * @since 1.0.0\n   * @category Request types\n   */\n  export type Without<A> = A extends Request<infer _Kind, infer _> ? never : A\n}\n\n/**\n * Services provided by the HTTP router, which are available in the\n * request context.\n *\n * @since 1.0.0\n * @category Request types\n */\nexport type Provided =\n  | HttpServerRequest.HttpServerRequest\n  | Scope.Scope\n  | HttpServerRequest.ParsedSearchParams\n  | RouteContext\n\n/**\n * Services provided to global middleware.\n *\n * @since 1.0.0\n * @category Request types\n */\nexport type GlobalProvided =\n  | HttpServerRequest.HttpServerRequest\n  | Scope.Scope\n\n/**\n * @since 1.0.0\n * @category Middleware\n */\nexport const MiddlewareTypeId: unique symbol = Symbol.for(\"@effect/platform/HttpLayerRouter/Middleware\")\n\n/**\n * @since 1.0.0\n * @category Middleware\n */\nexport type MiddlewareTypeId = typeof MiddlewareTypeId\n\n/**\n * A pseudo-error type that represents an error that should be not handled by\n * the middleware.\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport interface unhandled {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category Middleware\n */\nexport interface Middleware<\n  Config extends {\n    provides: any\n    handles: any\n    error: any\n    requires: any\n    layerError: any\n    layerRequires: any\n  }\n> {\n  readonly [MiddlewareTypeId]: Config\n\n  readonly layer: [Config[\"requires\"]] extends [never] ? Layer.Layer<\n      Request.From<\"Requires\", Config[\"provides\"]>,\n      Config[\"layerError\"],\n      | Config[\"layerRequires\"]\n      | Request.From<\"Requires\", Config[\"requires\"]>\n      | Request.From<\"Error\", Config[\"error\"]>\n    >\n    : \"Need to .combine(middleware) that satisfy the missing request dependencies\"\n\n  readonly combine: <\n    Config2 extends {\n      provides: any\n      handles: any\n      error: any\n      requires: any\n      layerError: any\n      layerRequires: any\n    }\n  >(other: Middleware<Config2>) => Middleware<{\n    provides: Config2[\"provides\"] | Config[\"provides\"]\n    handles: Config2[\"handles\"] | Config[\"handles\"]\n    error: Config2[\"error\"] | Exclude<Config[\"error\"], Config2[\"handles\"]>\n    requires: Exclude<Config[\"requires\"], Config2[\"provides\"]> | Config2[\"requires\"]\n    layerError: Config[\"layerError\"] | Config2[\"layerError\"]\n    layerRequires: Config[\"layerRequires\"] | Config2[\"layerRequires\"]\n  }>\n}\n\n/**\n * Create a middleware layer that can be used to modify requests and responses.\n *\n * By default, the middleware only affects the routes that it is provided to.\n *\n * If you want to create a middleware that applies globally to all routes, pass\n * the `global` option as `true`.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpMiddleware from \"@effect/platform/HttpMiddleware\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n * import * as Context from \"effect/Context\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n *\n * // Here we are defining a CORS middleware\n * const CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors()).layer\n * // You can also use HttpLayerRouter.cors() to create a CORS middleware\n *\n * class CurrentSession extends Context.Tag(\"CurrentSession\")<CurrentSession, {\n *   readonly token: string\n * }>() {}\n *\n * // You can create middleware that provides a service to the HTTP requests.\n * const SessionMiddleware = HttpLayerRouter.middleware<{\n *   provides: CurrentSession\n * }>()(\n *   Effect.gen(function*() {\n *     yield* Effect.log(\"SessionMiddleware initialized\")\n *\n *     return (httpEffect) =>\n *       Effect.provideService(httpEffect, CurrentSession, {\n *         token: \"dummy-token\"\n *       })\n *   })\n * ).layer\n *\n * Effect.gen(function*() {\n *   const router = yield* HttpLayerRouter.HttpRouter\n *   yield* router.add(\n *     \"GET\",\n *     \"/hello\",\n *     Effect.gen(function*() {\n *       // Requests can now access the current session\n *       const session = yield* CurrentSession\n *       return HttpServerResponse.text(`Hello, World! Your token is ${session.token}`)\n *     })\n *   )\n * }).pipe(\n *   Layer.effectDiscard,\n *   // Provide the SessionMiddleware & CorsMiddleware to some routes\n *   Layer.provide([SessionMiddleware, CorsMiddleware])\n * )\n * ```\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const middleware:\n  & middleware.Make<never, never>\n  & (<\n    Config extends {\n      provides?: any\n      handles?: any\n    } = {}\n  >() => middleware.Make<\n    Config extends { provides: infer R } ? R : never,\n    Config extends { handles: infer E } ? E : never\n  >) = function() {\n    if (arguments.length === 0) {\n      return makeMiddleware as any\n    }\n    return makeMiddleware(arguments[0], arguments[1]) as any\n  }\n\nconst makeMiddleware = (middleware: any, options?: {\n  readonly global?: boolean | undefined\n}) =>\n  options?.global ?\n    Layer.scopedDiscard(Effect.gen(function*() {\n      const router = yield* HttpRouter\n      const fn = Effect.isEffect(middleware) ? yield* middleware : middleware\n      yield* router.addGlobalMiddleware(fn)\n    }))\n    : new MiddlewareImpl(\n      Effect.isEffect(middleware) ?\n        Layer.scopedContext(Effect.map(middleware, (fn) => Context.unsafeMake(new Map([[fnContextKey, fn]])))) :\n        Layer.succeedContext(Context.unsafeMake(new Map([[fnContextKey, middleware]]))) as any\n    )\n\nlet middlewareId = 0\nconst fnContextKey = \"@effect/platform/HttpLayerRouter/MiddlewareFn\"\n\nclass MiddlewareImpl<\n  Config extends {\n    provides: any\n    handles: any\n    error: any\n    requires: any\n    layerError: any\n    layerRequires: any\n  }\n> implements Middleware<Config> {\n  readonly [MiddlewareTypeId]: Config = {} as any\n\n  constructor(\n    readonly layerFn: Layer.Layer<never>,\n    readonly dependencies?: Layer.Layer<any, any, any>\n  ) {\n    const contextKey = `@effect/platform/HttpLayerRouter/Middleware-${++middlewareId}` as const\n    this.layer = Layer.scopedContext(Effect.gen(this, function*() {\n      const context = yield* Effect.context<Scope.Scope>()\n      const stack = [context.unsafeMap.get(fnContextKey)]\n      if (this.dependencies) {\n        const memoMap = yield* Layer.CurrentMemoMap\n        const scope = Context.get(context, Scope.Scope)\n        const depsContext = yield* Layer.buildWithMemoMap(this.dependencies, memoMap, scope)\n        // eslint-disable-next-line no-restricted-syntax\n        stack.push(...getMiddleware(depsContext))\n      }\n      return Context.unsafeMake<never>(new Map([[contextKey, stack]]))\n    })).pipe(Layer.provide(this.layerFn))\n  }\n\n  layer: any\n\n  combine<\n    Config2 extends {\n      provides: any\n      handles: any\n      error: any\n      requires: any\n      layerError: any\n      layerRequires: any\n    }\n  >(other: Middleware<Config2>): Middleware<any> {\n    return new MiddlewareImpl(\n      this.layerFn,\n      this.dependencies ? Layer.provideMerge(this.dependencies, other.layer as any) : other.layer as any\n    ) as any\n  }\n}\n\nconst middlewareCache = new WeakMap<Context.Context<never>, any>()\nconst getMiddleware = (context: Context.Context<never>): Array<middleware.Fn> => {\n  let arr = middlewareCache.get(context)\n  if (arr) return arr\n  const topLevel = Arr.empty<Array<middleware.Fn>>()\n  let maxLength = 0\n  for (const [key, value] of context.unsafeMap) {\n    if (key.startsWith(\"@effect/platform/HttpLayerRouter/Middleware-\")) {\n      topLevel.push(value)\n      if (value.length > maxLength) {\n        maxLength = value.length\n      }\n    }\n  }\n  if (topLevel.length === 0) {\n    arr = []\n  } else {\n    const middleware = new Set<middleware.Fn>()\n    for (let i = maxLength - 1; i >= 0; i--) {\n      for (const arr of topLevel) {\n        if (i < arr.length) {\n          middleware.add(arr[i])\n        }\n      }\n    }\n    arr = Arr.fromIterable(middleware).reverse()\n  }\n  middlewareCache.set(context, arr)\n  return arr\n}\n\n/**\n * @since 1.0.0\n * @category Middleware\n */\nexport declare namespace middleware {\n  /**\n   * @since 1.0.0\n   * @category Middleware\n   */\n  export type Make<Provides = never, Handles = never> = {\n    <E, R, EX, RX, const Global extends boolean = false>(\n      middleware: Effect.Effect<\n        (\n          effect: Effect.Effect<\n            HttpServerResponse.HttpServerResponse,\n            Types.NoInfer<Handles | unhandled>,\n            Types.NoInfer<Provides>\n          >\n        ) =>\n          & Effect.Effect<\n            HttpServerResponse.HttpServerResponse,\n            E,\n            R\n          >\n          & (unhandled extends E ? unknown : \"You must only handle the configured errors\"),\n        EX,\n        RX\n      >,\n      options?: {\n        readonly global?: Global | undefined\n      }\n    ): Global extends true ? Layer.Layer<\n        | Request.From<\"Requires\", Provides>\n        | Request.From<\"Error\", Handles>\n        | Request.From<\"GlobalRequires\", Provides>\n        | Request.From<\"GlobalError\", Handles>,\n        EX,\n        | HttpRouter\n        | Exclude<RX, Scope.Scope>\n        | Request.From<\"GlobalRequires\", Exclude<R, GlobalProvided>>\n        | Request.From<\"GlobalError\", Exclude<E, unhandled>>\n      > :\n      Middleware<{\n        provides: Provides\n        handles: Handles\n        error: Exclude<E, unhandled>\n        requires: Exclude<R, Provided>\n        layerError: EX\n        layerRequires: Exclude<RX, Scope.Scope>\n      }>\n    <E, R, const Global extends boolean = false>(\n      middleware:\n        & ((\n          effect: Effect.Effect<\n            HttpServerResponse.HttpServerResponse,\n            Types.NoInfer<Handles | unhandled>,\n            Types.NoInfer<Provides>\n          >\n        ) => Effect.Effect<\n          HttpServerResponse.HttpServerResponse,\n          E,\n          R\n        >)\n        & (unhandled extends E ? unknown : \"You must only handle the configured errors\"),\n      options?: {\n        readonly global?: Global | undefined\n      }\n    ): Global extends true ? Layer.Layer<\n        | Request.From<\"Requires\", Provides>\n        | Request.From<\"Error\", Handles>\n        | Request.From<\"GlobalRequires\", Provides>\n        | Request.From<\"GlobalError\", Handles>,\n        never,\n        | HttpRouter\n        | Request.From<\"GlobalRequires\", Exclude<R, GlobalProvided>>\n        | Request.From<\"GlobalError\", Exclude<E, unhandled>>\n      > :\n      Middleware<{\n        provides: Provides\n        handles: Handles\n        error: Exclude<E, unhandled>\n        requires: Exclude<R, Provided>\n        layerError: never\n        layerRequires: never\n      }>\n  }\n\n  /**\n   * @since 1.0.0\n   * @category Middleware\n   */\n  export type Fn = (\n    effect: Effect.Effect<HttpServerResponse.HttpServerResponse>\n  ) => Effect.Effect<HttpServerResponse.HttpServerResponse>\n}\n\n/**\n * A middleware that applies CORS headers to the HTTP response.\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const cors = (\n  options?: {\n    readonly allowedOrigins?: ReadonlyArray<string> | undefined\n    readonly allowedMethods?: ReadonlyArray<string> | undefined\n    readonly allowedHeaders?: ReadonlyArray<string> | undefined\n    readonly exposedHeaders?: ReadonlyArray<string> | undefined\n    readonly maxAge?: number | undefined\n    readonly credentials?: boolean | undefined\n  } | undefined\n): Layer.Layer<never, never, HttpRouter> => middleware(HttpMiddleware.cors(options), { global: true })\n\n/**\n * A middleware that disables the logger for some routes.\n *\n * ```ts\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\n * import * as Layer from \"effect/Layer\"\n *\n * const Route = HttpLayerRouter.add(\"GET\", \"/hello\", HttpServerResponse.text(\"Hello, World!\")).pipe(\n *   // disable the logger for this route\n *   Layer.provide(HttpLayerRouter.disableLogger)\n * )\n * ```\n *\n * @since 1.0.0\n * @category Middleware\n */\nexport const disableLogger: Layer.Layer<never> = middleware(HttpMiddleware.withLoggerDisabled).layer\n\n/**\n * ```ts\n * import * as NodeHttpServer from \"@effect/platform-node/NodeHttpServer\"\n * import * as NodeRuntime from \"@effect/platform-node/NodeRuntime\"\n * import * as HttpApi from \"@effect/platform/HttpApi\"\n * import * as HttpApiBuilder from \"@effect/platform/HttpApiBuilder\"\n * import * as HttpApiEndpoint from \"@effect/platform/HttpApiEndpoint\"\n * import * as HttpApiGroup from \"@effect/platform/HttpApiGroup\"\n * import * as HttpApiScalar from \"@effect/platform/HttpApiScalar\"\n * import * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\n * import * as HttpMiddleware from \"@effect/platform/HttpMiddleware\"\n * import * as Effect from \"effect/Effect\"\n * import * as Layer from \"effect/Layer\"\n * import { createServer } from \"http\"\n *\n * // First, we define our HttpApi\n * class MyApi extends HttpApi.make(\"api\").add(\n *   HttpApiGroup.make(\"users\").add(\n *     HttpApiEndpoint.get(\"me\", \"/me\")\n *   ).prefix(\"/users\")\n * ) {}\n *\n * // Implement the handlers for the API\n * const UsersApiLayer = HttpApiBuilder.group(MyApi, \"users\", (handers) => handers.handle(\"me\", () => Effect.void))\n *\n * // Use `HttpLayerRouter.addHttpApi` to register the API with the router\n * const HttpApiRoutes = HttpLayerRouter.addHttpApi(MyApi, {\n *   openapiPath: \"/docs/openapi.json\"\n * }).pipe(\n *   // Provide the api handlers layer\n *   Layer.provide(UsersApiLayer)\n * )\n *\n * // Create a /docs route for the API documentation\n * const DocsRoute = HttpApiScalar.layerHttpLayerRouter({\n *   api: MyApi,\n *   path: \"/docs\"\n * })\n *\n * const CorsMiddleware = HttpLayerRouter.middleware(HttpMiddleware.cors())\n * // You can also use HttpLayerRouter.cors() to create a CORS middleware\n *\n * // Finally, we merge all routes and serve them using the Node HTTP server\n * const AllRoutes = Layer.mergeAll(\n *   HttpApiRoutes,\n *   DocsRoute\n * ).pipe(\n *   Layer.provide(CorsMiddleware.layer)\n * )\n *\n * HttpLayerRouter.serve(AllRoutes).pipe(\n *   Layer.provide(NodeHttpServer.layer(createServer, { port: 3000 })),\n *   Layer.launch,\n *   NodeRuntime.runMain\n * )\n * ```\n *\n * @since 1.0.0\n * @category HttpApi\n */\nexport const addHttpApi = <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(\n  api: HttpApi.HttpApi<Id, Groups, E, R>,\n  options?: {\n    readonly openapiPath?: `/${string}` | undefined\n  }\n): Layer.Layer<\n  never,\n  never,\n  | Etag.Generator\n  | HttpRouter\n  | FileSystem\n  | HttpPlatform\n  | Path\n  | R\n  | HttpApiGroup.HttpApiGroup.ToService<Id, Groups>\n  | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>\n> => {\n  const ApiMiddleware = middleware(HttpApiBuilder.buildMiddleware(api)).layer as Layer.Layer<never>\n  return HttpApiBuilder.Router.unwrap(Effect.fnUntraced(function*(router_) {\n    const router = yield* HttpRouter\n    const context = yield* Effect.context<\n      | Etag.Generator\n      | HttpRouter\n      | FileSystem\n      | HttpPlatform\n      | Path\n    >()\n    const routes = Arr.empty<Route<any, any>>()\n    for (const route of router_.routes) {\n      routes.push(makeRoute({\n        ...route as any,\n        handler: Effect.provide(route.handler, context)\n      }))\n    }\n\n    yield* (router.addAll(routes) as Effect.Effect<void>)\n\n    if (options?.openapiPath) {\n      const spec = OpenApi.fromApi(api)\n      yield* router.add(\"GET\", options.openapiPath, Effect.succeed(HttpServerResponse.unsafeJson(spec)))\n    }\n  }, Layer.effectDiscard)).pipe(\n    Layer.provide(ApiMiddleware)\n  )\n}\n\n/**\n * Serves the provided application layer as an HTTP server.\n *\n * @since 1.0.0\n * @category Server\n */\nexport const serve = <A, E, R, HE, HR = Request.Only<\"Requires\", R> | Request.Only<\"GlobalRequires\", R>>(\n  appLayer: Layer.Layer<A, E, R>,\n  options?: {\n    readonly routerConfig?: Partial<FindMyWay.RouterConfig> | undefined\n    readonly disableLogger?: boolean | undefined\n    readonly disableListenLog?: boolean\n    /**\n     * Middleware to apply to the HTTP server.\n     *\n     * NOTE: This middleware is applied to the entire HTTP server chain,\n     * including the sending of the response. This means that modifications\n     * to the response **WILL NOT** be reflected in the final response sent to the\n     * client.\n     *\n     * Use HttpLayerRouter.middleware to create middleware that can modify the\n     * response.\n     */\n    readonly middleware?: (\n      effect: Effect.Effect<\n        HttpServerResponse.HttpServerResponse,\n        Request.Only<\"Error\", R> | Request.Only<\"GlobalError\", R> | HttpServerError.RouteNotFound,\n        | Scope.Scope\n        | HttpServerRequest.HttpServerRequest\n        | Request.Only<\"Requires\", R>\n        | Request.Only<\"GlobalRequires\", R>\n      >\n    ) => Effect.Effect<HttpServerResponse.HttpServerResponse, HE, HR>\n  }\n): Layer.Layer<\n  never,\n  Request.Without<E>,\n  HttpServer.HttpServer | Exclude<Request.Without<R> | Exclude<HR, GlobalProvided>, HttpRouter>\n> => {\n  let middleware: any = options?.middleware\n  if (options?.disableLogger !== true) {\n    middleware = middleware ? compose(middleware, HttpMiddleware.logger) : HttpMiddleware.logger\n  }\n  const RouterLayer = options?.routerConfig\n    ? Layer.provide(layer, Layer.succeed(RouterConfig, options.routerConfig))\n    : layer\n  return Effect.gen(function*() {\n    const router = yield* HttpRouter\n    const handler = router.asHttpEffect()\n    return middleware ? HttpServer.serve(handler, middleware) : HttpServer.serve(handler)\n  }).pipe(\n    Layer.unwrapScoped,\n    Layer.provide(appLayer),\n    Layer.provide(RouterLayer),\n    options?.disableListenLog ? identity : HttpServer.withLogAddress\n  ) as any\n}\n\n/**\n * @since 1.0.0\n * @category Server\n */\nexport const toWebHandler = <\n  A,\n  E,\n  R extends\n    | HttpRouter\n    | Request<\"Requires\", any>\n    | Request<\"GlobalRequires\", any>\n    | Request<\"Error\", any>\n    | Request<\"GlobalError\", any>,\n  HE,\n  HR = Request.Only<\"Requires\", R> | Request.Only<\"GlobalRequires\", R>\n>(\n  appLayer: Layer.Layer<A, E, R>,\n  options?: {\n    readonly memoMap?: Layer.MemoMap | undefined\n    readonly routerConfig?: Partial<FindMyWay.RouterConfig> | undefined\n    readonly disableLogger?: boolean | undefined\n    /**\n     * Middleware to apply to the HTTP server.\n     *\n     * NOTE: This middleware is applied to the entire HTTP server chain,\n     * including the sending of the response. This means that modifications\n     * to the response **WILL NOT** be reflected in the final response sent to the\n     * client.\n     *\n     * Use HttpLayerRouter.middleware to create middleware that can modify the\n     * response.\n     */\n    readonly middleware?: (\n      effect: Effect.Effect<\n        HttpServerResponse.HttpServerResponse,\n        Request.Only<\"Error\", R> | Request.Only<\"GlobalError\", R> | HttpServerError.RouteNotFound,\n        | Scope.Scope\n        | HttpServerRequest.HttpServerRequest\n        | Request.Only<\"Requires\", R>\n        | Request.Only<\"GlobalRequires\", R>\n      >\n    ) => Effect.Effect<HttpServerResponse.HttpServerResponse, HE, HR>\n  }\n): {\n  readonly handler: [HR] extends [never]\n    ? ((request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>)\n    : ((request: globalThis.Request, context: Context.Context<HR>) => Promise<Response>)\n  readonly dispose: () => Promise<void>\n} => {\n  let middleware: any = options?.middleware\n  if (options?.disableLogger !== true) {\n    middleware = middleware ? compose(middleware, HttpMiddleware.logger) : HttpMiddleware.logger\n  }\n  const RouterLayer = options?.routerConfig\n    ? Layer.provide(layer, Layer.succeed(RouterConfig, options.routerConfig))\n    : layer\n  const runtime = ManagedRuntime.make(\n    Layer.provideMerge(appLayer, RouterLayer) as any,\n    options?.memoMap\n  )\n  let handlerCached:\n    | ((request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>)\n    | undefined\n  const handlerPromise = Effect.gen(function*() {\n    const router = yield* HttpRouter\n    const effect = router.asHttpEffect()\n    const rt = yield* runtime.runtimeEffect\n    const handler = HttpApp.toWebHandlerRuntime(rt)(effect, middleware)\n    handlerCached = handler\n    return handler\n  }).pipe(runtime.runPromise)\n  function handler(request: globalThis.Request, context?: Context.Context<never> | undefined): Promise<Response> {\n    if (handlerCached !== undefined) {\n      return handlerCached(request, context)\n    }\n    return handlerPromise.then((handler) => handler(request, context))\n  }\n  return { handler, dispose: runtime.dispose } as const\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Channel from \"effect/Channel\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Data from \"effect/Data\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport { Packr, Unpackr } from \"msgpackr\"\nimport * as Msgpackr from \"msgpackr\"\nimport * as ChannelSchema from \"./ChannelSchema.js\"\n\nexport {\n  /**\n   * @since 1.0.0\n   * @category re-exports\n   */\n  Msgpackr\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport const ErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/MsgPack/MsgPackError\")\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class MsgPackError extends Data.TaggedError(\"MsgPackError\")<{\n  readonly reason: \"Pack\" | \"Unpack\"\n  readonly cause: unknown\n}> {\n  /**\n   * @since 1.0.0\n   */\n  readonly [ErrorTypeId]: ErrorTypeId = ErrorTypeId\n\n  /**\n   * @since 1.0.0\n   */\n  get message() {\n    return this.reason\n  }\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const pack = <IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<unknown>,\n  IE | MsgPackError,\n  IE,\n  Done,\n  Done\n> =>\n  Channel.suspend(() => {\n    const packr = new Packr()\n    const loop: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<unknown>, IE | MsgPackError, IE, Done, Done> =\n      Channel\n        .readWithCause({\n          onInput: (input) =>\n            Channel.zipRight(\n              Channel.flatMap(\n                Effect.try({\n                  try: () => Chunk.of(packr.pack(Chunk.toReadonlyArray(input))),\n                  catch: (cause) => new MsgPackError({ reason: \"Pack\", cause })\n                }),\n                Channel.write\n              ),\n              loop\n            ),\n          onFailure: (cause) => Channel.failCause(cause),\n          onDone: Channel.succeed\n        })\n    return loop\n  })\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const packSchema = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) =>\n<IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<Uint8Array>,\n  Chunk.Chunk<A>,\n  IE | MsgPackError | ParseError,\n  IE,\n  Done,\n  Done,\n  R\n> => Channel.pipeTo(ChannelSchema.encode(schema)(), pack())\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unpack = <IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<unknown>,\n  Chunk.Chunk<Uint8Array>,\n  IE | MsgPackError,\n  IE,\n  Done,\n  Done\n> =>\n  Channel.flatMap(\n    Channel.sync(() => new Unpackr()),\n    (packr) => {\n      let incomplete: Uint8Array | undefined = undefined\n      const unpack = (value: Chunk.Chunk<Uint8Array>) =>\n        Effect.try({\n          try: () =>\n            Chunk.flatMap(value, (buf) => {\n              if (incomplete !== undefined) {\n                const chunk = new Uint8Array(incomplete.length + buf.length)\n                chunk.set(incomplete)\n                chunk.set(buf, incomplete.length)\n                buf = chunk\n                incomplete = undefined\n              }\n              try {\n                return Chunk.unsafeFromArray(packr.unpackMultiple(buf).flat())\n              } catch (error_) {\n                const error: any = error_\n                if (error.incomplete) {\n                  incomplete = buf.subarray(error.lastPosition)\n                  return Chunk.unsafeFromArray(error.values ?? [])\n                }\n                throw error\n              }\n            }),\n          catch: (cause) => new MsgPackError({ reason: \"Unpack\", cause })\n        })\n\n      const loop: Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<Uint8Array>, IE | MsgPackError, IE, Done, Done> =\n        Channel.readWithCause({\n          onInput: (input: Chunk.Chunk<Uint8Array>) =>\n            Channel.zipRight(\n              Channel.flatMap(unpack(input), Channel.write),\n              loop\n            ),\n          onFailure: (cause) => Channel.failCause(cause),\n          onDone: Channel.succeed\n        })\n\n      return loop\n    }\n  )\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unpackSchema = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n) =>\n<IE = never, Done = unknown>(): Channel.Channel<\n  Chunk.Chunk<A>,\n  Chunk.Chunk<Uint8Array>,\n  MsgPackError | ParseError | IE,\n  IE,\n  Done,\n  Done,\n  R\n> => Channel.pipeTo(unpack(), ChannelSchema.decodeUnknown(schema)())\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplex = <R, IE, OE, OutDone, InDone>(\n  self: Channel.Channel<Chunk.Chunk<Uint8Array>, Chunk.Chunk<Uint8Array>, OE, IE | MsgPackError, OutDone, InDone, R>\n): Channel.Channel<Chunk.Chunk<unknown>, Chunk.Chunk<unknown>, MsgPackError | OE, IE, OutDone, InDone, R> =>\n  Channel.pipeTo(\n    Channel.pipeTo(pack(), self),\n    unpack()\n  )\n\n/**\n * @since 1.0.0\n * @category combinators\n */\nexport const duplexSchema: {\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IA, II, IR, OA, OI, OR>(\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): <R, InErr, OutErr, OutDone, InDone>(\n    self: Channel.Channel<\n      Chunk.Chunk<Uint8Array>,\n      Chunk.Chunk<Uint8Array>,\n      OutErr,\n      MsgPackError | ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >\n  ) => Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    MsgPackError | ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    IR | OR | R\n  >\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n    self: Channel.Channel<\n      Chunk.Chunk<Uint8Array>,\n      Chunk.Chunk<Uint8Array>,\n      OutErr,\n      MsgPackError | ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >,\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ): Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    MsgPackError | ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n} = dual<\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <IA, II, IR, OA, OI, OR>(\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ) => <R, InErr, OutErr, OutDone, InDone>(\n    self: Channel.Channel<\n      Chunk.Chunk<Uint8Array>,\n      Chunk.Chunk<Uint8Array>,\n      OutErr,\n      MsgPackError | ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >\n  ) => Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    MsgPackError | ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >,\n  /**\n   * @since 1.0.0\n   * @category combinators\n   */\n  <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n    self: Channel.Channel<\n      Chunk.Chunk<Uint8Array>,\n      Chunk.Chunk<Uint8Array>,\n      OutErr,\n      MsgPackError | ParseError | InErr,\n      OutDone,\n      InDone,\n      R\n    >,\n    options: {\n      readonly inputSchema: Schema.Schema<IA, II, IR>\n      readonly outputSchema: Schema.Schema<OA, OI, OR>\n    }\n  ) => Channel.Channel<\n    Chunk.Chunk<OA>,\n    Chunk.Chunk<IA>,\n    MsgPackError | ParseError | OutErr,\n    InErr,\n    OutDone,\n    InDone,\n    R | IR | OR\n  >\n>(2, <R, InErr, OutErr, OutDone, InDone, IA, II, IR, OA, OI, OR>(\n  self: Channel.Channel<\n    Chunk.Chunk<Uint8Array>,\n    Chunk.Chunk<Uint8Array>,\n    OutErr,\n    MsgPackError | ParseError | InErr,\n    OutDone,\n    InDone,\n    R\n  >,\n  options: {\n    readonly inputSchema: Schema.Schema<IA, II, IR>\n    readonly outputSchema: Schema.Schema<OA, OI, OR>\n  }\n): Channel.Channel<\n  Chunk.Chunk<OA>,\n  Chunk.Chunk<IA>,\n  MsgPackError | ParseError | OutErr,\n  InErr,\n  OutDone,\n  InDone,\n  R | IR | OR\n> => ChannelSchema.duplexUnknown(duplex(self), options))\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport interface schema<S extends Schema.Schema.Any> extends Schema.transformOrFail<Schema.Schema<Uint8Array>, S> {}\n\n/**\n * @since 1.0.0\n * @category schemas\n */\nexport const schema = <S extends Schema.Schema.Any>(schema: S): schema<S> =>\n  Schema.transformOrFail(\n    Schema.Uint8ArrayFromSelf,\n    schema,\n    {\n      decode(fromA, _, ast) {\n        return ParseResult.try({\n          try: () => Msgpackr.decode(fromA) as Schema.Schema.Encoded<S>,\n          catch: (cause) =>\n            new ParseResult.Type(\n              ast,\n              fromA,\n              Predicate.hasProperty(cause, \"message\") ? String(cause.message) : String(cause)\n            )\n        })\n      },\n      encode(toI, _, ast) {\n        return ParseResult.try({\n          try: () => Msgpackr.encode(toI),\n          catch: (cause) =>\n            new ParseResult.Type(\n              ast,\n              toI,\n              Predicate.hasProperty(cause, \"message\") ? String(cause.message) : String(cause)\n            )\n        })\n      }\n    }\n  )\n", "export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE, RESET_BUFFER_MODE, RESERVE_START_SPACE } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\n", "var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, options) {\n\t\treturn this.unpack(source, options)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn asSafeString(read())\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nfunction asSafeString(property) {\n\t// protect against expensive (DoS) string conversions\n\tif (typeof property === 'string') return property;\n\tif (typeof property === 'number' || typeof property === 'boolean' || typeof property === 'bigint') return property.toString();\n\tif (property == null) return property + '';\n\tif (currentUnpackr.allowArraysInMapKeys && Array.isArray(property) && property.flat().every(item => ['string', 'number', 'boolean', 'bigint'].includes(typeof item))) {\n\t\treturn property.flat().toString();\n\t}\n\tthrow new Error(`Invalid property type for record: ${typeof property}`);\n}\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(asSafeString) // ensure that all keys are strings and\n\t// that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x42] = (data) => {\n\t// decode bigint\n\tlet length = data.length;\n\tlet value = BigInt(data[0] & 0x80 ? data[0] - 0x100 : data[0]);\n\tfor (let i = 1; i < length; i++) {\n\t\tvalue <<= BigInt(8);\n\t\tvalue += BigInt(data[i]);\n\t}\n\treturn value;\n}\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1], { cause: data[2] })\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle any other types that can cycle and make the code more robust if there are other extensions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse if (token >= 0x80 && token < 0x90 || token == 0xde || token == 0xdf)\n\t\ttarget = new Map()\n\telse if ((token >= 0xc7 && token <= 0xc9 || token >= 0xd4 && token <= 0xd8) && src[position + 1] === 0x73)\n\t\ttarget = new Set()\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (!refEntry.used) {\n\t\t// no cycle, can just use the returned read object\n\t\treturn refEntry.target = targetProperties // replace the placeholder with the real one\n\t} else {\n\t\t// there is a cycle, so we have to assign properties to original target\n\t\tObject.assign(target, targetProperties)\n\t}\n\n\t// copy over map/set entries if we're able to\n\tif (target instanceof Map)\n\t\tfor (let [k, v] of targetProperties.entries()) target.set(k, v)\n\tif (target instanceof Set)\n\t\tfor (let i of Array.from(targetProperties)) target.add(i)\n\treturn target\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tif (currentUnpackr.structuredClone === false) throw new Error('Structured clone extension is disabled')\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\t// we always have to slice to get a new ArrayBuffer that is aligned\n\tlet buffer = Uint8Array.prototype.slice.call(data, 1).buffer\n\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName) {\n\t\tif (typeCode === 16) return buffer\n\t\tif (typeCode === 17) return new DataView(buffer)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t}\n\treturn new glbl[typedArrayName](buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n}\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n", "import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, target.byteLength - position)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end,\n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\tif (encodeOptions & RESERVE_START_SPACE) position += (encodeOptions & 0xff)\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\tlet encodingError;\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} catch(error) {\n\t\t\t\tencodingError = error;\n\t\t\t\tthrow error;\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tresetStructures();\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (!encodingError) { // TODO: If there is an encoding error, should make the structures as uninitialized so they get rebuilt next time\n\t\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\t\treturn packr.pack(value, encodeOptions)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\t\t// don't keep large buffers around\n\t\t\t\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// don't keep large buffers around, they take too much memory and cause problems (limit at 1GB)\n\t\t\t\tif (target.length > 0x40000000) target = null\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst resetStructures = () => {\n\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\tstructures.length = sharedLength\n\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\tstructures.transitions = null\n\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\ttransitionsCount = 0\n\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\trecordIdsToRemove = []\n\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t}\n\t\t\t\trecordIdsToRemove = []\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\n\t\t\t\t\t\t\t// no extension found, write as plain object\n\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < 0x8000000000000000 && value >= -0x8000000000000000) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < 0x10000000000000000 && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else if (this.largeBigIntToString) {\n\t\t\t\t\t\treturn pack(value.toString());\n\t\t\t\t\t} else if ((this.useBigIntExtension || this.moreTypes) && value < BigInt(2)**BigInt(1023) && value > -(BigInt(2)**BigInt(1023))) {\n\t\t\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t\ttarget[position++] = 0x42 // \"B\" for BigInt\n\t\t\t\t\t\tlet bytes = [];\n\t\t\t\t\t\tlet alignedSign;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tlet byte = value & BigInt(0xff);\n\t\t\t\t\t\t\talignedSign = (byte & BigInt(0x80)) === (value < BigInt(0) ? BigInt(0x80) : BigInt(0));\n\t\t\t\t\t\t\tbytes.push(byte);\n\t\t\t\t\t\t\tvalue >>= BigInt(8);\n\t\t\t\t\t\t} while (!((value === BigInt(0) || value === BigInt(-1)) && alignedSign));\n\t\t\t\t\t\ttarget[position-2] = bytes.length;\n\t\t\t\t\t\tfor (let i = bytes.length; i > 0;) {\n\t\t\t\t\t\t\ttarget[position++] = Number(bytes[--i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, use' +\n\t\t\t\t\t\t\t' useBigIntExtension, or set largeBigIntToFloat to convert to float-64, or set' +\n\t\t\t\t\t\t\t' largeBigIntToString to convert to string')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber || this.skipValues) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys;\n\t\t\tif (this.skipValues) {\n\t\t\t\tkeys = [];\n\t\t\t\tfor (let key in object) {\n\t\t\t\t\tif ((typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) &&\n\t\t\t\t\t\t!this.skipValues.includes(object[key]))\n\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tkeys = Object.keys(object)\n\t\t\t}\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (size > 0xffff) {\n\t\t\t\tthrow new Error('Object is too large to serialize with fast 16-bit map size,' +\n\t\t\t\t' use the \"variableMapSize\" option to serialize this object');\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (typeof object.hasOwnProperty !== 'function' || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t}\n\n\t\t// create reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\n\t\tconst writeObject = checkUseRecords ? (object) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object) : writePlainObject(object)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, start, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tresetStructures();\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttarget.dataView || (target.dataView = new DataView(target.buffer, target.byteOffset, target.byteLength))\n\t\tposition = 0\n\t}\n\tset position (value) {\n\t\tposition = value;\n\t}\n\tget position() {\n\t\treturn position;\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, DataView, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message, error.cause ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x11, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\tif (!typedArray.buffer) typedArray = new Uint8Array(typedArray)\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\nexport const RESERVE_START_SPACE = 2048", "import { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nexport const decodeIter = unpackIter\nexport const encodeIter = packIter", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Data from \"effect/Data\"\nimport type * as Effect from \"effect/Effect\"\nimport type * as Socket from \"./Socket.js\"\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class SocketServer extends Context.Tag(\"@effect/platform/SocketServer\")<\n  SocketServer,\n  {\n    readonly address: Address\n    readonly run: <R, E, _>(\n      handler: (socket: Socket.Socket) => Effect.Effect<_, E, R>\n    ) => Effect.Effect<never, SocketServerError, R>\n  }\n>() {}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport const ErrorTypeId: unique symbol = Symbol.for(\"@effect/platform/SocketServer/SocketServerError\")\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport type ErrorTypeId = typeof ErrorTypeId\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class SocketServerError extends Data.TaggedError(\"SocketServerError\")<{\n  readonly reason: \"Open\" | \"Unknown\"\n  readonly cause: unknown\n}> {\n  /**\n   * @since 1.0.0\n   */\n  readonly [ErrorTypeId]: ErrorTypeId = ErrorTypeId\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    return this.reason\n  }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Address = UnixAddress | TcpAddress\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TcpAddress {\n  readonly _tag: \"TcpAddress\"\n  readonly hostname: string\n  readonly port: number\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface UnixAddress {\n  readonly _tag: \"UnixAddress\"\n  readonly path: string\n}\n", "/**\n * @since 1.0.0\n */\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { dual } from \"effect/Function\"\nimport * as Option from \"effect/Option\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface CollectorService {\n  readonly addAll: (_: Iterable<globalThis.Transferable>) => Effect.Effect<void>\n  readonly unsafeAddAll: (_: Iterable<globalThis.Transferable>) => void\n  readonly read: Effect.Effect<Array<globalThis.Transferable>>\n  readonly unsafeRead: () => Array<globalThis.Transferable>\n  readonly unsafeClear: () => Array<globalThis.Transferable>\n  readonly clear: Effect.Effect<Array<globalThis.Transferable>>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport class Collector extends Context.Tag(\"@effect/platform/Transferable/Collector\")<\n  Collector,\n  CollectorService\n>() {}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const unsafeMakeCollector = (): CollectorService => {\n  let tranferables: Array<globalThis.Transferable> = []\n  const unsafeAddAll = (transfers: Iterable<globalThis.Transferable>): void => {\n    // eslint-disable-next-line no-restricted-syntax\n    tranferables.push(...transfers)\n  }\n  const unsafeRead = (): Array<globalThis.Transferable> => tranferables\n  const unsafeClear = (): Array<globalThis.Transferable> => {\n    const prev = tranferables\n    tranferables = []\n    return prev\n  }\n  return Collector.of({\n    unsafeAddAll,\n    addAll: (transferables) => Effect.sync(() => unsafeAddAll(transferables)),\n    unsafeRead,\n    read: Effect.sync(unsafeRead),\n    unsafeClear,\n    clear: Effect.sync(unsafeClear)\n  })\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeCollector: Effect.Effect<CollectorService> = Effect.sync(unsafeMakeCollector)\n\n/**\n * @since 1.0.0\n * @category accessors\n */\nexport const addAll = (tranferables: Iterable<globalThis.Transferable>): Effect.Effect<void> =>\n  Effect.flatMap(\n    Effect.serviceOption(Collector),\n    Option.match({\n      onNone: () => Effect.void,\n      onSome: (_) => _.addAll(tranferables)\n    })\n  )\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const schema: {\n  /**\n   * @since 1.0.0\n   * @category schema\n   */\n  <I>(f: (_: I) => Iterable<globalThis.Transferable>): <A, R>(self: Schema.Schema<A, I, R>) => Schema.Schema<A, I, R>\n  /**\n   * @since 1.0.0\n   * @category schema\n   */\n  <A, I, R>(\n    self: Schema.Schema<A, I, R>,\n    f: (_: I) => Iterable<globalThis.Transferable>\n  ): Schema.Schema<A, I, R>\n} = dual(2, <A, I, R>(\n  self: Schema.Schema<A, I, R>,\n  f: (_: I) => Iterable<globalThis.Transferable>\n) =>\n  Schema.transformOrFail(\n    Schema.encodedSchema(self),\n    self,\n    { strict: true, decode: ParseResult.succeed, encode: (i) => Effect.as(addAll(f(i)), i) }\n  ))\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const ImageData: Schema.Schema<ImageData> = schema(\n  Schema.Any,\n  (_) => [(_ as ImageData).data.buffer]\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const MessagePort: Schema.Schema<MessagePort> = schema(\n  Schema.Any,\n  (_) => [_ as MessagePort]\n)\n\n/**\n * @since 1.0.0\n * @category schema\n */\nexport const Uint8Array: Schema.Schema<Uint8Array> = schema(\n  Schema.Uint8ArrayFromSelf,\n  (_) => [_.buffer]\n)\n", "/**\n * @since 1.0.0\n */\nimport type * as Cause from \"effect/Cause\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as internal from \"./internal/workerError.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const WorkerErrorTypeId: unique symbol = internal.WorkerErrorTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type WorkerErrorTypeId = typeof WorkerErrorTypeId\n\n/**\n * @since 1.0.0\n * @category predicates\n */\nexport const isWorkerError = (u: unknown): u is WorkerError => Predicate.hasProperty(u, WorkerErrorTypeId)\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport class WorkerError extends Schema.TaggedError<WorkerError>()(\"WorkerError\", {\n  reason: Schema.Literal(\"spawn\", \"decode\", \"send\", \"unknown\", \"encode\"),\n  cause: Schema.Defect\n}) {\n  /**\n   * @since 1.0.0\n   */\n  readonly [WorkerErrorTypeId]: WorkerErrorTypeId = WorkerErrorTypeId\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly Cause: Schema.Schema<\n    Cause.Cause<WorkerError>,\n    Schema.CauseEncoded<WorkerErrorFrom, unknown>\n  > = Schema.Cause({ error: this, defect: Schema.Defect })\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly encodeCause: (a: Cause.Cause<WorkerError>) => Schema.CauseEncoded<WorkerErrorFrom, unknown> = Schema\n    .encodeSync(this.Cause)\n\n  /**\n   * @since 1.0.0\n   */\n  static readonly decodeCause: (u: Schema.CauseEncoded<WorkerErrorFrom, unknown>) => Cause.Cause<WorkerError> = Schema\n    .decodeSync(this.Cause)\n\n  /**\n   * @since 1.0.0\n   */\n  get message(): string {\n    switch (this.reason) {\n      case \"send\":\n        return \"An error occurred calling .postMessage\"\n      case \"spawn\":\n        return \"An error occurred while spawning a worker\"\n      case \"decode\":\n        return \"An error occurred during decoding\"\n      case \"encode\":\n        return \"An error occurred during encoding\"\n      case \"unknown\":\n        return \"An unexpected error occurred\"\n    }\n  }\n}\n\n/**\n * @since 1.0.0\n * @category errors\n */\nexport interface WorkerErrorFrom {\n  readonly _tag: \"WorkerError\"\n  readonly reason: \"spawn\" | \"decode\" | \"send\" | \"unknown\" | \"encode\"\n  readonly cause: unknown\n}\n", "import type * as WorkerError_ from \"../WorkerError.js\"\n\n/** @internal */\nexport const WorkerErrorTypeId: WorkerError_.WorkerErrorTypeId = Symbol.for(\n  \"@effect/platform/WorkerError\"\n) as WorkerError_.WorkerErrorTypeId\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Deferred from \"effect/Deferred\"\nimport type * as Duration from \"effect/Duration\"\nimport type * as Effect from \"effect/Effect\"\nimport type { LazyArg } from \"effect/Function\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as ParseResult from \"effect/ParseResult\"\nimport type * as Pool from \"effect/Pool\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as Stream from \"effect/Stream\"\nimport * as internal from \"./internal/worker.js\"\nimport type { WorkerError, WorkerErrorFrom } from \"./WorkerError.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface BackingWorker<I, O> {\n  readonly send: (message: I, transfers?: ReadonlyArray<unknown>) => Effect.Effect<void, WorkerError>\n  readonly run: <A, E, R>(\n    handler: (_: BackingWorker.Message<O>) => Effect.Effect<A, E, R>\n  ) => Effect.Effect<never, E | WorkerError, R>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace BackingWorker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Message<O> = readonly [ready: 0] | readonly [data: 1, O]\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const PlatformWorkerTypeId: unique symbol = internal.PlatformWorkerTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type PlatformWorkerTypeId = typeof PlatformWorkerTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface PlatformWorker {\n  readonly [PlatformWorkerTypeId]: PlatformWorkerTypeId\n  readonly spawn: <I, O>(id: number) => Effect.Effect<BackingWorker<I, O>, WorkerError, Spawner>\n}\n\n/**\n * @since 1.0.0\n */\nexport const makePlatform: <W>() => <\n  P extends { readonly postMessage: (message: any, transfers?: any | undefined) => void }\n>(\n  options: {\n    readonly setup: (options: { readonly worker: W; readonly scope: Scope.Scope }) => Effect.Effect<P, WorkerError>\n    readonly listen: (\n      options: {\n        readonly port: P\n        readonly emit: (data: any) => void\n        readonly deferred: Deferred.Deferred<never, WorkerError>\n        readonly scope: Scope.Scope\n      }\n    ) => Effect.Effect<void>\n  }\n) => PlatformWorker = internal.makePlatform\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const PlatformWorker: Context.Tag<PlatformWorker, PlatformWorker> = internal.PlatformWorker\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Worker<I, O, E = never> {\n  readonly id: number\n  readonly execute: (message: I) => Stream.Stream<O, E | WorkerError>\n  readonly executeEffect: (message: I) => Effect.Effect<O, E | WorkerError>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Spawner {\n  readonly _: unique symbol\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Spawner: Context.Tag<Spawner, SpawnerFn<unknown>> = internal.Spawner\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SpawnerFn<W = unknown> {\n  (id: number): W\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace Worker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Options<I> {\n    readonly encode?: ((message: I) => Effect.Effect<unknown, WorkerError>) | undefined\n    readonly initialMessage?: LazyArg<I> | undefined\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Request<I = unknown> =\n    | readonly [id: number, data: 0, I, trace: Span | undefined]\n    | readonly [id: number, interrupt: 1]\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Span = readonly [traceId: string, spanId: string, sampled: boolean]\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Response<E, O = unknown> =\n    | readonly [id: number, data: 0, ReadonlyArray<O>]\n    | readonly [id: number, end: 1]\n    | readonly [id: number, end: 1, ReadonlyArray<O>]\n    | readonly [id: number, error: 2, E]\n    | readonly [id: number, defect: 3, Schema.CauseEncoded<WorkerErrorFrom, unknown>]\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface WorkerPool<I, O, E = never> {\n  readonly backing: Pool.Pool<Worker<I, O, E>, WorkerError>\n  readonly broadcast: (message: I) => Effect.Effect<void, E | WorkerError>\n  readonly execute: (message: I) => Stream.Stream<O, E | WorkerError>\n  readonly executeEffect: (message: I) => Effect.Effect<O, E | WorkerError>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace WorkerPool {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> =\n    & Worker.Options<I>\n    & ({\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly size: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n    } | {\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly minSize: number\n      readonly maxSize: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n      readonly timeToLive: Duration.DurationInput\n    })\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const WorkerManagerTypeId: unique symbol = internal.WorkerManagerTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type WorkerManagerTypeId = typeof WorkerManagerTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface WorkerManager {\n  readonly [WorkerManagerTypeId]: WorkerManagerTypeId\n  readonly spawn: <I, O, E>(\n    options: Worker.Options<I>\n  ) => Effect.Effect<Worker<I, O, E>, WorkerError, Scope.Scope | Spawner>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const WorkerManager: Context.Tag<WorkerManager, WorkerManager> = internal.WorkerManager\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeManager: Effect.Effect<WorkerManager, never, PlatformWorker> = internal.makeManager\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerManager: Layer.Layer<WorkerManager, never, PlatformWorker> = internal.layerManager\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePool: <I, O, E>(\n  options: WorkerPool.Options<I>\n) => Effect.Effect<WorkerPool<I, O, E>, WorkerError, WorkerManager | Spawner | Scope.Scope> = internal.makePool\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePoolLayer: <Tag, I, O, E>(\n  tag: Context.Tag<Tag, WorkerPool<I, O, E>>,\n  options: WorkerPool.Options<I>\n) => Layer.Layer<Tag, WorkerError, WorkerManager | Spawner> = internal.makePoolLayer\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SerializedWorker<I extends Schema.TaggedRequest.All> {\n  readonly id: number\n  readonly execute: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Stream.Stream<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly executeEffect: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace SerializedWorker {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> = Extract<I, { readonly _tag: \"InitialMessage\" }> extends never ? {\n      readonly initialMessage?: LazyArg<I>\n    }\n    : {\n      readonly initialMessage: LazyArg<Extract<I, { readonly _tag: \"InitialMessage\" }>>\n    }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface SerializedWorkerPool<I extends Schema.TaggedRequest.All> {\n  readonly backing: Pool.Pool<SerializedWorker<I>, WorkerError>\n  readonly broadcast: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer _A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<void, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly execute: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Stream.Stream<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n  readonly executeEffect: <Req extends I>(\n    message: Req\n  ) => Req extends Schema.WithResult<infer A, infer _I, infer E, infer _EI, infer R>\n    ? Effect.Effect<A, E | WorkerError | ParseResult.ParseError, R>\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace SerializedWorkerPool {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Options<I> =\n    & SerializedWorker.Options<I>\n    & ({\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly size: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n    } | {\n      readonly onCreate?: (worker: Worker<I, unknown, unknown>) => Effect.Effect<void, WorkerError>\n      readonly minSize: number\n      readonly maxSize: number\n      readonly concurrency?: number | undefined\n      readonly targetUtilization?: number | undefined\n      readonly timeToLive: Duration.DurationInput\n    })\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeSerialized: <I extends Schema.TaggedRequest.All>(\n  options: SerializedWorker.Options<I>\n) => Effect.Effect<SerializedWorker<I>, WorkerError, WorkerManager | Spawner | Scope.Scope> = internal.makeSerialized\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makePoolSerialized: <I extends Schema.TaggedRequest.All>(\n  options: SerializedWorkerPool.Options<I>\n) => Effect.Effect<SerializedWorkerPool<I>, WorkerError, WorkerManager | Spawner | Scope.Scope> =\n  internal.makePoolSerialized\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const makePoolSerializedLayer: <Tag, I extends Schema.TaggedRequest.All>(\n  tag: Context.Tag<Tag, SerializedWorkerPool<I>>,\n  options: SerializedWorkerPool.Options<I>\n) => Layer.Layer<Tag, WorkerError, WorkerManager | Spawner> = internal.makePoolSerializedLayer\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerSpawner: <W = unknown>(spawner: SpawnerFn<W>) => Layer.Layer<Spawner, never, never> =\n  internal.layerSpawner\n", "import * as Channel from \"effect/Channel\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport * as FiberSet from \"effect/FiberSet\"\nimport { identity, pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport * as Pool from \"effect/Pool\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Tracer from \"effect/Tracer\"\nimport * as Transferable from \"../Transferable.js\"\nimport type * as Worker from \"../Worker.js\"\nimport { WorkerError } from \"../WorkerError.js\"\n\n/** @internal */\nexport const PlatformWorkerTypeId: Worker.PlatformWorkerTypeId = Symbol.for(\n  \"@effect/platform/Worker/PlatformWorker\"\n) as Worker.PlatformWorkerTypeId\n\n/** @internal */\nexport const PlatformWorker = Context.GenericTag<Worker.PlatformWorker>(\n  \"@effect/platform/Worker/PlatformWorker\"\n)\n\n/** @internal */\nexport const WorkerManagerTypeId: Worker.WorkerManagerTypeId = Symbol.for(\n  \"@effect/platform/Worker/WorkerManager\"\n) as Worker.WorkerManagerTypeId\n\n/** @internal */\nexport const WorkerManager = Context.GenericTag<Worker.WorkerManager>(\n  \"@effect/platform/Worker/WorkerManager\"\n)\n\n/** @internal */\nexport const Spawner = Context.GenericTag<Worker.Spawner, Worker.SpawnerFn>(\n  \"@effect/platform/Worker/Spawner\"\n)\n\n/** @internal */\nexport const makeManager = Effect.gen(function*() {\n  const platform = yield* PlatformWorker\n  let idCounter = 0\n  return WorkerManager.of({\n    [WorkerManagerTypeId]: WorkerManagerTypeId,\n    spawn<I, O, E>({\n      encode,\n      initialMessage\n    }: Worker.Worker.Options<I>) {\n      return Effect.gen(function*() {\n        const id = idCounter++\n        let requestIdCounter = 0\n        const requestMap = new Map<\n          number,\n          Mailbox.Mailbox<O, E | WorkerError> | Deferred.Deferred<O, E | WorkerError>\n        >()\n\n        const collector = Transferable.unsafeMakeCollector()\n        const wrappedEncode = encode ?\n          ((message: I) =>\n            Effect.zipRight(\n              collector.clear,\n              Effect.provideService(encode(message), Transferable.Collector, collector)\n            )) :\n          Effect.succeed\n\n        const readyLatch = yield* Deferred.make<void>()\n        const backing = yield* platform.spawn<Worker.Worker.Request, Worker.Worker.Response<E, O>>(id)\n\n        yield* backing.run((message) => {\n          if (message[0] === 0) {\n            return Deferred.complete(readyLatch, Effect.void)\n          }\n          return handleMessage(message[1])\n        }).pipe(\n          Effect.onError((cause) =>\n            Effect.forEach(requestMap.values(), (mailbox) =>\n              Deferred.DeferredTypeId in mailbox\n                ? Deferred.failCause(mailbox, cause)\n                : mailbox.failCause(cause))\n          ),\n          Effect.tapErrorCause(Effect.logWarning),\n          Effect.retry(Schedule.spaced(1000)),\n          Effect.annotateLogs({\n            package: \"@effect/platform\",\n            module: \"Worker\"\n          }),\n          Effect.interruptible,\n          Effect.forkScoped\n        )\n\n        yield* Effect.addFinalizer(() =>\n          Effect.zipRight(\n            Effect.forEach(requestMap.values(), (mailbox) =>\n              Deferred.DeferredTypeId in mailbox\n                ? Deferred.interrupt(mailbox)\n                : mailbox.end, {\n              discard: true\n            }),\n            Effect.sync(() => requestMap.clear())\n          )\n        )\n\n        const handleMessage = (response: Worker.Worker.Response<E, O>) =>\n          Effect.suspend(() => {\n            const mailbox = requestMap.get(response[0])\n            if (!mailbox) return Effect.void\n\n            switch (response[1]) {\n              // data\n              case 0: {\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.succeed(mailbox, response[2][0])\n                  : mailbox.offerAll(response[2])\n              }\n              // end\n              case 1: {\n                if (response.length === 2) {\n                  return Deferred.DeferredTypeId in mailbox\n                    ? Deferred.interrupt(mailbox)\n                    : mailbox.end\n                }\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.succeed(mailbox, response[2][0])\n                  : Effect.zipRight(mailbox.offerAll(response[2]), mailbox.end)\n              }\n              // error / defect\n              case 2:\n              case 3: {\n                if (response[1] === 2) {\n                  return Deferred.DeferredTypeId in mailbox\n                    ? Deferred.fail(mailbox, response[2])\n                    : mailbox.fail(response[2])\n                }\n                const cause = WorkerError.decodeCause(response[2])\n                return Deferred.DeferredTypeId in mailbox\n                  ? Deferred.failCause(mailbox, cause)\n                  : mailbox.failCause(cause)\n              }\n            }\n          })\n\n        const executeAcquire = <\n          Q extends Mailbox.Mailbox<O, E | WorkerError> | Deferred.Deferred<O, E | WorkerError>\n        >(request: I, makeMailbox: Effect.Effect<Q>) =>\n          Effect.withFiberRuntime<{\n            readonly id: number\n            readonly mailbox: Q\n          }>((fiber) => {\n            const context = fiber.getFiberRef(FiberRef.currentContext)\n            const span = Context.getOption(context, Tracer.ParentSpan).pipe(\n              Option.filter((span): span is Tracer.Span => span._tag === \"Span\")\n            )\n            const id = requestIdCounter++\n            return makeMailbox.pipe(\n              Effect.tap((mailbox) => {\n                requestMap.set(id, mailbox)\n                return wrappedEncode(request).pipe(\n                  Effect.tap((payload) =>\n                    backing.send([\n                      id,\n                      0,\n                      payload,\n                      span._tag === \"Some\" ? [span.value.traceId, span.value.spanId, span.value.sampled] : undefined\n                    ], collector.unsafeRead())\n                  ),\n                  Effect.catchAllCause((cause) =>\n                    Mailbox.isMailbox<O, E | WorkerError>(mailbox)\n                      ? mailbox.failCause(cause)\n                      : Deferred.failCause(mailbox, cause)\n                  )\n                )\n              }),\n              Effect.map((mailbox) => ({ id, mailbox }))\n            )\n          })\n\n        const executeRelease = ({ id }: { readonly id: number }, exit: Exit.Exit<unknown, unknown>) => {\n          const release = Effect.sync(() => requestMap.delete(id))\n          return Exit.isFailure(exit) ?\n            Effect.zipRight(Effect.orDie(backing.send([id, 1])), release) :\n            release\n        }\n\n        const execute = (request: I) =>\n          Stream.fromChannel(\n            Channel.acquireUseRelease(\n              executeAcquire(request, Mailbox.make<O, E | WorkerError>()),\n              ({ mailbox }) => Mailbox.toChannel(mailbox),\n              executeRelease\n            )\n          )\n\n        const executeEffect = (request: I) =>\n          Effect.acquireUseRelease(\n            executeAcquire(request, Deferred.make<O, WorkerError | E>()),\n            ({ mailbox }) => Deferred.await(mailbox),\n            executeRelease\n          )\n\n        yield* Deferred.await(readyLatch)\n\n        if (initialMessage) {\n          yield* Effect.sync(initialMessage).pipe(\n            Effect.flatMap(executeEffect),\n            Effect.mapError((cause) => new WorkerError({ reason: \"spawn\", cause }))\n          )\n        }\n\n        return { id, execute, executeEffect }\n      })\n    }\n  })\n})\n\n/** @internal */\nexport const layerManager = Layer.effect(WorkerManager, makeManager)\n\n/** @internal */\nexport const makePool = <I, O, E>(\n  options: Worker.WorkerPool.Options<I>\n) =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const workers = new Set<Worker.Worker<I, O, E>>()\n    const acquire = pipe(\n      manager.spawn<I, O, E>(options),\n      Effect.tap((worker) =>\n        Effect.acquireRelease(\n          Effect.sync(() => workers.add(worker)),\n          () => Effect.sync(() => workers.delete(worker))\n        )\n      ),\n      options.onCreate ? Effect.tap(options.onCreate) : identity\n    )\n    const backing = \"minSize\" in options ?\n      yield* Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      yield* Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n    const pool: Worker.WorkerPool<I, O, E> = {\n      backing,\n      broadcast: (message: I) =>\n        Effect.forEach(workers, (worker) => worker.executeEffect(message), {\n          concurrency: \"unbounded\",\n          discard: true\n        }),\n      execute: (message: I) =>\n        Stream.unwrapScoped(Effect.map(\n          backing.get,\n          (worker) => worker.execute(message)\n        )),\n      executeEffect: (message: I) =>\n        Effect.scoped(Effect.flatMap(\n          backing.get,\n          (worker) => worker.executeEffect(message)\n        ))\n    }\n\n    // report any spawn errors\n    yield* Effect.scoped(backing.get)\n\n    return pool\n  })\n\n/** @internal */\nexport const makePoolLayer = <Tag, I, O, E>(\n  tag: Context.Tag<Tag, Worker.WorkerPool<I, O, E>>,\n  options: Worker.WorkerPool.Options<I>\n) => Layer.scoped(tag, makePool(options))\n\n/** @internal */\nexport const makeSerialized = <\n  I extends Schema.TaggedRequest.All\n>(\n  options: Worker.SerializedWorker.Options<I>\n): Effect.Effect<Worker.SerializedWorker<I>, WorkerError, Worker.WorkerManager | Worker.Spawner | Scope.Scope> =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const backing = yield* manager.spawn({\n      ...options as any,\n      encode(message) {\n        return Effect.mapError(\n          Schema.serialize(message as any),\n          (cause) => new WorkerError({ reason: \"encode\", cause })\n        )\n      }\n    })\n    const execute = <Req extends I>(message: Req) => {\n      const parseSuccess = Schema.decode(Schema.successSchema(message as any))\n      const parseFailure = Schema.decode(Schema.failureSchema(message as any))\n      return pipe(\n        backing.execute(message),\n        Stream.catchAll((error) => Effect.flatMap(parseFailure(error), Effect.fail)),\n        Stream.mapEffect(parseSuccess)\n      )\n    }\n    const executeEffect = <Req extends I>(message: Req) => {\n      const parseSuccess = Schema.decode(Schema.successSchema(message as any))\n      const parseFailure = Schema.decode(Schema.failureSchema(message as any))\n      return Effect.matchEffect(backing.executeEffect(message), {\n        onFailure: (error) => Effect.flatMap(parseFailure(error), Effect.fail),\n        onSuccess: parseSuccess\n      })\n    }\n    return identity<Worker.SerializedWorker<I>>({\n      id: backing.id,\n      execute: execute as any,\n      executeEffect: executeEffect as any\n    })\n  })\n\n/** @internal */\nexport const makePoolSerialized = <I extends Schema.TaggedRequest.All>(\n  options: Worker.SerializedWorkerPool.Options<I>\n) =>\n  Effect.gen(function*() {\n    const manager = yield* WorkerManager\n    const workers = new Set<Worker.SerializedWorker<I>>()\n    const acquire = pipe(\n      makeSerialized<I>(options),\n      Effect.tap((worker) => Effect.sync(() => workers.add(worker))),\n      Effect.tap((worker) => Effect.addFinalizer(() => Effect.sync(() => workers.delete(worker)))),\n      options.onCreate\n        ? Effect.tap(\n          options.onCreate as (worker: Worker.SerializedWorker<I>) => Effect.Effect<void, WorkerError>\n        )\n        : identity,\n      Effect.provideService(WorkerManager, manager)\n    )\n    const backing = yield* \"timeToLive\" in options ?\n      Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n    const pool: Worker.SerializedWorkerPool<I> = {\n      backing,\n      broadcast: <Req extends I>(message: Req) =>\n        Effect.forEach(workers, (worker) => worker.executeEffect(message), {\n          concurrency: \"unbounded\",\n          discard: true\n        }) as any,\n      execute: <Req extends I>(message: Req) =>\n        Stream.unwrapScoped(Effect.map(backing.get, (worker) => worker.execute(message))) as any,\n      executeEffect: <Req extends I>(message: Req) =>\n        Effect.scoped(Effect.flatMap(backing.get, (worker) => worker.executeEffect(message))) as any\n    }\n\n    // report any spawn errors\n    yield* Effect.scoped(backing.get)\n\n    return pool\n  })\n\n/** @internal */\nexport const makePoolSerializedLayer = <Tag, I extends Schema.TaggedRequest.All>(\n  tag: Context.Tag<Tag, Worker.SerializedWorkerPool<I>>,\n  options: Worker.SerializedWorkerPool.Options<I>\n) => Layer.scoped(tag, makePoolSerialized(options))\n\n/** @internal */\nexport const layerSpawner = <W = unknown>(spawner: Worker.SpawnerFn<W>) =>\n  Layer.succeed(\n    Spawner,\n    spawner\n  )\n\n/** @internal */\nexport const makePlatform = <W>() =>\n<\n  P extends {\n    readonly postMessage: (message: any, transfers?: any | undefined) => void\n  }\n>(options: {\n  readonly setup: (options: {\n    readonly worker: W\n    readonly scope: Scope.Scope\n  }) => Effect.Effect<P, WorkerError>\n  readonly listen: (options: {\n    readonly port: P\n    readonly emit: (data: any) => void\n    readonly deferred: Deferred.Deferred<never, WorkerError>\n    readonly scope: Scope.Scope\n  }) => Effect.Effect<void>\n}) =>\n  PlatformWorker.of({\n    [PlatformWorkerTypeId]: PlatformWorkerTypeId,\n    spawn<I, O>(id: number) {\n      return Effect.gen(function*() {\n        const spawn = (yield* Spawner) as Worker.SpawnerFn<W>\n        let currentPort: P | undefined\n        const buffer: Array<[I, ReadonlyArray<unknown> | undefined]> = []\n\n        const run = <A, E, R>(\n          handler: (_: Worker.BackingWorker.Message<O>) => Effect.Effect<A, E, R>\n        ): Effect.Effect<never, WorkerError | E, R> =>\n          Effect.uninterruptibleMask((restore) =>\n            Effect.gen(function*() {\n              const scope = yield* Effect.scope\n              const port = yield* options.setup({ worker: spawn(id), scope })\n              currentPort = port\n              yield* Scope.addFinalizer(\n                scope,\n                Effect.sync(() => {\n                  currentPort = undefined\n                })\n              )\n              const runtime = (yield* Effect.runtime<R | Scope.Scope>()).pipe(\n                Runtime.updateContext(Context.omit(Scope.Scope))\n              ) as Runtime.Runtime<R>\n              const fiberSet = yield* FiberSet.make<any, WorkerError | E>()\n              const runFork = Runtime.runFork(runtime)\n              yield* options.listen({\n                port,\n                scope,\n                emit(data) {\n                  FiberSet.unsafeAdd(fiberSet, runFork(handler(data)))\n                },\n                deferred: fiberSet.deferred as any\n              })\n              if (buffer.length > 0) {\n                for (const [message, transfers] of buffer) {\n                  port.postMessage([0, message], transfers as any)\n                }\n                buffer.length = 0\n              }\n              return (yield* restore(FiberSet.join(fiberSet))) as never\n            }).pipe(Effect.scoped)\n          )\n\n        const send = (message: I, transfers?: ReadonlyArray<unknown>) =>\n          Effect.try({\n            try: () => {\n              if (currentPort === undefined) {\n                buffer.push([message, transfers])\n              } else {\n                currentPort.postMessage([0, message], transfers as any)\n              }\n            },\n            catch: (cause) => new WorkerError({ reason: \"send\", cause })\n          })\n\n        return { run, send }\n      })\n    }\n  })\n", "/**\n * @since 1.0.0\n */\nimport type * as Context from \"effect/Context\"\nimport type * as Deferred from \"effect/Deferred\"\nimport type * as Effect from \"effect/Effect\"\nimport type * as Layer from \"effect/Layer\"\nimport type * as Mailbox from \"effect/Mailbox\"\nimport type * as Schema from \"effect/Schema\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as Stream from \"effect/Stream\"\nimport * as internal from \"./internal/workerRunner.js\"\nimport type { WorkerError } from \"./WorkerError.js\"\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface BackingRunner<I, O> {\n  readonly run: <A, E, R>(\n    handler: (portId: number, message: I) => Effect.Effect<A, E, R> | void\n  ) => Effect.Effect<void, never, Scope.Scope | R>\n  readonly send: (\n    portId: number,\n    message: O,\n    transfers?: ReadonlyArray<unknown>\n  ) => Effect.Effect<void>\n  readonly disconnects?: Mailbox.ReadonlyMailbox<number>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace BackingRunner {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Message<I> = readonly [request: 0, I] | readonly [close: 1]\n}\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const PlatformRunnerTypeId: unique symbol = internal.PlatformRunnerTypeId\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type PlatformRunnerTypeId = typeof PlatformRunnerTypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface PlatformRunner {\n  readonly [PlatformRunnerTypeId]: PlatformRunnerTypeId\n  readonly start: <I, O>(closeLatch: typeof CloseLatch.Service) => Effect.Effect<BackingRunner<I, O>, WorkerError>\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const PlatformRunner: Context.Tag<PlatformRunner, PlatformRunner> = internal.PlatformRunner\n\n/**\n * The worker close latch is used by platform runners to signal that the worker\n * has been closed.\n *\n * @since 1.0.0\n * @category CloseLatch\n */\nexport interface CloseLatch {\n  readonly _: unique symbol\n}\n\n/**\n * The worker close latch is used by platform runners to signal that the worker\n * has been closed.\n *\n * @since 1.0.0\n * @category CloseLatch\n */\nexport const CloseLatch: Context.Reference<CloseLatch, Deferred.Deferred<void, WorkerError>> = internal.CloseLatch\n\n/**\n * @since 1.0.0\n * @category CloseLatch\n */\nexport const layerCloseLatch: Layer.Layer<CloseLatch> = internal.layerCloseLatch\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace Runner {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Options<I, O, E> {\n    readonly decode?: (\n      message: unknown\n    ) => Effect.Effect<I, WorkerError>\n    readonly encodeOutput?: (\n      request: I,\n      message: O\n    ) => Effect.Effect<unknown, WorkerError>\n    readonly encodeError?: (\n      request: I,\n      error: E\n    ) => Effect.Effect<unknown, WorkerError>\n  }\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make: <I, E, R, O>(\n  process: (request: I) => Stream.Stream<O, E, R> | Effect.Effect<O, E, R>,\n  options?: Runner.Options<I, O, E>\n) => Effect.Effect<void, WorkerError, PlatformRunner | R | Scope.Scope> = internal.make\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layer: <I, E, R, O>(\n  process: (request: I) => Stream.Stream<O, E, R> | Effect.Effect<O, E, R>,\n  options?: Runner.Options<I, O, E> | undefined\n) => Layer.Layer<never, WorkerError, R | PlatformRunner> = internal.layer\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace SerializedRunner {\n  /**\n   * @since 1.0.0\n   */\n  export type Handlers<A extends Schema.TaggedRequest.All> = {\n    readonly [K in A[\"_tag\"]]: Extract<\n      A,\n      { readonly _tag: K }\n    > extends Schema.SerializableWithResult<\n      infer S,\n      infer _SI,\n      infer _SR,\n      infer A,\n      infer _AI,\n      infer E,\n      infer _EI,\n      infer _RR\n    > ? (\n        _: S\n      ) =>\n        | Stream.Stream<A, E, any>\n        | Effect.Effect<A, E, any>\n        | Layer.Layer<any, E, any>\n        | Layer.Layer<never, E, any>\n      : never\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type HandlersContext<\n    Handlers extends Record<string, (...args: ReadonlyArray<any>) => any>\n  > =\n    | Exclude<\n      {\n        [K in keyof Handlers]: ReturnType<Handlers[K]> extends Stream.Stream<\n          infer _A,\n          infer _E,\n          infer R\n        > ? R\n          : never\n      }[keyof Handlers],\n      InitialContext<Handlers>\n    >\n    | InitialEnv<Handlers>\n\n  /**\n   * @since 1.0.0\n   */\n  type InitialContext<\n    Handlers extends Record<string, (...args: ReadonlyArray<any>) => any>\n  > = Handlers[\"InitialMessage\"] extends (\n    ...args: ReadonlyArray<any>\n  ) => Layer.Layer<infer A, infer _E, infer _R> ? A\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  type InitialEnv<\n    Handlers extends Record<string, (...args: ReadonlyArray<any>) => any>\n  > = Handlers[\"InitialMessage\"] extends (\n    ...args: ReadonlyArray<any>\n  ) => Layer.Layer<infer _A, infer _E, infer R> ? R\n    : never\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeSerialized: <\n  R,\n  I,\n  A extends Schema.TaggedRequest.All,\n  const Handlers extends SerializedRunner.Handlers<A>\n>(\n  schema: Schema.Schema<A, I, R>,\n  handlers: Handlers\n) => Effect.Effect<\n  void,\n  WorkerError,\n  PlatformRunner | Scope.Scope | R | SerializedRunner.HandlersContext<Handlers>\n> = internal.makeSerialized\n\n/**\n * @since 1.0.0\n * @category layers\n */\nexport const layerSerialized: <\n  R,\n  I,\n  A extends Schema.TaggedRequest.All,\n  const Handlers extends SerializedRunner.Handlers<A>\n>(\n  schema: Schema.Schema<A, I, R>,\n  handlers: Handlers\n) => Layer.Layer<never, WorkerError, PlatformRunner | R | SerializedRunner.HandlersContext<Handlers>> =\n  internal.layerSerialized\n\n/**\n * Launch the specified layer, interrupting the fiber when the CloseLatch is\n * triggered.\n *\n * @since 1.0.0\n * @category Execution\n */\nexport const launch: <A, E, R>(layer: Layer.Layer<A, E, R>) => Effect.Effect<void, E | WorkerError, R> = internal.launch\n", "import * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport * as Effect from \"effect/Effect\"\nimport * as Either from \"effect/Either\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberId from \"effect/FiberId\"\nimport { pipe } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Schema from \"effect/Schema\"\nimport type * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Transferable from \"../Transferable.js\"\nimport type * as Worker from \"../Worker.js\"\nimport { isWorkerError, WorkerError } from \"../WorkerError.js\"\nimport type * as WorkerRunner from \"../WorkerRunner.js\"\n\n/** @internal */\nexport const PlatformRunnerTypeId: WorkerRunner.PlatformRunnerTypeId = Symbol.for(\n  \"@effect/platform/Runner/PlatformRunner\"\n) as WorkerRunner.PlatformRunnerTypeId\n\n/** @internal */\nexport const PlatformRunner = Context.GenericTag<WorkerRunner.PlatformRunner>(\n  \"@effect/platform/Runner/PlatformRunner\"\n)\n\n/** @internal */\nexport const CloseLatch = Context.Reference<WorkerRunner.CloseLatch>()(\"@effect/platform/WorkerRunner/CloseLatch\", {\n  defaultValue: () => Deferred.unsafeMake<void, WorkerError>(FiberId.none)\n})\n\n/** @internal */\nexport const layerCloseLatch = Layer.effect(CloseLatch, Deferred.make())\n\n/** @internal */\nexport const make = Effect.fnUntraced(function*<I, E, R, O>(\n  process: (request: I) => Stream.Stream<O, E, R> | Effect.Effect<O, E, R>,\n  options?: WorkerRunner.Runner.Options<I, O, E>\n) {\n  const fiber = yield* Effect.withFiberRuntime<Fiber.RuntimeFiber<void>>(Effect.succeed as any)\n  const platform = yield* PlatformRunner\n  const closeLatch = yield* CloseLatch\n  const backing = yield* platform.start<Worker.Worker.Request<I>, Worker.Worker.Response<E>>(closeLatch)\n  const fiberMap = new Map<number, Fiber.Fiber<unknown, unknown>>()\n\n  yield* Deferred.await(closeLatch).pipe(\n    Effect.onExit(() => {\n      fiber.currentScheduler.scheduleTask(() => {\n        fiber.unsafeInterruptAsFork(fiber.id())\n      }, 0)\n      return Effect.void\n    }),\n    Effect.forkScoped\n  )\n\n  yield* backing.run((portId, [id, kind, data, span]): Effect.Effect<void, WorkerError, R> => {\n    if (kind === 1) {\n      const fiber = fiberMap.get(id)\n      if (!fiber) return Effect.void\n      return Fiber.interrupt(fiber)\n    }\n\n    return Effect.withFiberRuntime<I, WorkerError>((fiber) => {\n      fiberMap.set(id, fiber)\n      return options?.decode ? options.decode(data) : Effect.succeed(data)\n    }).pipe(\n      Effect.flatMap((input) => {\n        const collector = Transferable.unsafeMakeCollector()\n        const stream = process(input)\n        let effect = Effect.isEffect(stream) ?\n          Effect.flatMap(stream, (out) =>\n            pipe(\n              options?.encodeOutput\n                ? Effect.provideService(options.encodeOutput(input, out), Transferable.Collector, collector)\n                : Effect.succeed(out),\n              Effect.flatMap((payload) => backing.send(portId, [id, 0, [payload]], collector.unsafeRead()))\n            )) :\n          pipe(\n            stream,\n            Stream.runForEachChunk((chunk) => {\n              if (options?.encodeOutput === undefined) {\n                const payload = Chunk.toReadonlyArray(chunk)\n                return backing.send(portId, [id, 0, payload])\n              }\n\n              collector.unsafeClear()\n              return pipe(\n                Effect.forEach(chunk, (data) => options.encodeOutput!(input, data)),\n                Effect.provideService(Transferable.Collector, collector),\n                Effect.flatMap((payload) => backing.send(portId, [id, 0, payload], collector.unsafeRead()))\n              )\n            }),\n            Effect.andThen(backing.send(portId, [id, 1]))\n          )\n\n        if (span) {\n          effect = Effect.withParentSpan(effect, {\n            _tag: \"ExternalSpan\",\n            traceId: span[0],\n            spanId: span[1],\n            sampled: span[2],\n            context: Context.empty()\n          })\n        }\n\n        return Effect.uninterruptibleMask((restore) =>\n          restore(effect).pipe(\n            Effect.catchIf(\n              isWorkerError,\n              (error) => backing.send(portId, [id, 3, WorkerError.encodeCause(Cause.fail(error))])\n            ),\n            Effect.catchAllCause((cause) =>\n              Either.match(Cause.failureOrCause(cause), {\n                onLeft: (error) => {\n                  collector.unsafeClear()\n                  return pipe(\n                    options?.encodeError\n                      ? Effect.provideService(\n                        options.encodeError(input, error),\n                        Transferable.Collector,\n                        collector\n                      )\n                      : Effect.succeed(error),\n                    Effect.flatMap((payload) => backing.send(portId, [id, 2, payload as any], collector.unsafeRead())),\n                    Effect.catchAllCause((cause) => backing.send(portId, [id, 3, WorkerError.encodeCause(cause)]))\n                  )\n                },\n                onRight: (cause) => backing.send(portId, [id, 3, WorkerError.encodeCause(cause)])\n              })\n            )\n          )\n        )\n      }),\n      Effect.ensuring(Effect.sync(() => fiberMap.delete(id)))\n    )\n  })\n})\n\n/** @internal */\nexport const layer = <I, E, R, O>(\n  process: (request: I) => Stream.Stream<O, E, R> | Effect.Effect<O, E, R>,\n  options?: WorkerRunner.Runner.Options<I, O, E>\n): Layer.Layer<never, WorkerError, WorkerRunner.PlatformRunner | R> =>\n  Layer.scopedDiscard(make(process, options)).pipe(\n    Layer.provide(layerCloseLatch)\n  )\n\n/** @internal */\nexport const makeSerialized = <\n  R,\n  I,\n  A extends Schema.TaggedRequest.All,\n  const Handlers extends WorkerRunner.SerializedRunner.Handlers<A>\n>(\n  schema: Schema.Schema<A, I, R>,\n  handlers: Handlers\n): Effect.Effect<\n  void,\n  WorkerError,\n  | R\n  | WorkerRunner.PlatformRunner\n  | Scope.Scope\n  | WorkerRunner.SerializedRunner.HandlersContext<Handlers>\n> =>\n  Effect.gen(function*() {\n    const scope = yield* Effect.scope\n    let context = Context.empty() as Context.Context<any>\n    const parseRequest = Schema.decodeUnknown(schema) as (_: unknown) => Effect.Effect<A>\n\n    return yield* make((request: A) => {\n      const result = (handlers as any)[request._tag](request)\n      if (Layer.isLayer(result)) {\n        return Effect.flatMap(Layer.buildWithScope(result, scope), (_) =>\n          Effect.sync(() => {\n            context = Context.merge(context, _)\n          }))\n      } else if (Effect.isEffect(result)) {\n        return Effect.provide(result, context)\n      }\n      return Stream.provideContext(result as any, context)\n    }, {\n      decode(message) {\n        return Effect.mapError(\n          parseRequest(message),\n          (cause) => new WorkerError({ reason: \"decode\", cause })\n        )\n      },\n      encodeError(request, message) {\n        return Effect.mapError(\n          Schema.serializeFailure(request as any, message),\n          (cause) => new WorkerError({ reason: \"encode\", cause })\n        )\n      },\n      encodeOutput(request, message) {\n        return Effect.catchAllCause(\n          Schema.serializeSuccess(request as any, message),\n          (cause) => new WorkerError({ reason: \"encode\", cause })\n        )\n      }\n    })\n  }) as any\n\n/** @internal */\nexport const layerSerialized = <\n  R,\n  I,\n  A extends Schema.TaggedRequest.All,\n  const Handlers extends WorkerRunner.SerializedRunner.Handlers<A>\n>(\n  schema: Schema.Schema<A, I, R>,\n  handlers: Handlers\n): Layer.Layer<\n  never,\n  WorkerError,\n  | R\n  | WorkerRunner.PlatformRunner\n  | WorkerRunner.SerializedRunner.HandlersContext<Handlers>\n> => Layer.scopedDiscard(makeSerialized(schema, handlers)).pipe(Layer.provide(layerCloseLatch))\n\n/** @internal */\nexport const launch = <A, E, R>(layer: Layer.Layer<A, E, R>): Effect.Effect<void, E | WorkerError, R> =>\n  Effect.scopedWith(Effect.fnUntraced(function*(scope) {\n    const context = yield* Layer.buildWithScope(Layer.provideMerge(layer, layerCloseLatch), scope)\n    const closeLatch = Context.get(context, CloseLatch)\n    return yield* Deferred.await(closeLatch)\n  }))\n"],
  "mappings": "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G,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAGrE,IAAMC,kBAAkB,CACtB,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAC3E,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,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a,mBAAmBb,MAAK,KAAKA;YACvC,QAAQ;YAAC;UACX;QACF;AACA,cAAMc,eAAelB,OAAOG,GAAG;AAE/B,YAAIe,iBAAiBC,QAAW;AAC9BnB,iBAAOG,GAAG,IAAIC;QAChB,OAAO;AAEL,cAAIc,aAAaE,KAAK;AACpBF,yBAAaG,KAAKjB,MAAK;UACzB,OAAO;AACLJ,mBAAOG,GAAG,IAAI,CAACe,cAAcd,MAAK;UACpC;QACF;MACF;AAGAA,MAAAA,SAAQ;AACRC,sBAAgBQ;AAChBP,sBAAgBO;AAChBN,wBAAkB;AAClBC,0BAAoB;AACpBC,mBAAa;AACbC,qBAAe;IACjB,WAESE,MAAM,IAAI;AACjB,UAAIN,iBAAiBD,eAAe;AAClCC,wBAAgBO;MAClB,OAEK;AACHL,4BAAoB;MACtB;IACF,WAESI,MAAM,IAAI;AACjB,UAAIN,gBAAgBD,eAAe;AACjCK,uBAAe;MACjB,OAAO;AACLD,qBAAa;MACf;IACF,WAESG,MAAM,IAAI;AACjB,UAAIN,gBAAgBD,eAAe;AACjCG,4BAAoB;MACtB,OAAO;AACLD,0BAAkB;MACpB;IACF;EACF;AAEA,SAAOP;AACT;AAoEA,IAAMsB,WAAWC,MAAMC,KACrB;EAAEC,QAAQ;AAAG,GACb,CAACC,GAAGC,MAAM,QAAQA,IAAI,KAAK,MAAM,MAAMA,EAAEC,SAAS,EAAE,GAAGC,YAAW,CAAE;AAUtE,IAAMC,WAAW,IAAIC,UAAU;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAAG,CACJ;;;AC7UD,IAAMC,mBAAmB;AACzB,IAAMC,wBAAwB;AAWvB,IAAMC,SAAOA,CAClBC,WAAwC,CAAA,MACnB,IAAIC,WAAWD,QAAO;AAE7C,IAAMC,aAAN,MAAgB;EACdC,YAAYF,WAAwC,CAAA,GAAE;AACpD,SAAKA,UAAU;MACbG,qBAAqB;MACrBC,wBAAwB;MACxBC,eAAe;MACfC,gBAAgB;MAChB,GAAGN;;EAEP;EAESA;EACTO,SAAuB,CAAA;EACvBC,QAAoC,CAAA;EAEpCC,GACEC,QACAC,MACAC,UAAU;AAEV,UAAMC,qBAAqBF,KAAKG,MAAMhB,qBAAqB;AAC3D,QAAIe,sBAAsBA,mBAAmBE,UAAUC,QAAW;AAChEC,aACEN,KAAKO,WAAWL,mBAAmBE,QAAQF,mBAAmB,CAAC,EAAEK,QACjE,+DAA+D;AAGjE,YAAMC,WAAWR,KAAKS,QACpBtB,uBACA,MAAM;AAER,YAAMuB,eAAeV,KAAKS,QACxBtB,uBACA,IAAI;AAGN,WAAKW,GAAGC,QAAQS,UAAUP,QAAO;AACjC,WAAKH,GAAGC,QAAQW,cAAcT,QAAO;AACrC;IACF;AAEA,QAAI,KAAKZ,QAAQI,wBAAwB;AACvCO,aAAOW,uBAAuBX,IAAI;IACpC;AAEA,QAAI,KAAKX,QAAQG,qBAAqB;AACpCQ,aAAOY,cAAcZ,IAAI;IAC3B;AAEA,UAAMa,UAAU,OAAOd,WAAW,WAAW,CAACA,MAAM,IAAIA;AACxD,eAAWA,WAAUc,SAAS;AAC5B,WAAKC,IAAIf,SAAQC,MAAMC,QAAO;IAChC;EACF;EAEAc,IAAIf,MAAwBC,UAAU;AACpC,SAAKH,GAAGkB,aAAahB,MAAMC,QAAO;EACpC;EAEQa,IAAIf,QAAgBC,MAAwBC,UAAU;AAC5D,QAAI,KAAKJ,MAAME,MAAM,MAAMM,QAAW;AACpC,WAAKR,MAAME,MAAM,IAAI,IAAIkB,WAAW,GAAG;IACzC;AAEA,QAAIC,UAAUlB;AACd,QAAIkB,YAAY,OAAO,KAAKrB,MAAME,MAAM,EAAEoB,OAAOZ,WAAW,GAAG;AAC7D,YAAMa,cAAc,KAAKvB,MAAME,MAAM;AACrC,WAAKF,MAAME,MAAM,IAAI,IAAIkB,WAAW,EAAE;AACtC,WAAKpB,MAAME,MAAM,EAAEsB,eAAe,GAAG,IAAID;IAC3C;AAEA,QAAIE,sBAAsB,KAAKzB,MAAME,MAAM,EAAEoB,OAAOZ;AACpD,QAAIgB,cAAoB,KAAK1B,MAAME,MAAM;AAEzC,UAAMyB,UAAS,CAAA;AACf,aAASC,IAAI,GAAGA,KAAKP,QAAQX,QAAQkB,KAAK;AACxC,UAAIP,QAAQQ,WAAWD,CAAC,MAAM,MAAMP,QAAQQ,WAAWD,IAAI,CAAC,MAAM,IAAI;AAEpEA;AACA;MACF;AAEA,YAAME,mBACJT,QAAQQ,WAAWD,CAAC,MAAM,MAAMP,QAAQQ,WAAWD,IAAI,CAAC,MAAM;AAChE,YAAMG,iBAAiBV,QAAQQ,WAAWD,CAAC,MAAM;AAEjD,UACEE,oBACAC,kBACCH,MAAMP,QAAQX,UAAUkB,MAAMH,qBAC/B;AACA,YAAIO,iBAAiBX,QAAQY,MAAMR,qBAAqBG,CAAC;AACzD,YAAI,CAAC,KAAKpC,QAAQK,eAAe;AAC/BmC,2BAAiBA,eAAeE,YAAW;QAC7C;AACAF,yBAAiBA,eAAeG,MAAM,IAAI,EAAEC,KAAK,GAAG;AACpDJ,yBAAiBA,eAAeG,MAAM,GAAG,EAAEC,KAAK,KAAK;AAErDV,sBAAeA,YAA2BW,kBACxCL,cAAc;MAElB;AAEA,UAAIF,kBAAkB;AACpB,YAAIQ,cAAc;AAClB,cAAMC,UAAU,CAAA;AAEhB,YAAIC,sBAAsBZ,IAAI;AAC9B,iBAASa,IAAID,uBAAuBC,KAAK;AACvC,gBAAMC,WAAWrB,QAAQQ,WAAWY,CAAC;AAErC,gBAAME,eAAeD,aAAa;AAClC,gBAAME,eAAeF,aAAa,MAAMA,aAAa;AACrD,gBAAMG,cAAcH,aAAa,MAAMD,MAAMpB,QAAQX;AAErD,cAAIiC,gBAAgBC,gBAAgBC,aAAa;AAC/C,kBAAMC,YAAYzB,QAAQY,MAAMO,qBAAqBC,CAAC;AACtDd,YAAAA,QAAOoB,KAAKD,SAAS;AAErBR,0BAAcA,eAAeK,gBAAgBC;AAE7C,gBAAID,cAAc;AAChB,oBAAMK,kBAAkBC,8BAA8B5B,SAASoB,CAAC;AAChE,oBAAMS,cAAc7B,QAAQY,MAAMQ,GAAGO,kBAAkB,CAAC;AAExDT,sBAAQQ,KAAKI,sBAAsBD,WAAW,CAAC;AAE/CT,kBAAIO,kBAAkB;YACxB,OAAO;AACLT,sBAAQQ,KAAK,OAAO;YACtB;AAEA,kBAAMK,uBAAuBX;AAC7B,mBAAOA,IAAIpB,QAAQX,QAAQ+B,KAAK;AAC9B,oBAAMC,YAAWrB,QAAQQ,WAAWY,CAAC;AACrC,kBAAIC,cAAa,GAAI;AACrB,kBAAIA,cAAa,IAAI;AACnB,sBAAMW,eAAehC,QAAQQ,WAAWY,IAAI,CAAC;AAC7C,oBAAIY,iBAAiB,GAAIZ;oBACpB;cACP;YACF;AAEA,gBAAIa,aAAajC,QAAQY,MAAMmB,sBAAsBX,CAAC;AACtD,gBAAIa,YAAY;AACdA,2BAAaA,WAAWnB,MAAM,IAAI,EAAEC,KAAK,GAAG;AAC5CkB,2BAAaA,WAAWnB,MAAM,GAAG,EAAEC,KAAK,KAAK;AAC7CG,sBAAQQ,KAAKQ,aAAaD,UAAU,CAAC;YACvC;AAEAd,kCAAsBC,IAAI;AAE1B,gBACEI,eACAxB,QAAQQ,WAAWY,CAAC,MAAM,MAC1BA,MAAMpB,QAAQX,QACd;AACA,oBAAM8C,cAAclB,cAAc,OAAOgB,aAAaA;AACtD,oBAAMG,WAAWpC,QAAQY,MAAML,GAAGa,CAAC;AAEnCpB,wBAAUA,QAAQY,MAAM,GAAGL,IAAI,CAAC,IAAI4B,cAAcnC,QAAQY,MAAMQ,CAAC;AACjEb,mBAAK4B,YAAY9C;AAEjB,oBAAMgD,QAAQpB,cACV,IAAIqB,OAAO,MAAMpB,QAAQH,KAAK,EAAE,IAAI,GAAG,IACvC5B;AACJkB,4BAAeA,YAA2BkC,sBACxCF,OACAJ,YACAG,QAAQ;AAEVhC,oCAAsBG,IAAI;AAC1B;YACF;UACF;QACF;MACF,WAAWG,gBAAgB;AAEzBJ,QAAAA,QAAOoB,KAAK,GAAG;AACfrB,sBAAeA,YAA2BmC,oBAAmB;AAC7DpC,8BAAsBG,IAAI;AAE1B,YAAIA,MAAMP,QAAQX,SAAS,GAAG;AAC5B,gBAAM,IAAIoD,MAAM,kDAAkD;QACpE;MACF;IACF;AAEA,QAAI,CAAC,KAAKtE,QAAQK,eAAe;AAC/BwB,gBAAUA,QAAQa,YAAW;IAC/B;AAEA,QAAIb,YAAY,KAAK;AACnBA,gBAAU;IACZ;AAEA,eAAW0C,cAAc,KAAKhE,QAAQ;AACpC,UAAIgE,WAAW7D,WAAWA,UAAU6D,WAAW1C,YAAYA,SAAS;AAClE,cAAM,IAAIyC,MACR,WAAW5D,MAAM,iCAAiCmB,OAAO,GAAG;MAEhE;IACF;AAEA,UAAM2C,SAAQ;MAAE9D;MAAQC;MAAMkB;MAASM,QAAAA;MAAQvB,SAAAA;IAAO;AACtD,SAAKL,OAAOgD,KAAKiB,MAAK;AACtBtC,gBAAYuC,SAASD,MAAK;EAC5B;EAEAE,IAAIhE,QAAgBC,MAAY;AAC9B,UAAMgE,OAAO,KAAKnE,MAAME,MAAM;AAC9B,QAAIiE,SAAS3D,QAAW;AACtB,aAAO;IACT;AAEA,UAAM4D,aAAaD,KAAKE,eAAelE,IAAI;AAC3C,QAAIiE,eAAe5D,QAAW;AAC5B,aAAO;IACT;AAEA,WAAO4D,WAAWE;EACpB;EAEAC,KAAKrE,QAAgBC,MAAY;AAC/B,QAAIuB,cAAgC,KAAK1B,MAAME,MAAM;AACrD,QAAIwB,gBAAgBlB,OAAW,QAAOA;AAEtC,QAAIL,KAAK0B,WAAW,CAAC,MAAM,IAAI;AAE7B1B,aAAOA,KAAKS,QAAQvB,kBAAkB,GAAG;IAC3C;AAKA,QAAI,KAAKG,QAAQI,wBAAwB;AACvCO,aAAOW,uBAAuBX,IAAI;IACpC;AAEA,QAAIqE;AACJ,QAAIC;AACJ,QAAIC;AAEJ,QAAI;AACFF,qBAAeG,cAAcxE,IAAI;AACjCA,aAAOqE,aAAarE;AACpBsE,oBAAcD,aAAaC;AAC3BC,0BAAoBF,aAAaE;IACnC,SAASE,OAAO;AACd,aAAOpE;IACT;AAEA,QAAI,KAAKhB,QAAQG,qBAAqB;AACpCQ,aAAOY,cAAcZ,IAAI;IAC3B;AAEA,UAAM0E,aAAa1E;AAEnB,QAAI,KAAKX,QAAQK,kBAAkB,OAAO;AACxCM,aAAOA,KAAK+B,YAAW;IACzB;AAEA,UAAMpC,iBAAiB,KAAKN,QAAQM;AAEpC,QAAIgF,YAAapD,YAA2BJ,OAAOZ;AACnD,UAAMiB,UAAS,CAAA;AACf,UAAMoD,UAAU5E,KAAKO;AAErB,UAAMsE,qBAAyC,CAAA;AAE/C,WAAO,MAAM;AACX,UAAIF,cAAcC,WAAWrD,YAAY4C,YAAY;AACnD,cAAMW,SAASvD,YAAYwD,gBAAgBX,KAAI;AAC/C,YAAIU,WAAWzE,QAAW;AACxB,iBAAO;YACLJ,SAAS6E,OAAO7E;YAChBuB,QAAQsD,OAAOE,aAAaxD,OAAM;YAClCyD,cAAiBC,OAAMZ,WAAW;;QAEtC;MACF;AAEA,UAAIN,OAAyBzC,YAAY4D,YACvCnF,MACA2E,WACAE,oBACArD,QAAOjB,MAAM;AAGf,UAAIyD,SAAS3D,QAAW;AACtB,YAAIwE,mBAAmBtE,WAAW,GAAG;AACnC,iBAAOF;QACT;AAEA,cAAM+E,mBAAmBP,mBAAmBQ,IAAG;AAC/CV,oBAAYS,iBAAiBE;AAC7B9D,QAAAA,QAAO+D,OAAOH,iBAAiBI,WAAW;AAC1CxB,eAAOoB,iBAAiBK;MAC1B;AAEAlE,oBAAcyC;AAGd,UAAIzC,YAAYmE,SAAS,cAAc;AACrCf,qBAAapD,YAAYJ,OAAOZ;AAChC;MACF;AAEA,UAAIgB,YAAYmE,SAAS,gBAAgB;AACvC,YAAIC,SAAQjB,WAAW5C,MAAM6C,SAAS;AACtC,YAAIJ,mBAAmB;AACrBoB,UAAAA,SAAQC,uBAAuBD,MAAK;QACtC;AAEAnE,QAAAA,QAAOoB,KAAK+C,MAAK;AACjBhB,oBAAYC;AACZ;MACF;AAEA,UAAIrD,YAAYmE,SAAS,kBAAkB;AACzC,YAAIG,gBAAgBnB,WAAWoB,QAAQ,KAAKnB,SAAS;AACrD,YAAIkB,kBAAkB,IAAI;AACxBA,0BAAgBjB;QAClB;AAEA,YAAIe,SAAQjB,WAAW5C,MAAM6C,WAAWkB,aAAa;AACrD,YAAItB,mBAAmB;AACrBoB,UAAAA,SAAQC,uBAAuBD,MAAK;QACtC;AAEA,YAAIpE,YAAYgC,UAAUlD,QAAW;AACnC,gBAAM0F,oBACJxE,YAAYgC,MAAMyC,KAAKL,MAAK;AAC9B,cAAII,sBAAsB,KAAM;AAEhC,mBAAStE,IAAI,GAAGA,IAAIsE,kBAAkBxF,QAAQkB,KAAK;AACjD,kBAAMwE,eAAuBF,kBAAkBtE,CAAC;AAChD,gBAAIwE,aAAa1F,SAASZ,gBAAgB;AACxC,qBAAOU;YACT;AACAmB,YAAAA,QAAOoB,KAAKqD,YAAY;UAC1B;QACF,OAAO;AACL,cAAIN,OAAMpF,SAASZ,gBAAgB;AACjC,mBAAOU;UACT;AACAmB,UAAAA,QAAOoB,KAAK+C,MAAK;QACnB;AAEAhB,oBAAYkB;MACd;IACF;EACF;;AAeF,IAAMK,iBAAN,MAAoB;EACTC,WAA2B,CAAA;EACpCC;EAEAhC,OAAI;AACF,WAAO,KAAKgC;EACd;EAEAC,IAAIxC,QAAY;AACd,UAAM5D,WAAmB;MACvBuB,QAAQqC,OAAMrC;MACdvB,SAAS4D,OAAM5D;MACf+E,cAAcsB,oBAAoBzC,OAAMrC,MAAM;;AAEhD,SAAK2E,SAASvD,KAAK3C,QAAO;AAC1B,SAAKmG,uBAAuB,KAAKD,SAAS,CAAC;EAC7C;;AAeF,IAAeI,WAAf,MAAuB;EACrBpC,aAAa;EACbvE;EACAmF;EAEAjB,SAASD,QAAY;AACnB,QAAI,KAAKjE,WAAWS,QAAW;AAC7B,WAAKT,SAAS,CAACiE,MAAK;IACtB,OAAO;AACL,WAAKjE,OAAOgD,KAAKiB,MAAK;IACxB;AAEA,QAAI,KAAKkB,mBAAmB1E,QAAW;AACrC,WAAK0E,iBAAiB,IAAImB,eAAc;IAC1C;AACA,SAAK/B,aAAa;AAClB,SAAKY,eAAesB,IAAIxC,MAAK;EAC/B;;AAUF,IAAe2C,aAAf,cAAkCD,SAAQ;EAC/BlF,iBAA6C,CAAA;EAEtDoF,wBACEzG,MACA2E,WAAiB;AAEjB,UAAM+B,cAAc,KAAKrF,eAAerB,KAAK2G,OAAOhC,SAAS,CAAC;AAC9D,QACE+B,gBAAgBrG,UAChB,CAACqG,YAAYE,YAAY5G,MAAM2E,SAAS,GACxC;AACA,aAAOtE;IACT;AACA,WAAOqG;EACT;EAEAxC,eAAelE,MAAc2E,YAAY,GAAC;AACxC,QAAI3E,KAAKO,WAAWoE,WAAW;AAC7B,aAAO;IACT;AAEA,UAAM+B,cAAc,KAAKD,wBAAwBzG,MAAM2E,SAAS;AAChE,QAAI+B,gBAAgBrG,QAAW;AAC7B,aAAOA;IACT;AAEA,WAAOqG,YAAYxC,eACjBlE,MACA2E,YAAY+B,YAAYvF,OAAOZ,MAAM;EAEzC;EAEA2B,kBAAkBlC,MAAY;AAC5B,QAAIA,KAAKO,WAAW,GAAG;AACrB,aAAO;IACT;AAEA,QAAImG,cAAc,KAAKrF,eAAerB,KAAK2G,OAAO,CAAC,CAAC;AACpD,QAAID,aAAa;AACf,UAAIjF,IAAI;AACR,aAAOA,IAAIiF,YAAYvF,OAAOZ,QAAQkB,KAAK;AACzC,YAAIzB,KAAK0B,WAAWD,CAAC,MAAMiF,YAAYvF,OAAOO,WAAWD,CAAC,GAAG;AAC3DiF,wBAAcA,YAAY1E,MAAM,MAAMP,CAAC;AACvC;QACF;MACF;AACA,aAAOiF,YAAYxE,kBAAkBlC,KAAK8B,MAAML,CAAC,CAAC;IACpD;AAEA,UAAMoF,QAAQ7G,KAAK2G,OAAO,CAAC;AAC3B,SAAKtF,eAAewF,KAAK,IAAI,IAAI5F,WAAWjB,IAAI;AAChD,WAAO,KAAKqB,eAAewF,KAAK;EAClC;;AAGF,IAAM5F,aAAN,MAAMA,oBAAmBuF,WAAU;EACxBd,OAAO;EAChBnG,YAAY4B,QAAc;AACxB,UAAK;AACL,SAAK2F,UAAU3F,MAAM;EACvB;EAEAA;EACAyF;EACSG,qBAA4C,CAAA;EAErDC;EAEQF,UAAU3F,QAAc;AAC9B,SAAKA,SAASA;AAEd,QAAIA,OAAOZ,WAAW,GAAG;AACvB,WAAKqG,cAAc,CAACK,OAAOC,eAAe;IAC5C,OAAO;AACL,YAAMC,MAAMhG,OAAOZ;AACnB,WAAKqG,cAAc,SAAU5G,MAAM2E,WAAS;AAC1C,iBAASlD,IAAI,GAAGA,IAAI0F,KAAK1F,KAAK;AAC5B,cAAIzB,KAAK0B,WAAWiD,YAAYlD,CAAC,MAAM,KAAKN,OAAOO,WAAWD,CAAC,GAAG;AAChE,mBAAO;UACT;QACF;AACA,eAAO;MACT;IACF;EACF;EAEA2F,mBAAmB7D,OAAyB;AAC1C,QAAIA,UAAUlD,QAAW;AACvB,aAAO,KAAK0G,mBAAmB3C,KAAKiD,WAASA,MAAMC,YAAY,KAAK;IACtE;AAEA,UAAMC,SAAShE,MAAMgE;AACrB,WAAO,KAAKR,mBAAmB3C,KAAKiD,WAAQ;AAC1C,UAAIA,MAAM9D,UAAUlD,QAAW;AAC7B,eAAO;MACT;AACA,aAAOgH,MAAM9D,MAAMgE,WAAWA;IAChC,CAAC;EACH;EAEA9D,sBACEF,OACAiE,cACAlE,UAAgB;AAEhB,QAAI+D,QAAQ,KAAKD,mBAAmB7D,KAAK;AACzC,QAAI8D,UAAUhH,QAAW;AACvBgH,YAAMI,UAAUpB,IAAI/C,QAAQ;AAC5B,aAAO+D;IACT;AAEAA,YAAQ,IAAIK,eAAenE,OAAOiE,cAAclE,QAAQ;AACxD,SAAKyD,mBAAmBnE,KAAKyE,KAAK;AAClC,SAAKN,mBAAmBY,KAAK,CAACC,QAAQC,WAAU;AAC9C,UAAI,CAACD,OAAON,QAAS,QAAO;AAC5B,UAAI,CAACO,OAAOP,QAAS,QAAO;AAE5B,UAAIM,OAAOJ,iBAAiBnH,OAAW,QAAO;AAC9C,UAAIwH,OAAOL,iBAAiBnH,OAAW,QAAO;AAE9C,UAAIwH,OAAOL,aAAaM,SAASF,OAAOJ,YAAY,EAAG,QAAO;AAC9D,UAAII,OAAOJ,aAAaM,SAASD,OAAOL,YAAY,EAAG,QAAO;AAE9D,aAAO;IACT,CAAC;AAED,WAAOH;EACT;EAEA3D,sBAAmB;AACjB,QAAI,KAAKsD,kBAAkB3G,QAAW;AACpC,WAAK2G,gBAAgB,IAAIe,aAAY;IACvC;AACA,WAAO,KAAKf;EACd;EAEAhF,MAAMgG,YAAwBzH,QAAc;AAC1C,UAAM0H,eAAe,KAAK9G,OAAOW,MAAM,GAAGvB,MAAM;AAChD,UAAM2H,cAAc,KAAK/G,OAAOW,MAAMvB,MAAM;AAE5C,SAAKuG,UAAUoB,WAAW;AAE1B,UAAMjE,aAAa,IAAIhD,YAAWgH,YAAY;AAC9ChE,eAAW5C,eAAe6G,YAAYvB,OAAO,CAAC,CAAC,IAAI;AACnDqB,eAAW3G,eAAe4G,aAAatB,OAAO,CAAC,CAAC,IAAI1C;AAEpD,WAAOA;EACT;EAEAkB,YACEnF,MACA2E,WACAwD,WACA3C,aAAmB;AAEnB,QAAIxB,OAAyB,KAAKyC,wBAAwBzG,MAAM2E,SAAS;AACzE,QAAIyD,6BAA6B;AAEjC,QAAIpE,SAAS3D,QAAW;AACtB,UAAI,KAAK0G,mBAAmBxG,WAAW,GAAG;AACxC,eAAO,KAAKyG;MACd;AAEAhD,aAAO,KAAK+C,mBAAmB,CAAC;AAChCqB,mCAA6B;IAC/B;AAEA,QAAI,KAAKpB,kBAAkB3G,QAAW;AACpC8H,gBAAUvF,KAAK;QACb4C;QACAF,kBAAkBX;QAClBc,aAAa,KAAKuB;OACnB;IACH;AAEA,aACMvF,IAAI,KAAKsF,mBAAmBxG,SAAS,GACzCkB,KAAK2G,4BACL3G,KACA;AACA0G,gBAAUvF,KAAK;QACb4C;QACAF,kBAAkBX;QAClBc,aAAa,KAAKsB,mBAAmBtF,CAAC;OACvC;IACH;AAEA,WAAOuC;EACT;;AAGF,IAAM0D,iBAAN,cAA6BlB,WAAU;EAG1BjD;EACAiE;EAHF9B,OAAO;EAChBnG,YACWgE,OACAiE,cACTlE,UAAgB;AAEhB,UAAK;AAJI,SAAAC,QAAAA;AACA,SAAAiE,eAAAA;AAIT,SAAKF,UAAU,CAAC,CAAC/D;AACjB,SAAKkE,YAAY,oBAAIY,IAAI,CAAC/E,QAAQ,CAAC;EACrC;EAESgE;EACAG;EAETtC,YAAYnF,MAAc2E,WAAiB;AACzC,WAAO,KAAK8B,wBAAwBzG,MAAM2E,SAAS;EACrD;;AAGF,IAAMoD,eAAN,cAA2BxB,SAAQ;EACxBb,OAAO;EAChBP,YACE8B,OACAC,YACAoB,YACAC,cAAoB;AAEpB,WAAOlI;EACT;;AAQF,IAAMC,SAAiBA,CAACkI,WAAWC,YAAW;AAC5C,MAAI,CAACD,WAAW;AACd,UAAM,IAAI7E,MAAM8E,OAAO;EACzB;AACF;AAEA,SAAS9H,uBAAuBX,MAAY;AAC1C,SAAOA,KAAKS,QAAQ,UAAU,GAAG;AACnC;AAEA,SAASG,cAAcZ,MAAY;AACjC,MAAIA,KAAKO,SAAS,KAAKP,KAAK0B,WAAW1B,KAAKO,SAAS,CAAC,MAAM,IAAI;AAC9D,WAAOP,KAAK8B,MAAM,GAAG,EAAE;EACzB;AACA,SAAO9B;AACT;AAEA,SAASsG,oBACP9E,SAA6B;AAE7B,QAAM2F,MAAM3F,QAAOjB;AACnB,SAAO,SAAUmI,aAAW;AAC1B,UAAMC,eAAuC,CAAA;AAC7C,aAASlH,IAAI,GAAGA,IAAI0F,KAAK1F,KAAK;AAC5BkH,mBAAanH,QAAOC,CAAC,CAAC,IAAIiH,YAAYjH,CAAC;IACzC;AACA,WAAOkH;EACT;AACF;AAEA,SAAS7F,8BAA8B9C,MAAc4I,KAAW;AAK9D,MAAIC,cAAc;AAElB,SAAOD,MAAM5I,KAAKO,QAAQ;AACxBqI;AAGA,QAAI5I,KAAK4I,GAAG,MAAM,MAAM;AACtBA;AACA;IACF;AAEA,QAAI5I,KAAK4I,GAAG,MAAM,KAAK;AACrBC;IACF,WAAW7I,KAAK4I,GAAG,MAAM,KAAK;AAC5BC;IACF;AAEA,QAAI,CAACA,YAAa,QAAOD;EAC3B;AAEA,QAAM,IAAIE,UAAU,mCAAmC9I,OAAO,GAAG;AACnE;AAEA,SAASgD,sBAAsBD,aAAmB;AAEhD,MAAIA,YAAYrB,WAAW,CAAC,MAAM,IAAI;AACpCqB,kBAAcA,YAAYjB,MAAM,GAAG,CAAC,IAAIiB,YAAYjB,MAAM,CAAC;EAC7D;AAEA,MAAIiB,YAAYrB,WAAWqB,YAAYxC,SAAS,CAAC,MAAM,IAAI;AACzDwC,kBACEA,YAAYjB,MAAM,GAAGiB,YAAYxC,SAAS,CAAC,IAC3CwC,YAAYjB,MAAMiB,YAAYxC,SAAS,CAAC;EAC5C;AAEA,SAAOwC;AACT;AAEA,SAASK,aAAa2F,QAAc;AAClC,SAAOA,OAAOtI,QAAQ,uBAAuB,MAAM;AACrD;AAIA,SAASuI,oBAAoBC,cAAsBC,aAAmB;AACpE,MAAID,iBAAiB,IAAI;AACvB,QAAIC,gBAAgB,GAAI,QAAO;AAE/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,IAAK,QAAO;AAChC,WAAO7I;EACT;AACA,MAAI4I,iBAAiB,IAAI;AACvB,QAAIC,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,IAAK,QAAO;AAChC,QAAIA,gBAAgB,GAAI,QAAO;AAC/B,QAAIA,gBAAgB,IAAK,QAAO;AAChC,WAAO7I;EACT;AACA,MAAI4I,iBAAiB,MAAMC,gBAAgB,IAAI;AAC7C,WAAO;EACT;AACA,SAAO7I;AACT;AAEA,SAASmE,cAAcxE,MAAY;AACjC,MAAImJ,eAAe;AACnB,MAAI5E,oBAAoB;AAExB,MAAID,cAAc;AAElB,WAAS7C,IAAI,GAAGA,IAAIzB,KAAKO,QAAQkB,KAAK;AACpC,UAAMc,WAAWvC,KAAK0B,WAAWD,CAAC;AAElC,QAAIc,aAAa,IAAI;AACnB,YAAM0G,eAAejJ,KAAK0B,WAAWD,IAAI,CAAC;AAC1C,YAAMyH,cAAclJ,KAAK0B,WAAWD,IAAI,CAAC;AAEzC,UAAIuH,oBAAoBC,cAAcC,WAAW,MAAM7I,QAAW;AAChE8I,uBAAe;MACjB,OAAO;AACL5E,4BAAoB;AAEpB,YAAI0E,iBAAiB,MAAMC,gBAAgB,IAAI;AAC7CC,yBAAe;AACfnJ,iBAAOA,KAAK8B,MAAM,GAAGL,IAAI,CAAC,IAAI,OAAOzB,KAAK8B,MAAML,IAAI,CAAC;AACrDA,eAAK;QACP;AACAA,aAAK;MACP;IAIF,WAAWc,aAAa,MAAMA,aAAa,MAAMA,aAAa,IAAI;AAChE+B,oBAActE,KAAK8B,MAAML,IAAI,CAAC;AAC9BzB,aAAOA,KAAK8B,MAAM,GAAGL,CAAC;AACtB;IACF;EACF;AACA,QAAM2H,cAAcD,eAAeE,UAAUrJ,IAAI,IAAIA;AACrD,SAAO;IAAEA,MAAMoJ;IAAa9E;IAAaC;EAAiB;AAC5D;AAEA,SAASqB,uBAAuB0D,cAAoB;AAClD,QAAMC,aAAaD,aAAaxD,QAAQ,GAAG;AAC3C,MAAIyD,eAAe,GAAI,QAAOD;AAE9B,MAAIE,UAAU;AACd,MAAIC,YAAYF;AAEhB,WAAS9H,IAAI8H,YAAY9H,IAAI6H,aAAa/I,QAAQkB,KAAK;AACrD,QAAI6H,aAAa5H,WAAWD,CAAC,MAAM,IAAI;AACrC,YAAMwH,eAAeK,aAAa5H,WAAWD,IAAI,CAAC;AAClD,YAAMyH,cAAcI,aAAa5H,WAAWD,IAAI,CAAC;AAEjD,YAAMiI,cAAcV,oBAAoBC,cAAcC,WAAW;AACjEM,iBAAWF,aAAaxH,MAAM2H,WAAWhI,CAAC,IAAIiI;AAE9CD,kBAAYhI,IAAI;IAClB;EACF;AACA,SACE6H,aAAaxH,MAAM,GAAGyH,UAAU,IAAIC,UAAUF,aAAaxH,MAAM2H,SAAS;AAE9E;AAEA,IAAMzI,cAAc,CAClB,OACA,QACA,YACA,WACA,QACA,UACA,OACA,QACA,QACA,QACA,YACA,SACA,cACA,cACA,SACA,QACA,UACA,WACA,SACA,QACA,YACA,aACA,SACA,OACA,UACA,UACA,UACA,UACA,aACA,SACA,UACA,UACA,UACA,aAAa;;;AF5zBR,IAAM2I,SACFA;;;AGzBJ,IAAMC,WAAwBC,OAAOC,IAAI,6BAA6B;AAGtE,IAAMC,cAAkCF,OAAOC,IAAI,mCAAmC;AAGtF,IAAME,qBAAgDH,OAAOC,IAClE,0CAA0C;AAIrC,IAAMG,eAAuBC,WAAgC,0CAA0C;AAE9G,IAAMC,WAAYC,OAAmEC,YAAYD,GAAGR,QAAM;AAGnG,IAAMU,SAAgBC,KAAIN,cAAeO,OAAMA,EAAEF,MAAM;AAGvD,IAAMG,cAAaA,CAaxBC,SACAC,aACE;AACF,QAAMC,SAAeC,cAAcH,SAAQC,QAAO;AAClD,SAAcG,SACLC,QAAO,GACbA,CAAAA,aAAW;AACV,UAAMC,UAAkBC,KAAIF,UAAuBG,iBAAiB;AACpE,UAAMC,eAAuBF,KAAIF,UAAuBK,kBAAkB;AAC1E,UAAMC,eAAuBJ,KAAIF,UAASd,YAAY;AACtD,WAAca,SAAQE,QAAQM,MAAOC,UACnCX,OAAM;MACJY,QAAQR,QAAQQ;MAChBC,KAAKT,QAAQS;MACbC,SAASV,QAAQU;MACjBC,SAASX,QAAQW;MACjBC,YAAYP,aAAaf;MACzBa;MACAI;KACD,CAAC;EACN,CAAC;AAEL;AAGO,IAAMM,gBAAeA,CAY1BnB,SACAC,aACE;AACF,QAAMC,SAAeC,cAAcH,SAAQC,QAAO;AAClD,SAAcG,SACLC,QAAO,GACbA,CAAAA,aAAW;AACV,UAAMC,UAAkBC,KAAIF,UAAuBG,iBAAiB;AACpE,UAAMC,eAAuBF,KAAIF,UAAuBK,kBAAkB;AAC1E,UAAMC,eAAuBJ,KAAIF,UAASd,YAAY;AACtD,WAAOW,OAAM;MACXY,QAAQR,QAAQQ;MAChBC,KAAKT,QAAQS;MACbC,SAASV,QAAQU;MACjBC,SAASX,QAAQW;MACjBC,YAAYP,aAAaf;MACzBa;KACD;EACH,CAAC;AAEL;AAGO,IAAMW,eAAeA,CAC1BpB,SACAC,aACE;AACF,QAAMC,SAAeC,cAAcH,SAAQC,QAAO;AAClD,SAAcG,SACLC,QAAO,GACbA,CAAAA,aAAW;AACV,UAAMI,eAAuBF,KAAIF,UAAuBK,kBAAkB;AAC1E,UAAMC,eAAuBJ,KAAIF,UAASd,YAAY;AACtD,WAAOW,OAAM;MAAE,GAAGO;MAAc,GAAGE,aAAaf;IAAM,CAAE;EAC1D,CAAC;AAEL;AAGO,IAAMyB,mBAAmBA,CAC9BrB,SACAC,aACE;AACF,QAAMC,SAAeC,cAAcH,SAAQC,QAAO;AAClD,SAAcG,SAAQb,cAAeO,OAAMI,OAAMJ,EAAEF,MAAM,CAAC;AAC5D;AAGO,IAAM0B,sBAAsBC,YACjC,mDACA,MAAeC,YAA4C,CAAA,CAAE,CAAC;AAIzD,IAAMC,mBAGTC,KACF,GACA,CAAUC,SAAgCC,WACjCC,QAAQF,SAAQL,qBAAqBM,MAAM,CAAC;AAIhD,IAAME,kBAAmBF,YACxBG,cAAcT,qBAAqBM,MAAM;AAEjD,IAAMI,cAAN,cAA0DC,gBAIzD;EAGYC;EACAC;EAHF,CAACjD,QAAM;EAChBkD,YACWF,QACAC,QAMR;AAED,UAAK;AATI,SAAAD,SAAAA;AACA,SAAAC,SAAAA;AAST,SAAKjD,QAAM,IAAIA;AACf,SAAKmD,UAAmB9B,KAAIe,mBAAmB,EAAEgB,KACxClC,SAASwB,YAAW,KAAKS,UAAUE,UAAU,MAAMX,MAAM,CAAQ,CAAC;EAE7E;EACQS;EAKRG,SAAM;AACJ,WAAO,KAAKH;EACd;EACAI,SAAM;AACJ,WAAO;MACLC,KAAK;MACLR,QAAQ,KAAKA,OAAOO,OAAM;MAC1BN,QAAQ,KAAKA,OAAOM,OAAM;;EAE9B;EACAE,WAAQ;AACN,WAAmBC,OAAO,IAAI;EAChC;EACA,CAAaC,iBAAiB,IAAC;AAC7B,WAAO,KAAKJ,OAAM;EACpB;;AAGF,IAAMF,YAAYA,CAChBO,MACAlB,WAC2C;AAC3C,QAAMmB,SAAmBC,OAAyBpB,MAAM;AACxD,QAAMO,SAAec,gBAAgBH,KAAKX,MAAM,EAAEtC,IAAI,CAAC,CAACqD,MAAMC,KAAKlD,QAAO,MACxE,CACEiD,MACA,IAAIE,iBACF,IAAIC,UACF,KACApD,UAASqD,gBAAgB,GAAGJ,IAAI,OAA2B,MAC3DC,KACAlD,UAASqD,gBAAuBC,KAAI,IAAYC,KAAKN,IAAI,GACzD,KAAK,GAEP,CAAA,CAAE,GAEJjD,QAAO,CACC;AAEZ,QAAMwD,YAAYtB,OAAOuB;AACzBC,EAAMC,QAAQd,KAAKZ,QAAS2B,CAAAA,WAAS;AACnC,QAAIA,OAAM/C,WAAW,KAAK;AACxBiC,aAAOe,IAAID,OAAMX,MAAMW,MAAK;IAC9B,OAAO;AACLd,aAAOgB,GAAGF,OAAM/C,QAAQ+C,OAAMX,MAAMW,MAAK;IAC3C;EACF,CAAC;AACD,SAAcG,iBAIXC,WAAS;AACV,UAAM5D,WAAkBmB,WAAW,IAAI0C,IAAID,MAAME,YAAqBC,cAAc,EAAEC,SAAS,CAAC;AAChG,UAAM/D,UAAkBgE,UAAUjE,UAAuBG,iBAAiB;AAC1E,QAAIiD,YAAY,GAAG;AACjB,YAAMc,cAAcjE,QAAQS,IAAIyD,QAAQ,GAAG;AAC3C,YAAMC,WAAWF,gBAAgB,KAAKjE,QAAQS,MAAMT,QAAQS,IAAI2D,MAAM,GAAGH,WAAW;AAEpF,eAASI,IAAI,GAAGA,IAAIlB,WAAWkB,KAAK;AAClC,cAAM,CAACzB,MAAMvC,cAAcV,QAAO,IAAIkC,OAAOwC,CAAC;AAC9C,YAAIF,aAAavB,QAAQuB,SAASG,WAAW1B,OAAO,GAAG,GAAG;AACxD7C,UAAAA,SAAQgE,UAAUQ,IAAItF,aAAauF,KAAKnE,YAAY;AACpD,cAAIV,UAASqD,kBAAkB,MAAM;AACnCjD,YAAAA,SAAQgE,UAAUQ,IAAkBrE,kBAAkBsE,KAAKC,gBAAgBzE,SAAS4C,IAAI,CAAC;UAC3F;AACA,iBAAcrB,QACLzB,SAAQO,aAAakD,MAAMmB,SAAqBC,UAAU,GACxDb,gBACT/D,QAAO;QAEX;MACF;IACF;AAEA,QAAI6E,SAASnC,OAAOoC,KAAK7E,QAAQQ,QAAQR,QAAQS,GAAG;AACpD,QAAImE,WAAWE,UAAa9E,QAAQQ,WAAW,QAAQ;AACrDoE,eAASnC,OAAOoC,KAAK,OAAO7E,QAAQS,GAAG;IACzC;AACA,QAAImE,WAAWE,QAAW;AACxB,aAAcC,MAAK,IAAUC,cAAc;QAAEhF;MAAO,CAAE,CAAC;IACzD;AACA,UAAMuD,SAAQqB,OAAOF;AACrB,QAAInB,OAAM0B,OAAOC,SAAS,QAAQ;AAChCnF,MAAAA,SAAQgE,UAAUQ,IAAkBrE,kBAAkBsE,KAAKC,gBAAgBzE,SAASuD,OAAM0B,OAAOE,KAAK,CAAC;IACzG;AACApF,IAAAA,SAAQgE,UAAUQ,IAAkBnE,mBAAmBoE,KAAKI,OAAOzE,YAAY;AAC/EJ,IAAAA,SAAQgE,UAAUQ,IAAItF,aAAauF,KAAK,IAAI1B,iBAAiBS,QAAOqB,OAAOtF,MAAM,CAAC;AAElF,UAAM8F,OAAeC,UAAUtF,UAAgBuF,UAAU;AACzD,QAAIF,KAAKF,SAAS,UAAUE,KAAKD,MAAMD,SAAS,QAAQ;AACtDE,WAAKD,MAAMI,UAAU,cAAchC,OAAMX,IAAI;IAC/C;AAEA,UAAM4C,kBAAyB1F,SAAQyD,OAAMmB,SAAqBC,UAAU;AAC5E,WAAcpD,QACXgC,OAAMkC,kBACLD,kBACOE,cAAcF,eAAe,GAK7B1B,gBACT/D,QAAO;EAEX,CAAC;AACH;AAEA,SAAS0E,gBAAgBzE,SAA0CiF,QAAc;AAC/E,QAAMU,YAAYV,OAAO7B;AACzB,SAAOpD,QAAQ4F,OAAO;IAAEnF,KAAKT,QAAQS,IAAI2C,UAAUuC,YAAY,MAAM3F,QAAQS,IAAI2D,MAAMuB,SAAS;EAAC,CAAE;AACrG;AAEA,IAAM5C,YAAN,cAA0D8C,MAAK;EAGlDrF;EACAoC;EACA8B;EACAO;EACAQ;EANF,CAAC1G,WAAW;EACrB+C,YACWtB,QACAoC,MACA8B,UACAO,SAAgBhC,KAAI,GACpBwC,mBAAkB,OAAK;AAEhC,UAAK;AANI,SAAAjF,SAAAA;AACA,SAAAoC,OAAAA;AACA,SAAA8B,UAAAA;AACA,SAAAO,SAAAA;AACA,SAAAQ,kBAAAA;AAGT,SAAK1G,WAAW,IAAIA;EACtB;EACAoD,SAAM;AACJ,WAAO;MACLC,KAAK;MACL5B,QAAQ,KAAKA;MACboC,MAAM,KAAKA;MACXqC,QAAQ,KAAKA,OAAO9C,OAAM;;EAE9B;;AAGF,IAAMW,mBAAN,MAAsB;EAGTS;EACAjE;EAHF,CAACN,kBAAkB;EAC5B8C,YACWyB,QACAjE,SAAoD;AADpD,SAAAiE,QAAAA;AACA,SAAAjE,SAAAA;AAET,SAAKN,kBAAkB,IAAIA;EAC7B;;AAIK,IAAM8G,UAAkC,IAAIpE,YAAiBoE,OAAK,GAAUA,OAAK,CAAE;AAGnF,IAAMC,gBACXnE,YAIG,IAAIF,YAAiBqE,cAAanE,MAAM,GAASkE,OAAK,CAAE;AAGtD,IAAME,YAAYA,CACvBxF,QACAoC,MACA8B,UACA/E,aAKA,IAAIoD,UACFvC,QACAoC,MACA8B,UACA/E,UAASsF,SAAgB/B,KAAKvD,SAAQsF,MAAM,IAAWhC,KAAI,GAC3DtD,UAAS8F,mBAAmB,KAAK;AAI9B,IAAMQ,UAAS7E,KAQpB,GAAG,CAACoB,MAAMe,WAAU,IAAI7B,YAAiBuE,QAAOzD,KAAKZ,QAAQ2B,MAAK,GAAUf,KAAKX,MAAM,CAAC;AAGnF,IAAMqE,SAAS9E,KAKpB,GAAG,CAACoB,MAAM2D,SAASC,UAAU5D,MAAM2D,IAAI,CAAC;AAGnC,IAAMC,YAAYA,IACpBC,YAEH,IAAI3E,YACF2E,QAAQC,OAAO,CAACC,KAAKC,QAAcC,WAAUF,KAAKC,IAAI5E,MAAM,GAASkE,OAAK,CAAsB,GAChGO,QAAQC,OACN,CAACC,KAAKC,QAAcC,WAAUF,KAAKC,IAAI3E,MAAM,GACvCiE,OAAK,CAMR,CACJ;AAGL,IAAMY,sBACJ9D,UACsBA,KAAK+D,SAAS,GAAG,IAAI/D,KAAKwB,MAAM,GAAG,EAAE,IAAIxB;AAG1D,IAAMgE,aAGTxF,KAAK,GAAG,CAACoB,MAAMyC,WAAU;AAC3BA,WAASyB,oBAAoBzB,MAAM;AACnC,SAAOzC,SAAS,MAAMyC,SAASA,SAASzC;AAC1C,CAAC;AAGM,IAAMqE,YAAYzF,KAIvB,GACA,CAACoB,MAAMyC,WAAU;AACfA,WAASyB,oBAAoBzB,MAAM;AACnC,SAAO,IAAIvD,YACHnC,KAAIiD,KAAKZ,QAAS2B,CAAAA,WACtB,IAAIR,UACFQ,OAAM/C,QACN+C,OAAMX,SAAS,MAAMqC,SAASA,SAAS1B,OAAMX,MAC7CW,OAAMmB,SACCoC,OACEvH,KAAIgE,OAAM0B,QAASzF,OAAMyF,SAASzF,CAAC,GAC1C,MAAa0D,KAAK+B,MAAM,CAAC,GAE3B1B,OAAMkC,eAAe,CACtB,GACGlG,KAAIiD,KAAKX,QAAQ,CAAC,CAACe,MAAMC,GAAG,MAAM,CAACD,SAAS,MAAMqC,SAASA,SAASrC,MAAMC,GAAG,CAAC,CAAC;AAEzF,CAAC;AAII,IAAMkE,QAAQ3F,KAWnB,GACA,CAACoB,MAAMI,MAAMuD,SAASD,OAAO1D,MAAMqE,UAAUV,MAAMvD,IAAI,CAAC,CAAC;AAIpD,IAAMoE,WAAW5F,KAmBrB6F,UAAmB5H,YAAY4H,KAAK,CAAC,GAAGrI,QAAM,GAC/C,CACE4D,MACAI,MACAuD,MACAxG,aAIA,IAAI+B,YAAqBc,KAAKZ,QAAcqE,QAAOzD,KAAKX,QAAQ,CAAC6E,oBAAoB9D,IAAI,GAAGuD,MAAMxG,QAAO,CAAC,CAAC,CAAQ;AAIhH,IAAM4D,QAAS/C,YAmBpBY,KAeG6F,UAAS9H,SAAS8H,KAAK,CAAC,CAAC,GAAG,CAACzE,MAAMI,MAAM8B,UAAS/E,aACnD,IAAI+B,YACIuE,QACJzD,KAAKZ,QACL,IAAImB,UACFvC,QACAoC,MACA8B,UACOzB,KAAI,GACXtD,UAAS8F,mBAAmB,KAAK,CAClC,GAEHjD,KAAKX,MAAM,CACZ;AAGE,IAAM2B,OAAMD,MAAM,GAAG;AAGrB,IAAMtD,QAAMsD,MAAM,KAAK;AAGvB,IAAM2D,QAAO3D,MAAM,MAAM;AAGzB,IAAM4D,OAAM5D,MAAM,KAAK;AAGvB,IAAM6D,SAAQ7D,MAAM,OAAO;AAG3B,IAAM8D,OAAM9D,MAAM,QAAQ;AAG1B,IAAM+D,QAAO/D,MAAM,MAAM;AAGzB,IAAM5D,WAAU4D,MAAM,SAAS;AAG/B,IAAMgE,MAAMnG,KAQjB,GAAG,CAACoB,MAAMgF,MACV,IAAI9F,YACInC,KACJiD,KAAKZ,QACJ2B,CAAAA,WACC,IAAIR,UACFQ,OAAM/C,QACN+C,OAAMX,MACN4E,EAAS1H,SAAQyD,OAAMmB,SAAqBC,UAAU,CAAC,GACvDpB,OAAM0B,QACN1B,OAAMkC,eAAe,CACtB,GAEClG,KACJiD,KAAKX,QACL,CAAC,CAACe,MAAMC,GAAG,MAAM,CAACD,MAAM4E,EAAE3E,GAAU,CAAC,CAAC,CACvC,CACF;AAGI,IAAM4E,aAAYrG,KAQvB,GAAG,CAACoB,MAAMgF,MACV,IAAI9F,YACInC,KACJiD,KAAKZ,QACJ2B,CAAAA,WACC,IAAIR,UACFQ,OAAM/C,QACN+C,OAAMX,MACN4E,EAAEjE,OAAMmB,OAAO,GACfnB,OAAM0B,QACN1B,OAAMkC,eAAe,CACtB,GAEClG,KACJiD,KAAKX,QACL,CAAC,CAACe,MAAMC,GAAG,MAAM,CAACD,MAAa9C,SAAQ0H,EAAE3E,GAAU,GAAe8B,UAAU,CAAC,CAAC,CAC/E,CACF;AAGI,IAAM+C,YAAWtG,KAQtB,GAAG,CAACoB,MAAMgF,MAAMC,WAAUjF,MAAakF,SAASF,CAAC,CAAC,CAAC;AAG9C,IAAMG,iBAAgBvG,KAQ3B,GAAG,CAACoB,MAAMgF,MAAMC,WAAUjF,MAAamF,cAAcH,CAAC,CAAC,CAAC;AAGnD,IAAMI,YAAWxG,KAYtB,GAAG,CAACoB,MAAMqF,GAAGL,MAAMC,WAAUjF,MAAaoF,SAASC,GAAGL,CAAC,CAAC,CAAC;AAGpD,IAAMM,aA2CT1G,KAAK,GAAG,CAACoB,MAAmCuF,UAAcR,IAAI/E,MAAasF,UAAUC,KAAK,CAAC,CAAC;AAEzF,IAAMC,kBAAiB5G,KAY5B,GAAG,CACHoB,MACAyF,MACAC,YACgEX,IAAI/E,MAAawF,eAAeC,MAAKC,OAAO,CAAC,CAAC;AAGzG,IAAMC,wBAAuB/G,KAwBlC,GAAG,CACHoB,MACAyF,MACA5G,YAOGkG,IAAI/E,MAAa2F,qBAAqBF,MAAK5G,OAAM,CAAC,CAAQ;AAE/D,IAAM+G,cAAcA,MAA4C;AAC9D,MAAI3F,SAASqD;AACb,SAAO;IACLuC,SAAS9E,QAAK;AACZ,aAAc+E,KAAK,MAAK;AACtB7F,iBAASwD,QAAOxD,QAAQc,MAAK;MAC/B,CAAC;IACH;IACAC,IAAIZ,MAAM8B,UAAS/E,UAAO;AACxB,aAAc2I,KAAK,MAAK;AACtB7F,iBAASe,KAAIf,QAAQG,MAAM8B,UAAS/E,QAAO;MAC7C,CAAC;IACH;IACAM,IAAI2C,MAAM8B,UAAS/E,UAAO;AACxB,aAAc2I,KAAK,MAAK;AACtB7F,iBAASxC,MAAIwC,QAAQG,MAAM8B,UAAS/E,QAAO;MAC7C,CAAC;IACH;IACAuH,KAAKtE,MAAM8B,UAAS/E,UAAO;AACzB,aAAc2I,KAAK,MAAK;AACtB7F,iBAASyE,MAAKzE,QAAQG,MAAM8B,UAAS/E,QAAO;MAC9C,CAAC;IACH;IACAwH,IAAIvE,MAAM8B,UAAS/E,UAAO;AACxB,aAAc2I,KAAK,MAAK;AACtB7F,iBAAS0E,KAAI1E,QAAQG,MAAM8B,UAAS/E,QAAO;MAC7C,CAAC;IACH;IACAyH,MAAMxE,MAAM8B,UAAS/E,UAAO;AAC1B,aAAc2I,KAAK,MAAK;AACtB7F,iBAAS2E,OAAM3E,QAAQG,MAAM8B,UAAS/E,QAAO;MAC/C,CAAC;IACH;IACA0H,IAAIzE,MAAM8B,UAAS/E,UAAO;AACxB,aAAc2I,KAAK,MAAK;AACtB7F,iBAAS4E,KAAI5E,QAAQG,MAAM8B,UAAS/E,QAAO;MAC7C,CAAC;IACH;IACA2H,KAAK1E,MAAM8B,UAAS/E,UAAO;AACzB,aAAc2I,KAAK,MAAK;AACtB7F,iBAAS6E,MAAK7E,QAAQG,MAAM8B,UAAS/E,QAAO;MAC9C,CAAC;IACH;IACAA,QAAQiD,MAAM8B,UAAS6D,MAAI;AACzB,aAAcD,KAAK,MAAK;AACtB7F,iBAAS9C,SAAQ8C,QAAQG,MAAM8B,UAAS6D,IAAI;MAC9C,CAAC;IACH;IACA9F,QAAe6F,KAAK,MAAM7F,MAAM;IAChCsE,MAAMnE,MAAMuD,MAAI;AACd,aAAcmC,KAAK,MAAK;AACtB7F,iBAASsE,MAAMtE,QAAQG,MAAMuD,IAAI;MACnC,CAAC;IACH;IACAa,SAASpE,MAAMC,KAAKlD,UAAO;AACzB,aAAc2I,KAAK,MAAK;AACtB7F,iBAASuE,SAASvE,QAAQG,MAAMC,KAAKlD,QAAO;MAC9C,CAAC;IACH;IACAuG,OAAOC,MAAI;AACT,aAAcmC,KAAK,MAAK;AACtB7F,iBAASyD,OAAOzD,QAAQ0D,IAAI;MAC9B,CAAC;IACH;;AAEJ;AAGO,IAAMqC,OACiBC,QAC5B,MAKI;AACF,QAAMC,MAAMC,WAAWC;AACvB,QAAMC,QAAQH,IAAII;AAClBJ,MAAII,kBAAkB;AACtB,QAAMC,gBAAgB,IAAIL,IAAG;AAC7BA,MAAII,kBAAkBD;AAEtB,WAASG,WAAQ;EAAI;AACrB,QAAMC,YAAYD;AAClBE,SAAOC,eAAeH,UAAUE,OAAOE,eAAuBlK,WAAsBuJ,EAAE,CAAC,CAAC;AACxFO,WAASxE,MAAMiE;AACfS,SAAOG,eAAeL,UAAU,SAAS;IACvC/I,MAAG;AACD,aAAO8I,cAAcO;IACvB;GACD;AACDL,YAAUM,OAAajB,MAAKW,WAAWb,WAAW;AAClDa,YAAUxG,SAAgB3C,SAAQmJ,WAAYzJ,OAAMA,EAAEiD,MAAM;AAC5DwG,YAAU1B,MAAOC,OACfyB,UAAUjH,KACDlC,SAAQ0H,CAAC,GACVgC,eACAC,SAAQR,UAAUM,IAAI,CAAC;AAEjCN,YAAUS,SAAUlC,OAClByB,UAAUjH,KACDlC,SAASN,OAAMA,EAAEiD,MAAM,GACvBlD,KAAIiI,CAAC,GACNmC,cACAF,SAAQR,UAAUM,IAAI,CAAC;AAEjCN,YAAUW,QAASC,CAAAA,gBAAeZ,UAAUS,OAAkBE,OAAMC,WAAiB,CAAC;AACtF,SAAOb;AACT;;;AJ7zBK,IAAMc,WAAiCA;AAgIvC,IAAMC,eAAsCA;AAsD5C,IAAMC,sBAA6CA;AAsBnD,IAAMC,gBAAiEA;AAMvE,IAAMC,UAIAA;AAMN,IAAMC,cAmBAA;AAMN,IAAMC,gBAoBAA;AAMN,IAAMC,gBAIFA;AAMJ,IAAMC,oBAG8DA;AAMpE,IAAMC,uBAAgEA;AAMtE,IAAMC,oBAWAA;AAMN,IAAMC,mBAAkFA;AAMxF,IAAMC,UAA6BA;AAMnC,IAAMC,gBAGFA;AAMJ,IAAMC,aAK2CA;AAMjD,IAAMC,cAWAA;AAMN,IAAMC,aAWAA;AAMN,IAAMC,UAmBAA;AAMN,IAAMC,UAgBAA;AAMN,IAAMC,aAEuFA;AAM7F,IAAMC,SAWAA;AAMN,IAAMC,YA8BAA;AAMN,IAAMC,SAgBAA;AAMN,IAAMC,OA4BAA;AAMN,IAAMC,QAsBAA;AAMN,IAAMC,QAsBAA;AAMN,IAAMC,SAsBAA;AAMN,IAAMC,OAsBAA;AAMN,IAAMC,OAsBAA;AAMN,IAAMC,QAsBAA;AAMN,IAAMC,WAsBAA;AAMN,IAAMC,OAcAA;AAMN,IAAMC,aAgBAA;AAMN,IAAMC,YAWAA;AAMN,IAAMC,iBAWAA;AAMN,IAAMC,YAiBAA;AAMN,IAAMC,aA8CAA;AAMN,IAAMC,kBAWAA;AAMN,IAAMC,wBAyBAA;AAMN,IAAMC,OAGFA;AAML,IAAOC,UAAP,cAAuBD,KAAI,qCAAqC,EAAC,EAAW;AAAA;;;AKr9BlF;;iBAAAE;EAAA,YAAAC;EAAA;;AAwPO,IAAMC,SAAiBC,CAAAA,YAAwC;AACpE,QAAMC,OAAmC,CAAA;AACzC,QAAMC,MAAYC,aAAaH,SAAQ;IAAEC;EAAI,CAAE;AAC/C,MAAI,CAAQG,cAAcH,IAAI,GAAG;AAC/BC,QAAIG,QAAQJ;EACd;AACA,SAAOC;AACT;AAuBO,IAAMC,eAAeA,CAAUH,SAAgCM,aAKpDC,SAAQP,QAAOQ,KAAKF,QAAO;AAGtC,IAAMC,WAAUA,CAACC,KAAcF,aAKrB;AACf,QAAMG,cAAwBF,QAAQC,KAAK;IACzCE,aAAaJ,SAAQL;IACrBU,gBAAgBL,SAAQM,YAAY;IACpCC,QAAQ;IACRC,2BAA2BR,SAAQQ;IACnCC,8BAA8BT,SAAQS;GACvC;AACD,SAAON;AACT;;;ACxSA;;;;;;;;;;;;;;;qBAAAO;EAAA;;AAkBM,IAAOC,aAAP,cAAkCC,IAAI,qCAAqC,EAAC,EAAsB;AAAA;AAMlG,IAAOC,QAAP,cAA6BD,IAAI,gCAAgC,EAAC,EAAiB;AAAA;AAMnF,IAAOE,UAAP,cAA+BF,IAAI,kCAAkC,EAAC,EAAmB;AAAA;AAMzF,IAAOG,cAAP,cAAmCH,IAAI,sCAAsC,EAAC,EAAuB;AAAA;AAMrG,IAAOI,UAAP,cAA+BJ,IAAI,kCAAkC,EAAC,EAA+B;AAAA;AAMrG,IAAOK,eAAP,cACYL,IAAI,uCAAuC,EAAC,EAAyC;AAAA;AAOjG,IAAOM,UAAP,cACYN,IAAI,kCAAkC,EAAC,EAA6C;AAAA;AAOhG,IAAOO,SAAP,cAA8BP,IAAI,iCAAiC,EAAC,EAAkB;AAAA;AAMtF,IAAOQ,UAAP,cAA+BR,IAAI,kCAAkC,EAAC,EAAmB;AAAA;AAMzF,IAAOS,aAAP,cAAkCT,IAAI,qCAAqC,EAAC,EAAuB;AAAA;AAMnG,IAAOU,WAAP,cAAgCV,IAAI,mCAAmC,EAAC,EAAqC;AAAA;AAM7G,IAAOW,UAAP,cAA+BC,UAAS,EAAY,oCAAoC;EAC5FC,cAAcC;CACf,EAAC;AAAA;AAOI,IAAOC,YAAP,cAAiCf,IAAI,oCAAoC,EAAC,EAG7E;AAAA;AAEH,IAAMgB,iBAAsEC,UAI9C;AAC5B,QAAMC,UAAUC,OAAOD,QAAQD,IAAI;AACnC,SAAQG,CAAAA,aAAW;AACjB,QAAIC,WAAkBC,OAAK;AAC3B,eAAW,CAACC,KAAKC,IAAG,KAAKN,SAAS;AAChC,UAAIE,SAAQG,GAAG,MAAME,QAAW;AAC9BJ,QAAAA,WAAkBK,IAAIL,UAASG,MAAKJ,SAAQG,GAAG,CAAE;MACnD;IACF;AACA,WAAOF;EACT;AACF;AAMO,IAAMM,eAgBiBX,eAAe;EAC3CY,YAAY7B;EACZ8B,OAAO5B;EACP6B,SAAS5B;EACT6B,aAAa5B;EACb6B,SAAS5B;EACT6B,SAASzB;EACT0B,YAAYzB;EACZ0B,cAAc9B;EACd+B,SAAS9B;EACT+B,QAAQ9B;EACR+B,UAAU5B;EACV6B,SAAS5B;EACT6B,WAAWzB;CACZ;AAED,IAAM0B,WAAWC,YAAY,qCAAqC,MAAM,oBAAIC,QAAO,CAAoC;AAOvH,SAASC,kBACPC,KACArB,MACAsB,GAAiB;AAEjB,QAAMC,IAAYC,UAAUH,KAAKrB,IAAG;AACpC,MAAWyB,OAAOF,CAAC,GAAG;AACpBD,MAAEC,EAAEG,KAAK;EACX;AACF;AAqDO,IAAMC,UAAUA,CACrBC,MACAhC,aAGe;AACf,QAAMiC,UAASZ,SAASa,IAAIF,IAAG;AAC/B,MAAIC,YAAW5B,QAAW;AACxB,WAAO4B;EACT;AACA,QAAME,iBAAwD,CAAA;AAC9D,MAAIC,OAAoB;IACtBC,SAAS;IACTC,MAAM;MACJ7B,OAAe8B,WAAUP,KAAIzB,aAAa1B,OAAO,MAAM,KAAK;MAC5D6B,SAAiB6B,WAAUP,KAAIzB,aAAazB,SAAS,MAAM,OAAO;;IAEpE0D,OAAO,CAAA;IACPC,YAAY;MACVC,SAASP;MACTQ,iBAAiB,CAAA;;IAEnBC,UAAU,CAAA;IACV/C,MAAM,CAAA;;AAGR,WAASgD,WAAWC,KAAY;AAC9B,WAAkBC,SAAQD,KAAK;MAC7BE,MAAMb;MACNc,8BAA8BjD,UAASiD;KACxC;EACH;AAEA,WAASC,uBACPC,MACAP,UAAyB;AAEzB,QAAIR,KAAKK,WAAWE,gBAAgBQ,IAAI,MAAM9C,QAAW;AACvD;IACF;AACA+B,SAAKK,WAAWE,gBAAgBQ,IAAI,IAAIC,mBAAmBR,QAAQ;EACrE;AAEApB,oBAAkBQ,KAAIzB,aAAqB8C,mBAAoBC,sBAAoB;AACjFA,qBAAiBC,QAASC,qBAAoBX,WAAWW,gBAAgBV,GAAG,CAAC;EAC/E,CAAC;AACDtB,oBAAkBQ,KAAIzB,aAAaxB,aAAc4B,iBAAe;AAC9DyB,SAAKE,KAAK3B,cAAcA;EAC1B,CAAC;AACDa,oBAAkBQ,KAAIzB,aAAavB,SAAU4B,aAAW;AACtDwB,SAAKE,KAAK1B,UAAUA;EACtB,CAAC;AACDY,oBAAkBQ,KAAIzB,aAAanB,SAAUyB,aAAW;AACtDuB,SAAKE,KAAKzB,UAAUA;EACtB,CAAC;AACDW,oBAAkBQ,KAAIzB,aAAarB,SAAU8B,aAAW;AACtDoB,SAAKpB,UAAU,CAAC,GAAGA,OAAO;EAC5B,CAAC;AAEDgB,EAAAA,KAAIyB,YAAYF,QAASG,CAAAA,gBAAc;AACrC,QAAI,CAAmBC,WAAWD,WAAU,GAAG;AAC7C;IACF;AACA,eAAW,CAACP,MAAMP,QAAQ,KAAK7C,OAAOD,QAAQ4D,YAAWd,QAAQ,GAAG;AAClEM,6BAAuBC,MAAMP,QAAQ;AACrCR,WAAKQ,SAASgB,KAAK;QAAE,CAACT,IAAI,GAAG,CAAA;MAAE,CAAE;IACnC;EACF,CAAC;AACDU,EAAQC,QAAQ9B,MAAK;IACnB+B,QAAQ;MAAEC,OAAAA;IAAK,GAAE;AACf,UAAY9B,KAAI8B,OAAMzD,aAAahB,OAAO,GAAG;AAC3C;MACF;AACA,UAAIa,OAAsB;QACxB+C,MAAcZ,WAAUyB,OAAMzD,aAAa1B,OAAO,MAAMmF,OAAMxD,UAAU;;AAG1EgB,wBAAkBwC,OAAMzD,aAAaxB,aAAc4B,iBAAe;AAChEP,QAAAA,KAAIO,cAAcA;MACpB,CAAC;AACDa,wBAAkBwC,OAAMzD,aAAatB,cAAe8B,kBAAgB;AAClEX,QAAAA,KAAIW,eAAeA;MACrB,CAAC;AACDS,wBAAkBwC,OAAMzD,aAAajB,UAAW4B,cAAY;AAC1DnB,eAAOkE,OAAO7D,MAAKc,QAAQ;MAC7B,CAAC;AACDM,wBAAkBwC,OAAMzD,aAAaZ,WAAYuE,iBAAe;AAC9D9D,QAAAA,OAAM8D,YAAY9D,IAAG;MACvB,CAAC;AAEDgC,WAAKvC,KAAK+D,KAAKxD,IAAG;IACpB;IACA+D,WAAW;MAAEC;MAAUC,QAAAA;MAAQL,OAAAA;MAAOM,mBAAAA;MAAmBZ,YAAAA;MAAYa;MAAUC;IAAS,GAAE;AACxF,UAAYtC,KAAIoC,oBAAmB/E,OAAO,GAAG;AAC3C;MACF;AACA,UAAIkF,KAA2B;QAC7B5E,MAAM,CAAS0C,WAAUyB,OAAMzD,aAAa1B,OAAO,MAAMmF,OAAMxD,UAAU,CAAC;QAC1EkE,aAAqBnC,WACnB6B,SAAS7D,aACT5B,YACA,MAAMqF,OAAMW,WAAWP,SAASjB,OAAO,GAAGa,OAAMxD,UAAU,IAAI4D,SAASjB,IAAI,EAAE;QAE/EyB,YAAY,CAAA;QACZhC,UAAU,CAAA;QACViC,WAAW,CAAA;;AAGb,eAASC,mBACPC,MAIAC,oBAAgC;AAEhC,mBAAW,CAACC,QAAQ;UAAEnC;UAAKnC;QAAW,CAAE,KAAKoE,MAAK;AAChD,cAAIN,GAAGI,UAAUI,MAAM,EAAG;AAC1BR,aAAGI,UAAUI,MAAM,IAAI;YACrBtE,aAAoB4B,UAAU5B,aAAaqE,kBAAkB;;AAE/DlC,cAAIoC,KACKC,OAAQrC,CAAAA,SAAQ,CAAesC,mBAAmBtC,IAAG,CAAC,GACtDiC,KAAKjC,CAAAA,SAAO;AACjB,kBAAMuC,WAAyBC,YAAYxC,IAAG;AAC9C2B,eAAGI,UAAUI,MAAM,EAAEM,UAAU;cAC7B,CAACF,SAASG,WAAW,GAAG;gBACtBC,QAAQ5C,WAAWC,IAAG;;;UAG5B,CAAC,CAAC;QAEN;MACF;AAEA,eAAS4C,kBAAkBD,SAA0CE,GAA6B;AAChG,YAAW9D,OAAO4D,OAAM,GAAG;AACzB,gBAAMG,cAAa/C,WAAW4C,QAAO3D,MAAMgB,GAAG;AAC9C,cAAI,gBAAgB8C,aAAY;AAC9B7F,mBAAOD,QAAQ8F,YAAWC,UAAU,EAAEtC,QAAQ,CAAC,CAACJ,MAAM2C,YAAY,MAAK;AACrErB,iBAAGG,WAAWhB,KAAK;gBACjBT;gBACA4C,IAAIJ;gBACJF,QAAQK;gBACRE,UAAUJ,YAAWI,SAASC,SAAS9C,IAAI;gBAC3C,GAAI2C,aAAanF,gBAAgBN,SAAY;kBAAEM,aAAamF,aAAanF;gBAAW,IAAKN;eAC1F;YACH,CAAC;UACH;QACF;MACF;AAEAmB,wBAAkB4C,SAAS7D,aAAaxB,aAAc4B,iBAAe;AACnE8D,WAAG9D,cAAcA;MACnB,CAAC;AACDa,wBAAkB4C,SAAS7D,aAAanB,SAAUyB,aAAW;AAC3D4D,WAAG5D,UAAUA;MACf,CAAC;AACDW,wBAAkB4C,SAAS7D,aAAalB,YAAayB,gBAAc;AACjE2D,WAAG3D,aAAaA;MAClB,CAAC;AACDU,wBAAkB4C,SAAS7D,aAAatB,cAAe8B,kBAAgB;AACrE0D,WAAG1D,eAAeA;MACpB,CAAC;AAED2C,MAAAA,YAAWH,QAASG,CAAAA,gBAAc;AAChC,YAAI,CAAmBC,WAAWD,WAAU,GAAG;AAC7C;QACF;AACA,mBAAW,CAACP,MAAMP,QAAQ,KAAK7C,OAAOD,QAAQ4D,YAAWd,QAAQ,GAAG;AAClEM,iCAAuBC,MAAMP,QAAQ;AACrC6B,aAAG7B,SAASgB,KAAK;YAAE,CAACT,IAAI,GAAG,CAAA;UAAE,CAAE;QACjC;MACF,CAAC;AACD,YAAM+C,WAAqBA,QAAQ9B,SAAS+B,MAAM;AAClD,UAAID,YAAW3B,SAAS6B,OAAO,GAAG;AAChC,cAAMb,UAA8B,CAAA;AACpChB,iBAAShB,QAAQ,CAAC;UAAET;QAAG,GAAI0C,gBAAe;AACxCD,kBAAQC,WAAqC,IAAI;YAC/CC,QAAQ5C,WAAWC,GAAG;;QAE1B,CAAC;AACD2B,WAAG4B,cAAc;UAAEd;UAASS,UAAU;QAAI;MAC5C;AAEAN,wBAAkBtB,SAASkC,YAAY,MAAM;AAC7C,UAAI,CAACJ,UAAS;AACZR,0BAAkBtB,SAASmC,eAAe,OAAO;MACnD;AACAb,wBAAkBtB,SAASoC,eAAe,QAAQ;AAClDd,wBAAkBtB,SAASqC,iBAAiB,OAAO;AAEnD3B,yBAAmBN,WAAW,MAAM,SAAS;AAC7CM,yBAAmBT,SAAQ,MAAM,OAAO;AAExC,YAAMqC,OAAOtC,SAASsC,KAAKC,QAAQ,cAAc,MAAM;AACvD,YAAMR,SAAS/B,SAAS+B,OAAOS,YAAW;AAC1C,UAAI,CAACxE,KAAKI,MAAMkE,IAAI,GAAG;AACrBtE,aAAKI,MAAMkE,IAAI,IAAI,CAAA;MACrB;AAEAlF,wBAAkB4C,SAAS7D,aAAajB,UAAW4B,cAAY;AAC7DnB,eAAOkE,OAAOQ,IAAIvD,QAAQ;MAC5B,CAAC;AACDM,wBAAkB4C,SAAS7D,aAAaZ,WAAYuE,iBAAe;AACjEO,aAAKP,YAAYO,EAAE;MACrB,CAAC;AAEDrC,WAAKI,MAAMkE,IAAI,EAAEP,MAAM,IAAI1B;IAC7B;GACD;AAEDjD,oBAAkBQ,KAAIzB,aAAajB,UAAW4B,cAAY;AACxDnB,WAAOkE,OAAO7B,MAAMlB,QAAQ;EAC9B,CAAC;AACDM,oBAAkBQ,KAAIzB,aAAaZ,WAAYuE,iBAAe;AAC5D9B,WAAO8B,YAAY9B,IAAI;EACzB,CAAC;AAEDf,WAASwF,IAAI7E,MAAKI,IAAI;AAEtB,SAAOA;AACT;AAEA,IAAMgB,qBAAsBR,cAAoD;AAC9E,QAAMkE,OAAuC,CAAA;AAC7CtF,oBAAkBoB,SAASrC,aAAaxB,aAAc4B,iBAAe;AACnEmG,SAAKnG,cAAcA;EACrB,CAAC;AACD,UAAQiC,SAASmE,MAAI;IACnB,KAAK,SAAS;AACZ,aAAO;QACL,GAAGD;QACHE,MAAM;QACNC,QAAQ;;IAEZ;IACA,KAAK,UAAU;AACb,YAAMhG,UAAiBW,UAAUgB,SAASrC,aAAapB,MAAM,EAAE+F,KACtDH,KAAK9D,CAAAA,aAAY;QAAEiG,cAAcjG;MAAM,EAAG,GAC1CkG,cAAc;AAEvB,aAAO;QACL,GAAGL;QACHE,MAAM;QACNC,QAAQ;QACR,GAAGhG;;IAEP;IACA,KAAK,UAAU;AACb,aAAO;QACL,GAAG6F;QACHE,MAAM;QACN7D,MAAMP,SAASzC;QACf4F,IAAInD,SAASmD;;IAEjB;EACF;AACF;;;ACreA;;;;;;;;;;;;;;;;eAAAqB;EAAA,oBAAAC;;AAkDM,IAAOC,SAAP,cAAiCC,KAAI,wCAAwC,EAAC,EAAU;AAAA;AAQvF,IAAMC,MACXA,CAAAA,SAMMC,OACIC,KACDC,KAAWC,QAAO,GAAKA,CAAAA,cAAa;EAAEJ,KAAKA;EAAYI,SAAAA;AAAO,EAAG,CAAC;AAatE,IAAMC,SACXC,CAAAA,gBASAC,QAAQC,KACCL,KAAKM,SAAmBJ,OAAMI,KAAYH,WAAW,CAAC,GACvDI,cACAC,SAAQ,CAACb,OAAOc,MAAMC,WAAWC,KAAK,CAAC,CAAC;AAS3C,IAAMP,UAIFQ,IAAI,aAAS;AACtB,QAAM;IAAEf,KAAAA;IAAKI,SAAAA;EAAO,IAAK,OAAeF;AACxC,QAAMI,cAAaU,kBAAkBhB,KAAIiB,aAAab,QAAO;AAC7D,QAAMc,SAASC,gBAAgBb,aAAY,OAAOR,OAAOoB,MAAM;AAC/D,QAAME,uBAAuB,OAAOP;AACpC,QAAMQ,gBAAgB,OAAOD,qBAAqBE;AAClD,QAAMC,cAAcC,gBAAgBxB,IAAU;AAC9C,QAAMyB,cAAqBC,cAAcH,WAAW;AACpD,SAAOL,OAAOV,KACZa,eACOM,cAAeC,WACbC,YAAmBlB,QAAQc,YAAkBK,OAAOF,KAAK,CAAC,GAAGxB,QAAO,GAAG;IAC5E2B,WAAWA,MAAaC,WAAUJ,KAAK;IACvCK,WAAkBC;GACnB,CAAC,CACH;AAEL,CAAC;AAMM,IAAMC,kBAMFC,WACT,WACEpC,MAAsC;AAEtC,QAAMI,WAAU,OAAcA,QAAO;AACrC,QAAMiC,gBAAgBrB,kBAAkBhB,KAAIiB,aAAab,QAAO;AAChE,QAAMmB,cAAcC,gBAAgBxB,IAAU;AAC9C,QAAMyB,cAAqBC,cAAcH,WAAW;AACpD,SAAQtB,CAAAA,YACC0B,cACLR,gBAAgBkB,eAAepC,OAAM,GACpC2B,WACQC,YAAmBlB,QAAQc,YAAkBK,OAAOF,KAAK,CAAC,GAAGxB,QAAO,GAAG;IAC5E2B,WAAWA,MAAaC,WAAUJ,KAAK;IACvCK,WAAkBC;GACnB,CAAC;AAEV,CAAC;AA6BI,IAAMI,gBAAeA,CAC1BxB,QACAyB,aAYE;AACF,QAAMC,WAAyBC,MACvBC,SAAS5B,QAAOhB,OAAOc,MAAMC,WAAWC,KAAK,GACnDyB,UAASI,OAAO;AAElB,MAAIC;AACJ,QAAMC,iBAAwB9B,IAAI,aAAS;AACzC,UAAMN,MAAM,OAAOF;AACnB,UAAMuC,KAAK,OAAON,SAAQO;AAC1B,UAAMC,WAAkBC,oBAAoBH,EAAE,EAAEP,UAASjC,aAAaiC,SAAQjC,WAAWG,GAAU,IAAWA,GAAG;AACjHmC,oBAAgBI;AAChB,WAAOA;EACT,CAAC,EAAExC,KAAKgC,SAAQU,UAAU;AAC1B,WAASF,SAAQG,SAAkB/C,UAA4C;AAC7E,QAAIwC,kBAAkBQ,QAAW;AAC/B,aAAOR,cAAcO,SAAS/C,QAAO;IACvC;AACA,WAAOyC,eAAeQ,KAAML,CAAAA,aAAYA,SAAQG,SAAS/C,QAAO,CAAC;EACnE;AACA,SAAO;IAAE4C,SAAAA;IAASM,SAASd,SAAQc;EAAO;AAC5C;AAMO,IAAMC,iBAAgCC,OAAOC,IAAI,0CAA0C;AAuLlG,IAAMC,gBAAgB;EACpB,CAACH,cAAc,GAAG;IAChBI,YAAYC;;EAEdpD,OAAI;AACF,WAAOqD,cAAc,MAAMC,SAAS;EACtC;EACAC,OAEEC,MACAhB,UACAT,UAAwE;AAExE,UAAM0B,WAAW,KAAKC,MAAMC,UAAUH,IAAI;AAC1C,WAAOI,aAAa;MAClBF,OAAO,KAAKA;MACZG,UAAgBC,QAAO,KAAKD,UAAU;QACpCJ;QACAjB,SAAAA;QACAuB,iBAAiB;QACjBC,iBAAiBjC,UAASiC,mBAAmB;OAC9C;KACF;EACH;EACAC,UAEET,MACAhB,UACAT,UAAwE;AAExE,UAAM0B,WAAW,KAAKC,MAAMC,UAAUH,IAAI;AAC1C,WAAOI,aAAa;MAClBF,OAAO,KAAKA;MACZG,UAAgBC,QAAO,KAAKD,UAAU;QACpCJ;QACAjB,SAAAA;QACAuB,iBAAiB;QACjBC,iBAAiBjC,UAASiC,mBAAmB;OAC9C;KACF;EACH;;AAGF,IAAMJ,eACJ7B,CAAAA,aAIuC;AACvC,QAAMmC,OAAOC,OAAOC,OAAOlB,aAAa;AACxCgB,OAAKR,QAAQ3B,SAAQ2B;AACrBQ,OAAKL,WAAW9B,SAAQ8B;AACxB,SAAOK;AACT;AAaO,IAAMR,QAAQA,CAQnBlE,MACA6E,WACAC,UAYAhF,OAAOiF,IAAK7D,YACHH,IAAI,aAAS;AAClB,QAAMX,WAAU,OAAcA,QAAO;AACrC,QAAM8D,SAAQlE,KAAIgF,OAAOH,SAAS;AAClC,QAAMI,SAASH,MAAMV,aAAa;IAAEF,OAAAA;IAAOG,UAAgBa,OAAK;EAAE,CAAE,CAAC;AACrE,QAAMb,WAA2Cc,SAASF,MAAM,IAC3D,OAAOA,SACRA;AACJ,QAAMG,kBAAkBpE,kBAAmBkD,OAAcjD,aAAab,QAAO;AAC7E,QAAMiF,SAA4C,CAAA;AAClD,aAAWC,QAAQjB,SAASA,UAAU;AACpC,UAAM/D,cAAaU,kBAAmBsE,KAAarB,SAAShD,aAAab,UAASgF,eAAe;AACjGC,WAAOE,KAAKC,eACVF,KAAKrB,UACL3D,aACA,SAAS6C,SAAO;AACd,aAAcsC,gBACZH,KAAKtC,QAAQG,OAAO,GACnBuC,WAAkBC,MAAMvF,UAASsF,KAAK,CAAC;IAE5C,GACAJ,KAAKf,iBACLe,KAAKd,eAAe,CACrB;EACH;AACA,SAAOtD,OAAO0E,OAAkBC,cAAaR,MAAM,CAAC;AACtD,CAAC,CAAC;AASC,IAAMrC,UAAUA,CASrB8C,MACAC,YACAC,OACAC,MAaGA;AAIL,IAAMC,iBAAiBA,CACrB/C,SACAgD,YACAC,oBAOE;AACF,MAAI,CAAYC,QAAQlD,QAAQmD,MAAM,GAAG;AACvC,WAAcpE,SAAQiE,UAAS;EACjC;AACA,QAAMI,cAAcpD,QAAQqD,QAAQ,cAAc,IAC9CrD,QAAQqD,QAAQ,cAAc,EAAEC,YAAW,EAAGC,KAAI,IAClD;AACJ,MAAIH,YAAYI,SAAS,kBAAkB,GAAG;AAC5C,WAAcC,MAAMzD,QAAQ0D,IAAI;EAClC,WAAWN,YAAYI,SAAS,qBAAqB,GAAG;AACtD,WAAcC,MAAaE,OAAMV,iBAAiB;MAChDW,QAAQA,MAAM5D,QAAQ6D;MACtBC,QAASC,YAAqBC,WAAWhE,QAAQ6D,WAAWE,MAAM;KACnE,CAAC;EACJ,WAAWX,YAAYI,SAAS,uBAAuB,GAAG;AACxD,WAAcxG,KAAWyG,MAAMzD,QAAQiE,aAAa,GAAaC,SAAQ;EAC3E,WAAWd,YAAYe,WAAW,OAAO,GAAG;AAC1C,WAAcV,MAAMzD,QAAQoE,IAAI;EAClC;AACA,SAAcpH,KAAWyG,MAAMzD,QAAQqE,WAAW,GAAIC,YAAW,IAAIC,WAAWD,MAAM,CAAC;AACzF;AAOA,IAAMzG,oBAAoBA,CACxBV,aACAF,UACAuH,YACiB;AACjB,QAAMxH,OAAM,IAAIyH,IAGbD,OAAO;AACVrH,EAAAA,YAAWuH,QAASC,CAAAA,SAAO;AACzB3H,IAAAA,KAAI4H,IAAID,KAAIE,KAAK;MACfF,KAAAA;MACA7H,QAAgBgI,UAAU7H,UAAS0H,IAAU;KAC9C;EACH,CAAC;AACD,SAAO3H;AACT;AAEA,SAAS+H,mBAAmBC,KAAcH,KAAiB;AACzD,UAAQG,IAAIC,MAAI;IACd,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;IACT,KAAK,eAAe;AAClB,UAAIJ,QAAQ5E,QAAW;AACrB,cAAMiF,KAAKF,IAAIG,mBAAmBC,KAAMF,CAAAA,QAAOA,IAAGrE,SAASgE,GAAG;AAC9D,eAAOK,OAAOjF,SACV8E,mBAAmBG,GAAGG,MAAMR,GAAG,IAC/BG,IAAIM,gBAAgBC,KAAMC,CAAAA,QAAcA,GAAUlG,MAAKkG,IAAGC,SAAS,CAAC,EAAEZ,GAAG,KAAKE,mBAAmBS,IAAGH,IAAI,CAAC;MAC/G;AACA,aAAO;IACT;IACA,KAAK;AACH,aAAOL,IAAIU,MAAMH,KAAMF,UAASN,mBAAmBM,MAAMR,GAAG,CAAC;IAC/D,KAAK;AACH,aAAOE,mBAAmBC,IAAIlC,EAAC,GAAI+B,GAAG;IACxC,KAAK;IACL,KAAK;AACH,aAAOE,mBAAmBC,IAAIW,MAAMd,GAAG;EAC3C;AACA,SAAO;AACT;AAQM,SAAUe,mBACdC,SACAb,KAAY;AAEZ,QAAMc,MAA8C,CAAA;AACpD,aAAWjB,OAAOgB,SAAQ;AACxB,UAAME,SAAQF,QAAOhB,GAAG;AACxBiB,QAAIjB,GAAG,IAAImB,MAAMC,QAAQF,MAAK,KAAKhB,mBAAmBC,KAAKH,GAAG,IAAIkB,SAAQ,CAACA,MAAK;EAClF;AACA,SAAOD;AACT;AAEA,IAAMzD,iBAAiBA,CACrB6D,WACA/I,aACA0C,UACAsG,eACA9E,qBAC8B;AAC9B,QAAMP,WAAWoF;AACjB,QAAME,oBAAoBtF,SAASuF,cAAchJ,KACxCL,KAAI,CAAC;IAAEgI;EAAG,MAAqBsB,mBAAmBtB,GAAG,MAAM/E,MAAS,GACpEsG,UAAUC,UAAU,CAAC;AAE9B,QAAMvD,kBAAkBnC,SAASuF,cAAchJ,KACtCoJ,gBAAgB,CAAC;IAAEzB;EAAG,MAAqB0B,aAAa1B,GAAG,KAAmBsB,mBAAmBtB,GAAG,CAAC,CAAC;AAE/G,QAAM2B,aAAoB3J,KAAI8D,SAAS8F,YAAmBC,aAAa;AACvE,QAAMC,gBAAgBX,iBAAiBC,oBAC5BW,KAAI,IACJ/J,KAAI8D,SAASuF,eAAsBQ,aAAa;AAC3D,QAAMG,gBAAuBhK,KAAI8D,SAASmG,eAAsBJ,aAAa;AAC7E,QAAMK,gBAAuBC,OAAOC,kBAAkBtG,SAASuG,aAAa,CAAC;AAC7E,SAAkBC,WAChBxG,SAASqC,QACTrC,SAASyG,MACTvJ,gBACEb,aACOS,IAAI,aAAS;AAClB,UAAM4J,QAAeC,WAAiBC,gBAAe,CAAE;AACvD,UAAMzK,WAAUuK,MAAMG;AACtB,UAAMC,cAAsB9C,UAAU7H,UAA2B4K,iBAAiB;AAClF,UAAMC,eAAuBhD,UAAU7H,UAAoB8K,aAAY;AACvE,UAAM/E,aAAoB8B,UAAU7H,UAA2B+K,kBAAkB;AACjF,UAAMhI,UAAe;MAAEA,SAAS4H;IAAW;AAC3C,QAAIjB,WAAW1B,SAAS,QAAQ;AAC9BjF,cAAQuH,OAAO,OAAOZ,WAAWZ,MAAM+B,aAAajC,MAAM;IAC5D;AACA,QAAIiB,cAAc7B,SAAS,QAAQ;AACjCjF,cAAQiI,UAAU,OAAcC,SAC9BnF,eAAe6E,aAAa5E,YAAWC,eAAe,GACtD6D,cAAcf,KAAK;IAEvB,WAAWK,mBAAmB;AAC5BpG,cAAQiI,UAAiBtE,OAAMV,iBAAiB;QAC9CW,QAAQA,MAAMgE,YAAYO;QAC1BrE,QAASC,YAAqBqE,iBAAiBR,YAAYO,iBAAiBpE,MAAM;OACnF;IACH;AACA,QAAIiD,cAAc/B,SAAS,QAAQ;AACjCjF,cAAQqD,UAAU,OAAO2D,cAAcjB,MAAM6B,YAAYvE,OAAO;IAClE;AACA,QAAIvC,SAASuH,gBAAgBpD,SAAS,QAAQ;AAC5C,YAAMqD,UAASxH,SAASuH,gBAAgBtC;AACxC/F,cAAQgD,YAAY,OAAc6D,cAAcyB,OAAM,EAAE1C,mBAAmB5C,YAAWsF,QAAOtD,GAAG,CAAC;IACnG;AACA,UAAMuD,WAAW,OAAO1I,SAAQG,OAAO;AACvC,WAA0BwI,kBAAiBD,QAAQ,IAAIA,WAAW,OAAOrB,cAAcqB,QAAQ;EACjG,CAAC,EAAElL,KACMoL,QAAoBC,cAAcC,mBAAmBC,gBAAgB,CAAC,CAC9E,GAEH;IAAEvH,iBAAAA;EAAe,CAAE;AAEvB;AAEA,IAAMrD,kBAAkBA,CACtBb,aACA0C,aACE;AACF,aAAWgJ,SAAS1L,YAAW2L,OAAM,GAAI;AACvC,UAAMhM,UAA2BiM,kBAAkBF,MAAMlE,MAAMqE,uBAAuBH,KAAY,IAAIA,MAAM/L;AAC5G,QAAI+L,MAAMlE,IAAIsE,UAAU;AACtB,YAAMC,WAAWrJ;AACjBA,MAAAA,WAAiBnB,YAAY5B,SAAQ;QACnC8B,WAAWA,MAAMsK;QACjBpK,WAAW+J,MAAMlE,IAAIwE,aAAalJ,SAC7B8F,CAAAA,WAAiBqD,eAAeF,UAAUL,MAAMlE,IAAIwE,UAAiBpD,MAAK,IAC1EsD,OAAMH;OACZ;IACH,OAAO;AACLrJ,MAAAA,WAAUgJ,MAAMlE,IAAIwE,aAAalJ,SACtBqJ,qBAAqBzJ,UAASgJ,MAAMlE,IAAIwE,UAAiBrM,OAAM,IAC/DyM,SAASzM,SAAQ+C,QAAO;IACrC;EACF;AACA,SAAOA;AACT;AAEA,IAAM2J,0BAA0BC,YAC9B,2BACA,MAAM,oBAAIC,QAAO,CAAE;AAGrB,IAAMV,yBACJH,WAIgC;AAChC,MAAIW,wBAAwBG,IAAId,KAAK,GAAG;AACtC,WAAOW,wBAAwBI,IAAIf,KAAK;EAC1C;AAEA,MAAI/L;AACJ,aAAW,CAAC+H,KAAKgF,QAAQ,KAAKrI,OAAOsI,QAAQjB,MAAMlE,IAAIkF,QAAQ,GAAG;AAChE,UAAME,UAASC,eAAeH,QAAQ;AACtC,UAAMhK,WAAUgJ,MAAM/L,OAAO+H,GAAG;AAChC,UAAM1H,cAAoB+K,SAAQ6B,SAAQlK,QAAO;AACjD/C,IAAAA,UAASA,YAAWmD,SAAY9C,cAAoB8M,SAASnN,SAAQ,MAAMK,WAAU;EACvF;AACA,MAAIL,YAAWmD,QAAW;AACxBnD,IAAAA,UAAgBoN;EAClB;AACAV,0BAAwB5E,IAAIiE,OAAO/L,OAAM;AACzC,SAAOA;AACT;AAEA,IAAMqN,iBAAwBC,QAA2B5B,iBAAgB;AAEzE,IAAMpB,oBACJkB,CAAAA,YACiE;AACjE,QAAM+B,UAAU,oBAAIC,IAAG;AACvBC,EAAcC,WAAWH,SAAS/B,OAAM;AACxC,SAAcmC,OAAM,GAAGzE,MAAML,KAAK0E,SAASK,iBAAiB,CAAC;AAC/D;AAEA,IAAMrM,kBACJxB,CAAAA,SACiE;AACjE,QAAMwN,UAAU,oBAAIC,IAAG;AACvBC,EAAcC,WAAWH,SAASxN,KAAIuB,WAAW;AACjD,aAAW2C,UAASS,OAAOsH,OAAOjM,KAAIgF,MAAM,GAAG;AAC7C,eAAWf,YAAYU,OAAOsH,OAAO/H,OAAMC,SAAS,GAAG;AACrDuJ,MAAcC,WAAWH,SAASvJ,SAAS1C,WAAW;IACxD;AACAmM,IAAcC,WAAWH,SAAStJ,OAAM3C,WAAW;EACrD;AACA,SAAcqM,OAAM,GAAGzE,MAAML,KAAK0E,SAASM,eAAe,CAAC;AAC7D;AAEA,IAAMC,kBAAkBA,CAAIvB,GAAMwB,IAAsB7F,QAC1C8F,MAAK,IAAgBC,UAAU/F,KAAKqE,GAAG,oBAAoB,CAAC;AAE1E,IAAM2B,mBAAoBC,CAAAA,eAAuC;AAC/D,QAAMC,QAAQ,oBAAIxB,QAAO;AACzB,QAAMyB,mBAAmBA,CACvBC,MACA/B,GACArE,QACgF;AAChF,UAAMqG,WAAwBC,OAAOtG,IAAIuG,EAAE;AAC3C,UAAMC,SAASP,WAAUjG,IAAIuG,EAAE;AAC/B,QAAIF,UAAS;AACX,aAA0BtJ,QAAM;QAAEyJ;MAAM,CAAE;IAC5C;AACA,UAAMC,WAAyBC,YAAY1G,IAAIuG,EAAE;AACjD,YAAQE,SAASE,MAAI;MACnB,KAAK,QAAQ;AACX,eAAcC,SACOlI,MAAK0H,MAAM;UAC5BI;UACApI,aAAaqI,SAASrI;SACvB,GACAyI,WAAU,IAAgBC,KAAK9G,KAAK6G,OAAO,0BAA0B,CAAC;MAE3E;MACA,KAAK,QAAQ;AACX,eAAmB9M,SAA2BqF,MAAKgH,MAAa;UAC9DI;UACApI,aAAaqI,SAASrI;SACvB,CAAC;MACJ;MACA,KAAK,cAAc;AACjB,eAAmBrE,SAA2BgN,YAAWX,MAAa;UACpEI;UACApI,aAAaqI,SAASrI;SACvB,CAAC;MACJ;MACA,KAAK,aAAa;AAChB,eAAmBrE,SAA2BiE,WAAUoI,MAAa;UACnEI;UACApI,aAAaqI,SAASrI;SACvB,CAAC;MACJ;IACF;EACF;AACA,SAAiBkF,CAAAA,YAA8F;AAC7G,QAAI4C,MAAMvB,IAAIrB,QAAOtD,GAAG,GAAG;AACzB,aAAOkG,MAAMtB,IAAItB,QAAOtD,GAAG;IAC7B;AACA,UAAMgH,aAAmBC,gBAAgB9B,gBAAgB7B,SAAQ;MAC/DyB,QAAQa;MACRzD,QAAQgE;KACT;AACDD,UAAMtG,IAAIoH,WAAUhH,KAAKgH,UAAS;AAClC,WAAOA;EACT;AACF;AAEA,IAAMtB,oBAAoBM,iBAA+BkB,mBAAmB;AAC5E,IAAMvB,kBAAkBK,iBAA+BmB,iBAAiB;AAUlE,IAAOzO,aAAP,MAAOA,oBAA2Bd,IAAI,4CAA4C,EAAC,EAMtF;;;;EAID,OAAgBe,QAAcyO,MAAK1O,aAAY,MAAK;AAClD,QAAIP,cAA4CsD;AAChD,WAAO/C,YAAW2O,GAAG;MACnBC,KAAMxJ,OACGsJ,KAAK,MAAK;AACf,cAAMG,OAAOpP;AACbA,QAAAA,cAAcG,SAAQwF,EAAEyJ,KAAKjP,GAAG,CAAC;MACnC,CAAC;MACHa,UAAiBiO,KAAK,MAAMjP,WAAU;KACvC;EACH,CAAC;;AAWH,IAAMqP,gBACJrP,CAAAA,gBAEOS,IAAI,aAAS;AAClB,QAAMX,WAAU,OAAcA,QAAO;AACrC,QAAMwP,UAAU,OAAO/O;AACvB,SAAO+O,QAAQH,IAAKlP,CAAAA,aACXkF,gBAAgBnF,YAAWC,QAAO,GAAImF,WAAkBC,MAAMvF,UAASsF,KAAK,CAAC,CAAC;AAEzF,CAAC;AAEH,IAAMmK,yBACJvP,CAAAA,gBAEOS,IAAI,aAAS;AAClB,QAAM6O,UAAU,OAAO/O;AACvB,SAAO+O,QAAQH,IAAInP,WAAU;AAC/B,CAAC;AAQI,IAAMA,aAmDTA,IACCwP,SAYI;AACP,QAAMC,WAAmBC,UAAUF,KAAK,CAAC,CAAC;AAC1C,QAAMG,cAAcF,WAAWD,KAAK,CAAC,GAAGG,gBAAgB,OAAQH,KAAa,CAAC,GAAGG,gBAAgB;AACjG,QAAMR,OAAMQ,cAAcN,gBAAgBE;AAC1C,QAAMvP,cAAayP,WAAWD,KAAK,CAAC,IAAIA,KAAK,CAAC;AAC9C,UAAe3K,SAAS7E,WAAU,IACxB4P,cAAqB7E,SAAQ/K,aAAmBmP,IAAG,CAAC,IACpDS,cAAcT,KAAInP,WAAiB,CAAC,GAAGE,KAAWG,SAAQE,WAAWC,KAAK,CAAC;AACvF;AAQO,IAAMqP,iBACX5N,CAAAA,aAQuBjC,WAA0B8P,MAAK7N,QAAO,CAAC;AAQzD,IAAM8N,oBACX9N,CAAAA,aAKAzC,OAAOiF,IAAK7D,YACHH,IAAI,aAAS;AAClB,QAAM;IAAEf,KAAAA;EAAG,IAAK,OAAeE;AAC/B,QAAMoQ,OAAeC,QAAQvQ,MAAK;IAChCwQ,8BAA8BjO,UAASiO;GACxC;AACD,QAAM9E,WAAW,OAA0B7E,MAAKyJ,IAAI,EAAE9P,KAC7CoG,KAAK;AAEd,SAAO1F,OAAO6L,IAAIxK,UAASmI,QAAQ,iBAAwBxI,SAAQwJ,QAAQ,CAAC;AAC9E,CAAC,CAAC;AAGN,IAAM+E,YAAY,UAAUC;AAC5B,IAAMC,WAAW,SAASD;AAMnB,IAAMvD,iBACXzI,UAKE;AACF,UAAQA,KAAK0D,MAAI;IACf,KAAK,UAAU;AACb,aAAcjI,KACM6K,mBACjB7H,aAAqBV,OAAMU,QAAQqD,QAAQoK,iBAAiB,IAAIC,MAAMJ,SAAS,CAAC,CAAQ;IAE7F;IACA,KAAK,UAAU;AACb,YAAMzI,MAAMtD,KAAKoM,OAAO,WAAWpM,KAAKsD,IAAIvB,YAAW,IAAK/B,KAAKsD;AACjE,YAAMyD,UAAgBsF,OAAO;QAC3B,CAAC/I,GAAG,GAAUgJ;OACf;AACD,YAAM9D,UAAS+D,MACbvM,KAAKoM,OAAO,UACUI,oBAAmBzF,OAAM,IAC3C/G,KAAKoM,OAAO,WACMK,eAAc1F,OAAM,IACpB2F,eAAc3F,OAAM,CAAC;AAE7C,aAAc3E,OAAMoG,SAAQ;QAC1BnL,WAAWA,MAAeU,MAAK,EAAE;QACjCR,WAAY6E,CAAAA,WAAmBrE,MAAKqE,OAAMkB,GAAG,CAAC;OAC/C;IACH;IACA,KAAK,SAAS;AACZ,YAAM9C,UAAwD;QAC5DmM,UAAU;QACVC,UAAmB7O,MAAK,EAAE;;AAE5B,aAAyBuI,kBAAkBxK,KAClC6K,SAASlI,aAAqBoO,oBAAoBpO,QAAQqD,QAAQoK,iBAAiB,IAAIC,MAAMF,QAAQ,CAAC,CAAC,GACvG7J,OAAM;QACX/E,WAAWA,MAAMmD;QACjBjD,WAAYuP,YAAU;AACpB,gBAAMC,QAAQD,OAAOE,MAAM,GAAG;AAC9B,cAAID,MAAMf,WAAW,GAAG;AACtB,mBAAOxL;UACT;AACA,iBAAO;YACLmM,UAAUI,MAAM,CAAC;YACjBH,UAAmB7O,MAAKgP,MAAM,CAAC,CAAC;;QAEpC;OACD,CAAC;IAEN;EACF;AACF;AAiBO,IAAME,oBAAoBA,CAC/BjN,MACAwE,QACA3G,aACuB;AACvB,QAAMqP,cAAc,OAAO1I,WAAU,WAAWA,SAAiBA,MAAMA,MAAK;AAC5E,SAAe2I,0BAAyB,CAACC,MAAMpG,aACtC9E,MACcmL,WAAUrG,UAAUhH,KAAKsD,KAAK4J,aAAa;IAC5DI,QAAQ;IACRC,UAAU;IACV,GAAG1P;GACJ,CAAC,CACH;AAEL;;;AC3mCA;;mBAAA2P;EAAA;;sBAAAC;EAAA,mBAAAC;EAAA;gBAAAC;EAAA,WAAAC;EAAA;;cAAAC;EAAA;eAAAC;EAAA,YAAAC;EAAA,kBAAAC;EAAA,cAAAC;EAAA,kBAAAC;EAAA;eAAAC;EAAA,kBAAAC;EAAA,oBAAAC;EAAA,oBAAAC;EAAA,wBAAAC;EAAA,aAAAC;EAAA;sBAAAC;EAAA,WAAAC;;AA0CO,IAAMC,WAAwBC,OAAOC,IAAI,6CAA6C;AA+DtF,IAAMC,aAA0DC,WACrE,kCAAkC;AAO7B,IAAMC,SAAcC,IAAI,aAAS;AACtC,QAAMC,SAAmBF,OAAwB,OAAOG,YAAY;AACpE,QAAMC,cAAa,oBAAIC,IAAG;AAE1B,QAAMC,UACJC,YAOOC,YAAaC,CAAAA,aAAmC;AACrD,UAAML,cAAaM,cAAcD,QAAO;AACxC,UAAME,mBAAmBC,CAAAA,YAAgE;AACvF,eAASC,IAAI,GAAGA,IAAIT,YAAWU,QAAQD,KAAK;AAC1CD,QAAAA,UAASR,YAAWS,CAAC,EAAED,OAAM;MAC/B;AACA,aAAOA;IACT;AACA,aAASC,IAAI,GAAGA,IAAIN,OAAOO,QAAQD,KAAK;AACtC,YAAME,SAAQX,YAAWU,WAAW,IAAIP,OAAOM,CAAC,IAAIG,WAAU;QAC5D,GAAGT,OAAOM,CAAC;QACXI,SAASN,iBAAgBJ,OAAOM,CAAC,EAAEI,OAA+D;OACnG;AACD,UAAIF,OAAMG,WAAW,KAAK;AACxBhB,eAAOiB,IAAIJ,OAAMK,MAAML,MAAY;MACrC,OAAO;AACLb,eAAOmB,GAAGN,OAAMG,QAAQH,OAAMK,MAAML,MAAY;MAClD;IACF;EACF,CAAC;AAEH,SAAOjB,WAAWwB,GAAG;IACnB,CAAC3B,QAAM,GAAGA;IACV4B,SAA2BC,QAAc;AACvC,aAAO1B,WAAWwB,GAAG;QACnB,GAAG;QACHC,UAAWE,eAAsB,KAAKF,SAASG,YAAWF,QAAQC,SAAS,CAAC;QAC5EnB,QAASC,YAAWD,QAAOC,OAAOoB,IAAIC,YAAYJ,MAAM,CAAC,CAAC;QAC1DK,KAAKA,CAACX,QAAQE,MAAMH,UAASa,aAC3BxB,QAAO,CACLU,WAAU;UACRE;UACAE,MAAMM,YAAWN,MAAMI,MAAM;UAC7BP,SAAgBc,SAASd,QAAO,IAC5BA,WACOe,SAA0BC,mBAAmBhB,QAAO;UAC/DiB,iBAAiBJ,UAASI,mBAAmB;UAC7CV,QAAeW,KAAKX,MAAM;SAC3B,CAAC,CACH;OACJ;IACH;IACAlB,QAAAA;IACAuB,KAAKA,CAACX,QAAQE,MAAMH,UAASa,aAAYxB,QAAO,CAACS,OAAMG,QAAQE,MAAMH,UAASa,QAAO,CAAC,CAAC;IACvFM,qBAAsBC,iBACbC,KAAK,MAAK;AACflC,MAAAA,YAAWyB,IAAIQ,WAAkB;IACnC,CAAC;IACHE,eAAY;AACV,UAAItB,WAAiBuB,iBAAkEC,WAAS;AAC9F,cAAMC,aAAa,IAAIC,IAAIF,MAAMG,eAAeC,SAAS;AACzD,cAAMC,UAAUJ,WAAWK,IAAsBd,kBAAkBe,GAAG;AACtE,YAAIC,SAAS/C,OAAOgD,KAAKJ,QAAQ5B,QAAQ4B,QAAQK,GAAG;AACpD,YAAIF,WAAWG,UAAaN,QAAQ5B,WAAW,QAAQ;AACrD+B,mBAAS/C,OAAOgD,KAAK,OAAOJ,QAAQK,GAAG;QACzC;AACA,YAAIF,WAAWG,QAAW;AACxB,iBAAcC,MAAK,IAAoBC,cAAc;YAAER;UAAO,CAAE,CAAC;QACnE;AACA,cAAM/B,SAAQkC,OAAOhC;AACrB,YAAIF,OAAMS,OAAO+B,SAAS,QAAQ;AAChCb,qBAAWc,IAAsBvB,kBAAkBe,KAAKS,iBAAgBX,SAAS/B,OAAMS,OAAOkC,KAAK,CAAC;QACtG;AACAhB,mBAAWc,IAAsBG,mBAAmBX,KAAKC,OAAOW,YAAY;AAC5ElB,mBAAWc,IAAIK,cAAab,KAAK;UAC/B,CAACc,mBAAkB,GAAGA;UACtB/C,OAAAA;UACAgD,QAAQd,OAAOc;SAChB;AAED,cAAMC,OAAOtB,WAAWK,IAAWkB,WAAWjB,GAAG;AACjD,YAAIgB,QAAQA,KAAKT,SAAS,QAAQ;AAChCS,eAAKE,UAAU,cAAcnD,OAAMK,IAAI;QACzC;AACA,eAAc+C,QACXpD,OAAMmB,kBACLnB,OAAME,UACCmD,cAAcrD,OAAME,OAAO,GAI3B2B,gBACDyB,WAAW3B,UAAU,CAAC;MAElC,CAAC;AACD,UAAItC,YAAWkE,SAAS,EAAG,QAAOrD;AAClC,iBAAWsD,MAAUC,QAAQpE,WAAU,GAAG;AACxCa,QAAAA,WAAUsD,GAAGtD,QAAc;MAC7B;AACA,aAAOA;IACT;GACD;AACH,CAAC;AAED,SAASwC,iBAAgBX,SAA8CtB,QAAc;AACnF,QAAMiD,YAAYjD,OAAOV;AACzB,SAAOgC,QAAQ4B,OAAO;IAAEvB,KAAKL,QAAQK,IAAIrC,UAAU2D,YAAY,MAAM3B,QAAQK,IAAIwB,MAAMF,SAAS;EAAC,CAAE;AACrG;AAMM,IAAOtE,eAAP,cAAoCyE,UAAS,EAAiB,iDAAiD;EACnHC,cAAcC,SAA0C,CAAA,CAAE;CAC3D,EAAC;AAAA;AAqDK,IAAMC,OACXC,OACsEC,cAAqBjD,SAAQlC,YAAYkF,CAAC,CAAC;AAe5G,IAAMnD,OAAMA,CACjBX,QACAE,MACAH,UAGAa,aAIAiD,KAAK7E,YAAWA,OAAO2B,IAAIX,QAAQE,MAAMH,UAASa,QAAO,CAAC;AAiBrD,IAAMxB,SAASA,CACpBC,QACAuB,aAWMmD,cAAqBhF,IAAI,aAAS;AACtC,QAAMiF,QAAenD,SAASxB,MAAM,IAAI,OAAOA,SAASA;AACxD,MAAIL,SAAS,OAAOJ;AACpB,MAAIgC,UAASN,QAAQ;AACnBtB,aAASA,OAAOqB,SAASO,SAAQN,MAAM;EACzC;AACA,SAAOtB,OAAOI,OAAO4E,KAAK;AAC5B,CAAC,CAAC;AAMG,IAAMC,SAAuCvE,OAAOd,YAAYE,MAAI;AAMpE,IAAMoF,eACXC,cAUOpF,IAAI,aAAS;AAClB,QAAMqF,SAAQ,OAAcA;AAC5B,QAAMC,UAAU,OAAaC;AAC7B,QAAM/E,WAAU,OAAagF,iBACrBC,aAAaL,UAAUF,MAAK,GAClCI,SACAD,MAAK;AAEP,QAAMpF,SAAiB6C,KAAItC,UAASX,UAAU;AAC9C,SAAOI,OAAOqC,aAAY;AAC5B,CAAC;AAMI,IAAMoD,eAA6B/F,OAAOC,IAAI,wCAAwC;AAuC7F,IAAMmB,aAAmBc,CAAAA,cAOrB;EACA,GAAGA;EACHI,iBAAiBJ,SAAQI,mBAAmB;EAC5CV,QAAQM,SAAQN,UAAiBoE,KAAI;EACrC,CAACD,YAAW,GAAGA;;AAOZ,IAAM5E,SAAQA,CACnBG,QACAE,MACAH,UAGAa,aAIAd,WAAU;EACR,GAAGc;EACHZ;EACAE;EACAH,SAAgBc,SAASd,QAAO,IAAIA,WAAiBe,SAA0BC,mBAAmBhB,QAAO;EACzGiB,iBAAiBJ,UAASI,mBAAmB;CAC9C;AAQH,IAAM2D,uBACJzE,UACeA,KAAK0E,SAAS,GAAG,IAAI1E,KAAKuD,MAAM,GAAG,EAAE,IAAIvD;AAMnD,IAAMM,cAWTqE,KAAK,GAAG,CAACC,MAAcxE,WAAkB;AAC3CA,WAASqE,qBAAoBrE,MAAmB;AAChD,SAAOwE,SAAS,MAAMxE,SAASA,SAASwE;AAC1C,CAAC;AAMM,IAAMpE,cAWTmE,KAAK,GAAG,CAAOC,MAAmBxE,WACpCR,WAAU;EACR,GAAGgF;EACH5E,MAAMM,YAAWsE,KAAK5E,MAAMI,MAAM;EAClCA,QAAeyE,OAAMD,KAAKxE,QAAQ;IAChC0E,QAAQA,MAAa/D,KAAKX,MAAgB;IAC1C2E,QAASC,oBAA0BjE,KAAKT,YAAW0E,gBAAgB5E,MAAM,CAAW;GACrF;CACF,CAAC;AAkEG,IAAM6E,mBAAkCzG,OAAOC,IAAI,6CAA6C;AA0HhG,IAAMO,cAUN,WAAA;AACH,MAAIkG,UAAUxF,WAAW,GAAG;AAC1B,WAAOyF;EACT;AACA,SAAOA,eAAeD,UAAU,CAAC,GAAGA,UAAU,CAAC,CAAC;AAClD;AAEF,IAAMC,iBAAiBA,CAACnG,aAAiB0B,aAGvCA,UAAS0E,SACDvB,cAAqBhF,IAAI,aAAS;AACtC,QAAMC,SAAS,OAAOJ;AACtB,QAAMyE,KAAYxC,SAAS3B,WAAU,IAAI,OAAOA,cAAaA;AAC7D,SAAOF,OAAOkC,oBAAoBmC,EAAE;AACtC,CAAC,CAAC,IACA,IAAIkC,eACG1E,SAAS3B,WAAU,IAClBsG,cAAqB/E,KAAIvB,aAAamE,QAAeF,WAAW,oBAAI1B,IAAI,CAAC,CAACgE,cAAcpC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,IAC/FqC,eAAuBvC,WAAW,oBAAI1B,IAAI,CAAC,CAACgE,cAAcvG,WAAU,CAAC,CAAC,CAAC,CAAC,CAAQ;AAG9F,IAAIyG,eAAe;AACnB,IAAMF,eAAe;AAErB,IAAMF,iBAAN,MAAMA,gBAAc;EAaPK;EACAC;EAJF,CAACV,gBAAgB,IAAY,CAAA;EAEtCW,YACWF,SACAC,cAAyC;AADzC,SAAAD,UAAAA;AACA,SAAAC,eAAAA;AAET,UAAME,aAAa,+CAA+C,EAAEJ,YAAY;AAChF,SAAK1B,QAAcuB,cAAqBzG,IAAI,MAAM,aAAS;AACzD,YAAMQ,WAAU,OAAcA,QAAO;AACrC,YAAMyG,QAAQ,CAACzG,SAAQoC,UAAUE,IAAI4D,YAAY,CAAC;AAClD,UAAI,KAAKI,cAAc;AACrB,cAAMxB,UAAU,OAAaC;AAC7B,cAAMF,SAAgBvC,KAAItC,UAAe0G,KAAK;AAC9C,cAAMC,cAAc,OAAa3B,iBAAiB,KAAKsB,cAAcxB,SAASD,MAAK;AAEnF4B,cAAMG,KAAK,GAAG3G,cAAc0G,WAAW,CAAC;MAC1C;AACA,aAAe/C,WAAkB,oBAAI1B,IAAI,CAAC,CAACsE,YAAYC,KAAK,CAAC,CAAC,CAAC;IACjE,CAAC,CAAC,EAAEI,KAAWC,SAAQ,KAAKT,OAAO,CAAC;EACtC;EAEA3B;EAEAqC,QASEC,OAA0B;AAC1B,WAAO,IAAIhB,gBACT,KAAKK,SACL,KAAKC,eAAqBrB,aAAa,KAAKqB,cAAcU,MAAMtC,KAAY,IAAIsC,MAAMtC,KAAY;EAEtG;;AAGF,IAAMuC,kBAAkB,oBAAIC,QAAO;AACnC,IAAMjH,gBAAiBD,CAAAA,aAAyD;AAC9E,MAAImH,MAAMF,gBAAgB3E,IAAItC,QAAO;AACrC,MAAImH,IAAK,QAAOA;AAChB,QAAMC,WAAeC,MAAK;AAC1B,MAAIC,YAAY;AAChB,aAAW,CAAC/E,KAAKU,MAAK,KAAKjD,SAAQoC,WAAW;AAC5C,QAAIG,IAAIgF,WAAW,8CAA8C,GAAG;AAClEH,eAASR,KAAK3D,MAAK;AACnB,UAAIA,OAAM5C,SAASiH,WAAW;AAC5BA,oBAAYrE,OAAM5C;MACpB;IACF;EACF;AACA,MAAI+G,SAAS/G,WAAW,GAAG;AACzB8G,UAAM,CAAA;EACR,OAAO;AACL,UAAMxH,cAAa,oBAAIC,IAAG;AAC1B,aAASQ,IAAIkH,YAAY,GAAGlH,KAAK,GAAGA,KAAK;AACvC,iBAAW+G,QAAOC,UAAU;AAC1B,YAAIhH,IAAI+G,KAAI9G,QAAQ;AAClBV,UAAAA,YAAWyB,IAAI+F,KAAI/G,CAAC,CAAC;QACvB;MACF;IACF;AACA+G,UAAUK,aAAa7H,WAAU,EAAEoE,QAAO;EAC5C;AACAkD,kBAAgBlE,IAAI/C,UAASmH,GAAG;AAChC,SAAOA;AACT;AAwGO,IAAMM,QACXpG,CAAAA,aAQ0C1B,YAA0B8H,MAAKpG,QAAO,GAAG;EAAE0E,QAAQ;AAAI,CAAE;AAmB9F,IAAM2B,gBAAoC/H,YAA0BgI,mBAAkB,EAAEjD;AA8DxF,IAAMkD,aAAaA,CACxBC,MACAxG,aAcE;AACF,QAAMyG,gBAAgBnI,YAA0BoI,gBAAgBF,IAAG,CAAC,EAAEnD;AACtE,SAAsBsD,OAAOC,OAAcC,WAAW,WAAUC,SAAO;AACrE,UAAM1I,SAAS,OAAOJ;AACtB,UAAMW,WAAU,OAAcA,QAAO;AAOrC,UAAMF,SAAauH,MAAK;AACxB,eAAW/G,UAAS6H,QAAQrI,QAAQ;AAClCA,aAAO8G,KAAKrG,WAAU;QACpB,GAAGD;QACHE,SAAgBsG,QAAQxG,OAAME,SAASR,QAAO;OAC/C,CAAC;IACJ;AAEA,WAAQP,OAAOI,OAAOC,MAAM;AAE5B,QAAIuB,UAAS+G,aAAa;AACxB,YAAMC,OAAeC,QAAQT,IAAG;AAChC,aAAOpI,OAAO2B,IAAI,OAAOC,SAAQ+G,aAAoBG,SAA2BC,YAAWH,IAAI,CAAC,CAAC;IACnG;EACF,GAASI,aAAa,CAAC,EAAE5B,KACjBC,SAAQgB,aAAa,CAAC;AAEhC;AAQO,IAAMY,SAAQA,CACnB9D,UACAvD,aA8BE;AACF,MAAI1B,cAAkB0B,UAAS1B;AAC/B,MAAI0B,UAASqG,kBAAkB,MAAM;AACnC/H,IAAAA,cAAaA,cAAagJ,QAAQhJ,aAA2BiJ,OAAM,IAAmBA;EACxF;AACA,QAAMC,cAAcxH,UAASyH,eACnBhC,SAAQpC,QAAa6D,SAAQ7I,cAAc2B,SAAQyH,YAAY,CAAC,IACtEpE;AACJ,SAAclF,IAAI,aAAS;AACzB,UAAMC,SAAS,OAAOJ;AACtB,UAAMmB,WAAUf,OAAOqC,aAAY;AACnC,WAAOnC,cAAwB+I,OAAMlI,UAASb,WAAU,IAAe+I,OAAMlI,QAAO;EACtF,CAAC,EAAEqG,KACKkC,cACAjC,SAAQlC,QAAQ,GAChBkC,SAAQ+B,WAAW,GACzBxH,UAAS2H,mBAAmBC,WAAsBC,eAAc;AAEpE;AAMO,IAAMC,gBAAeA,CAY1BvE,UACAvD,aA+BE;AACF,MAAI1B,cAAkB0B,UAAS1B;AAC/B,MAAI0B,UAASqG,kBAAkB,MAAM;AACnC/H,IAAAA,cAAaA,cAAagJ,QAAQhJ,aAA2BiJ,OAAM,IAAmBA;EACxF;AACA,QAAMC,cAAcxH,UAASyH,eACnBhC,SAAQpC,QAAa6D,SAAQ7I,cAAc2B,SAAQyH,YAAY,CAAC,IACtEpE;AACJ,QAAM0E,WAAyB7J,MACvB0F,aAAaL,UAAUiE,WAAW,GACxCxH,UAASyD,OAAO;AAElB,MAAIuE;AAGJ,QAAMC,iBAAwB9J,IAAI,aAAS;AACzC,UAAMC,SAAS,OAAOJ;AACtB,UAAMc,UAASV,OAAOqC,aAAY;AAClC,UAAMyH,KAAK,OAAOH,SAAQI;AAC1B,UAAMhJ,WAAkBiJ,oBAAoBF,EAAE,EAAEpJ,SAAQR,WAAU;AAClE0J,oBAAgB7I;AAChB,WAAOA;EACT,CAAC,EAAEqG,KAAKuC,SAAQM,UAAU;AAC1B,WAASlJ,SAAQ6B,SAA6BrC,UAA4C;AACxF,QAAIqJ,kBAAkB1G,QAAW;AAC/B,aAAO0G,cAAchH,SAASrC,QAAO;IACvC;AACA,WAAOsJ,eAAeK,KAAMnJ,CAAAA,aAAYA,SAAQ6B,SAASrC,QAAO,CAAC;EACnE;AACA,SAAO;IAAEQ,SAAAA;IAASoJ,SAASR,SAAQQ;EAAO;AAC5C;;;ACxqCA;;qBAAAC;EAAA;;gBAAAC;EAAA;cAAAC;EAAA;gBAAAC;EAAA,cAAAC;EAAA;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBAAAC;AAAA,EAAA;AAAA,gBAAAC;AAAA,EAAA;AAAA,gBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAI;AACJ,IAAI;AACH,YAAU,IAAI,YAAY;AAC3B,SAAQ,OAAO;AAAC;AAChB,IAAI;AACJ,IAAI;AACJ,IAAI,WAAW;AAEf,IAAM,cAAc,CAAC;AACrB,IAAI,UAAU;AACd,IAAI,iBAAiB;AACrB,IAAI,iBAAiB,CAAC;AACtB,IAAI;AACJ,IAAI;AACJ,IAAI,iBAAiB;AACrB,IAAI,eAAe;AACnB,IAAI;AACJ,IAAI;AACJ,IAAI,oBAAoB,CAAC;AACzB,IAAI;AACJ,IAAI,iBAAiB;AAAA,EACpB,YAAY;AAAA,EACZ,eAAe;AAChB;AACO,IAAM,SAAN,MAAa;AAAC;AACd,IAAM,KAAK,IAAI,OAAO;AAC7B,GAAG,OAAO;AACV,IAAI,iBAAiB;AACrB,IAAI,4BAA4B;AAChC,IAAI;AAAJ,IAAgB;AAAhB,IAAoC;AAGpC,IAAI;AACH,MAAI,SAAS,EAAE;AAChB,SAAQ,OAAO;AAEd,8BAA4B;AAC7B;AAEO,IAAM,UAAN,MAAM,SAAQ;AAAA,EACpB,YAAYC,UAAS;AACpB,QAAIA,UAAS;AACZ,UAAIA,SAAQ,eAAe,SAASA,SAAQ,kBAAkB;AAC7D,QAAAA,SAAQ,gBAAgB;AACzB,UAAIA,SAAQ,cAAcA,SAAQ,YAAY,OAAO;AACpD,QAAAA,SAAQ,UAAU;AAClB,YAAI,CAACA,SAAQ,cAAcA,SAAQ,cAAc,OAAO;AACvD,UAAAA,SAAQ,aAAa,CAAC;AACtB,cAAI,CAACA,SAAQ;AACZ,YAAAA,SAAQ,sBAAsB;AAAA,QAChC;AAAA,MACD;AACA,UAAIA,SAAQ;AACX,QAAAA,SAAQ,WAAW,eAAeA,SAAQ,WAAW;AAAA,eAC7CA,SAAQ,eAAe;AAC/B,SAACA,SAAQ,aAAa,CAAC,GAAG,gBAAgB;AAC1C,QAAAA,SAAQ,WAAW,eAAe;AAAA,MACnC;AACA,UAAIA,SAAQ,eAAe;AAC1B,QAAAA,SAAQ,cAAc;AAAA,MACvB;AAAA,IACD;AACA,WAAO,OAAO,MAAMA,QAAO;AAAA,EAC5B;AAAA,EACA,OAAO,QAAQA,UAAS;AACvB,QAAI,KAAK;AAER,aAAO,UAAU,MAAM;AACtB,oBAAY;AACZ,eAAO,OAAO,KAAK,OAAO,QAAQA,QAAO,IAAI,SAAQ,UAAU,OAAO,KAAK,gBAAgB,QAAQA,QAAO;AAAA,MAC3G,CAAC;AAAA,IACF;AACA,QAAI,CAAC,OAAO,UAAU,OAAO,gBAAgB;AAC5C,eAAS,OAAO,WAAW,cAAc,OAAO,KAAK,MAAM,IAAI,IAAI,WAAW,MAAM;AACrF,QAAI,OAAOA,aAAY,UAAU;AAChC,eAASA,SAAQ,OAAO,OAAO;AAC/B,iBAAWA,SAAQ,SAAS;AAAA,IAC7B,OAAO;AACN,iBAAW;AACX,eAASA,WAAU,KAAKA,WAAU,OAAO;AAAA,IAC1C;AACA,qBAAiB;AACjB,mBAAe;AACf,gBAAY;AACZ,cAAU;AACV,qBAAiB;AACjB,UAAM;AAIN,QAAI;AACH,iBAAW,OAAO,aAAa,OAAO,WAAW,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AAAA,IAClH,SAAQ,OAAO;AAEd,YAAM;AACN,UAAI,kBAAkB;AACrB,cAAM;AACP,YAAM,IAAI,MAAM,sDAAuD,UAAU,OAAO,UAAU,WAAY,OAAO,YAAY,OAAO,OAAO,OAAO;AAAA,IACvJ;AACA,QAAI,gBAAgB,UAAS;AAC5B,uBAAiB;AACjB,UAAI,KAAK,YAAY;AACpB,4BAAoB,KAAK;AACzB,eAAO,YAAYA,QAAO;AAAA,MAC3B,WAAW,CAAC,qBAAqB,kBAAkB,SAAS,GAAG;AAC9D,4BAAoB,CAAC;AAAA,MACtB;AAAA,IACD,OAAO;AACN,uBAAiB;AACjB,UAAI,CAAC,qBAAqB,kBAAkB,SAAS;AACpD,4BAAoB,CAAC;AAAA,IACvB;AACA,WAAO,YAAYA,QAAO;AAAA,EAC3B;AAAA,EACA,eAAe,QAAQC,UAAS;AAC/B,QAAI,QAAQ,eAAe;AAC3B,QAAI;AACH,uBAAiB;AACjB,UAAI,OAAO,OAAO;AAClB,UAAIC,SAAQ,OAAO,KAAK,OAAO,QAAQ,IAAI,IAAI,eAAe,OAAO,QAAQ,IAAI;AACjF,UAAID,UAAS;AACZ,YAAIA,SAAQC,QAAO,cAAc,QAAQ,MAAM,MAAO;AACtD,eAAM,WAAW,MAAM;AACtB,yBAAe;AACf,cAAID,SAAQ,YAAY,GAAG,cAAc,QAAQ,MAAM,OAAO;AAC7D;AAAA,UACD;AAAA,QACD;AAAA,MACD,OACK;AACJ,iBAAS,CAAEC,MAAM;AACjB,eAAM,WAAW,MAAM;AACtB,yBAAe;AACf,iBAAO,KAAK,YAAY,CAAC;AAAA,QAC1B;AACA,eAAO;AAAA,MACR;AAAA,IACD,SAAQ,OAAO;AACd,YAAM,eAAe;AACrB,YAAM,SAAS;AACf,YAAM;AAAA,IACP,UAAE;AACD,uBAAiB;AACjB,kBAAY;AAAA,IACb;AAAA,EACD;AAAA,EACA,iBAAiB,kBAAkB,oBAAoB;AACtD,QAAI;AACH,yBAAmB,mBAAmB,KAAK,MAAM,gBAAgB;AAClE,uBAAmB,oBAAoB,CAAC;AACxC,QAAI,OAAO,SAAS,gBAAgB;AACnC,yBAAmB,iBAAiB,IAAI,eAAa,UAAU,MAAM,CAAC,CAAC;AACxE,aAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,IAAI,GAAG,KAAK;AACxD,UAAI,YAAY,iBAAiB,CAAC;AAClC,UAAI,WAAW;AACd,kBAAU,WAAW;AACrB,YAAI,KAAK;AACR,oBAAU,WAAY,IAAI,MAAO;AAAA,MACnC;AAAA,IACD;AACA,qBAAiB,eAAe,iBAAiB;AACjD,aAAS,MAAM,sBAAsB,CAAC,GAAG;AACxC,UAAI,MAAM,GAAG;AACZ,YAAI,YAAY,iBAAiB,EAAE;AACnC,YAAI,WAAW,mBAAmB,EAAE;AACpC,YAAI,UAAU;AACb,cAAI;AACH,aAAC,iBAAiB,sBAAsB,iBAAiB,oBAAoB,CAAC,IAAI,EAAE,IAAI;AACzF,2BAAiB,EAAE,IAAI;AAAA,QACxB;AAAA,MACD;AAAA,IACD;AACA,WAAO,KAAK,aAAa;AAAA,EAC1B;AAAA,EACA,OAAO,QAAQF,UAAS;AACvB,WAAO,KAAK,OAAO,QAAQA,QAAO;AAAA,EACnC;AACD;AAIO,SAAS,YAAYG,UAAS;AACpC,MAAI;AACH,QAAI,CAAC,eAAe,WAAW,CAAC,gBAAgB;AAC/C,UAAI,eAAe,kBAAkB,gBAAgB;AACrD,UAAI,eAAe,kBAAkB;AACpC,0BAAkB,SAAS;AAAA,IAC7B;AACA,QAAI;AACJ,QAAI,eAAe,yBAAyB,IAAI,QAAQ,IAAI,MAAQ,IAAI,QAAQ,KAAK,MAAQ,YAAY;AACxG,eAAS,WAAW,KAAK,UAAU,QAAQ,cAAc;AACzD,YAAM;AACN,UAAI,EAAEA,YAAWA,SAAQ,SAAS;AACjC,iBAAS,OAAO,OAAO;AACxB,iBAAW;AAAA,IACZ;AACC,eAAS,KAAK;AACf,QAAI,gBAAgB;AACnB,iBAAW,eAAe;AAC1B,uBAAiB;AAAA,IAClB;AACA,QAAI;AAGH,wBAAkB,oBAAoB;AAEvC,QAAI,YAAY,QAAQ;AAEvB,UAAI,qBAAqB,kBAAkB;AAC1C,0BAAkB;AACnB,0BAAoB;AACpB,YAAM;AACN,UAAI;AACH,uBAAe;AAAA,IACjB,WAAW,WAAW,QAAQ;AAE7B,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACrD,WAAW,CAAC,gBAAgB;AAC3B,UAAI;AACJ,UAAI;AACH,mBAAW,KAAK,UAAU,QAAQ,CAAC,GAAGC,WAAU,OAAOA,WAAU,WAAW,GAAGA,MAAK,MAAMA,MAAK,EAAE,MAAM,GAAG,GAAG;AAAA,MAC9G,SAAQ,OAAO;AACd,mBAAW,8BAA8B,QAAQ;AAAA,MAClD;AACA,YAAM,IAAI,MAAM,8CAA8C,QAAQ;AAAA,IACvE;AAEA,WAAO;AAAA,EACR,SAAQ,OAAO;AACd,QAAI,qBAAqB,kBAAkB;AAC1C,wBAAkB;AACnB,gBAAY;AACZ,QAAI,iBAAiB,cAAc,MAAM,QAAQ,WAAW,0BAA0B,KAAK,WAAW,QAAQ;AAC7G,YAAM,aAAa;AAAA,IACpB;AACA,UAAM;AAAA,EACP;AACD;AAEA,SAAS,oBAAoB;AAC5B,WAAS,MAAM,kBAAkB,mBAAmB;AACnD,sBAAkB,EAAE,IAAI,kBAAkB,kBAAkB,EAAE;AAAA,EAC/D;AACA,oBAAkB,oBAAoB;AACvC;AAEO,SAAS,OAAO;AACtB,MAAI,QAAQ,IAAI,UAAU;AAC1B,MAAI,QAAQ,KAAM;AACjB,QAAI,QAAQ,KAAM;AACjB,UAAI,QAAQ;AACX,eAAO;AAAA,WACH;AACJ,YAAI,YAAY,kBAAkB,QAAQ,EAAI,KAC7C,eAAe,iBAAiB,eAAe,EAAE,QAAQ,EAAI;AAC9D,YAAI,WAAW;AACd,cAAI,CAAC,UAAU,MAAM;AACpB,sBAAU,OAAO,sBAAsB,WAAW,QAAQ,EAAI;AAAA,UAC/D;AACA,iBAAO,UAAU,KAAK;AAAA,QACvB;AACC,iBAAO;AAAA,MACT;AAAA,IACD,WAAW,QAAQ,KAAM;AAExB,eAAS;AACT,UAAI,eAAe,eAAe;AACjC,YAAI,SAAS,CAAC;AACd,iBAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC/B,cAAI,MAAM,QAAQ;AAClB,cAAI,QAAQ;AACX,kBAAM;AACP,iBAAO,GAAG,IAAI,KAAK;AAAA,QACpB;AACA,eAAO;AAAA,MACR,OAAO;AACN,YAAIC,OAAM,oBAAI,IAAI;AAClB,iBAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC/B,UAAAA,KAAI,IAAI,KAAK,GAAG,KAAK,CAAC;AAAA,QACvB;AACA,eAAOA;AAAA,MACR;AAAA,IACD,OAAO;AACN,eAAS;AACT,UAAI,QAAQ,IAAI,MAAM,KAAK;AAC3B,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC/B,cAAM,CAAC,IAAI,KAAK;AAAA,MACjB;AACA,UAAI,eAAe;AAClB,eAAO,OAAO,OAAO,KAAK;AAC3B,aAAO;AAAA,IACR;AAAA,EACD,WAAW,QAAQ,KAAM;AAExB,QAAI,SAAS,QAAQ;AACrB,QAAI,gBAAgB,UAAU;AAC7B,aAAO,UAAU,MAAM,WAAW,iBAAiB,YAAY,UAAU,cAAc;AAAA,IACxF;AACA,QAAI,gBAAgB,KAAK,SAAS,KAAK;AAEtC,UAAI,SAAS,SAAS,KAAK,gBAAgB,MAAM,IAAI,eAAe,MAAM;AAC1E,UAAI,UAAU;AACb,eAAO;AAAA,IACT;AACA,WAAO,gBAAgB,MAAM;AAAA,EAC9B,OAAO;AACN,QAAID;AACJ,YAAQ,OAAO;AAAA,MACd,KAAK;AAAM,eAAO;AAAA,MAClB,KAAK;AACJ,YAAI,gBAAgB;AACnB,UAAAA,SAAQ,KAAK;AACb,cAAIA,SAAQ;AACX,mBAAO,eAAe,CAAC,EAAE,MAAM,eAAe,WAAW,eAAe,aAAaA,MAAK;AAAA;AAE1F,mBAAO,eAAe,CAAC,EAAE,MAAM,eAAe,WAAW,eAAe,aAAaA,MAAK;AAAA,QAC5F;AACA,eAAO;AAAA;AAAA,MACR,KAAK;AAAM,eAAO;AAAA,MAClB,KAAK;AAAM,eAAO;AAAA,MAClB,KAAK;AAEJ,QAAAA,SAAQ,IAAI,UAAU;AACtB,YAAIA,WAAU;AACb,gBAAM,IAAI,MAAM,0BAA0B;AAC3C,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AAEJ,eAAO,QAAQ,IAAI,UAAU,CAAC;AAAA,MAC/B,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AACJ,QAAAA,SAAQ,SAAS,WAAW,QAAQ;AACpC,YAAI,eAAe,aAAa,GAAG;AAElC,cAAI,aAAa,QAAS,IAAI,QAAQ,IAAI,QAAS,IAAM,IAAI,WAAW,CAAC,KAAK,CAAE;AAChF,sBAAY;AACZ,kBAAS,aAAaA,UAASA,SAAQ,IAAI,MAAM,SAAU,KAAK;AAAA,QACjE;AACA,oBAAY;AACZ,eAAOA;AAAA,MACR,KAAK;AACJ,QAAAA,SAAQ,SAAS,WAAW,QAAQ;AACpC,oBAAY;AACZ,eAAOA;AAAA;AAAA,MAER,KAAK;AACJ,eAAO,IAAI,UAAU;AAAA,MACtB,KAAK;AACJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAOA;AAAA,MACR,KAAK;AACJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAOA;AAAA,MACR,KAAK;AACJ,YAAI,eAAe,gBAAgB,UAAU;AAC5C,UAAAA,SAAQ,SAAS,UAAU,QAAQ,IAAI;AACvC,UAAAA,UAAS,SAAS,UAAU,WAAW,CAAC;AAAA,QACzC,WAAW,eAAe,gBAAgB,UAAU;AACnD,UAAAA,SAAQ,SAAS,aAAa,QAAQ,EAAE,SAAS;AAAA,QAClD,WAAW,eAAe,gBAAgB,QAAQ;AACjD,UAAAA,SAAQ,SAAS,aAAa,QAAQ;AACtC,cAAIA,UAAO,OAAO,CAAC,KAAG,OAAO,EAAE,EAAG,CAAAA,SAAM,OAAOA,MAAK;AAAA,QACrD;AACC,UAAAA,SAAQ,SAAS,aAAa,QAAQ;AACvC,oBAAY;AACZ,eAAOA;AAAA;AAAA,MAGR,KAAK;AACJ,eAAO,SAAS,QAAQ,UAAU;AAAA,MACnC,KAAK;AACJ,QAAAA,SAAQ,SAAS,SAAS,QAAQ;AAClC,oBAAY;AACZ,eAAOA;AAAA,MACR,KAAK;AACJ,QAAAA,SAAQ,SAAS,SAAS,QAAQ;AAClC,oBAAY;AACZ,eAAOA;AAAA,MACR,KAAK;AACJ,YAAI,eAAe,gBAAgB,UAAU;AAC5C,UAAAA,SAAQ,SAAS,SAAS,QAAQ,IAAI;AACtC,UAAAA,UAAS,SAAS,UAAU,WAAW,CAAC;AAAA,QACzC,WAAW,eAAe,gBAAgB,UAAU;AACnD,UAAAA,SAAQ,SAAS,YAAY,QAAQ,EAAE,SAAS;AAAA,QACjD,WAAW,eAAe,gBAAgB,QAAQ;AACjD,UAAAA,SAAQ,SAAS,YAAY,QAAQ;AACrC,cAAIA,UAAO,OAAO,EAAE,KAAG,OAAO,EAAE,KAAGA,UAAO,OAAO,CAAC,KAAG,OAAO,EAAE,EAAG,CAAAA,SAAM,OAAOA,MAAK;AAAA,QACpF;AACC,UAAAA,SAAQ,SAAS,YAAY,QAAQ;AACtC,oBAAY;AACZ,eAAOA;AAAA,MAER,KAAK;AAEJ,QAAAA,SAAQ,IAAI,UAAU;AACtB,YAAIA,UAAS,KAAM;AAClB,iBAAO,iBAAiB,IAAI,UAAU,IAAI,EAAI;AAAA,QAC/C,OAAO;AACN,cAAI,YAAY,kBAAkBA,MAAK;AACvC,cAAI,WAAW;AACd,gBAAI,UAAU,MAAM;AACnB;AACA,qBAAO,UAAU,KAAK,KAAK,CAAC;AAAA,YAC7B,WAAW,UAAU,UAAU;AAC9B;AACA,qBAAO,UAAU;AAAA,YAClB;AACC,qBAAO,UAAU,IAAI,SAAS,UAAU,EAAE,QAAQ,CAAC;AAAA,UACrD;AACC,kBAAM,IAAI,MAAM,uBAAuBA,MAAK;AAAA,QAC9C;AAAA,MACD,KAAK;AAEJ,QAAAA,SAAQ,IAAI,QAAQ;AACpB,YAAIA,UAAS,KAAM;AAClB;AACA,iBAAO,iBAAiB,IAAI,UAAU,IAAI,IAAM,IAAI,UAAU,CAAC;AAAA,QAChE;AACC,iBAAO,QAAQ,CAAC;AAAA,MAClB,KAAK;AAEJ,eAAO,QAAQ,CAAC;AAAA,MACjB,KAAK;AAEJ,eAAO,QAAQ,CAAC;AAAA,MACjB,KAAK;AAEJ,eAAO,QAAQ,EAAE;AAAA,MAClB,KAAK;AAEJ,QAAAA,SAAQ,IAAI,UAAU;AACtB,YAAI,gBAAgB,UAAU;AAC7B,iBAAO,UAAU,MAAM,WAAW,iBAAiB,YAAYA,UAAS,cAAc;AAAA,QACvF;AACA,eAAO,YAAYA,MAAK;AAAA,MACzB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,YAAI,gBAAgB,UAAU;AAC7B,iBAAO,UAAU,MAAM,WAAW,iBAAiB,YAAYA,UAAS,cAAc;AAAA,QACvF;AACA,eAAO,aAAaA,MAAK;AAAA,MAC1B,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,YAAI,gBAAgB,UAAU;AAC7B,iBAAO,UAAU,MAAM,WAAW,iBAAiB,YAAYA,UAAS,cAAc;AAAA,QACvF;AACA,eAAO,aAAaA,MAAK;AAAA,MAC1B,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,UAAUA,MAAK;AAAA,MACvB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,UAAUA,MAAK;AAAA,MACvB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB,KAAK;AAEJ,QAAAA,SAAQ,SAAS,UAAU,QAAQ;AACnC,oBAAY;AACZ,eAAO,QAAQA,MAAK;AAAA,MACrB;AACC,YAAI,SAAS;AACZ,iBAAO,QAAQ;AAChB,YAAI,UAAU,QAAW;AACxB,cAAI,QAAQ,IAAI,MAAM,oCAAoC;AAC1D,gBAAM,aAAa;AACnB,gBAAM;AAAA,QACP;AACA,cAAM,IAAI,MAAM,+BAA+B,KAAK;AAAA,IAEtD;AAAA,EACD;AACD;AACA,IAAM,YAAY;AAClB,SAAS,sBAAsB,WAAW,SAAS;AAClD,WAAS,aAAa;AAErB,QAAI,WAAW,UAAU,2BAA2B;AACnD,UAAIE,cAAa,UAAU,OAAQ,IAAI,SAAS,KAAK,+BAA+B,eAAe,aAAa,kBAAkB,MACjI,OAAO,UAAU,IAAI,SAAO,QAAQ,cAAc,iBAAiB,UAAU,KAAK,GAAG,IAAI,MAAM,SAAU,MAAM,KAAK,UAAU,GAAG,IAAI,OAAQ,EAAE,KAAK,GAAG,IAAI,KAAK,EAAG,IAAI;AACxK,UAAI,UAAU,aAAa;AAC1B,kBAAU,OAAO,uBAAuB,SAAS,UAAU,IAAI;AAChE,aAAOA,YAAW;AAAA,IACnB;AACA,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,IAAI,GAAG,KAAK;AACjD,UAAI,MAAM,UAAU,CAAC;AACrB,UAAI,QAAQ;AACX,cAAM;AACP,aAAO,GAAG,IAAI,KAAK;AAAA,IACpB;AACA,QAAI,eAAe;AAClB,aAAO,OAAO,OAAO,MAAM;AAC5B,WAAO;AAAA,EACR;AACA,aAAW,QAAQ;AACnB,MAAI,UAAU,aAAa,GAAG;AAC7B,WAAO,uBAAuB,SAAS,UAAU;AAAA,EAClD;AACA,SAAO;AACR;AAEA,IAAM,yBAAyB,CAAC,SAAS,UAAU;AAClD,SAAO,WAAW;AACjB,QAAI,WAAW,IAAI,UAAU;AAC7B,QAAI,aAAa;AAChB,aAAO,MAAM;AACd,QAAI,KAAK,UAAU,KAAK,EAAE,WAAW,YAAY,MAAM,WAAW,YAAY;AAC9E,QAAI,YAAY,kBAAkB,EAAE,KAAK,eAAe,EAAE,EAAE;AAC5D,QAAI,CAAC,WAAW;AACf,YAAM,IAAI,MAAM,kCAAkC,EAAE;AAAA,IACrD;AACA,QAAI,CAAC,UAAU;AACd,gBAAU,OAAO,sBAAsB,WAAW,OAAO;AAC1D,WAAO,UAAU,KAAK;AAAA,EACvB;AACD;AAEO,SAAS,iBAAiB;AAChC,MAAI,mBAAmB,UAAU,MAAM;AAEtC,UAAM;AACN,WAAO,eAAe,cAAc;AAAA,EACrC,CAAC;AACD,SAAO,oBAAoB,eAAe,iBAAiB,kBAAkB,iBAAiB;AAC/F;AAEA,IAAI,kBAAkB;AACtB,IAAI,cAAc;AAClB,IAAI,eAAe;AACnB,IAAI,eAAe;AACZ,IAAI,8BAA8B;AAyCzC,SAAS,aAAa,QAAQ;AAC7B,MAAI;AACJ,MAAI,SAAS,IAAI;AAChB,QAAI,SAAS,gBAAgB,MAAM;AAClC,aAAO;AAAA,EACT;AACA,MAAI,SAAS,MAAM;AAClB,WAAO,QAAQ,OAAO,IAAI,SAAS,UAAU,YAAY,MAAM,CAAC;AACjE,QAAM,MAAM,WAAW;AACvB,QAAM,QAAQ,CAAC;AACf,WAAS;AACT,SAAO,WAAW,KAAK;AACtB,UAAM,QAAQ,IAAI,UAAU;AAC5B,SAAK,QAAQ,SAAU,GAAG;AAEzB,YAAM,KAAK,KAAK;AAAA,IACjB,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,MAAO,QAAQ,OAAS,IAAK,KAAK;AAAA,IACzC,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,MAAO,QAAQ,OAAS,KAAO,SAAS,IAAK,KAAK;AAAA,IACzD,YAAY,QAAQ,SAAU,KAAM;AAEnC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,YAAM,QAAQ,IAAI,UAAU,IAAI;AAChC,UAAI,QAAS,QAAQ,MAAS,KAAS,SAAS,KAAS,SAAS,IAAQ;AAC1E,UAAI,OAAO,OAAQ;AAClB,gBAAQ;AACR,cAAM,KAAO,SAAS,KAAM,OAAS,KAAM;AAC3C,eAAO,QAAU,OAAO;AAAA,MACzB;AACA,YAAM,KAAK,IAAI;AAAA,IAChB,OAAO;AACN,YAAM,KAAK,KAAK;AAAA,IACjB;AAEA,QAAI,MAAM,UAAU,MAAQ;AAC3B,gBAAU,aAAa,MAAM,QAAQ,KAAK;AAC1C,YAAM,SAAS;AAAA,IAChB;AAAA,EACD;AAEA,MAAI,MAAM,SAAS,GAAG;AACrB,cAAU,aAAa,MAAM,QAAQ,KAAK;AAAA,EAC3C;AAEA,SAAO;AACR;AAYA,SAAS,UAAU,QAAQ;AAC1B,MAAI,QAAQ,IAAI,MAAM,MAAM;AAC5B,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,UAAM,CAAC,IAAI,KAAK;AAAA,EACjB;AACA,MAAI,eAAe;AAClB,WAAO,OAAO,OAAO,KAAK;AAC3B,SAAO;AACR;AAEA,SAAS,QAAQ,QAAQ;AACxB,MAAI,eAAe,eAAe;AACjC,QAAI,SAAS,CAAC;AACd,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,UAAI,MAAM,QAAQ;AAClB,UAAI,QAAQ;AACX,cAAM;AACP,aAAO,GAAG,IAAI,KAAK;AAAA,IACpB;AACA,WAAO;AAAA,EACR,OAAO;AACN,QAAIC,OAAM,oBAAI,IAAI;AAClB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,MAAAA,KAAI,IAAI,KAAK,GAAG,KAAK,CAAC;AAAA,IACvB;AACA,WAAOA;AAAA,EACR;AACD;AAEA,IAAI,eAAe,OAAO;AAC1B,SAAS,eAAe,QAAQ;AAC/B,MAAI,QAAQ;AACZ,MAAI,QAAQ,IAAI,MAAM,MAAM;AAC5B,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,UAAM,OAAO,IAAI,UAAU;AAC3B,SAAK,OAAO,OAAQ,GAAG;AACrB,iBAAW;AACX;AAAA,IACD;AACA,UAAM,CAAC,IAAI;AAAA,EACZ;AACA,SAAO,aAAa,MAAM,QAAQ,KAAK;AACzC;AACA,SAAS,gBAAgB,QAAQ;AAChC,MAAI,SAAS,GAAG;AACf,QAAI,SAAS,GAAG;AACf,UAAI,WAAW;AACd,eAAO;AAAA,WACH;AACJ,YAAI,IAAI,IAAI,UAAU;AACtB,aAAK,IAAI,OAAQ,GAAG;AACnB,sBAAY;AACZ;AAAA,QACD;AACA,eAAO,aAAa,CAAC;AAAA,MACtB;AAAA,IACD,OAAO;AACN,UAAI,IAAI,IAAI,UAAU;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,WAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACrC,oBAAY;AACZ;AAAA,MACD;AACA,UAAI,SAAS;AACZ,eAAO,aAAa,GAAG,CAAC;AACzB,UAAI,IAAI,IAAI,UAAU;AACtB,WAAK,IAAI,OAAQ,GAAG;AACnB,oBAAY;AACZ;AAAA,MACD;AACA,aAAO,aAAa,GAAG,GAAG,CAAC;AAAA,IAC5B;AAAA,EACD,OAAO;AACN,QAAI,IAAI,IAAI,UAAU;AACtB,QAAI,IAAI,IAAI,UAAU;AACtB,QAAI,IAAI,IAAI,UAAU;AACtB,QAAI,IAAI,IAAI,UAAU;AACtB,SAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACzE,kBAAY;AACZ;AAAA,IACD;AACA,QAAI,SAAS,GAAG;AACf,UAAI,WAAW;AACd,eAAO,aAAa,GAAG,GAAG,GAAG,CAAC;AAAA,WAC1B;AACJ,YAAI,IAAI,IAAI,UAAU;AACtB,aAAK,IAAI,OAAQ,GAAG;AACnB,sBAAY;AACZ;AAAA,QACD;AACA,eAAO,aAAa,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,MAClC;AAAA,IACD,WAAW,SAAS,GAAG;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,WAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACrC,oBAAY;AACZ;AAAA,MACD;AACA,UAAI,SAAS;AACZ,eAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACrC,UAAI,IAAI,IAAI,UAAU;AACtB,WAAK,IAAI,OAAQ,GAAG;AACnB,oBAAY;AACZ;AAAA,MACD;AACA,aAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,IACxC,OAAO;AACN,UAAI,IAAI,IAAI,UAAU;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,UAAI,IAAI,IAAI,UAAU;AACtB,WAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACzE,oBAAY;AACZ;AAAA,MACD;AACA,UAAI,SAAS,IAAI;AAChB,YAAI,WAAW;AACd,iBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,aACtC;AACJ,cAAI,IAAI,IAAI,UAAU;AACtB,eAAK,IAAI,OAAQ,GAAG;AACnB,wBAAY;AACZ;AAAA,UACD;AACA,iBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,QAC9C;AAAA,MACD,WAAW,SAAS,IAAI;AACvB,YAAI,IAAI,IAAI,UAAU;AACtB,YAAI,IAAI,IAAI,UAAU;AACtB,aAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACrC,sBAAY;AACZ;AAAA,QACD;AACA,YAAI,SAAS;AACZ,iBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACjD,YAAI,IAAI,IAAI,UAAU;AACtB,aAAK,IAAI,OAAQ,GAAG;AACnB,sBAAY;AACZ;AAAA,QACD;AACA,eAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,MACpD,OAAO;AACN,YAAI,IAAI,IAAI,UAAU;AACtB,YAAI,IAAI,IAAI,UAAU;AACtB,YAAI,IAAI,IAAI,UAAU;AACtB,YAAI,IAAI,IAAI,UAAU;AACtB,aAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACzE,sBAAY;AACZ;AAAA,QACD;AACA,YAAI,SAAS,IAAI;AAChB,cAAI,WAAW;AACd,mBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,eAClD;AACJ,gBAAI,IAAI,IAAI,UAAU;AACtB,iBAAK,IAAI,OAAQ,GAAG;AACnB,0BAAY;AACZ;AAAA,YACD;AACA,mBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,UAC1D;AAAA,QACD,OAAO;AACN,cAAI,IAAI,IAAI,UAAU;AACtB,cAAI,IAAI,IAAI,UAAU;AACtB,eAAK,IAAI,OAAQ,MAAM,IAAI,OAAQ,GAAG;AACrC,wBAAY;AACZ;AAAA,UACD;AACA,cAAI,SAAS;AACZ,mBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC7D,cAAI,IAAI,IAAI,UAAU;AACtB,eAAK,IAAI,OAAQ,GAAG;AACnB,wBAAY;AACZ;AAAA,UACD;AACA,iBAAO,aAAa,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,QAChE;AAAA,MACD;AAAA,IACD;AAAA,EACD;AACD;AAEA,SAAS,mBAAmB;AAC3B,MAAI,QAAQ,IAAI,UAAU;AAC1B,MAAI;AACJ,MAAI,QAAQ,KAAM;AAEjB,aAAS,QAAQ;AAAA,EAClB,OAAO;AACN,YAAO,OAAO;AAAA,MACb,KAAK;AAEJ,iBAAS,IAAI,UAAU;AACvB;AAAA,MACD,KAAK;AAEJ,iBAAS,SAAS,UAAU,QAAQ;AACpC,oBAAY;AACZ;AAAA,MACD,KAAK;AAEJ,iBAAS,SAAS,UAAU,QAAQ;AACpC,oBAAY;AACZ;AAAA,MACD;AACC,cAAM,IAAI,MAAM,iBAAiB;AAAA,IACnC;AAAA,EACD;AACA,SAAO,aAAa,MAAM;AAC3B;AAGA,SAAS,QAAQ,QAAQ;AACxB,SAAO,eAAe;AAAA;AAAA,IAErB,WAAW,UAAU,MAAM,KAAK,KAAK,UAAU,YAAY,MAAM;AAAA,MACjE,IAAI,SAAS,UAAU,YAAY,MAAM;AAC3C;AACA,SAAS,QAAQ,QAAQ;AACxB,MAAI,OAAO,IAAI,UAAU;AACzB,MAAI,kBAAkB,IAAI,GAAG;AAC5B,QAAI;AACJ,WAAO,kBAAkB,IAAI,EAAE,IAAI,SAAS,UAAU,MAAO,YAAY,MAAO,GAAG,CAAC,iBAAiB;AACpG,iBAAW;AACX,UAAI;AACH,eAAO,KAAK;AAAA,MACb,UAAE;AACD,mBAAW;AAAA,MACZ;AAAA,IACD,CAAC;AAAA,EACF;AAEC,UAAM,IAAI,MAAM,4BAA4B,IAAI;AAClD;AAEA,IAAI,WAAW,IAAI,MAAM,IAAI;AAC7B,SAAS,UAAU;AAClB,MAAI,SAAS,IAAI,UAAU;AAC3B,MAAI,UAAU,OAAQ,SAAS,KAAM;AAEpC,aAAS,SAAS;AAClB,QAAI,gBAAgB;AACnB,aAAO,UAAU,MAAM,WAAW,iBAAiB,YAAY,UAAU,cAAc;AAAA,aAC/E,EAAE,gBAAgB,KAAK,SAAS;AACxC,aAAO,gBAAgB,MAAM;AAAA,EAC/B,OAAO;AACN;AACA,WAAO,aAAa,KAAK,CAAC;AAAA,EAC3B;AACA,MAAI,OAAQ,UAAU,KAAM,SAAS,IAAI,SAAS,UAAU,QAAQ,IAAI,SAAS,IAAI,IAAI,QAAQ,IAAI,MAAM;AAC3G,MAAI,QAAQ,SAAS,GAAG;AACxB,MAAI,gBAAgB;AACpB,MAAI,MAAM,WAAW,SAAS;AAC9B,MAAI;AACJ,MAAI,IAAI;AACR,MAAI,SAAS,MAAM,SAAS,QAAQ;AACnC,WAAO,gBAAgB,KAAK;AAC3B,cAAQ,SAAS,UAAU,aAAa;AACxC,UAAI,SAAS,MAAM,GAAG,GAAG;AACxB,wBAAgB;AAChB;AAAA,MACD;AACA,uBAAiB;AAAA,IAClB;AACA,WAAO;AACP,WAAO,gBAAgB,KAAK;AAC3B,cAAQ,IAAI,eAAe;AAC3B,UAAI,SAAS,MAAM,GAAG,GAAG;AACxB,wBAAgB;AAChB;AAAA,MACD;AAAA,IACD;AACA,QAAI,kBAAkB,KAAK;AAC1B,iBAAW;AACX,aAAO,MAAM;AAAA,IACd;AACA,WAAO;AACP,oBAAgB;AAAA,EACjB;AACA,UAAQ,CAAC;AACT,WAAS,GAAG,IAAI;AAChB,QAAM,QAAQ;AACd,SAAO,gBAAgB,KAAK;AAC3B,YAAQ,SAAS,UAAU,aAAa;AACxC,UAAM,KAAK,KAAK;AAChB,qBAAiB;AAAA,EAClB;AACA,SAAO;AACP,SAAO,gBAAgB,KAAK;AAC3B,YAAQ,IAAI,eAAe;AAC3B,UAAM,KAAK,KAAK;AAAA,EACjB;AAEA,MAAI,SAAS,SAAS,KAAK,gBAAgB,MAAM,IAAI,eAAe,MAAM;AAC1E,MAAI,UAAU;AACb,WAAO,MAAM,SAAS;AACvB,SAAO,MAAM,SAAS,gBAAgB,MAAM;AAC7C;AAEA,SAAS,aAAa,UAAU;AAE/B,MAAI,OAAO,aAAa,SAAU,QAAO;AACzC,MAAI,OAAO,aAAa,YAAY,OAAO,aAAa,aAAa,OAAO,aAAa,SAAU,QAAO,SAAS,SAAS;AAC5H,MAAI,YAAY,KAAM,QAAO,WAAW;AACxC,MAAI,eAAe,wBAAwB,MAAM,QAAQ,QAAQ,KAAK,SAAS,KAAK,EAAE,MAAM,UAAQ,CAAC,UAAU,UAAU,WAAW,QAAQ,EAAE,SAAS,OAAO,IAAI,CAAC,GAAG;AACrK,WAAO,SAAS,KAAK,EAAE,SAAS;AAAA,EACjC;AACA,QAAM,IAAI,MAAM,qCAAqC,OAAO,QAAQ,EAAE;AACvE;AAEA,IAAM,mBAAmB,CAAC,IAAI,aAAa;AAC1C,MAAI,YAAY,KAAK,EAAE,IAAI,YAAY;AAEvC,MAAI,YAAY;AAChB,MAAI,aAAa,QAAW;AAC3B,SAAK,KAAK,KAAK,GAAG,YAAY,KAAK,OAAQ,YAAY,KAAK;AAC5D,cAAU,WAAW;AAAA,EACtB;AACA,MAAI,oBAAoB,kBAAkB,EAAE;AAI5C,MAAI,sBAAsB,kBAAkB,YAAY,iBAAiB;AACxE,KAAC,kBAAkB,sBAAsB,kBAAkB,oBAAoB,CAAC,IAAI,EAAE,IAAI;AAAA,EAC3F;AACA,oBAAkB,EAAE,IAAI;AACxB,YAAU,OAAO,sBAAsB,WAAW,SAAS;AAC3D,SAAO,UAAU,KAAK;AACvB;AACA,kBAAkB,CAAC,IAAI,MAAM;AAAC;AAC9B,kBAAkB,CAAC,EAAE,WAAW;AAEhC,kBAAkB,EAAI,IAAI,CAAC,SAAS;AAEnC,MAAI,SAAS,KAAK;AAClB,MAAIC,SAAQ,OAAO,KAAK,CAAC,IAAI,MAAO,KAAK,CAAC,IAAI,MAAQ,KAAK,CAAC,CAAC;AAC7D,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,IAAAA,WAAU,OAAO,CAAC;AAClB,IAAAA,UAAS,OAAO,KAAK,CAAC,CAAC;AAAA,EACxB;AACA,SAAOA;AACR;AAEA,IAAI,SAAS,EAAE,OAAO,WAAW,eAAe;AAChD,kBAAkB,GAAI,IAAI,MAAM;AAC/B,MAAI,OAAO,KAAK;AAChB,UAAQ,OAAO,KAAK,CAAC,CAAC,KAAK,OAAO,KAAK,CAAC,GAAG,EAAE,OAAO,KAAK,CAAC,EAAE,CAAC;AAC9D;AAEA,kBAAkB,GAAI,IAAI,CAAC,SAAS;AAEnC,MAAI,eAAe,oBAAoB,MAAO,OAAM,IAAI,MAAM,wCAAwC;AACtG,MAAI,KAAK,SAAS,UAAU,WAAW,CAAC;AACxC,MAAI,CAAC;AACJ,mBAAe,oBAAI,IAAI;AACxB,MAAI,QAAQ,IAAI,QAAQ;AACxB,MAAIC;AAEJ,MAAI,SAAS,OAAQ,QAAQ,OAAQ,SAAS,OAAQ,SAAS;AAC9D,IAAAA,UAAS,CAAC;AAAA,WACF,SAAS,OAAQ,QAAQ,OAAQ,SAAS,OAAQ,SAAS;AACnE,IAAAA,UAAS,oBAAI,IAAI;AAAA,YACR,SAAS,OAAQ,SAAS,OAAQ,SAAS,OAAQ,SAAS,QAAS,IAAI,WAAW,CAAC,MAAM;AACpG,IAAAA,UAAS,oBAAI,IAAI;AAAA;AAEjB,IAAAA,UAAS,CAAC;AAEX,MAAI,WAAW,EAAE,QAAAA,QAAO;AACxB,eAAa,IAAI,IAAI,QAAQ;AAC7B,MAAI,mBAAmB,KAAK;AAC5B,MAAI,CAAC,SAAS,MAAM;AAEnB,WAAO,SAAS,SAAS;AAAA,EAC1B,OAAO;AAEN,WAAO,OAAOA,SAAQ,gBAAgB;AAAA,EACvC;AAGA,MAAIA,mBAAkB;AACrB,aAAS,CAAC,GAAG,CAAC,KAAK,iBAAiB,QAAQ,EAAG,CAAAA,QAAO,IAAI,GAAG,CAAC;AAC/D,MAAIA,mBAAkB;AACrB,aAAS,KAAK,MAAM,KAAK,gBAAgB,EAAG,CAAAA,QAAO,IAAI,CAAC;AACzD,SAAOA;AACR;AAEA,kBAAkB,GAAI,IAAI,CAAC,SAAS;AAEnC,MAAI,eAAe,oBAAoB,MAAO,OAAM,IAAI,MAAM,wCAAwC;AACtG,MAAI,KAAK,SAAS,UAAU,WAAW,CAAC;AACxC,MAAI,WAAW,aAAa,IAAI,EAAE;AAClC,WAAS,OAAO;AAChB,SAAO,SAAS;AACjB;AAEA,kBAAkB,GAAI,IAAI,MAAM,IAAI,IAAI,KAAK,CAAC;AAEvC,IAAM,cAAc,CAAC,QAAO,SAAQ,gBAAe,SAAQ,UAAS,SAAQ,UAAS,WAAU,WAAU,YAAW,WAAW,EAAE,IAAI,UAAQ,OAAO,OAAO;AAElK,IAAI,OAAO,OAAO,eAAe,WAAW,aAAa;AACzD,kBAAkB,GAAI,IAAI,CAAC,SAAS;AACnC,MAAI,WAAW,KAAK,CAAC;AAErB,MAAI,SAAS,WAAW,UAAU,MAAM,KAAK,MAAM,CAAC,EAAE;AAEtD,MAAI,iBAAiB,YAAY,QAAQ;AACzC,MAAI,CAAC,gBAAgB;AACpB,QAAI,aAAa,GAAI,QAAO;AAC5B,QAAI,aAAa,GAAI,QAAO,IAAI,SAAS,MAAM;AAC/C,UAAM,IAAI,MAAM,yCAAyC,QAAQ;AAAA,EAClE;AACA,SAAO,IAAI,KAAK,cAAc,EAAE,MAAM;AACvC;AACA,kBAAkB,GAAI,IAAI,MAAM;AAC/B,MAAI,OAAO,KAAK;AAChB,SAAO,IAAI,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AACnC;AACA,IAAM,cAAc,CAAC;AACrB,kBAAkB,EAAI,IAAI,CAAC,SAAS;AACnC,MAAI,YAAY,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC;AAC1E,MAAI,eAAe;AACnB,cAAY,WAAW,KAAK;AAC5B,mBAAiB;AACjB,mBAAiB,CAAC,iBAAiB,GAAG,iBAAiB,CAAC;AACxD,iBAAe,YAAY;AAC3B,iBAAe,YAAY;AAC3B,iBAAe,qBAAqB;AACpC,aAAW;AACX,SAAO,KAAK;AACb;AAEA,kBAAkB,GAAI,IAAI,CAAC,SAAS;AAEnC,MAAI,KAAK,UAAU;AAClB,WAAO,IAAI,MAAM,KAAK,CAAC,IAAI,YAAa,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,GAAI;AAAA,WACjF,KAAK,UAAU;AACvB,WAAO,IAAI;AAAA,QACR,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,MAAM,KAAK,CAAC,KAAK,MAAM,QACtE,KAAK,CAAC,IAAI,KAAO,aAAc,KAAK,CAAC,IAAI,YAAa,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK;AAAA,IAAI;AAAA,WAClG,KAAK,UAAU;AACvB,WAAO,IAAI;AAAA,QACR,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,OAAO,KAAK,CAAC,KAAK,KAAK,KAAK,CAAC,KAAK,QAC9D,KAAK,CAAC,IAAI,MAAQ,mBAAmB,KAAK,KAAK,CAAC,IAAI,gBAAgB,KAAK,CAAC,IAAI,aAAc,KAAK,CAAC,IAAI,YAAa,KAAK,CAAC,KAAK,OAAO,KAAK,EAAE,KAAK,KAAK,KAAK,EAAE,KAAK;AAAA,IAAI;AAAA;AAE1K,WAAO,oBAAI,KAAK,SAAS;AAC3B;AAIA,SAAS,UAAU,UAAU;AAC5B,MAAI;AACH,gBAAY;AACb,MAAI,cAAc;AAClB,MAAI,gBAAgB;AACpB,MAAI,sBAAsB;AAC1B,MAAI,sBAAsB;AAC1B,MAAI,oBAAoB;AACxB,MAAI,iBAAiB;AACrB,MAAI,eAAe;AACnB,MAAI,oBAAoB;AACxB,MAAI,sBAAsB;AAG1B,MAAI,WAAW,IAAI,WAAW,IAAI,MAAM,GAAG,MAAM,CAAC;AAClD,MAAI,kBAAkB;AACtB,MAAI,0BAA0B,kBAAkB,MAAM,GAAG,kBAAkB,MAAM;AACjF,MAAI,aAAa;AACjB,MAAI,sBAAsB;AAC1B,MAAID,SAAQ,SAAS;AACrB,WAAS;AACT,aAAW;AACX,mBAAiB;AACjB,mBAAiB;AACjB,iBAAe;AACf,cAAY;AACZ,YAAU;AACV,iBAAe;AACf,mBAAiB;AACjB,QAAM;AACN,mBAAiB;AACjB,sBAAoB;AACpB,oBAAkB,OAAO,GAAG,kBAAkB,QAAQ,GAAG,uBAAuB;AAChF,mBAAiB;AACjB,aAAW,IAAI,SAAS,IAAI,QAAQ,IAAI,YAAY,IAAI,UAAU;AAClE,SAAOA;AACR;AACO,SAAS,cAAc;AAC7B,QAAM;AACN,iBAAe;AACf,sBAAoB;AACrB;AAEO,SAAS,aAAa,WAAW;AACvC,MAAI,UAAU;AACb,sBAAkB,UAAU,IAAI,IAAI,UAAU;AAAA;AAE9C,sBAAkB,UAAU,IAAI,IAAI;AACtC;AAEO,IAAM,SAAS,IAAI,MAAM,GAAG;AACnC,SAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC7B,SAAO,CAAC,IAAI,EAAE,OAAO,KAAK,MAAM,QAAQ,IAAI,OAAO;AACpD;AACO,IAAM,UAAU;AACvB,IAAI,iBAAiB,IAAI,QAAQ,EAAE,YAAY,MAAM,CAAC;AAC/C,IAAM,SAAS,eAAe;AAC9B,IAAM,iBAAiB,eAAe;AACtC,IAAME,UAAS,eAAe;AAC9B,IAAM,kBAAkB;AAAA,EAC9B,OAAO;AAAA,EACP,QAAQ;AAAA,EACR,eAAe;AAAA,EACf,aAAa;AACd;AACA,IAAI,WAAW,IAAI,aAAa,CAAC;AACjC,IAAI,UAAU,IAAI,WAAW,SAAS,QAAQ,GAAG,CAAC;AAC3C,SAAS,aAAa,eAAe;AAC3C,WAAS,CAAC,IAAI;AACd,MAAI,aAAa,QAAS,QAAQ,CAAC,IAAI,QAAS,IAAM,QAAQ,CAAC,KAAK,CAAE;AACtE,UAAS,aAAa,iBAAiB,gBAAgB,IAAI,MAAM,SAAU,KAAK;AACjF;;;ACpqCA,IAAI;AACJ,IAAI;AACH,gBAAc,IAAI,YAAY;AAC/B,SAAS,OAAO;AAAC;AACjB,IAAI;AAAJ,IAAgB;AAChB,IAAM,gBAAgB,OAAO,WAAW;AACxC,IAAM,oBAAoB,gBACzB,SAAS,QAAQ;AAAE,SAAO,OAAO,gBAAgB,MAAM;AAAE,IAAI;AAC9D,IAAM,YAAY,gBAAgB,SAAS;AAC3C,IAAM,kBAAkB,gBAAgB,aAAc;AACtD,IAAI;AAAJ,IAAY;AACZ,IAAI;AACJ,IAAIC,YAAW;AACf,IAAI;AACJ,IAAIC,kBAAiB;AACrB,IAAI;AACJ,IAAM,kBAAkB;AACxB,IAAM,cAAc;AACb,IAAM,gBAAgB,OAAO,WAAW;AACxC,IAAM,QAAN,cAAoB,QAAQ;AAAA,EAClC,YAAYC,UAAS;AACpB,UAAMA,QAAO;AACb,SAAK,SAAS;AACd,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAIC;AACJ,QAAI,aAAa,UAAU,UAAU,YAAY,SAAS,QAAQH,WAAU;AAC3E,aAAO,OAAO,UAAU,QAAQA,WAAU,OAAO,aAAaA,SAAQ;AAAA,IACvE,IAAK,eAAe,YAAY,aAC/B,SAAS,QAAQA,WAAU;AAC1B,aAAO,YAAY,WAAW,QAAQ,OAAO,SAASA,SAAQ,CAAC,EAAE;AAAA,IAClE,IAAI;AAEL,QAAI,QAAQ;AACZ,QAAI,CAACE;AACJ,MAAAA,WAAU,CAAC;AACZ,QAAI,eAAeA,YAAWA,SAAQ;AACtC,QAAI,sBAAsBA,SAAQ,cAAcA,SAAQ;AACxD,QAAI,sBAAsBA,SAAQ;AAClC,QAAI,uBAAuB;AAC1B,4BAAsB,sBAAsB,KAAK;AAClD,QAAI,sBAAsB;AACzB,YAAM,IAAI,MAAM,oCAAoC;AACrD,QAAIA,SAAQ,mBAAmBA,SAAQ,aAAa,QAAW;AAC9D,WAAK,YAAY;AAAA,IAClB;AACA,QAAI,mBAAmBA,SAAQ;AAC/B,QAAI,oBAAoB;AACvB,yBAAmB,sBAAsB,KAAK;AAC/C,QAAI,CAAC,KAAK,cAAcA,SAAQ,cAAc;AAC7C,WAAK,aAAa,CAAC;AAEpB,QAAI,oBAAoB,sBAAsB,MAAO,mBAAmB,sBAAsB;AAC9F,QAAI,gBAAgB,sBAAsB;AAC1C,QAAI,iBAAiB,sBAAsB,mBAAmB;AAC9D,QAAI,iBAAiB,MAAM;AAC1B,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACvE;AACA,QAAI,oBAAoB,CAAC;AACzB,QAAI,mBAAmB;AACvB,QAAI,uCAAuC;AAE3C,SAAK,OAAO,KAAK,SAAS,SAASE,QAAO,eAAe;AACxD,UAAI,CAAC,QAAQ;AACZ,iBAAS,IAAI,kBAAkB,IAAI;AACnC,qBAAa,OAAO,aAAa,OAAO,WAAW,IAAI,SAAS,OAAO,QAAQ,GAAG,IAAI;AACtF,QAAAJ,YAAW;AAAA,MACZ;AACA,gBAAU,OAAO,SAAS;AAC1B,UAAI,UAAUA,YAAW,MAAO;AAE/B,iBAAS,IAAI,kBAAkB,OAAO,MAAM;AAC5C,qBAAa,OAAO,aAAa,OAAO,WAAW,IAAI,SAAS,OAAO,QAAQ,GAAG,OAAO,MAAM;AAC/F,kBAAU,OAAO,SAAS;AAC1B,QAAAA,YAAW;AAAA,MACZ;AACC,QAAAA,YAAYA,YAAW,IAAK;AAC7B,cAAQA;AACR,UAAI,gBAAgB,oBAAqB,CAAAA,aAAa,gBAAgB;AACtE,MAAAG,gBAAe,MAAM,kBAAkB,oBAAI,IAAI,IAAI;AACnD,UAAI,MAAM,iBAAiB,OAAOC,WAAU,UAAU;AACrD,QAAAH,kBAAiB,CAAC;AAClB,QAAAA,gBAAe,OAAO;AAAA,MACvB;AACC,QAAAA,kBAAiB;AAClB,mBAAa,MAAM;AACnB,UAAI,YAAY;AACf,YAAI,WAAW;AACd,uBAAa,MAAM,iBAAiB,MAAM,cAAc,CAAC;AAC1D,YAAI,eAAe,WAAW,gBAAgB;AAC9C,YAAI,eAAe,qBAAqB;AAEvC,gBAAM,IAAI,MAAM,uGAAuG,WAAW,YAAY;AAAA,QAC/I;AACA,YAAI,CAAC,WAAW,aAAa;AAE5B,qBAAW,cAAc,uBAAO,OAAO,IAAI;AAC3C,mBAAS,IAAI,GAAG,IAAI,cAAc,KAAK;AACtC,gBAAI,OAAO,WAAW,CAAC;AACvB,gBAAI,CAAC;AACJ;AACD,gBAAI,gBAAgB,aAAa,WAAW;AAC5C,qBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC5C,kBAAI,MAAM,KAAK,CAAC;AAChB,+BAAiB,WAAW,GAAG;AAC/B,kBAAI,CAAC,gBAAgB;AACpB,iCAAiB,WAAW,GAAG,IAAI,uBAAO,OAAO,IAAI;AAAA,cACtD;AACA,2BAAa;AAAA,YACd;AACA,uBAAW,aAAa,IAAI,IAAI;AAAA,UACjC;AACA,eAAK,4BAA4B;AAAA,QAClC;AACA,YAAI,CAAC,cAAc;AAClB,qBAAW,SAAS,eAAe;AAAA,QACpC;AAAA,MACD;AACA,UAAI;AACH,0BAAkB;AACnB,UAAI;AACJ,UAAI;AACH,YAAI,MAAM,yBAAyBG,UAASA,OAAM,eAAeA,OAAM,gBAAgB;AACtF,sBAAYA,MAAK;AAAA;AAEjB,UAAAC,MAAKD,MAAK;AACX,YAAI,aAAaH;AACjB,YAAIA;AACH,uBAAa,OAAOI,OAAM,CAAC;AAC5B,YAAIF,iBAAgBA,cAAa,aAAa;AAC7C,cAAI,cAAcA,cAAa,YAAY,KAAK,CAAC,GAAG,MAAM,EAAE,SAAS,EAAE,SAAS,IAAI,EAAE;AACtF,cAAI,IAAI,YAAY;AACpB,cAAI,oBAAoB;AACxB,iBAAO,cAAc,IAAI,GAAG;AAC3B,gBAAI,iBAAiB,YAAY,EAAE,CAAC,EAAE,SAAS;AAC/C,gBAAI,iBAAkB,WAAW,kBAAkB,SAAU,sBAAsB;AAClF,kCAAoB;AACrB,gBAAI,iBAAkB,WAAW,WAAW,OAAQ;AACnD,kBAAI,qBAAqB;AACxB,qCAAqB;AAAA,YACvB,OAAO;AACN,kBAAI,qBAAqB,GAAG;AAE3B,2BAAW;AAAA,kBAAU,WAAW,WAAW;AAAA,kBAC1C,WAAW,UAAU,WAAW,WAAW,KAAK,IAAI;AAAA,gBAAiB;AACtE,oCAAoB;AAAA,cACrB;AACA,2BAAa,WAAW;AACxB;AAAA,YACD;AAAA,UACD;AACA,cAAI,qBAAqB,KAAK,YAAY;AAEzC,uBAAW;AAAA,cAAU,WAAW,WAAW;AAAA,cAC1C,WAAW,UAAU,WAAW,WAAW,KAAK,IAAI;AAAA,YAAiB;AAAA,UACvE;AACA,UAAAH,aAAY,YAAY,SAAS;AACjC,cAAIA,YAAW;AACd,qBAASA,SAAQ;AAClB,gBAAM,SAASA;AACf,cAAI,aAAa,UAAU,OAAO,SAAS,OAAOA,SAAQ,GAAG,WAAW;AACxE,UAAAG,gBAAe;AACf,iBAAO;AAAA,QACR;AACA,cAAM,SAASH;AACf,YAAI,gBAAgB,mBAAmB;AACtC,iBAAO,QAAQ;AACf,iBAAO,MAAMA;AACb,iBAAO;AAAA,QACR;AACA,eAAO,OAAO,SAAS,OAAOA,SAAQ;AAAA,MACvC,SAAQ,OAAO;AACd,wBAAgB;AAChB,cAAM;AAAA,MACP,UAAE;AACD,YAAI,YAAY;AACf,0BAAgB;AAChB,cAAI,mBAAmB,MAAM,gBAAgB;AAC5C,gBAAI,eAAe,WAAW,gBAAgB;AAE9C,gBAAI,eAAe,OAAO,SAAS,OAAOA,SAAQ;AAClD,gBAAI,gBAAgB,kBAAkB,YAAY,KAAK;AACvD,gBAAI,CAAC,eAAe;AACnB,kBAAI,MAAM,eAAe,eAAe,cAAc,YAAY,MAAM,OAAO;AAE9E,uBAAO,MAAM,KAAKI,QAAO,aAAa;AAAA,cACvC;AACA,oBAAM,4BAA4B;AAElC,kBAAI,OAAO,SAAS,WAAY,UAAS;AACzC,qBAAO;AAAA,YACR;AAAA,UACD;AAAA,QACD;AAEA,YAAI,OAAO,SAAS,WAAY,UAAS;AACzC,YAAI,gBAAgB;AACnB,UAAAJ,YAAW;AAAA,MACb;AAAA,IACD;AACA,UAAM,kBAAkB,MAAM;AAC7B,UAAI,uCAAuC;AAC1C;AACD,UAAI,eAAe,WAAW,gBAAgB;AAC9C,UAAI,WAAW,SAAS,gBAAgB,CAAC;AACxC,mBAAW,SAAS;AACrB,UAAI,mBAAmB,KAAO;AAE7B,mBAAW,cAAc;AACzB,+CAAuC;AACvC,2BAAmB;AACnB,YAAI,kBAAkB,SAAS;AAC9B,8BAAoB,CAAC;AAAA,MACvB,WAAW,kBAAkB,SAAS,KAAK,CAAC,cAAc;AACzD,iBAAS,IAAI,GAAG,IAAI,kBAAkB,QAAQ,IAAI,GAAG,KAAK;AACzD,4BAAkB,CAAC,EAAE,aAAa,IAAI;AAAA,QACvC;AACA,4BAAoB,CAAC;AAAA,MACtB;AAAA,IACD;AACA,UAAM,YAAY,CAACI,WAAU;AAC5B,UAAI,SAASA,OAAM;AACnB,UAAI,SAAS,IAAM;AAClB,eAAOJ,WAAU,IAAI,MAAO;AAAA,MAC7B,WAAW,SAAS,OAAS;AAC5B,eAAOA,WAAU,IAAI;AACrB,eAAOA,WAAU,IAAI,UAAU;AAC/B,eAAOA,WAAU,IAAI,SAAS;AAAA,MAC/B,OAAO;AACN,eAAOA,WAAU,IAAI;AACrB,mBAAW,UAAUA,WAAU,MAAM;AACrC,QAAAA,aAAY;AAAA,MACb;AACA,eAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,QAAAK,MAAKD,OAAM,CAAC,CAAC;AAAA,MACd;AAAA,IACD;AACA,UAAMC,QAAO,CAACD,WAAU;AACvB,UAAIJ,YAAW;AACd,iBAAS,SAASA,SAAQ;AAE3B,UAAI,OAAO,OAAOI;AAClB,UAAI;AACJ,UAAI,SAAS,UAAU;AACtB,YAAI,YAAYA,OAAM;AACtB,YAAIH,mBAAkB,aAAa,KAAK,YAAY,MAAQ;AAC3D,eAAKA,gBAAe,QAAQ,aAAa,iBAAiB;AACzD,gBAAI;AACJ,gBAAIK,aAAYL,gBAAe,CAAC,IAAIA,gBAAe,CAAC,EAAE,SAAS,IAAIA,gBAAe,CAAC,EAAE,SAAS,KAAK;AACnG,gBAAID,YAAWM,YAAW;AACzB,uBAAS,SAASN,YAAWM,SAAQ;AACtC,gBAAI;AACJ,gBAAIL,gBAAe,UAAU;AAC5B,2BAAaA;AACb,qBAAOD,SAAQ,IAAI;AACnB,cAAAA,aAAY;AACZ,qBAAOA,WAAU,IAAI;AACrB,yBAAWA,YAAW;AACtB,cAAAA,aAAY;AACZ,2BAAa,OAAOK,OAAM,CAAC;AAC3B,yBAAW,UAAU,WAAW,QAAQ,GAAGL,YAAW,QAAQ,QAAQ;AAAA,YACvE,OAAO;AACN,qBAAOA,WAAU,IAAI;AACrB,qBAAOA,WAAU,IAAI;AACrB,yBAAWA,YAAW;AACtB,cAAAA,aAAY;AAAA,YACb;AACA,YAAAC,kBAAiB,CAAC,IAAI,EAAE;AACxB,YAAAA,gBAAe,WAAW;AAC1B,YAAAA,gBAAe,OAAO;AACtB,YAAAA,gBAAe,WAAW;AAAA,UAC3B;AACA,cAAI,UAAU,YAAY,KAAKG,MAAK;AACpC,UAAAH,gBAAe,UAAU,IAAI,CAAC,KAAKG;AACnC,iBAAOJ,WAAU,IAAI;AACrB,UAAAK,MAAK,UAAU,CAAC,YAAY,SAAS;AACrC;AAAA,QACD;AACA,YAAI;AAEJ,YAAI,YAAY,IAAM;AACrB,uBAAa;AAAA,QACd,WAAW,YAAY,KAAO;AAC7B,uBAAa;AAAA,QACd,WAAW,YAAY,OAAS;AAC/B,uBAAa;AAAA,QACd,OAAO;AACN,uBAAa;AAAA,QACd;AACA,YAAI,WAAW,YAAY;AAC3B,YAAIL,YAAW,WAAW;AACzB,mBAAS,SAASA,YAAW,QAAQ;AAEtC,YAAI,YAAY,MAAQ,CAAC,YAAY;AACpC,cAAI,GAAG,IAAI,IAAI,cAAcA,YAAW;AACxC,eAAK,IAAI,GAAG,IAAI,WAAW,KAAK;AAC/B,iBAAKI,OAAM,WAAW,CAAC;AACvB,gBAAI,KAAK,KAAM;AACd,qBAAO,aAAa,IAAI;AAAA,YACzB,WAAW,KAAK,MAAO;AACtB,qBAAO,aAAa,IAAI,MAAM,IAAI;AAClC,qBAAO,aAAa,IAAI,KAAK,KAAO;AAAA,YACrC,YACE,KAAK,WAAY,WAChB,KAAKA,OAAM,WAAW,IAAI,CAAC,KAAK,WAAY,OAC7C;AACD,mBAAK,UAAY,KAAK,SAAW,OAAO,KAAK;AAC7C;AACA,qBAAO,aAAa,IAAI,MAAM,KAAK;AACnC,qBAAO,aAAa,IAAI,MAAM,KAAK,KAAO;AAC1C,qBAAO,aAAa,IAAI,MAAM,IAAI,KAAO;AACzC,qBAAO,aAAa,IAAI,KAAK,KAAO;AAAA,YACrC,OAAO;AACN,qBAAO,aAAa,IAAI,MAAM,KAAK;AACnC,qBAAO,aAAa,IAAI,MAAM,IAAI,KAAO;AACzC,qBAAO,aAAa,IAAI,KAAK,KAAO;AAAA,YACrC;AAAA,UACD;AACA,mBAAS,cAAcJ,YAAW;AAAA,QACnC,OAAO;AACN,mBAAS,WAAWI,QAAOJ,YAAW,UAAU;AAAA,QACjD;AAEA,YAAI,SAAS,IAAM;AAClB,iBAAOA,WAAU,IAAI,MAAO;AAAA,QAC7B,WAAW,SAAS,KAAO;AAC1B,cAAI,aAAa,GAAG;AACnB,mBAAO,WAAWA,YAAW,GAAGA,YAAW,GAAGA,YAAW,IAAI,MAAM;AAAA,UACpE;AACA,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AAAA,QACtB,WAAW,SAAS,OAAS;AAC5B,cAAI,aAAa,GAAG;AACnB,mBAAO,WAAWA,YAAW,GAAGA,YAAW,GAAGA,YAAW,IAAI,MAAM;AAAA,UACpE;AACA,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI,UAAU;AAC/B,iBAAOA,WAAU,IAAI,SAAS;AAAA,QAC/B,OAAO;AACN,cAAI,aAAa,GAAG;AACnB,mBAAO,WAAWA,YAAW,GAAGA,YAAW,GAAGA,YAAW,IAAI,MAAM;AAAA,UACpE;AACA,iBAAOA,WAAU,IAAI;AACrB,qBAAW,UAAUA,WAAU,MAAM;AACrC,UAAAA,aAAY;AAAA,QACb;AACA,QAAAA,aAAY;AAAA,MACb,WAAW,SAAS,UAAU;AAC7B,YAAII,WAAU,MAAMA,QAAO;AAE1B,cAAIA,SAAQ,MAASA,SAAQ,OAAQ,KAAK,eAAe,SAAWA,SAAQ,MAAQ,CAAC,KAAK,uBAAwB;AACjH,mBAAOJ,WAAU,IAAII;AAAA,UACtB,WAAWA,SAAQ,KAAO;AACzB,mBAAOJ,WAAU,IAAI;AACrB,mBAAOA,WAAU,IAAII;AAAA,UACtB,WAAWA,SAAQ,OAAS;AAC3B,mBAAOJ,WAAU,IAAI;AACrB,mBAAOA,WAAU,IAAII,UAAS;AAC9B,mBAAOJ,WAAU,IAAII,SAAQ;AAAA,UAC9B,OAAO;AACN,mBAAOJ,WAAU,IAAI;AACrB,uBAAW,UAAUA,WAAUI,MAAK;AACpC,YAAAJ,aAAY;AAAA,UACb;AAAA,QACD,WAAWI,UAAS,MAAMA,QAAO;AAChC,cAAIA,UAAS,KAAO;AACnB,mBAAOJ,WAAU,IAAI,MAAQI;AAAA,UAC9B,WAAWA,UAAS,MAAO;AAC1B,mBAAOJ,WAAU,IAAI;AACrB,mBAAOA,WAAU,IAAII,SAAQ;AAAA,UAC9B,WAAWA,UAAS,QAAS;AAC5B,mBAAOJ,WAAU,IAAI;AACrB,uBAAW,SAASA,WAAUI,MAAK;AACnC,YAAAJ,aAAY;AAAA,UACb,OAAO;AACN,mBAAOA,WAAU,IAAI;AACrB,uBAAW,SAASA,WAAUI,MAAK;AACnC,YAAAJ,aAAY;AAAA,UACb;AAAA,QACD,OAAO;AACN,cAAI;AACJ,eAAK,aAAa,KAAK,cAAc,KAAKI,SAAQ,cAAeA,UAAS,aAAa;AACtF,mBAAOJ,WAAU,IAAI;AACrB,uBAAW,WAAWA,WAAUI,MAAK;AACrC,gBAAI;AACJ,gBAAI,aAAa;AAAA,aAEb,WAAWA,SAAQ,QAAS,OAAOJ,SAAQ,IAAI,QAAS,IAAM,OAAOA,YAAW,CAAC,KAAK,CAAE,MAAM,MAAO,UAAU;AAClH,cAAAA,aAAY;AACZ;AAAA,YACD;AACC,cAAAA;AAAA,UACF;AACA,iBAAOA,WAAU,IAAI;AACrB,qBAAW,WAAWA,WAAUI,MAAK;AACrC,UAAAJ,aAAY;AAAA,QACb;AAAA,MACD,WAAW,SAAS,YAAY,SAAS,YAAY;AACpD,YAAI,CAACI;AACJ,iBAAOJ,WAAU,IAAI;AAAA,aACjB;AACJ,cAAIG,eAAc;AACjB,gBAAI,UAAUA,cAAa,IAAIC,MAAK;AACpC,gBAAI,SAAS;AACZ,kBAAI,CAAC,QAAQ,IAAI;AAChB,oBAAI,cAAcD,cAAa,gBAAgBA,cAAa,cAAc,CAAC;AAC3E,wBAAQ,KAAK,YAAY,KAAK,OAAO;AAAA,cACtC;AACA,qBAAOH,WAAU,IAAI;AACrB,qBAAOA,WAAU,IAAI;AACrB,yBAAW,UAAUA,WAAU,QAAQ,EAAE;AACzC,cAAAA,aAAY;AACZ;AAAA,YACD;AACC,cAAAG,cAAa,IAAIC,QAAO,EAAE,QAAQJ,YAAW,MAAM,CAAC;AAAA,UACtD;AACA,cAAI,cAAcI,OAAM;AACxB,cAAI,gBAAgB,QAAQ;AAC3B,wBAAYA,MAAK;AAAA,UAClB,WAAW,gBAAgB,OAAO;AACjC,sBAAUA,MAAK;AAAA,UAChB,WAAW,gBAAgB,KAAK;AAC/B,gBAAI,KAAK,iBAAkB,QAAOJ,WAAU,IAAI;AAAA,iBAC3C;AACJ,uBAASI,OAAM;AACf,kBAAI,SAAS,IAAM;AAClB,uBAAOJ,WAAU,IAAI,MAAO;AAAA,cAC7B,WAAW,SAAS,OAAS;AAC5B,uBAAOA,WAAU,IAAI;AACrB,uBAAOA,WAAU,IAAI,UAAU;AAC/B,uBAAOA,WAAU,IAAI,SAAS;AAAA,cAC/B,OAAO;AACN,uBAAOA,WAAU,IAAI;AACrB,2BAAW,UAAUA,WAAU,MAAM;AACrC,gBAAAA,aAAY;AAAA,cACb;AACA,uBAAS,CAAC,KAAK,UAAU,KAAKI,QAAO;AACpC,gBAAAC,MAAK,GAAG;AACR,gBAAAA,MAAK,UAAU;AAAA,cAChB;AAAA,YACD;AAAA,UACD,OAAO;AACN,qBAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,IAAI,GAAG,KAAK;AAClD,kBAAI,iBAAiB,iBAAiB,CAAC;AACvC,kBAAID,kBAAiB,gBAAgB;AACpC,oBAAI,YAAY,WAAW,CAAC;AAC5B,oBAAI,UAAU,OAAO;AACpB,sBAAI,UAAU,MAAM;AACnB,2BAAOJ,WAAU,IAAI;AACrB,2BAAOA,WAAU,IAAI,UAAU;AAC/B,2BAAOA,WAAU,IAAI;AAAA,kBACtB;AACA,sBAAI,cAAc,UAAU,MAAM,KAAK,MAAMI,MAAK;AAClD,sBAAI,gBAAgBA,QAAO;AAC1B,wBAAI,MAAM,QAAQA,MAAK,GAAG;AACzB,gCAAUA,MAAK;AAAA,oBAChB,OAAO;AACN,kCAAYA,MAAK;AAAA,oBAClB;AAAA,kBACD,OAAO;AACN,oBAAAC,MAAK,WAAW;AAAA,kBACjB;AACA;AAAA,gBACD;AACA,oBAAI,gBAAgB;AACpB,oBAAI,oBAAoB;AACxB,oBAAI,kBAAkBL;AACtB,yBAAS;AACT,oBAAI;AACJ,oBAAI;AACH,2BAAS,UAAU,KAAK,KAAK,MAAMI,QAAO,CAAC,SAAS;AAEnD,6BAAS;AACT,oCAAgB;AAChB,oBAAAJ,aAAY;AACZ,wBAAIA,YAAW;AACd,+BAASA,SAAQ;AAClB,2BAAO;AAAA,sBACN;AAAA,sBAAQ;AAAA,sBAAY,UAAUA,YAAW;AAAA,oBAC1C;AAAA,kBACD,GAAGK,KAAI;AAAA,gBACR,UAAE;AAED,sBAAI,eAAe;AAClB,6BAAS;AACT,iCAAa;AACb,oBAAAL,YAAW;AACX,8BAAU,OAAO,SAAS;AAAA,kBAC3B;AAAA,gBACD;AACA,oBAAI,QAAQ;AACX,sBAAI,OAAO,SAASA,YAAW;AAC9B,6BAAS,OAAO,SAASA,SAAQ;AAClC,kBAAAA,YAAW,mBAAmB,QAAQ,QAAQA,WAAU,UAAU,IAAI;AAAA,gBACvE;AACA;AAAA,cACD;AAAA,YACD;AAEA,gBAAI,MAAM,QAAQI,MAAK,GAAG;AACzB,wBAAUA,MAAK;AAAA,YAChB,OAAO;AAEN,kBAAIA,OAAM,QAAQ;AACjB,sBAAMG,QAAOH,OAAM,OAAO;AAE1B,oBAAIG,UAASH;AACZ,yBAAOC,MAAKE,KAAI;AAAA,cAClB;AAGA,kBAAI,SAAS;AACZ,uBAAOF,MAAK,KAAK,iBAAiB,KAAK,cAAcD,MAAK,CAAC;AAG5D,0BAAYA,MAAK;AAAA,YAClB;AAAA,UACD;AAAA,QACD;AAAA,MACD,WAAW,SAAS,WAAW;AAC9B,eAAOJ,WAAU,IAAII,SAAQ,MAAO;AAAA,MACrC,WAAW,SAAS,UAAU;AAC7B,YAAIA,SAAQ,sBAAsBA,UAAS,qBAAqB;AAE/D,iBAAOJ,WAAU,IAAI;AACrB,qBAAW,YAAYA,WAAUI,MAAK;AAAA,QACvC,WAAWA,SAAQ,uBAAuBA,SAAQ,GAAG;AAEpD,iBAAOJ,WAAU,IAAI;AACrB,qBAAW,aAAaA,WAAUI,MAAK;AAAA,QACxC,OAAO;AAEN,cAAI,KAAK,oBAAoB;AAC5B,mBAAOJ,WAAU,IAAI;AACrB,uBAAW,WAAWA,WAAU,OAAOI,MAAK,CAAC;AAAA,UAC9C,WAAW,KAAK,qBAAqB;AACpC,mBAAOC,MAAKD,OAAM,SAAS,CAAC;AAAA,UAC7B,YAAY,KAAK,sBAAsB,KAAK,cAAcA,SAAQ,OAAO,CAAC,KAAG,OAAO,IAAI,KAAKA,SAAQ,EAAE,OAAO,CAAC,KAAG,OAAO,IAAI,IAAI;AAChI,mBAAOJ,WAAU,IAAI;AACrB,YAAAA;AACA,mBAAOA,WAAU,IAAI;AACrB,gBAAI,QAAQ,CAAC;AACb,gBAAI;AACJ,eAAG;AACF,kBAAI,OAAOI,SAAQ,OAAO,GAAI;AAC9B,6BAAe,OAAO,OAAO,GAAI,QAAQA,SAAQ,OAAO,CAAC,IAAI,OAAO,GAAI,IAAI,OAAO,CAAC;AACpF,oBAAM,KAAK,IAAI;AACf,cAAAA,WAAU,OAAO,CAAC;AAAA,YACnB,SAAS,GAAGA,WAAU,OAAO,CAAC,KAAKA,WAAU,OAAO,EAAE,MAAM;AAC5D,mBAAOJ,YAAS,CAAC,IAAI,MAAM;AAC3B,qBAAS,IAAI,MAAM,QAAQ,IAAI,KAAI;AAClC,qBAAOA,WAAU,IAAI,OAAO,MAAM,EAAE,CAAC,CAAC;AAAA,YACvC;AACA;AAAA,UACD,OAAO;AACN,kBAAM,IAAI,WAAWI,SAAQ,uLAEe;AAAA,UAC7C;AAAA,QACD;AACA,QAAAJ,aAAY;AAAA,MACb,WAAW,SAAS,aAAa;AAChC,YAAI,KAAK;AACR,iBAAOA,WAAU,IAAI;AAAA,aACjB;AACJ,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AAAA,QACtB;AAAA,MACD,OAAO;AACN,cAAM,IAAI,MAAM,mBAAmB,IAAI;AAAA,MACxC;AAAA,IACD;AAEA,UAAM,mBAAoB,KAAK,mBAAmB,KAAK,wBAAwB,KAAK,aAAc,CAAC,WAAW;AAE7G,UAAI;AACJ,UAAI,KAAK,YAAY;AACpB,eAAO,CAAC;AACR,iBAASQ,QAAO,QAAQ;AACvB,eAAK,OAAO,OAAO,mBAAmB,cAAc,OAAO,eAAeA,IAAG,MAC5E,CAAC,KAAK,WAAW,SAAS,OAAOA,IAAG,CAAC;AACrC,iBAAK,KAAKA,IAAG;AAAA,QACf;AAAA,MACD,OAAO;AACN,eAAO,OAAO,KAAK,MAAM;AAAA,MAC1B;AACA,UAAI,SAAS,KAAK;AAClB,UAAI,SAAS,IAAM;AAClB,eAAOR,WAAU,IAAI,MAAO;AAAA,MAC7B,WAAW,SAAS,OAAS;AAC5B,eAAOA,WAAU,IAAI;AACrB,eAAOA,WAAU,IAAI,UAAU;AAC/B,eAAOA,WAAU,IAAI,SAAS;AAAA,MAC/B,OAAO;AACN,eAAOA,WAAU,IAAI;AACrB,mBAAW,UAAUA,WAAU,MAAM;AACrC,QAAAA,aAAY;AAAA,MACb;AACA,UAAI;AACJ,UAAI,KAAK,sBAAsB;AAC9B,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,gBAAM,KAAK,CAAC;AACZ,cAAI,MAAM,OAAO,GAAG;AACpB,UAAAK,MAAK,MAAM,GAAG,IAAI,MAAM,GAAG;AAC3B,UAAAA,MAAK,OAAO,GAAG,CAAC;AAAA,QACjB;AAAA,MAED,OAAO;AACN,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,UAAAA,MAAK,MAAM,KAAK,CAAC,CAAC;AAClB,UAAAA,MAAK,OAAO,GAAG,CAAC;AAAA,QACjB;AAAA,MACD;AAAA,IACD,IACA,CAAC,WAAW;AACX,aAAOL,WAAU,IAAI;AACrB,UAAI,eAAeA,YAAW;AAC9B,MAAAA,aAAY;AACZ,UAAI,OAAO;AACX,eAAS,OAAO,QAAQ;AACvB,YAAI,OAAO,OAAO,mBAAmB,cAAc,OAAO,eAAe,GAAG,GAAG;AAC9E,UAAAK,MAAK,GAAG;AACR,UAAAA,MAAK,OAAO,GAAG,CAAC;AAChB;AAAA,QACD;AAAA,MACD;AACA,UAAI,OAAO,OAAQ;AAClB,cAAM,IAAI,MAAM,uHAC4C;AAAA,MAC7D;AACA,aAAO,iBAAiB,KAAK,IAAI,QAAQ;AACzC,aAAO,eAAe,KAAK,IAAI,OAAO;AAAA,IACvC;AAEA,UAAM,cAAc,KAAK,eAAe,QAAQ,mBAC/CH,SAAQ,sBAAsB,CAAC;AAAA;AAAA,MAChC,CAAC,WAAW;AACX,YAAI,gBAAgB,aAAa,WAAW,gBAAgB,WAAW,cAAc,uBAAO,OAAO,IAAI;AACvG,YAAI,eAAeF,cAAa;AAChC,YAAI;AACJ,iBAAS,OAAO,QAAQ;AACvB,cAAI,OAAO,OAAO,mBAAmB,cAAc,OAAO,eAAe,GAAG,GAAG;AAC9E,6BAAiB,WAAW,GAAG;AAC/B,gBAAI;AACH,2BAAa;AAAA,iBACT;AAEJ,kBAAI,OAAO,OAAO,KAAK,MAAM;AAC7B,kBAAI,iBAAiB;AACrB,2BAAa,WAAW;AACxB,kBAAI,iBAAiB;AACrB,uBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,IAAI,GAAG,KAAK;AAC5C,oBAAIQ,OAAM,KAAK,CAAC;AAChB,iCAAiB,WAAWA,IAAG;AAC/B,oBAAI,CAAC,gBAAgB;AACpB,mCAAiB,WAAWA,IAAG,IAAI,uBAAO,OAAO,IAAI;AACrD;AAAA,gBACD;AACA,6BAAa;AAAA,cACd;AACA,kBAAI,eAAe,QAAQ,KAAKR,WAAU;AAEzC,gBAAAA;AACA,0BAAU,YAAY,MAAM,cAAc;AAAA,cAC3C;AACC,gCAAgB,YAAY,MAAM,cAAc,cAAc;AAC/D,0BAAY;AACZ,2BAAa,eAAe,GAAG;AAAA,YAChC;AACA,YAAAK,MAAK,OAAO,GAAG,CAAC;AAAA,UACjB;AAAA,QACD;AACA,YAAI,CAAC,WAAW;AACf,cAAI,WAAW,WAAW,aAAa;AACvC,cAAI;AACH,mBAAO,eAAe,KAAK,IAAI;AAAA;AAE/B,4BAAgB,YAAY,OAAO,KAAK,MAAM,GAAG,cAAc,CAAC;AAAA,QAClE;AAAA,MACD;AAAA,QACA,CAAC,WAAW;AACX,UAAI,gBAAgB,aAAa,WAAW,gBAAgB,WAAW,cAAc,uBAAO,OAAO,IAAI;AACvG,UAAI,iBAAiB;AACrB,eAAS,OAAO,OAAQ,KAAI,OAAO,OAAO,mBAAmB,cAAc,OAAO,eAAe,GAAG,GAAG;AACtG,yBAAiB,WAAW,GAAG;AAC/B,YAAI,CAAC,gBAAgB;AACpB,2BAAiB,WAAW,GAAG,IAAI,uBAAO,OAAO,IAAI;AACrD;AAAA,QACD;AACA,qBAAa;AAAA,MACd;AACA,UAAI,WAAW,WAAW,aAAa;AACvC,UAAI,UAAU;AACb,YAAI,YAAY,MAAQ,mBAAmB;AAC1C,iBAAOL,WAAU,MAAM,YAAY,MAAQ,MAAQ;AACnD,iBAAOA,WAAU,IAAI,YAAY;AAAA,QAClC;AACC,iBAAOA,WAAU,IAAI;AAAA,MACvB,OAAO;AACN,kBAAU,YAAY,WAAW,YAAY,OAAO,KAAK,MAAM,GAAG,cAAc;AAAA,MACjF;AAEA,eAAS,OAAO;AACf,YAAI,OAAO,OAAO,mBAAmB,cAAc,OAAO,eAAe,GAAG,GAAG;AAC9E,UAAAK,MAAK,OAAO,GAAG,CAAC;AAAA,QACjB;AAAA,IACF;AAGA,UAAM,kBAAkB,OAAO,KAAK,cAAc,cAAc,KAAK;AAErE,UAAM,cAAc,kBAAkB,CAAC,WAAW;AACjD,sBAAgB,MAAM,IAAI,YAAY,MAAM,IAAI,iBAAiB,MAAM;AAAA,IACxE,IAAI;AAEJ,UAAM,WAAW,CAAC,QAAQ;AACzB,UAAI;AACJ,UAAI,MAAM,UAAW;AAEpB,YAAK,MAAM,QAAS;AACnB,gBAAM,IAAI,MAAM,wDAAwD;AACzE,kBAAU,KAAK;AAAA,UAAI;AAAA,UAClB,KAAK,MAAM,KAAK,KAAK,MAAM,UAAU,MAAM,WAAY,OAAO,IAAI,OAAQ,IAAI,IAAM,IAAI;AAAA,QAAM;AAAA,MAChG;AACC,mBAAY,KAAK,IAAK,MAAM,SAAU,GAAG,OAAO,SAAS,CAAC,KAAK,MAAM,KAAM;AAC5E,UAAI,YAAY,IAAI,kBAAkB,OAAO;AAC7C,mBAAa,UAAU,aAAa,UAAU,WAAW,IAAI,SAAS,UAAU,QAAQ,GAAG,OAAO;AAClG,YAAM,KAAK,IAAI,KAAK,OAAO,MAAM;AACjC,UAAI,OAAO;AACV,eAAO,KAAK,WAAW,GAAG,OAAO,GAAG;AAAA;AAEpC,kBAAU,IAAI,OAAO,MAAM,OAAO,GAAG,CAAC;AACvC,MAAAL,aAAY;AACZ,cAAQ;AACR,gBAAU,UAAU,SAAS;AAC7B,aAAO,SAAS;AAAA,IACjB;AACA,UAAM,YAAY,CAAC,YAAY,MAAM,mBAAmB;AACvD,UAAI,WAAW,WAAW;AAC1B,UAAI,CAAC;AACJ,mBAAW;AACZ,UAAI,WAAW,iBAAiB,KAAK,wBAAwB,CAAC,KAAK,qBAAqB,IAAI,GAAG;AAC9F,mBAAW,WAAW;AACtB,YAAI,EAAE,WAAW;AAChB,qBAAW;AACZ,mBAAW,YAAY,WAAW;AAAA,MACnC,OAAO;AACN,YAAI,YAAY;AACf,qBAAW;AACZ,mBAAW,SAAS,WAAW;AAAA,MAChC;AACA,UAAI,WAAW,KAAK,WAAW,YAAY,MAAQ,oBAAqB,WAAW,MAAS,IAAI;AAChG,iBAAW,aAAa,IAAI;AAC5B,iBAAW,WAAW;AACtB,iBAAW,WAAW,EAAI,IAAI;AAE9B,UAAI,WAAW,eAAe;AAC7B,aAAK,WAAW;AAChB,mBAAW,eAAe,WAAW;AACrC,0BAAkB;AAClB,YAAI,YAAY,GAAG;AAClB,iBAAOA,WAAU,KAAK,WAAW,MAAQ;AACzC,iBAAOA,WAAU,IAAI;AAAA,QACtB,OAAO;AACN,iBAAOA,WAAU,IAAI;AAAA,QACtB;AAAA,MACD,OAAO;AACN,YAAI,YAAY,GAAG;AAClB,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,KAAK,WAAW,MAAQ;AACzC,iBAAOA,WAAU,IAAI;AAAA,QACtB,OAAO;AACN,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AACrB,iBAAOA,WAAU,IAAI;AAAA,QACtB;AAEA,YAAI;AACH,8BAAoB,uCAAuC;AAE5D,YAAI,kBAAkB,UAAU;AAC/B,4BAAkB,MAAM,EAAE,aAAa,IAAI;AAC5C,0BAAkB,KAAK,UAAU;AACjC,QAAAK,MAAK,IAAI;AAAA,MACV;AAAA,IACD;AACA,UAAM,kBAAkB,CAAC,YAAY,MAAM,iBAAiB,mBAAmB;AAC9E,UAAI,aAAa;AACjB,UAAI,eAAeL;AACnB,UAAI,cAAc;AAClB,UAAI,YAAY;AAChB,eAAS;AACT,MAAAA,YAAW;AACX,cAAQ;AACR,UAAI,CAAC;AACJ,qBAAa,SAAS,IAAI,kBAAkB,IAAI;AACjD,gBAAU,OAAO,SAAS;AAC1B,gBAAU,YAAY,MAAM,cAAc;AAC1C,mBAAa;AACb,UAAI,eAAeA;AACnB,eAAS;AACT,MAAAA,YAAW;AACX,gBAAU;AACV,cAAQ;AACR,UAAI,eAAe,GAAG;AACrB,YAAI,SAASA,YAAW,eAAe;AACvC,YAAI,SAAS;AACZ,mBAAS,MAAM;AAChB,YAAI,oBAAoB,kBAAkB;AAC1C,eAAO,WAAW,oBAAoB,cAAc,oBAAoB,GAAGA,SAAQ;AACnF,eAAO,IAAI,WAAW,MAAM,GAAG,YAAY,GAAG,iBAAiB;AAC/D,QAAAA,YAAW;AAAA,MACZ,OAAO;AACN,eAAO,kBAAkB,KAAK,IAAI,WAAW,CAAC;AAAA,MAC/C;AAAA,IACD;AACA,UAAM,cAAc,CAAC,WAAW;AAC/B,UAAI,cAAc,iBAAiB,QAAQ,QAAQ,OAAOA,WAAU,YAAY,UAAU,CAACI,QAAOK,cAAa,uBAAuB;AACrI,YAAI;AACH,iBAAO,kBAAkB;AAC1B,QAAAT,YAAWS;AACX,YAAI,cAAc;AAClB,QAAAJ,MAAKD,MAAK;AACV,wBAAgB;AAChB,YAAI,gBAAgB,QAAQ;AAC3B,iBAAO,EAAE,UAAAJ,WAAU,YAAY,OAAO;AAAA,QACvC;AACA,eAAOA;AAAA,MACR,GAAG,IAAI;AACP,UAAI,gBAAgB;AACnB,eAAO,YAAY,MAAM;AAC1B,MAAAA,YAAW;AAAA,IACZ;AAAA,EACD;AAAA,EACA,UAAU,QAAQ;AAEjB,aAAS;AACT,WAAO,aAAa,OAAO,WAAW,IAAI,SAAS,OAAO,QAAQ,OAAO,YAAY,OAAO,UAAU;AACtG,IAAAA,YAAW;AAAA,EACZ;AAAA,EACA,IAAI,SAAUI,QAAO;AACpB,IAAAJ,YAAWI;AAAA,EACZ;AAAA,EACA,IAAI,WAAW;AACd,WAAOJ;AAAA,EACR;AAAA,EACA,kBAAkB;AACjB,QAAI,KAAK;AACR,WAAK,aAAa,CAAC;AACpB,QAAI,KAAK;AACR,WAAK,eAAe,CAAC;AAAA,EACvB;AACD;AAEA,mBAAmB,CAAE,MAAM,KAAK,OAAO,QAAQ,aAAa,OAAO,eAAe,WAAW,SAAS,EAAE,aAA4B,UAAU,MAAO;AACrJ,aAAa,CAAC;AAAA,EACb,KAAK,MAAM,kBAAkBK,OAAM;AAClC,QAAIK,WAAU,KAAK,QAAQ,IAAI;AAC/B,SAAK,KAAK,kBAAkB,KAAK,gBAAgB,MAAM,MAAMA,YAAW,KAAKA,WAAU,YAAa;AAEnG,UAAI,EAAE,QAAAC,SAAQ,YAAAC,aAAY,UAAAZ,UAAQ,IAAI,iBAAiB,CAAC;AACxD,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAY,YAAW,UAAUZ,WAAUU,QAAO;AAAA,IACvC,WAAWA,WAAU,KAAKA,WAAU,YAAa;AAEhD,UAAI,EAAE,QAAAC,SAAQ,YAAAC,aAAY,UAAAZ,UAAQ,IAAI,iBAAiB,EAAE;AACzD,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAY,YAAW,UAAUZ,WAAU,KAAK,gBAAgB,IAAI,OAAYU,WAAU,MAAO,cAAgB,EAAE;AACvG,MAAAE,YAAW,UAAUZ,YAAW,GAAGU,QAAO;AAAA,IAC3C,WAAW,MAAMA,QAAO,GAAG;AAC1B,UAAI,KAAK,eAAe;AACvB,yBAAiB,CAAC;AAClB,eAAOL,MAAK,KAAK,cAAc,CAAC;AAAA,MACjC;AAEA,UAAI,EAAE,QAAAM,SAAQ,YAAAC,aAAY,UAAAZ,UAAQ,IAAI,iBAAiB,CAAC;AACxD,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AAAA,IACtB,OAAO;AAEN,UAAI,EAAE,QAAAW,SAAQ,YAAAC,aAAY,UAAAZ,UAAQ,IAAI,iBAAiB,EAAE;AACzD,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAY,YAAW,UAAUZ,WAAU,KAAK,gBAAgB,IAAI,GAAO;AAC/D,MAAAY,YAAW,YAAYZ,YAAW,GAAG,OAAO,KAAK,MAAMU,QAAO,CAAC,CAAC;AAAA,IACjE;AAAA,EACD;AACD,GAAG;AAAA,EACF,KAAKG,MAAK,kBAAkBR,OAAM;AACjC,QAAI,KAAK,kBAAkB;AAC1B,uBAAiB,CAAC;AAClB,aAAOA,MAAK,CAAC,CAAC;AAAA,IACf;AACA,QAAI,QAAQ,MAAM,KAAKQ,IAAG;AAC1B,QAAI,EAAE,QAAAF,SAAQ,UAAAX,UAAQ,IAAI,iBAAiB,KAAK,YAAY,IAAI,CAAC;AACjE,QAAI,KAAK,WAAW;AACnB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AAAA,IACtB;AACA,IAAAK,MAAK,KAAK;AAAA,EACX;AACD,GAAG;AAAA,EACF,KAAK,OAAO,kBAAkBA,OAAM;AACnC,QAAI,EAAE,QAAAM,SAAQ,UAAAX,UAAQ,IAAI,iBAAiB,KAAK,YAAY,IAAI,CAAC;AACjE,QAAI,KAAK,WAAW;AACnB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AAAA,IACtB;AACA,IAAAK,MAAK,CAAE,MAAM,MAAM,MAAM,SAAS,MAAM,KAAM,CAAC;AAAA,EAChD;AACD,GAAG;AAAA,EACF,KAAK,OAAO,kBAAkBA,OAAM;AACnC,QAAI,EAAE,QAAAM,SAAQ,UAAAX,UAAQ,IAAI,iBAAiB,KAAK,YAAY,IAAI,CAAC;AACjE,QAAI,KAAK,WAAW;AACnB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AACrB,MAAAW,QAAOX,WAAU,IAAI;AAAA,IACtB;AACA,IAAAK,MAAK,CAAE,MAAM,QAAQ,MAAM,KAAM,CAAC;AAAA,EACnC;AACD,GAAG;AAAA,EACF,KAAK,aAAa,kBAAkB;AACnC,QAAI,KAAK;AACR,qBAAe,aAAa,IAAM,gBAAgB;AAAA;AAElD,kBAAY,gBAAgB,OAAO,KAAK,WAAW,IAAI,IAAI,WAAW,WAAW,GAAG,gBAAgB;AAAA,EACtG;AACD,GAAG;AAAA,EACF,KAAK,YAAY,kBAAkB;AAClC,QAAI,cAAc,WAAW;AAC7B,QAAI,gBAAgB,aAAa,KAAK;AACrC,qBAAe,YAAY,YAAY,QAAQ,YAAY,IAAI,GAAG,gBAAgB;AAAA;AAElF,kBAAY,YAAY,gBAAgB;AAAA,EAC1C;AACD,GAAG;AAAA,EACF,KAAK,aAAa,kBAAkB;AACnC,QAAI,KAAK;AACR,qBAAe,aAAa,IAAM,gBAAgB;AAAA;AAElD,kBAAY,gBAAgB,OAAO,KAAK,WAAW,IAAI,IAAI,WAAW,WAAW,GAAG,gBAAgB;AAAA,EACtG;AACD,GAAG;AAAA,EACF,KAAK,IAAI,kBAAkB;AAC1B,QAAI,EAAE,QAAAM,SAAQ,UAAAX,UAAQ,IAAI,iBAAiB,CAAC;AAC5C,IAAAW,QAAOX,SAAQ,IAAI;AAAA,EACpB;AACD,CAAC;AAED,SAAS,eAAe,YAAY,MAAM,kBAAkBc,SAAQ;AACnE,MAAI,SAAS,WAAW;AACxB,MAAI,SAAS,IAAI,KAAO;AACvB,QAAI,EAAE,QAAAH,SAAQ,UAAAX,UAAS,IAAI,iBAAiB,IAAI,MAAM;AACtD,IAAAW,QAAOX,WAAU,IAAI;AACrB,IAAAW,QAAOX,WAAU,IAAI,SAAS;AAAA,EAC/B,WAAW,SAAS,IAAI,OAAS;AAChC,QAAI,EAAE,QAAAW,SAAQ,UAAAX,UAAS,IAAI,iBAAiB,IAAI,MAAM;AACtD,IAAAW,QAAOX,WAAU,IAAI;AACrB,IAAAW,QAAOX,WAAU,IAAK,SAAS,KAAM;AACrC,IAAAW,QAAOX,WAAU,IAAK,SAAS,IAAK;AAAA,EACrC,OAAO;AACN,QAAI,EAAE,QAAAW,SAAQ,UAAAX,WAAU,YAAAY,YAAW,IAAI,iBAAiB,IAAI,MAAM;AAClE,IAAAD,QAAOX,WAAU,IAAI;AACrB,IAAAY,YAAW,UAAUZ,WAAU,SAAS,CAAC;AACzC,IAAAA,aAAY;AAAA,EACb;AACA,EAAAW,QAAOX,WAAU,IAAI;AACrB,EAAAW,QAAOX,WAAU,IAAI;AACrB,MAAI,CAAC,WAAW,OAAQ,cAAa,IAAI,WAAW,UAAU;AAC9D,EAAAW,QAAO,IAAI,IAAI,WAAW,WAAW,QAAQ,WAAW,YAAY,WAAW,UAAU,GAAGX,SAAQ;AACrG;AACA,SAAS,YAAY,QAAQ,kBAAkB;AAC9C,MAAI,SAAS,OAAO;AACpB,MAAIW,SAAQX;AACZ,MAAI,SAAS,KAAO;AACnB,QAAI,EAAE,QAAAW,SAAQ,UAAAX,UAAS,IAAI,iBAAiB,SAAS,CAAC;AACtD,IAAAW,QAAOX,WAAU,IAAI;AACrB,IAAAW,QAAOX,WAAU,IAAI;AAAA,EACtB,WAAW,SAAS,OAAS;AAC5B,QAAI,EAAE,QAAAW,SAAQ,UAAAX,UAAS,IAAI,iBAAiB,SAAS,CAAC;AACtD,IAAAW,QAAOX,WAAU,IAAI;AACrB,IAAAW,QAAOX,WAAU,IAAI,UAAU;AAC/B,IAAAW,QAAOX,WAAU,IAAI,SAAS;AAAA,EAC/B,OAAO;AACN,QAAI,EAAE,QAAAW,SAAQ,UAAAX,WAAU,YAAAY,YAAW,IAAI,iBAAiB,SAAS,CAAC;AAClE,IAAAD,QAAOX,WAAU,IAAI;AACrB,IAAAY,YAAW,UAAUZ,WAAU,MAAM;AACrC,IAAAA,aAAY;AAAA,EACb;AACA,EAAAW,QAAO,IAAI,QAAQX,SAAQ;AAC5B;AAEA,SAAS,mBAAmB,QAAQW,SAAQX,WAAU,MAAM;AAC3D,MAAI,SAAS,OAAO;AACpB,UAAQ,QAAQ;AAAA,IACf,KAAK;AACJ,MAAAW,QAAOX,WAAU,IAAI;AACrB;AAAA,IACD,KAAK;AACJ,MAAAW,QAAOX,WAAU,IAAI;AACrB;AAAA,IACD,KAAK;AACJ,MAAAW,QAAOX,WAAU,IAAI;AACrB;AAAA,IACD,KAAK;AACJ,MAAAW,QAAOX,WAAU,IAAI;AACrB;AAAA,IACD,KAAK;AACJ,MAAAW,QAAOX,WAAU,IAAI;AACrB;AAAA,IACD;AACC,UAAI,SAAS,KAAO;AACnB,QAAAW,QAAOX,WAAU,IAAI;AACrB,QAAAW,QAAOX,WAAU,IAAI;AAAA,MACtB,WAAW,SAAS,OAAS;AAC5B,QAAAW,QAAOX,WAAU,IAAI;AACrB,QAAAW,QAAOX,WAAU,IAAI,UAAU;AAC/B,QAAAW,QAAOX,WAAU,IAAI,SAAS;AAAA,MAC/B,OAAO;AACN,QAAAW,QAAOX,WAAU,IAAI;AACrB,QAAAW,QAAOX,WAAU,IAAI,UAAU;AAC/B,QAAAW,QAAOX,WAAU,IAAK,UAAU,KAAM;AACtC,QAAAW,QAAOX,WAAU,IAAK,UAAU,IAAK;AACrC,QAAAW,QAAOX,WAAU,IAAI,SAAS;AAAA,MAC/B;AAAA,EACF;AACA,EAAAW,QAAOX,WAAU,IAAI;AACrB,EAAAW,QAAO,IAAI,QAAQX,SAAQ;AAC3B,EAAAA,aAAY;AACZ,SAAOA;AACR;AAEA,SAAS,UAAU,YAAY,aAAa;AAE3C,MAAI;AACJ,MAAI,iBAAiB,YAAY,SAAS;AAC1C,MAAI,UAAU,WAAW,SAAS;AAClC,SAAO,SAAS,YAAY,IAAI,GAAG;AAClC,QAAI,SAAS,OAAO;AACpB,QAAI,KAAK,OAAO;AAChB,eAAW,WAAW,SAAS,gBAAgB,QAAQ,OAAO;AAC9D,sBAAkB;AAClB,QAAIA,YAAW,SAAS;AACxB,eAAWA,WAAU,IAAI;AACzB,eAAWA,WAAU,IAAI;AACzB,eAAWA,WAAU,IAAI,MAAM;AAC/B,eAAWA,WAAU,IAAK,MAAM,KAAM;AACtC,eAAWA,WAAU,IAAK,MAAM,IAAK;AACrC,eAAWA,WAAU,IAAI,KAAK;AAC9B,cAAU;AAAA,EACX;AACA,SAAO;AACR;AAEA,SAAS,aAAa,OAAOK,OAAM,mBAAmB;AACrD,MAAIJ,gBAAe,SAAS,GAAG;AAC9B,eAAW,UAAUA,gBAAe,WAAW,OAAOD,YAAW,oBAAoBC,gBAAe,WAAW,KAAK;AACpH,IAAAA,gBAAe,kBAAkBD,YAAW;AAC5C,QAAI,eAAeC;AACnB,IAAAA,kBAAiB;AACjB,IAAAI,MAAK,aAAa,CAAC,CAAC;AACpB,IAAAA,MAAK,aAAa,CAAC,CAAC;AAAA,EACrB;AACD;AAEO,SAASU,cAAa,WAAW;AACvC,MAAI,UAAU,OAAO;AACpB,QAAI,CAAC,UAAU,QAAQ,CAAC,UAAU;AACjC,YAAM,IAAI,MAAM,yCAAyC;AAC1D,QAAI,UAAU,QAAQ,CAAC,UAAU;AAChC,YAAM,IAAI,MAAM,gEAAgE;AACjF,qBAAiB,QAAQ,UAAU,KAAK;AACxC,eAAW,QAAQ,SAAS;AAAA,EAC7B;AACA,eAAmB,SAAS;AAC7B;AACA,SAAS,kBAAkB,YAAY,OAAO;AAC7C,aAAW,eAAe,CAAC,uBAAuB;AACjD,QAAI,aAAa,CAAC,uBAAwB,MAAM,6BAA6B,OAAO,mBAAmB;AACvG,QAAI,CAAC;AACJ,YAAM,iBAAiB,kBAAkB;AAC1C,WAAO;AAAA,EACR;AACA,SAAO;AACR;AAMA,IAAI,eAAe,IAAI,MAAM,EAAE,YAAY,MAAM,CAAC;AAC3C,IAAM,OAAO,aAAa;AAC1B,IAAMC,UAAS,aAAa;AAC5B,IAAM,UAAU;AAGhB,IAAM,EAAE,OAAO,QAAQ,eAAe,YAAY,IAAI;AACtD,IAAM,oBAAoB;AAC1B,IAAM,oBAAoB;AAC1B,IAAM,sBAAsB;;;AC5kC5B,SAAS,SAAU,gBAAgBC,WAAU,CAAC,GAAG;AACtD,MAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;AACzD,UAAM,IAAI,MAAM,wFAAwF;AAAA,EAC1G,WAAW,OAAO,eAAe,OAAO,QAAQ,MAAM,YAAY;AAChE,WAAO,aAAa,gBAAgBA,QAAO;AAAA,EAC7C,WAAW,OAAO,eAAe,SAAS,cAAc,OAAO,eAAe,OAAO,aAAa,MAAM,YAAY;AAClH,WAAO,cAAc,gBAAgBA,QAAO;AAAA,EAC9C,OAAO;AACL,UAAM,IAAI,MAAM,4FAA4F;AAAA,EAC9G;AACF;AAEA,UAAW,aAAc,gBAAgBA,UAAS;AAChD,QAAM,QAAQ,IAAI,MAAMA,QAAO;AAC/B,aAAWC,UAAS,gBAAgB;AAClC,UAAM,MAAM,KAAKA,MAAK;AAAA,EACxB;AACF;AAEA,gBAAiB,cAAe,gBAAgBD,UAAS;AACvD,QAAM,QAAQ,IAAI,MAAMA,QAAO;AAC/B,mBAAiBC,UAAS,gBAAgB;AACxC,UAAM,MAAM,KAAKA,MAAK;AAAA,EACxB;AACF;AASO,SAAS,WAAY,gBAAgBD,WAAU,CAAC,GAAG;AACxD,MAAI,CAAC,kBAAkB,OAAO,mBAAmB,UAAU;AACzD,UAAM,IAAI,MAAM,4FAA4F;AAAA,EAC9G;AAEA,QAAM,UAAU,IAAI,QAAQA,QAAO;AACnC,MAAI;AACJ,QAAM,SAAS,CAAC,UAAU;AACxB,QAAI;AAEJ,QAAI,YAAY;AACd,cAAQ,OAAO,OAAO,CAAC,YAAY,KAAK,CAAC;AACzC,mBAAa;AAAA,IACf;AAEA,QAAI;AACF,eAAS,QAAQ,eAAe,KAAK;AAAA,IACvC,SAAS,KAAK;AACZ,UAAI,IAAI,YAAY;AAClB,qBAAa,MAAM,MAAM,IAAI,YAAY;AACzC,iBAAS,IAAI;AAAA,MACf,OAAO;AACL,cAAM;AAAA,MACR;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAEA,MAAI,OAAO,eAAe,OAAO,QAAQ,MAAM,YAAY;AACzD,WAAQ,UAAW,OAAQ;AACzB,iBAAWC,UAAS,gBAAgB;AAClC,eAAQ,OAAOA,MAAK;AAAA,MACtB;AAAA,IACF,EAAG;AAAA,EACL,WAAW,OAAO,eAAe,OAAO,aAAa,MAAM,YAAY;AACrE,WAAQ,gBAAiB,OAAQ;AAC/B,uBAAiBA,UAAS,gBAAgB;AACxC,eAAQ,OAAOA,MAAK;AAAA,MACtB;AAAA,IACF,EAAG;AAAA,EACL;AACF;AACO,IAAM,aAAa;AACnB,IAAM,aAAa;;;AHnFnB,IAAM,aAAa;AACnB,IAAM,gBAAgB;;;ADwBtB,IAAMC,eAA6BC,OAAOC,IAAI,uCAAuC;AAYtF,IAAOC,eAAP,cAAiCC,YAAY,cAAc,EAG/D;;;;EAIS,CAACJ,YAAW,IAAiBA;;;;EAKtC,IAAIK,UAAO;AACT,WAAO,KAAKC;EACd;;AAOK,IAAMC,QAAOA,MAQVC,SAAQ,MAAK;AACnB,QAAMC,QAAQ,IAAIC,MAAK;AACvB,QAAMC,OAEDC,cAAc;IACbC,SAAUC,WACAC,UACEC,SACCC,KAAI;MACTA,KAAKA,MAAYC,GAAGT,MAAMF,KAAWY,gBAAgBL,KAAK,CAAC,CAAC;MAC5DM,OAAQC,WAAU,IAAIlB,aAAa;QAAEG,QAAQ;QAAQe;MAAK,CAAE;KAC7D,GACOC,KAAK,GAEfX,IAAI;IAERY,WAAYF,WAAkBG,WAAUH,KAAK;IAC7CI,QAAgBC;GACjB;AACL,SAAOf;AACT,CAAC;AAMI,IAAMgB,aACXC,CAAAA,YAEF,MAQaC,OAAqBC,QAAOF,OAAM,EAAC,GAAIrB,MAAI,CAAE;AAMnD,IAAMwB,UAASA,MAQZf,SACEgB,MAAK,MAAM,IAAIC,QAAO,CAAE,GAC/BxB,WAAS;AACR,MAAIyB,aAAqCC;AACzC,QAAMJ,UAAUK,CAAAA,WACPnB,KAAI;IACTA,KAAKA,MACGD,QAAQoB,QAAQC,SAAO;AAC3B,UAAIH,eAAeC,QAAW;AAC5B,cAAMG,QAAQ,IAAIC,WAAWL,WAAWM,SAASH,IAAIG,MAAM;AAC3DF,cAAMG,IAAIP,UAAU;AACpBI,cAAMG,IAAIJ,KAAKH,WAAWM,MAAM;AAChCH,cAAMC;AACNJ,qBAAaC;MACf;AACA,UAAI;AACF,eAAaO,gBAAgBjC,MAAMkC,eAAeN,GAAG,EAAEO,KAAI,CAAE;MAC/D,SAASC,QAAQ;AACf,cAAMC,QAAaD;AACnB,YAAIC,MAAMZ,YAAY;AACpBA,uBAAaG,IAAIU,SAASD,MAAME,YAAY;AAC5C,iBAAaN,gBAAgBI,MAAMG,UAAU,CAAA,CAAE;QACjD;AACA,cAAMH;MACR;IACF,CAAC;IACH1B,OAAQC,WAAU,IAAIlB,aAAa;MAAEG,QAAQ;MAAUe;IAAK,CAAE;GAC/D;AAEH,QAAMV,OACIC,cAAc;IACpBC,SAAUC,WACAC,UACEC,SAAQe,QAAOjB,KAAK,GAAWQ,KAAK,GAC5CX,IAAI;IAERY,WAAYF,WAAkBG,WAAUH,KAAK;IAC7CI,QAAgBC;GACjB;AAEH,SAAOf;AACT,CAAC;AAOE,IAAMuC,eACXtB,CAAAA,YAEF,MAQaC,OAAOE,QAAM,GAAkBoB,eAAcvB,OAAM,EAAC,CAAE;AAM5D,IAAMwB,UACXC,UAEQxB,OACEA,OAAOtB,MAAI,GAAI8C,IAAI,GAC3BtB,QAAM,CAAE;AAOL,IAAMuB,eAwDTC,KAwDF,GAAG,CACHF,MASAG,aAYiBC,cAAcL,QAAOC,IAAI,GAAGG,QAAO,CAAC;AAYhD,IAAM5B,UAAuCA,CAAAA,YAC3C8B,gBACEC,oBACP/B,SACA;EACEgC,OAAOC,OAAOC,GAAGC,KAAG;AAClB,WAAmB9C,KAAI;MACrBA,KAAKA,MAAe2C,QAAOC,KAAK;MAChCzC,OAAQC,WACN,IAAgB2C,KACdD,KACAF,OACUI,YAAY5C,OAAO,SAAS,IAAI6C,OAAO7C,MAAMhB,OAAO,IAAI6D,OAAO7C,KAAK,CAAC;KAEpF;EACH;EACAS,OAAOqC,KAAKL,GAAGC,KAAG;AAChB,WAAmB9C,KAAI;MACrBA,KAAKA,MAAea,QAAOqC,GAAG;MAC9B/C,OAAQC,WACN,IAAgB2C,KACdD,KACAI,KACUF,YAAY5C,OAAO,SAAS,IAAI6C,OAAO7C,MAAMhB,OAAO,IAAI6D,OAAO7C,KAAK,CAAC;KAEpF;EACH;CACD;;;AKlXL;;qBAAA+C;EAAA;;;AAYM,IAAOC,eAAP,cAAoCC,IAAI,+BAA+B,EAAC,EAQ3E;AAAA;AAMI,IAAMC,eAA6BC,OAAOC,IAAI,iDAAiD;AAYhG,IAAOC,oBAAP,cAAsCC,YAAY,mBAAmB,EAGzE;;;;EAIS,CAACJ,YAAW,IAAiBA;;;;EAKtC,IAAIK,UAAO;AACT,WAAO,KAAKC;EACd;;;;ACpDF;;;;;oBAAAC;EAAA,cAAAC;EAAA;gBAAAC;EAAA;;AA2BM,IAAOC,YAAP,cAAiCC,IAAI,yCAAyC,EAAC,EAGlF;AAAA;AAMI,IAAMC,sBAAsBA,MAAuB;AACxD,MAAIC,eAA+C,CAAA;AACnD,QAAMC,eAAgBC,eAAsD;AAE1EF,iBAAaG,KAAK,GAAGD,SAAS;EAChC;AACA,QAAME,aAAaA,MAAsCJ;AACzD,QAAMK,cAAcA,MAAqC;AACvD,UAAMC,OAAON;AACbA,mBAAe,CAAA;AACf,WAAOM;EACT;AACA,SAAOT,UAAUU,GAAG;IAClBN;IACAO,QAASC,mBAAyBC,KAAK,MAAMT,aAAaQ,aAAa,CAAC;IACxEL;IACAO,MAAaD,KAAKN,UAAU;IAC5BC;IACAO,OAAcF,KAAKL,WAAW;GAC/B;AACH;AAMO,IAAMQ,gBAAwDH,KAAKX,mBAAmB;AAMtF,IAAMS,UAAUR,kBACdc,SACEC,cAAclB,SAAS,GACvBmB,OAAM;EACXC,QAAQA,MAAaC;EACrBC,QAASC,OAAMA,EAAEZ,OAAOR,YAAY;CACrC,CAAC;AAOC,IAAMqB,UAcTC,KAAK,GAAG,CACVC,MACAC,MAEOC,gBACEC,cAAcH,IAAI,GACzBA,MACA;EAAEI,QAAQ;EAAMC,QAAoBC;EAASC,QAASC,OAAaC,GAAGxB,QAAOgB,EAAEO,CAAC,CAAC,GAAGA,CAAC;AAAC,CAAE,CACzF;AAMI,IAAME,YAAsCZ,QAC1Ca,KACNd,OAAM,CAAEA,EAAgBe,KAAKC,MAAM,CAAC;AAOhC,IAAMC,cAA0ChB,QAC9Ca,KACNd,OAAM,CAACA,CAAgB,CAAC;AAOpB,IAAMkB,cAAwCjB,QAC5CkB,oBACNnB,OAAM,CAACA,EAAEgB,MAAM,CAAC;;;AC7HnB;;;2BAAAI;EAAA;;;;ACDO,IAAMC,oBAAoDC,OAAOC,IACtE,8BAA8B;;;ADQzB,IAAMC,qBAA4CA;AAYlD,IAAMC,gBAAiBC,OAA2CC,YAAYD,GAAGF,kBAAiB;AAMnG,IAAOI,cAAP,cAAkCC,aAAW,EAAgB,eAAe;EAChFC,QAAeC,QAAQ,SAAS,UAAU,QAAQ,WAAW,QAAQ;EACrEC,OAAcC;CACf,EAAC;;;;EAIS,CAACT,kBAAiB,IAAuBA;;;;EAKlD,OAAgBU,QAGLA,MAAM;IAAEC,OAAO;IAAMC,QAAeH;EAAM,CAAE;;;;EAKvD,OAAgBI,cACbC,WAAW,KAAKJ,KAAK;;;;EAKxB,OAAgBK,cACbC,WAAW,KAAKN,KAAK;;;;EAKxB,IAAIO,UAAO;AACT,YAAQ,KAAKX,QAAM;MACjB,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;MACT,KAAK;AACH,eAAO;IACX;EACF;;;;AE7DF;;wBAAAY;EAAA,4BAAAC;EAAA,eAAAC;EAAA,qBAAAC;EAAA,2BAAAC;EAAA,oBAAAC;EAAA,oBAAAC;EAAA,mBAAAC;EAAA,oBAAAC;EAAA,gBAAAC;EAAA,qBAAAC;EAAA,0BAAAC;EAAA,+BAAAC;EAAA,sBAAAC;;;;ACSO,IAAMC,uBAAoDC,OAAOC,IACtE,wCAAwC;AAInC,IAAMC,iBAAyBC,WACpC,wCAAwC;AAInC,IAAMC,sBAAkDJ,OAAOC,IACpE,uCAAuC;AAIlC,IAAMI,gBAAwBF,WACnC,uCAAuC;AAIlC,IAAMG,UAAkBH,WAC7B,iCAAiC;AAI5B,IAAMI,cAAqBC,IAAI,aAAS;AAC7C,QAAMC,WAAW,OAAOP;AACxB,MAAIQ,YAAY;AAChB,SAAOL,cAAcM,GAAG;IACtB,CAACP,mBAAmB,GAAGA;IACvBQ,MAAe;MACbC,QAAAA;MACAC;IAAc,GACW;AACzB,aAAcN,IAAI,aAAS;AACzB,cAAMO,KAAKL;AACX,YAAIM,mBAAmB;AACvB,cAAMC,aAAa,oBAAIC,IAAG;AAK1B,cAAMC,YAAyBC,oBAAmB;AAClD,cAAMC,gBAAgBR,UAClBS,aACOC,SACLJ,UAAUK,OACHC,eAAeZ,QAAOS,OAAO,GAAgBI,WAAWP,SAAS,CAAC,IAEtEQ;AAET,cAAMC,aAAa,OAAgBC,MAAI;AACvC,cAAMC,UAAU,OAAOrB,SAASG,MAA2DG,EAAE;AAE7F,eAAOe,QAAQC,IAAKT,aAAW;AAC7B,cAAIA,QAAQ,CAAC,MAAM,GAAG;AACpB,mBAAgBU,SAASJ,YAAmBK,KAAI;UAClD;AACA,iBAAOC,cAAcZ,QAAQ,CAAC,CAAC;QACjC,CAAC,EAAEa,KACMC,QAASC,WACPC,SAAQrB,WAAWsB,OAAM,GAAKC,aAC1BC,kBAAkBD,UACdE,UAAUF,SAASH,KAAK,IACjCG,QAAQE,UAAUL,KAAK,CAAC,CAAC,GAE1BM,cAAqBC,UAAU,GAC/BC,MAAeC,OAAO,GAAI,CAAC,GAC3BC,aAAa;UAClBC,SAAS;UACTC,QAAQ;SACT,GACMC,eACAC,UAAU;AAGnB,eAAcC,cAAa,MAClB7B,SACEe,SAAQrB,WAAWsB,OAAM,GAAKC,aAC1BC,kBAAkBD,UACda,UAAUb,OAAO,IAC1BA,QAAQc,KAAK;UACjBC,SAAS;SACV,GACMC,KAAK,MAAMvC,WAAWO,MAAK,CAAE,CAAC,CACtC;AAGH,cAAMU,gBAAiBuB,cACdC,QAAQ,MAAK;AAClB,gBAAMlB,UAAUvB,WAAW0C,IAAIF,SAAS,CAAC,CAAC;AAC1C,cAAI,CAACjB,QAAS,QAAcP;AAE5B,kBAAQwB,SAAS,CAAC,GAAC;;YAEjB,KAAK,GAAG;AACN,qBAAgBhB,kBAAkBD,UACrBb,QAAQa,SAASiB,SAAS,CAAC,EAAE,CAAC,CAAC,IACxCjB,QAAQoB,SAASH,SAAS,CAAC,CAAC;YAClC;;YAEA,KAAK,GAAG;AACN,kBAAIA,SAASI,WAAW,GAAG;AACzB,uBAAgBpB,kBAAkBD,UACrBa,UAAUb,OAAO,IAC1BA,QAAQc;cACd;AACA,qBAAgBb,kBAAkBD,UACrBb,QAAQa,SAASiB,SAAS,CAAC,EAAE,CAAC,CAAC,IACjClC,SAASiB,QAAQoB,SAASH,SAAS,CAAC,CAAC,GAAGjB,QAAQc,GAAG;YAChE;;YAEA,KAAK;YACL,KAAK,GAAG;AACN,kBAAIG,SAAS,CAAC,MAAM,GAAG;AACrB,uBAAgBhB,kBAAkBD,UACrBsB,KAAKtB,SAASiB,SAAS,CAAC,CAAC,IAClCjB,QAAQsB,KAAKL,SAAS,CAAC,CAAC;cAC9B;AACA,oBAAMpB,QAAQ0B,YAAYC,YAAYP,SAAS,CAAC,CAAC;AACjD,qBAAgBhB,kBAAkBD,UACrBE,UAAUF,SAASH,KAAK,IACjCG,QAAQE,UAAUL,KAAK;YAC7B;UACF;QACF,CAAC;AAEH,cAAM4B,iBAAiBA,CAErBC,SAAYC,gBACLC,iBAGHC,WAAS;AACX,gBAAMC,WAAUD,MAAME,YAAqBC,cAAc;AACzD,gBAAMC,OAAeC,UAAUJ,UAAgBK,UAAU,EAAExC,KAClDyC,OAAQH,CAAAA,UAA8BA,MAAKI,SAAS,MAAM,CAAC;AAEpE,gBAAM9D,MAAKC;AACX,iBAAOmD,YAAYhC,KACV2C,IAAKtC,aAAW;AACrBvB,uBAAW8D,IAAIhE,KAAIyB,OAAO;AAC1B,mBAAOnB,cAAc6C,OAAO,EAAE/B,KACrB2C,IAAKE,aACVlD,QAAQmD,KAAK,CACXlE,KACA,GACAiE,SACAP,KAAKI,SAAS,SAAS,CAACJ,KAAKS,MAAMC,SAASV,KAAKS,MAAME,QAAQX,KAAKS,MAAMG,OAAO,IAAIC,MAAS,GAC7FnE,UAAUoE,WAAU,CAAE,CAAC,GAErBC,cAAenD,WACZoD,UAA8BjD,OAAO,IACzCA,QAAQE,UAAUL,KAAK,IACdK,UAAUF,SAASH,KAAK,CAAC,CACvC;UAEL,CAAC,GACMqD,KAAKlD,cAAa;YAAEzB,IAAAA;YAAIyB;UAAO,EAAG,CAAC;QAE9C,CAAC;AAEH,cAAMmD,iBAAiBA,CAAC;UAAE5E,IAAAA;QAAE,GAA6B6E,UAAqC;AAC5F,gBAAMC,UAAiBrC,KAAK,MAAMvC,WAAW6E,OAAO/E,GAAE,CAAC;AACvD,iBAAYgF,UAAUH,KAAI,IACjBrE,SAAgByE,MAAMlE,QAAQmD,KAAK,CAAClE,KAAI,CAAC,CAAC,CAAC,GAAG8E,OAAO,IAC5DA;QACJ;AAEA,cAAMI,WAAW/B,aACRgC,YACGC,mBACNlC,eAAeC,SAAiBrC,MAAI,CAAsB,GAC1D,CAAC;UAAEW;QAAO,MAAe4D,UAAU5D,OAAO,GAC1CmD,cAAc,CACf;AAGL,cAAMU,gBAAiBnC,aACdiC,kBACLlC,eAAeC,SAAkBrC,MAAI,CAAsB,GAC3D,CAAC;UAAEW;QAAO,MAAgB8D,OAAM9D,OAAO,GACvCmD,cAAc;AAGlB,eAAgBW,OAAM1E,UAAU;AAEhC,YAAId,gBAAgB;AAClB,iBAAc0C,KAAK1C,cAAc,EAAEqB,KAC1BoE,SAAQF,aAAa,GACrBG,SAAUnE,WAAU,IAAI0B,YAAY;YAAE0C,QAAQ;YAASpE;UAAK,CAAE,CAAC,CAAC;QAE3E;AAEA,eAAO;UAAEtB;UAAIkF,SAAAA;UAASI;QAAa;MACrC,CAAC;IACH;GACD;AACH,CAAC;AAGM,IAAMK,eAAqBC,OAAOtG,eAAeE,WAAW;AAG5D,IAAMqG,WACXC,CAAAA,aAEOrG,IAAI,aAAS;AAClB,QAAMsG,UAAU,OAAOzG;AACvB,QAAM0G,UAAU,oBAAIC,IAAG;AACvB,QAAMC,UAAU9E,KACd2E,QAAQlG,MAAeiG,QAAO,GACvB/B,IAAKoC,YACHC,eACE3D,KAAK,MAAMuD,QAAQK,IAAIF,MAAM,CAAC,GACrC,MAAa1D,KAAK,MAAMuD,QAAQjB,OAAOoB,MAAM,CAAC,CAAC,CAChD,GAEHL,SAAQQ,WAAkBvC,IAAI+B,SAAQQ,QAAQ,IAAIC,QAAQ;AAE5D,QAAMxF,UAAU,aAAa+E,WAC3B,OAAYU,YAAY;IACtBN;IACAO,KAAKX,SAAQY;IACbC,KAAKb,SAAQc;IACbC,aAAaf,SAAQe;IACrBC,mBAAmBhB,SAAQgB;IAC3BC,YAAYjB,SAAQiB;GACrB,IACD,OAAYjG,MAAK;IACfoF;IACAc,MAAMlB,SAAQkB;IACdH,aAAaf,SAAQe;IACrBC,mBAAmBhB,SAAQgB;GAC5B;AACH,QAAMG,OAAmC;IACvClG;IACAmG,WAAY3G,aACHgB,SAAQyE,SAAUG,YAAWA,OAAOb,cAAc/E,OAAO,GAAG;MACjEsG,aAAa;MACbrE,SAAS;KACV;IACH0C,SAAU3E,aACD4G,cAAoBxC,KACzB5D,QAAQ6B,KACPuD,YAAWA,OAAOjB,QAAQ3E,OAAO,CAAC,CACpC;IACH+E,eAAgB/E,aACP6G,OAAc5B,SACnBzE,QAAQ6B,KACPuD,YAAWA,OAAOb,cAAc/E,OAAO,CAAC,CAC1C;;AAIL,SAAc6G,OAAOrG,QAAQ6B,GAAG;AAEhC,SAAOqE;AACT,CAAC;AAGI,IAAMI,gBAAgBA,CAC3BC,MACAxB,aACSsB,QAAOE,MAAKzB,SAASC,QAAO,CAAC;AAGjC,IAAMyB,iBAGXzB,CAAAA,aAEOrG,IAAI,aAAS;AAClB,QAAMsG,UAAU,OAAOzG;AACvB,QAAMyB,UAAU,OAAOgF,QAAQlG,MAAM;IACnC,GAAGiG;IACHhG,OAAOS,SAAO;AACZ,aAAckF,SACL+B,UAAUjH,OAAc,GAC9Be,WAAU,IAAI0B,YAAY;QAAE0C,QAAQ;QAAUpE;MAAK,CAAE,CAAC;IAE3D;GACD;AACD,QAAM4D,WAA0B3E,aAAgB;AAC9C,UAAMkH,eAAsBC,QAAcC,cAAcpH,OAAc,CAAC;AACvE,UAAMqH,eAAsBF,QAAcG,cAActH,OAAc,CAAC;AACvE,WAAOa,KACLL,QAAQmE,QAAQ3E,OAAO,GAChBuH,UAAUC,WAAiBvC,SAAQoC,aAAaG,KAAK,GAAUhF,KAAI,CAAC,GACpEiF,UAAUP,YAAY,CAAC;EAElC;AACA,QAAMnC,gBAAgC/E,aAAgB;AACpD,UAAMkH,eAAsBC,QAAcC,cAAcpH,OAAc,CAAC;AACvE,UAAMqH,eAAsBF,QAAcG,cAActH,OAAc,CAAC;AACvE,WAAc0H,YAAYlH,QAAQuE,cAAc/E,OAAO,GAAG;MACxD2H,WAAYH,WAAiBvC,SAAQoC,aAAaG,KAAK,GAAUhF,KAAI;MACrEoF,WAAWV;KACZ;EACH;AACA,SAAOlB,SAAqC;IAC1CvG,IAAIe,QAAQf;IACZkF,SAASA;IACTI;GACD;AACH,CAAC;AAGI,IAAM8C,qBACXtC,CAAAA,aAEOrG,IAAI,aAAS;AAClB,QAAMsG,UAAU,OAAOzG;AACvB,QAAM0G,UAAU,oBAAIC,IAAG;AACvB,QAAMC,UAAU9E,KACdmG,eAAkBzB,QAAO,GAClB/B,IAAKoC,YAAkB1D,KAAK,MAAMuD,QAAQK,IAAIF,MAAM,CAAC,CAAC,GACtDpC,IAAKoC,YAAkB9D,cAAa,MAAaI,KAAK,MAAMuD,QAAQjB,OAAOoB,MAAM,CAAC,CAAC,CAAC,GAC3FL,SAAQQ,WACGvC,IACP+B,SAAQQ,QAAoF,IAE5FC,UACG7F,eAAepB,eAAeyG,OAAO,CAAC;AAE/C,QAAMhF,UAAU,OAAO,gBAAgB+E,WAChCU,YAAY;IACfN;IACAO,KAAKX,SAAQY;IACbC,KAAKb,SAAQc;IACbC,aAAaf,SAAQe;IACrBC,mBAAmBhB,SAAQgB;IAC3BC,YAAYjB,SAAQiB;GACrB,IACIjG,MAAK;IACRoF;IACAc,MAAMlB,SAAQkB;IACdH,aAAaf,SAAQe;IACrBC,mBAAmBhB,SAAQgB;GAC5B;AACH,QAAMG,OAAuC;IAC3ClG;IACAmG,WAA2B3G,aAClBgB,SAAQyE,SAAUG,YAAWA,OAAOb,cAAc/E,OAAO,GAAG;MACjEsG,aAAa;MACbrE,SAAS;KACV;IACH0C,SAAyB3E,aAChB4G,cAAoBxC,KAAI5D,QAAQ6B,KAAMuD,YAAWA,OAAOjB,QAAQ3E,OAAO,CAAC,CAAC;IAClF+E,eAA+B/E,aACtB6G,OAAc5B,SAAQzE,QAAQ6B,KAAMuD,YAAWA,OAAOb,cAAc/E,OAAO,CAAC,CAAC;;AAIxF,SAAc6G,OAAOrG,QAAQ6B,GAAG;AAEhC,SAAOqE;AACT,CAAC;AAGI,IAAMoB,0BAA0BA,CACrCf,MACAxB,aACSsB,QAAOE,MAAKc,mBAAmBtC,QAAO,CAAC;AAG3C,IAAMwC,eAA6BC,aAClC3H,SACJrB,SACAgJ,OAAO;AAIJ,IAAMC,eAAeA,MAK1B1C,CAAAA,aAYA3G,eAAeS,GAAG;EAChB,CAACZ,oBAAoB,GAAGA;EACxBa,MAAYG,IAAU;AACpB,WAAcP,IAAI,aAAS;AACzB,YAAMI,QAAS,OAAON;AACtB,UAAIkJ;AACJ,YAAMC,SAAyD,CAAA;AAE/D,YAAM1H,OACJ2H,CAAAA,aAEOC,oBAAqBC,aACnBpJ,IAAI,aAAS;AAClB,cAAMqJ,SAAQ,OAAcA;AAC5B,cAAMC,OAAO,OAAOjD,SAAQkD,MAAM;UAAE7C,QAAQtG,MAAMG,EAAE;UAAG8I,OAAAA;QAAK,CAAE;AAC9DL,sBAAcM;AACd,eAAa1G,aACXyG,QACOrG,KAAK,MAAK;AACfgG,wBAAclE;QAChB,CAAC,CAAC;AAEJ,cAAM0E,YAAW,OAAcA,SAAO,GAAqB7H,KACjD8H,cAAsBC,KAAWC,KAAK,CAAC,CAAC;AAElD,cAAMC,WAAW,OAAgBvI,MAAI;AACrC,cAAMwI,WAAkBA,QAAQL,QAAO;AACvC,eAAOnD,SAAQyD,OAAO;UACpBR;UACAD,OAAAA;UACAU,KAAKC,MAAI;AACPC,YAASC,UAAUN,UAAUC,SAAQX,SAAQc,IAAI,CAAC,CAAC;UACrD;UACAG,UAAUP,SAASO;SACpB;AACD,YAAIlB,OAAO5F,SAAS,GAAG;AACrB,qBAAW,CAACvC,SAASsJ,SAAS,KAAKnB,QAAQ;AACzCK,iBAAKe,YAAY,CAAC,GAAGvJ,OAAO,GAAGsJ,SAAgB;UACjD;AACAnB,iBAAO5F,SAAS;QAClB;AACA,eAAQ,OAAO+F,QAAiBkB,KAAKV,QAAQ,CAAC;MAChD,CAAC,EAAEjI,KAAYgG,MAAM,CAAC;AAG1B,YAAMlD,OAAOA,CAAC3D,SAAYsJ,cACjBG,KAAI;QACTA,KAAKA,MAAK;AACR,cAAIvB,gBAAgBlE,QAAW;AAC7BmE,mBAAOuB,KAAK,CAAC1J,SAASsJ,SAAS,CAAC;UAClC,OAAO;AACLpB,wBAAYqB,YAAY,CAAC,GAAGvJ,OAAO,GAAGsJ,SAAgB;UACxD;QACF;QACAK,OAAQ5I,WAAU,IAAI0B,YAAY;UAAE0C,QAAQ;UAAQpE;QAAK,CAAE;OAC5D;AAEH,aAAO;QAAEN,KAAAA;QAAKkD;MAAI;IACpB,CAAC;EACH;CACD;;;AD7aI,IAAMiG,wBAA+CA;AAoBrD,IAAMC,gBAckBA;AAMxB,IAAMC,kBAAuEA;AAwB7E,IAAMC,WAA6DA;AA2FnE,IAAMC,uBAA8CA;AAuBpD,IAAMC,iBAAoEA;AAM1E,IAAMC,eAA4EA;AAMlF,IAAMC,gBAA2EA;AAMjF,IAAMC,YAE0FA;AAMhG,IAAMC,iBAG0DA;AA0FhE,IAAMC,kBAE0FA;AAMhG,IAAMC,sBAGFA;AAMJ,IAAMC,2BAG0DA;AAMhE,IAAMC,gBACFA;;;AErWX;;oBAAAC;EAAA,sBAAAC;EAAA,4BAAAC;EAAA,cAAAC;EAAA,aAAAC;EAAA,uBAAAC;EAAA,uBAAAC;EAAA,YAAAC;EAAA,sBAAAC;;;;ACQO,IAAMC,uBAA0DC,OAAOC,IAC5E,wCAAwC;AAInC,IAAMC,iBAAyBC,WACpC,wCAAwC;AAInC,IAAMC,aAAqBC,UAAS,EAA4B,4CAA4C;EACjHC,cAAcA,MAAeC,YAAsCC,KAAI;CACxE;AAGM,IAAMC,kBAAwBC,OAAON,YAAqBO,MAAI,CAAE;AAGhE,IAAMA,SAAcC,WAAW,WACpCC,SACAC,UAA8C;AAE9C,QAAMC,QAAQ,OAAcC,iBAAkDC,QAAc;AAC5F,QAAMC,WAAW,OAAOhB;AACxB,QAAMiB,aAAa,OAAOf;AAC1B,QAAMgB,UAAU,OAAOF,SAASG,MAA2DF,UAAU;AACrG,QAAMG,WAAW,oBAAIC,IAAG;AAExB,SAAgBC,OAAML,UAAU,EAAEM,KACzBC,OAAO,MAAK;AACjBX,UAAMY,iBAAiBC,aAAa,MAAK;AACvCb,YAAMc,sBAAsBd,MAAMe,GAAE,CAAE;IACxC,GAAG,CAAC;AACJ,WAAcC;EAChB,CAAC,GACMC,UAAU;AAGnB,SAAOZ,QAAQa,IAAI,CAACC,QAAQ,CAACJ,IAAIK,MAAMC,MAAMC,IAAI,MAA0C;AACzF,QAAIF,SAAS,GAAG;AACd,YAAMpB,SAAQO,SAASgB,IAAIR,EAAE;AAC7B,UAAI,CAACf,OAAO,QAAcgB;AAC1B,aAAaQ,WAAUxB,MAAK;IAC9B;AAEA,WAAcC,iBAAkCD,CAAAA,WAAS;AACvDO,eAASkB,IAAIV,IAAIf,MAAK;AACtB,aAAOD,UAAS2B,SAAS3B,SAAQ2B,OAAOL,IAAI,IAAWnB,SAAQmB,IAAI;IACrE,CAAC,EAAEX,KACMiB,SAASC,WAAS;AACvB,YAAMC,YAAyBC,oBAAmB;AAClD,YAAMC,UAASjC,QAAQ8B,KAAK;AAC5B,UAAIjC,UAAgBqC,SAASD,OAAM,IAC1BJ,SAAQI,SAASE,SACtBvB,KACEX,UAASmC,eACEC,eAAepC,SAAQmC,aAAaN,OAAOK,GAAG,GAAgBG,WAAWP,SAAS,IAClF3B,SAAQ+B,GAAG,GACfN,SAASU,aAAYhC,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAG,CAACsB,OAAO,CAAC,GAAGR,UAAUU,WAAU,CAAE,CAAC,CAAC,CAC9F,IACH7B,KACEqB,SACOS,gBAAiBC,WAAS;AAC/B,YAAI1C,UAASmC,iBAAiBQ,QAAW;AACvC,gBAAML,UAAgBM,gBAAgBF,KAAK;AAC3C,iBAAOpC,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAGsB,OAAO,CAAC;QAC9C;AAEAR,kBAAUe,YAAW;AACrB,eAAOlC,KACEmC,SAAQJ,OAAQpB,CAAAA,UAAStB,SAAQmC,aAAcN,OAAOP,KAAI,CAAC,GAC3Dc,eAA4BC,WAAWP,SAAS,GAChDF,SAASU,aAAYhC,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAGsB,OAAO,GAAGR,UAAUU,WAAU,CAAE,CAAC,CAAC;MAE/F,CAAC,GACMO,QAAQzC,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,CAAC,CAAC,CAAC,CAAC;AAGjD,UAAIO,MAAM;AACR3B,QAAAA,UAAgBoD,eAAepD,SAAQ;UACrCqD,MAAM;UACNC,SAAS3B,KAAK,CAAC;UACf4B,QAAQ5B,KAAK,CAAC;UACd6B,SAAS7B,KAAK,CAAC;UACf8B,SAAiBC,OAAK;SACvB;MACH;AAEA,aAAcC,oBAAqBC,aACjCA,QAAQ5D,OAAM,EAAEe,KACP8C,QACLC,eACCC,WAAUrD,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAG4C,YAAYC,YAAkBC,MAAKH,KAAK,CAAC,CAAC,CAAC,CAAC,GAE/EI,cAAeC,WACbC,MAAYC,eAAeF,KAAK,GAAG;QACxCG,QAASR,WAAS;AAChB7B,oBAAUe,YAAW;AACrB,iBAAOlC,KACLX,UAASoE,cACEhC,eACPpC,SAAQoE,YAAYvC,OAAO8B,KAAK,GACnBtB,WACbP,SAAS,IAEF3B,SAAQwD,KAAK,GACjB/B,SAASU,aAAYhC,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAGsB,OAAc,GAAGR,UAAUU,WAAU,CAAE,CAAC,GAC1FuB,cAAeC,CAAAA,WAAU1D,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAG4C,YAAYC,YAAYG,MAAK,CAAC,CAAC,CAAC,CAAC;QAElG;QACAK,SAAUL,CAAAA,WAAU1D,QAAQiC,KAAKnB,QAAQ,CAACJ,IAAI,GAAG4C,YAAYC,YAAYG,MAAK,CAAC,CAAC;OACjF,CAAC,CACH,CACF;IAEL,CAAC,GACMM,SAAgBC,KAAK,MAAM/D,SAASgE,OAAOxD,EAAE,CAAC,CAAC,CAAC;EAE3D,CAAC;AACH,CAAC;AAGM,IAAMyD,SAAQA,CACnB1E,SACAC,aAEM0E,cAAc7E,OAAKE,SAASC,QAAO,CAAC,EAAEW,KACpCgE,SAAQhF,eAAe,CAAC;AAI3B,IAAMiF,kBAAiBA,CAM5BC,SACAC,aASOC,IAAI,aAAS;AAClB,QAAMC,SAAQ,OAAcA;AAC5B,MAAI3B,WAAkBC,OAAK;AAC3B,QAAM2B,eAAsBC,cAAcL,OAAM;AAEhD,SAAO,OAAOhF,OAAMsF,aAAc;AAChC,UAAMC,SAAUN,SAAiBK,QAAQlC,IAAI,EAAEkC,OAAO;AACtD,QAAUE,QAAQD,MAAM,GAAG;AACzB,aAAcxD,SAAc0D,eAAeF,QAAQJ,MAAK,GAAIO,OACnDhB,KAAK,MAAK;AACflB,QAAAA,WAAkBmC,MAAMnC,UAASkC,CAAC;MACpC,CAAC,CAAC;IACN,WAAkBtD,SAASmD,MAAM,GAAG;AAClC,aAAcT,QAAQS,QAAQ/B,QAAO;IACvC;AACA,WAAcoC,eAAeL,QAAe/B,QAAO;EACrD,GAAG;IACD1B,OAAO+D,SAAO;AACZ,aAAcC,SACZV,aAAaS,OAAO,GACnB1B,WAAU,IAAIJ,YAAY;QAAEgC,QAAQ;QAAU5B;MAAK,CAAE,CAAC;IAE3D;IACAI,YAAYe,SAASO,SAAO;AAC1B,aAAcC,SACLE,iBAAiBV,SAAgBO,OAAO,GAC9C1B,WAAU,IAAIJ,YAAY;QAAEgC,QAAQ;QAAU5B;MAAK,CAAE,CAAC;IAE3D;IACA7B,aAAagD,SAASO,SAAO;AAC3B,aAAc3B,cACL+B,iBAAiBX,SAAgBO,OAAO,GAC9C1B,WAAU,IAAIJ,YAAY;QAAEgC,QAAQ;QAAU5B;MAAK,CAAE,CAAC;IAE3D;GACD;AACH,CAAC;AAGI,IAAM+B,kBAAkBA,CAM7BlB,SACAC,aAOSJ,cAAcE,gBAAeC,SAAQC,QAAQ,CAAC,EAAEnE,KAAWgE,SAAQhF,eAAe,CAAC;AAGvF,IAAMqG,SAAmBvB,CAAAA,WACvBwB,WAAkBnG,WAAW,WAAUkF,QAAK;AACjD,QAAM3B,WAAU,OAAaiC,eAAqBY,aAAazB,QAAO9E,eAAe,GAAGqF,MAAK;AAC7F,QAAM3E,aAAqBmB,KAAI6B,UAAS/D,UAAU;AAClD,SAAO,OAAgBoB,OAAML,UAAU;AACzC,CAAC,CAAC;;;ADrLG,IAAM8F,wBAA+CA;AAqBrD,IAAMC,kBAAuEA;AAoB7E,IAAMC,cAA2FA;AAMjG,IAAMC,mBAAoDA;AA8B1D,IAAMC,SAGsEA;AAM5E,IAAMC,SAGuDA;AA6E7D,IAAMC,kBAYAA;AAMN,IAAMC,mBASFA;AASJ,IAAMC,UAAqGA;",
  "names": ["decode", "decodeUnknown", "encode", "encodeUnknown", "encode", "schema", "ChunkFromSelf", "loop", "readWithCause", "onInput", "input", "zipRight", "flatMap", "write", "onFailure", "cause", "failCause", "onDone", "succeed", "encodeUnknown", "decode", "chunk", "pipe", "done", "decodeUnknown", "duplex", "dual", "self", "options", "outputSchema", "inputSchema", "pipeTo", "mapOutEffect", "duplexUnknown", "TypeId", "TypeId", "Symbol", "for", "isPlatformError", "u", "hasProperty", "TypeIdError", "typeId", "tag", "Base", "Error", "_tag", "prototype", "name", "Module", "Literal", "BadArgument", "TaggedError", "module", "method", "String", "description", "optional", "cause", "Defect", "message", "SystemErrorReason", "SystemError", "reason", "syscall", "pathOrDescriptor", "Union", "Number", "undefined", "PlatformError", "TypeId", "empty", "fromIterable", "get", "merge", "remove", "set", "TypeId", "Symbol", "for", "isCookies", "u", "hasProperty", "CookieTypeId", "ErrorTypeId", "CookiesError", "TypeIdError", "message", "reason", "Proto", "BaseProto", "toJSON", "_id", "cookies", "map", "cookie", "pipe", "pipeArguments", "arguments", "fromReadonlyRecord", "self", "Object", "create", "fromIterable", "record", "name", "fromSetCookie", "headers", "arrayHeaders", "header", "parseSetCookie", "trim", "isSome", "push", "value", "parts", "split", "_", "filter", "length", "none", "firstEqual", "indexOf", "slice", "fieldContentRegExp", "test", "valueEncoded", "tryDecodeURIComponent", "some", "assign", "CookieProto", "options", "i", "part", "equalIndex", "key", "undefined", "toLowerCase", "domain", "replace", "date", "Date", "isNaN", "getTime", "expires", "maxAge", "parseInt", "seconds", "path", "priority", "httpOnly", "secure", "partitioned", "sameSite", "keys", "empty", "isEmpty", "isEmptyRecord", "makeCookie", "left", "encodedValue", "encodeURIComponent", "isFinite", "decode", "right", "unsafeMakeCookie", "getOrThrowWith", "identity", "setCookie", "dual", "set", "setAllCookie", "merge", "that", "remove", "get", "args", "getValue", "unsafeSet", "setAll", "either", "isLeft", "unsafeSetAll", "serializeCookie", "str", "toSeconds", "Math", "trunc", "toUTCString", "toCookieHeader", "values", "join", "toRecord", "index", "toSetCookieHeaders", "parseHeader", "result", "strLen", "pos", "terminatorPos", "eqIdx", "substring", "val", "charCodeAt", "decodeURIComponent", "GeneratorTypeId", "layer", "layerWeak", "toString", "GeneratorTypeId", "Symbol", "for", "tag", "GenericTag", "toString", "self", "_tag", "value", "fromFileInfo", "info", "mtime", "getTime", "size", "fromFileWeb", "file", "lastModified", "layer", "succeed", "of", "sync", "layerWeak", "toString", "GeneratorTypeId", "Generator", "tag", "layer", "layerWeak", "empty", "get", "merge", "redact", "remove", "set", "setAll", "HeadersTypeId", "Symbol", "for", "isHeaders", "u", "hasProperty", "Proto", "Object", "assign", "create", "symbolRedactable", "fiberRefs", "redact", "getOrDefault", "currentRedactedNames", "make", "input", "schemaFromSelf", "declare", "identifier", "equivalence", "getEquivalence", "Equivalence", "schema", "transform", "Record", "key", "String", "value", "strict", "decode", "record", "fromInput", "encode", "identity", "empty", "undefined", "iterator", "out", "k", "v", "toLowerCase", "entries", "Array", "isArray", "join", "unsafeFromRecord", "setPrototypeOf", "has", "dual", "self", "get", "set", "setAll", "headers", "merge", "remove", "modify", "name", "test", "i", "length", "globalValue", "unsafeMake", "TypeId", "TypeId", "Symbol", "for", "TypeId", "isHttpClientError", "u", "hasProperty", "RequestError", "TypeIdError", "methodAndUrl", "request", "method", "url", "message", "description", "reason", "ResponseError", "info", "response", "status", "GiB", "KiB", "MiB", "PiB", "Size", "TiB", "layerNoop", "make", "makeNoop", "tag", "GenericTag", "Size", "bytes", "BigInt", "KiB", "n", "MiB", "GiB", "TiB", "bigint1024", "bigintPiB", "PiB", "make", "impl", "of", "exists", "path", "pipe", "access", "as", "catchTag", "e", "reason", "succeed", "fail", "readFileString", "encoding", "tryMap", "readFile", "try", "_", "TextDecoder", "decode", "catch", "cause", "BadArgument", "module", "method", "description", "stream", "options", "open", "flag", "offset", "tap", "file", "seek", "identity", "map", "unwrapScoped", "sink", "forEach", "writeAll", "writeFileString", "data", "flatMap", "TextEncoder", "encode", "writeFile", "notFound", "SystemError", "pathOrDescriptor", "makeNoop", "fileSystem", "chmod", "chown", "copy", "copyFile", "link", "makeDirectory", "die", "makeTempDirectory", "makeTempDirectoryScoped", "makeTempFile", "makeTempFileScoped", "readDirectory", "readLink", "realPath", "remove", "void", "rename", "oldPath", "stat", "symlink", "fromPath", "truncate", "utimes", "watch", "layerNoop", "bufferSize", "bytesToRead", "bytesToRead_", "chunkSize", "chunkSize_", "undefined", "loop", "totalBytesRead", "toRead", "readAlloc", "match", "onNone", "onSome", "buf", "write", "length", "bufferChunks", "fromChannel", "capacity", "Size", "KiB", "MiB", "GiB", "TiB", "PiB", "FileSystem", "tag", "make", "makeNoop", "layerNoop", "FileTypeId", "Symbol", "for", "isFile", "u", "FileDescriptor", "nominal", "WatchEventCreate", "tagged", "WatchEventUpdate", "WatchEventRemove", "WatchBackend", "Tag", "append", "appendAll", "empty", "fromInput", "remove", "schemaFromSelf", "set", "setAll", "toRecord", "toString", "fromInput", "input", "parsed", "fromInputNested", "out", "i", "length", "Array", "isArray", "keys", "value", "push", "slice", "join", "entries", "Symbol", "iterator", "fromIterable", "Object", "key", "undefined", "String", "nested", "k", "v", "schemaFromSelf", "Tuple", "annotations", "identifier", "empty", "getAll", "dual", "self", "reduce", "acc", "getFirst", "map", "findFirst", "getLast", "findLast", "set", "append", "filter", "setAll", "toSet", "appendAll", "includes", "remove", "makeUrl", "url", "params", "hash", "urlInstance", "URL", "baseUrl", "searchParams", "_tag", "right", "e", "left", "toString", "URLSearchParams", "globalThis", "location", "origin", "pathname", "toRecord", "create", "curr", "schemaJson", "schema", "options", "parse", "decodeUnknown", "parseJson", "field", "getOrElse", "schemaStruct", "schemaFromString", "transform", "decode", "fromA", "encode", "toI", "schemaRecord", "schemaParse", "compose", "TypeId", "TypeId", "Symbol", "for", "schemaBodyJson", "schema", "options", "parse", "decodeUnknown", "self", "flatMap", "json", "schemaBodyUrlParams", "decode", "schemaStruct", "urlParamsBody", "schemaHeaders", "headers", "MaxBodySize", "Reference", "defaultValue", "none", "withMaxBodySize", "dual", "effect", "size", "provideService", "map", "Size", "inspect", "that", "contentType", "body", "includes", "runSync", "text", "obj", "redact", "remoteAddress", "toJSON", "undefined", "toHeaders", "span", "unsafeFromRecord", "b3", "traceId", "spanId", "sampled", "parent", "_tag", "value", "traceparent", "fromHeaders", "headers", "w3c", "xb3", "none", "parts", "split", "length", "some", "externalSpan", "w3cTraceId", "w3cSpanId", "version", "flags", "test", "parseInt", "Uint8Array", "annotations", "AnnotationMultipart", "Symbol", "for", "AnnotationMultipartStream", "AnnotationStatus", "AnnotationEmptyDecodeable", "AnnotationEncoding", "AnnotationParam", "extractAnnotations", "ast", "result", "mergedAnnotations", "_tag", "to", "annotations", "getAnnotation", "key", "getStatus", "defaultStatus", "getEmptyDecodeable", "getMultipart", "getMultipartStream", "encodingJson", "kind", "contentType", "getEncoding", "fallback", "getParam", "name", "omit", "status", "undefined", "isVoid", "from", "f", "getStatusSuccessAST", "getStatusSuccess", "self", "getStatusErrorAST", "getStatusError", "extractUnionTypes", "process", "isUnion", "type", "types", "out", "push", "UnionUnifyAST", "that", "Union", "make", "Array", "Set", "UnionUnify", "param", "dual", "schema", "Empty", "Void", "asEmpty", "options", "transform", "typeSchema", "decode", "encode", "constVoid", "Created", "Accepted", "NoContent", "MultipartTypeId", "Multipart", "MultipartStreamTypeId", "MultipartStream", "defaultContentType", "encoding", "withEncoding", "jsonSchema", "format", "Text", "String", "Uint8Array", "Uint8ArrayFromSelf", "astCache", "globalValue", "WeakMap", "deunionize", "schemas", "has", "add", "get", "astType", "memberSchema", "set", "EmptyError", "symbol", "tag", "StructuralClass", "commit", "fail", "prototype", "Object", "assign", "TypeId", "pipe", "defineProperty", "declare", "u", "hasProperty", "identifier", "title", "constant", "Forbidden", "TypeId", "TypeId", "Symbol", "for", "Issue", "ArrayFormatterIssue", "annotations", "identifier", "description", "HttpApiDecodeError", "TaggedError", "issues", "Array", "message", "String", "status", "fromParseError", "error", "ArrayFormatter", "formatError", "pipe", "zip", "TreeFormatter", "map", "refailParseError", "flatMap", "fail", "BadRequest", "EmptyError", "tag", "Unauthorized", "Forbidden", "NotFound", "MethodNotAllowed", "NotAcceptable", "RequestTimeout", "Conflict", "Gone", "InternalServerError", "NotImplemented", "ServiceUnavailable", "TypeId", "make", "TypeId", "Symbol", "for", "isHttpApi", "u", "hasProperty", "Api", "Tag", "Proto", "pipe", "pipeArguments", "arguments", "add", "group", "makeProto", "identifier", "groups", "set", "errorSchema", "annotations", "middlewares", "addHttpApi", "api", "newGroups", "key", "newGroup", "annotateContext", "empty", "merge", "Set", "UnionUnify", "addError", "schema", "status", "prefix", "map", "middleware", "tag", "failure", "annotate", "value", "context", "options", "HttpApi", "Object", "setPrototypeOf", "make", "Map", "HttpApiDecodeError", "reflect", "self", "apiErrors", "extractMembers", "ast", "getStatusErrorAST", "values", "groupErrors", "groupAnnotations", "onGroup", "mergedAnnotations", "endpoints", "endpoint", "predicate", "errors", "onEndpoint", "payloads", "payloadSchema", "_tag", "extractPayloads", "emptyMap", "successes", "successSchema", "getStatusSuccessAST", "inherited", "getStatus", "members", "process", "type", "isNeverKeyword", "extractAnnotations", "isEmptyRecord", "emptyDecodeable", "getEmptyDecodeable", "current", "get", "description", "none", "orElse", "getDescriptionOrIdentifier", "UnionUnifyAST", "isVoidKeyword", "encodedAST", "some", "HttpApiSchema", "extractUnionTypes", "forEach", "topAst", "encoding", "getEncoding", "contentType", "getMultipart", "getMultipartStream", "undefined", "Union", "types", "to", "fromNullable", "DescriptionAnnotationId", "IdentifierAnnotationId", "AdditionalSchemas", "Tag", "TypeId", "TypeId", "Symbol", "for", "SecurityTypeId", "isSecurity", "u", "hasProperty", "Tag", "id", "options", "Err", "globalThis", "Error", "limit", "stackTraceLimit", "creationError", "TagClass", "TagClass_", "Object", "setPrototypeOf", "getPrototypeOf", "GenericTag", "key", "defineProperty", "get", "stack", "failure", "optional", "undefined", "Never", "provides", "security", "keys", "length", "ErrorTypeId", "HttpBodyError", "TypeId", "empty", "file", "fileInfo", "fileWeb", "formData", "formDataRecord", "json", "jsonSchema", "raw", "stream", "text", "uint8Array", "unsafeJson", "urlParams", "TypeId", "Symbol", "for", "ErrorTypeId", "bodyError", "tagged", "HttpBodyError", "reason", "BodyBase", "constructor", "NodeInspectSymbol", "toJSON", "toString", "format", "EmptyImpl", "_tag", "_id", "empty", "RawImpl", "body", "contentType", "contentLength", "raw", "options", "Uint8ArrayImpl", "length", "startsWith", "endsWith", "TextDecoder", "decode", "uint8Array", "encoder", "TextEncoder", "text", "encode", "unsafeJson", "JSON", "stringify", "json", "try", "catch", "error", "urlParams", "jsonSchema", "schema", "flatMap", "mapError", "file", "path", "FileSystem", "fs", "map", "stat", "info", "stream", "Number", "size", "fileInfo", "fileWeb", "fromReadableStream", "identity", "type", "FormDataImpl", "formData", "formDataRecord", "entries", "FormData", "key", "value", "Object", "Array", "isArray", "item", "append", "String", "StreamImpl", "TypeId", "isHttpBody", "u", "hasProperty", "ErrorTypeId", "HttpBodyError", "empty", "raw", "uint8Array", "text", "unsafeJson", "json", "jsonSchema", "urlParams", "formData", "formDataRecord", "stream", "file", "fileInfo", "fileWeb", "make", "stream", "make", "strings", "args", "argsLength", "length", "values", "Array", "effects", "i", "arg", "isOption", "_tag", "primitiveToString", "value", "isSuccess", "effect_instruction_i0", "isEffect", "push", "succeed", "consolidate", "map", "forEach", "index", "effect", "tap", "concurrency", "discard", "_", "stream", "chunks", "buffer", "len", "hasProperty", "StreamTypeId", "flatMap", "fromIterable", "chunk", "isArray", "join", "toString", "out", "u", "_op", "TypeId", "empty", "file", "fileWeb", "formData", "html", "htmlStream", "isServerResponse", "json", "mergeCookies", "raw", "redirect", "removeCookie", "replaceCookies", "schemaJson", "setBody", "setCookie", "setCookies", "setHeader", "setHeaders", "setStatus", "stream", "text", "toWeb", "uint8Array", "unsafeJson", "unsafeSetCookie", "unsafeSetCookies", "updateCookies", "urlParams", "TypeId", "Symbol", "for", "respondableSymbol", "ServerResponseImpl", "StructuralClass", "status", "statusText", "cookies", "body", "headers", "constructor", "contentType", "contentLength", "newHeaders", "toString", "commit", "succeed", "NodeInspectSymbol", "toJSON", "format", "_id", "redact", "isServerResponse", "u", "empty", "options", "fromInput", "redirect", "location", "unsafeFromRecord", "merge", "uint8Array", "getContentType", "text", "html", "strings", "args", "map", "make", "_", "htmlStream", "context", "stream", "provideContext", "encodeText", "json", "unsafeJson", "schemaJson", "schema", "encode", "jsonSchema", "httpPlatform", "GenericTag", "file", "path", "flatMap", "platform", "fileResponse", "fileWeb", "fileWebResponse", "urlParams", "raw", "formData", "setHeader", "dual", "self", "key", "value", "set", "replaceCookies", "setCookie", "name", "unsafeSetCookie", "unsafeSet", "updateCookies", "f", "setCookies", "setAll", "mergeCookies", "unsafeSetCookies", "unsafeSetAll", "removeCookie", "remove", "setHeaders", "input", "setStatus", "setBody", "_tag", "toWeb", "response", "globalThis", "Headers", "isEmpty", "toAdd", "toSetCookieHeaders", "header", "append", "withoutBody", "Response", "undefined", "toReadableStreamRuntime", "runtime", "defaultRuntime", "TypeId", "Symbol", "for", "isServerResponse", "empty", "redirect", "uint8Array", "text", "html", "htmlStream", "json", "schemaJson", "unsafeJson", "urlParams", "raw", "formData", "stream", "file", "fileWeb", "setHeader", "setHeaders", "removeCookie", "replaceCookies", "setCookie", "unsafeSetCookie", "updateCookies", "mergeCookies", "setCookies", "unsafeSetCookies", "setBody", "setStatus", "toWeb", "symbol", "Symbol", "for", "isRespondable", "u", "hasProperty", "badRequest", "empty", "status", "notFound", "toResponse", "self", "isServerResponse", "succeed", "orDie", "toResponseOrElse", "orElse", "catchAllCause", "isParseError", "isNoSuchElementException", "toResponseOrElseDefect", "RequestError", "ResponseError", "TypeId", "causeResponse", "causeResponseStripped", "clientAbortFiberId", "exitResponse", "isServerError", "TypeId", "Symbol", "for", "isServerError", "u", "hasProperty", "clientAbortFiberId", "globalValue", "runtime", "causeResponse", "cause", "effect", "stripped", "reduce", "succeed", "internalServerError", "empty", "acc", "_tag", "some", "toResponseOrElse", "error", "toResponseOrElseDefect", "defect", "none", "response", "fiberId", "clientAbortError", "serverAbortError", "map", "isEmptyType", "die", "sequential", "causeResponseStripped", "stripSomeDefects", "isServerResponse", "status", "exitResponse", "exit", "value", "TypeId", "RequestError", "TypeIdError", "symbol", "empty", "status", "methodAndUrl", "request", "method", "url", "message", "description", "reason", "isServerError", "RouteNotFound", "constructor", "options", "stack", "name", "ResponseError", "info", "response", "ServeError", "clientAbortFiberId", "causeResponse", "causeResponseStripped", "exitResponse", "Path", "TypeId", "layer", "TypeId", "Symbol", "for", "Path", "GenericTag", "normalizeStringPosix", "path", "allowAboveRoot", "res", "lastSegmentLength", "lastSlash", "dots", "code", "i", "length", "charCodeAt", "lastSlashIndex", "lastIndexOf", "slice", "_format", "sep", "pathObject", "dir", "root", "base", "name", "ext", "fromFileUrl", "url", "protocol", "fail", "BadArgument", "module", "method", "description", "hostname", "pathname", "n", "third", "codePointAt", "succeed", "decodeURIComponent", "resolve", "resolvedPath", "resolvedAbsolute", "cwd", "undefined", "arguments", "process", "globalThis", "CHAR_FORWARD_SLASH", "toFileUrl", "filepath", "outURL", "URL", "resolved", "filePathLast", "encodePathChars", "percentRegEx", "backslashRegEx", "newlineRegEx", "carriageReturnRegEx", "tabRegEx", "includes", "replace", "posixImpl", "of", "normalize", "isAbsolute", "trailingSeparator", "join", "joined", "arg", "relative", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toEnd", "toLen", "lastCommonSep", "fromCode", "toCode", "out", "dirname", "hasRoot", "end", "matchedSlash", "basename", "start", "extIdx", "firstNonSlashEnd", "extname", "startDot", "startPart", "preDotState", "format", "TypeError", "parse", "ret", "toNamespacedPath", "identity", "layer", "TypeId", "Path", "layer", "ErrorTypeId", "TypeId", "isFile", "schemaJson", "paramRE", "quotedPairRE", "mediaTypeRE", "mediaTypeRENoSlash", "defaultContentType", "value", "parameters", "Object", "create", "parse", "header", "withoutSlash", "index", "indexOf", "type", "slice", "trim", "mediaRE", "test", "result", "toLowerCase", "key", "match", "lastIndex", "exec", "length", "replace", "constMaxPairs", "constMaxSize", "State", "constContinue", "_tag", "constNameChars", "constValueChars", "make", "decoder", "TextDecoder", "state", "key", "headers", "Object", "create", "value", "undefined", "crlf", "previousChunk", "pairs", "size", "reset", "concatUint8Array", "a", "b", "newUint8Array", "Uint8Array", "length", "set", "error", "reason", "write", "chunk", "start", "endOffset", "previousCursor", "newChunk", "end", "outer", "i", "decode", "subarray", "toLowerCase", "whitespace", "byte", "push", "endPosition", "makeState", "needle_", "needle", "TextEncoder", "encode", "needleLength", "length", "indexes", "i", "b", "undefined", "push", "firstByte", "previousChunk", "previousChunkLength", "matchIndex", "make", "callback", "seed", "state", "makeIndexOf", "globalThis", "chunk", "fromIndex", "Buffer", "prototype", "indexOf", "call", "skipTable", "Uint8Array", "fill", "lastIndex", "lengthTotal", "j", "k", "write", "chunkLength", "newChunk", "set", "pos", "match", "subarray", "earliestIndex", "len", "index", "end", "State", "errInvalidDisposition", "_tag", "errEndNotReached", "errMaxParts", "limit", "errMaxTotalSize", "errMaxPartSize", "errMaxFieldSize", "constCR", "TextEncoder", "encode", "defaultIsFile", "info", "filename", "undefined", "contentType", "parseBoundary", "headers", "parse", "parameters", "boundary", "noopOnChunk", "_chunk", "make", "onFile", "onPart", "onField", "onError", "onDone", "isFile", "maxParts", "Infinity", "maxTotalSize", "maxPartSize", "maxFieldSize", "write", "end", "state", "index", "parts", "onChunk", "headerSkip", "partSize", "totalSize", "fieldChunks", "fieldSize", "skipBody", "body", "headerParser", "split", "chunk", "length", "buf", "Uint8Array", "offset", "i", "set", "result", "error", "contentDisposition", "value", "encodedFilename", "decodeURIComponent", "name", "contentTypeParameters", "contentDispositionParameters", "endPosition", "subarray", "push", "utf8Decoder", "TextDecoder", "getDecoder", "charset", "decodeField", "decode", "make", "defaultIsFile", "decodeField", "TypeId", "Symbol", "for", "isPart", "u", "hasProperty", "isField", "_tag", "isFile", "isPersistedFile", "isTagged", "ErrorTypeId", "MultipartError", "TaggedError", "reason", "Literal", "cause", "Defect", "message", "FileSchema", "declare", "identifier", "jsonSchema", "type", "format", "FilesSchema", "Array", "SingleFileSchema", "transform", "pipe", "itemsCount", "strict", "decode", "file", "encode", "schemaPersisted", "schema", "options", "decodeUnknown", "schemaJson", "fromJson", "parseJson", "dual", "persisted", "field", "map", "Struct", "_", "makeConfig", "headers", "withFiberRuntime", "fiber", "mimeTypes", "get", "currentContext", "FieldMimeTypes", "succeed", "maxParts", "getOrUndefined", "MaxParts", "maxFieldSize", "Number", "MaxFieldSize", "maxPartSize", "MaxFileSize", "maxTotalSize", "MaxBodySize", "length", "undefined", "info", "some", "contentType", "includes", "defaultIsFile", "makeChannel", "bufferSize", "acquireUseRelease", "all", "make", "config", "mailbox", "partsBuffer", "exit", "none", "input", "awaitRead", "void", "emit", "element", "offer", "error", "failCause", "end", "done", "_value", "parser", "onField", "value", "push", "FieldImpl", "name", "decodeField", "onFile", "chunks", "finished", "take", "suspend", "zipRight", "pump", "chunk", "unsafeFromArray", "write", "FileImpl", "onError", "error_", "fail", "convertError", "onDone", "flatMap", "takeAll", "sync", "Chunk", "forEach", "partsChannel", "writeExit", "embedInput", "shutdown", "self", "limit", "PartBase", "Class", "constructor", "key", "toJSON", "_id", "content", "contentEffect", "channel", "filename", "fromChannel", "pipeTo", "collectUint8Array", "run", "mapError", "defaultWriteFile", "path", "FileSystem", "fs", "sink", "accumulator", "Uint8Array", "loop", "readWithCause", "onInput", "newAccumulator", "set", "onFailure", "toPersisted", "stream", "writeFile", "gen", "path_", "Path", "dir", "makeTempDirectoryScoped", "Object", "create", "runForEach", "part", "join", "basename", "slice", "filePart", "PersistedFileImpl", "isArray", "catchTags", "SystemError", "BadArgument", "withLimits", "effect", "provide", "withLimitsContext", "contextMap", "Map", "Size", "maxFileSize", "fieldMimeTypes", "fromIterable", "unsafeMake", "withLimitsStream", "provideSomeContext", "Reference", "defaultValue", "withMaxParts", "count", "provideService", "constant", "withMaxFieldSize", "size", "withMaxFileSize", "withFieldMimeTypes", "TypeId", "makeChannel", "toChannel", "TypeId", "Symbol", "for", "isSocket", "u", "hasProperty", "Socket", "GenericTag", "CloseEventTypeId", "CloseEvent", "code", "reason", "constructor", "toString", "isCloseEvent", "SocketErrorTypeId", "isSocketError", "SocketGenericError", "TypeIdError", "message", "SocketCloseError", "is", "isClean", "closeReason", "toChannelMap", "self", "f", "gen", "scope", "mailbox", "make", "writeScope", "fork", "sequential", "write", "extend", "writer", "emit", "chunk", "data", "input", "awaitRead", "void", "catchAllCause", "cause", "failCause", "error", "zipRight", "close", "done", "runRaw", "unsafeOffer", "pipe", "into", "forkIn", "interruptible", "embedInput", "toChannel", "unwrapScoped", "encoder", "TextEncoder", "encode", "toChannelString", "dual", "args", "encoding", "decoder", "TextDecoder", "decode", "toChannelWith", "makeChannel", "unwrap", "map", "defaultCloseCodeIsError", "WebSocket", "WebSocketConstructor", "layerWebSocketConstructorGlobal", "succeed", "url", "protocols", "globalThis", "makeWebSocket", "options", "fromWebSocket", "acquireRelease", "flatMap", "ws", "sync", "acquire", "withFiberRuntime", "fiber", "currentWS", "latch", "unsafeMakeLatch", "acquireContext", "currentContext", "closeCodeIsError", "handler", "scopedWith", "fiberSet", "run", "provideService", "runtime", "open", "onMessage", "event", "Blob", "promise", "arrayBuffer", "andThen", "buffer", "Uint8Array", "result", "isEffect", "onError", "removeEventListener", "onClose", "Deferred", "unsafeDone", "deferred", "fail", "addEventListener", "once", "readyState", "openDeferred", "unsafeMake", "id", "await", "timeoutFail", "duration", "openTimeout", "onTimeout", "raceFirst", "join", "catchIf", "_", "mapInputContext", "merge", "ensuring", "unsafeClose", "undefined", "whenOpen", "send", "of", "makeWebSocketChannel", "layerWebSocket", "effect", "currentSendQueueCapacity", "globalValue", "fromTransformStream", "currentStream", "stream", "reader", "readable", "getReader", "addFinalizer", "cancel", "runFork", "tryPromise", "try", "value", "read", "catch", "writers", "WeakMap", "getWriter", "get", "writable", "set", "suspend", "TypeId", "fromWeb", "schemaBodyForm", "schemaBodyFormJson", "schemaBodyJson", "schemaBodyMultipart", "schemaBodyUrlParams", "schemaCookies", "schemaHeaders", "schemaSearchParams", "searchParamsFromURL", "toURL", "upgrade", "upgradeChannel", "TypeId", "Symbol", "for", "serverRequestTag", "GenericTag", "parsedSearchParamsTag", "upgrade", "flatMap", "request", "upgradeChannel", "unwrap", "map", "toChannelWith", "multipartPersisted", "multipart", "searchParamsFromURL", "url", "out", "key", "value", "searchParams", "entries", "entry", "undefined", "Array", "isArray", "push", "schemaCookies", "schema", "options", "parse", "decodeUnknown", "req", "cookies", "schemaHeaders", "schemaSearchParams", "schemaBodyJson", "isMultipart", "headers", "toLowerCase", "includes", "schemaBodyForm", "parseMultipart", "schemaPersisted", "parseUrlParams", "schemaBodyUrlParams", "schemaBodyMultipart", "schemaBodyFormJson", "schemaJson", "field", "mapError", "cause", "RequestError", "reason", "urlParamsBody", "fromWeb", "ServerRequestImpl", "removeHost", "index", "indexOf", "slice", "Class", "source", "headersOverride", "remoteAddressOverride", "constructor", "toJSON", "inspect", "_id", "method", "originalUrl", "modify", "remoteAddress", "toUpperCase", "some", "none", "fromInput", "cachedCookies", "parseHeader", "cookie", "stream", "body", "fromReadableStream", "fail", "description", "textEffect", "text", "runSync", "cached", "tryPromise", "try", "catch", "json", "tryMap", "_", "JSON", "URLSearchParams", "multipartEffect", "toPersisted", "multipartStream", "pipeThroughChannel", "MultipartError", "makeChannel", "arrayBufferEffect", "arrayBuffer", "toURL", "self", "host", "protocol", "URL", "TypeId", "HttpServerRequest", "serverRequestTag", "ParsedSearchParams", "parsedSearchParamsTag", "searchParamsFromURL", "persistedMultipart", "multipartPersisted", "upgrade", "upgradeChannel", "schemaCookies", "schemaHeaders", "schemaSearchParams", "schemaBodyJson", "schemaBodyForm", "schemaBodyUrlParams", "schemaBodyMultipart", "schemaBodyFormJson", "fromWeb", "toURL", "appendPreResponseHandler", "currentPreResponseHandlers", "withPreResponseHandler", "currentPreResponseHandlers", "globalValue", "Symbol", "for", "unsafeMake", "none", "appendPreResponseHandler", "handler", "update", "match", "onNone", "some", "onSome", "prev", "request", "response", "flatMap", "withPreResponseHandler", "dual", "self", "locallyWith", "make", "middleware", "loggerDisabled", "globalValue", "Symbol", "for", "unsafeMake", "withLoggerDisabled", "self", "zipRight", "set", "currentTracerDisabledWhen", "constFalse", "withTracerDisabledWhen", "dual", "pred", "locally", "withTracerDisabledWhenEffect", "withTracerDisabledForUrls", "urls", "req", "includes", "url", "SpanNameGenerator", "Reference", "defaultValue", "request", "method", "withSpanNameGenerator", "f", "provide", "succeed", "logger", "httpApp", "counter", "withFiberRuntime", "fiber", "unsafeGet", "currentContext", "HttpServerRequest", "withLogSpan", "flatMap", "exit", "getFiberRef", "_tag", "response", "cause", "causeResponseStripped", "annotateLogs", "log", "value", "status", "tracer", "disabled", "getOrUndefined", "toURL", "undefined", "username", "password", "redactedHeaderNames", "currentRedactedNames", "redactedHeaders", "redact", "headers", "nameGenerator", "get", "useSpan", "parent", "fromHeaders", "kind", "captureStackTrace", "span", "attribute", "toString", "pathname", "query", "search", "slice", "protocol", "name", "String", "remoteAddress", "withParentSpan", "exitResponse", "xForwardedHeaders", "updateService", "modify", "split", "trim", "searchParamsParser", "context", "params", "searchParamsFromURL", "URL", "originalUrl", "add", "ParsedSearchParams", "cors", "options", "opts", "allowedOrigins", "allowedMethods", "allowedHeaders", "exposedHeaders", "credentials", "isAllowedOrigin", "origin", "allowOrigin", "originHeader", "length", "vary", "allowMethods", "join", "allowCredentials", "allowHeaders", "accessControlRequestHeaders", "exposeHeaders", "maxAge", "headersFromRequest", "unsafeFromRecord", "headersFromRequestOptions", "preResponseHandler", "setHeaders", "empty", "appendPreResponseHandler", "handledSymbol", "Symbol", "for", "toHandled", "self", "handleResponse", "middleware", "responded", "withFiberRuntime", "fiber", "flatMap", "response", "request", "unsafeGet", "currentContext", "HttpServerRequest", "handler", "getFiberRef", "currentPreResponseHandlers", "_tag", "as", "tap", "value", "withErrorHandling", "catchAllCause", "cause", "causeResponse", "zipRight", "failCause", "withMiddleware", "unify", "undefined", "tracer", "matchCauseEffect", "onFailure", "void", "_cause", "empty", "status", "onSuccess", "uninterruptible", "scoped", "ejectDefaultScopeClose", "scope", "ejectedScopes", "add", "unsafeEjectStreamScope", "body", "getOrThrow", "getCurrentFiber", "Scope", "setBody", "stream", "ensuring", "close", "contentType", "contentLength", "globalValue", "WeakSet", "effect", "make", "onExit", "extend", "exit", "has", "appendPreResponseHandler", "withPreResponseHandler", "toWebHandlerRuntime", "runtime", "run", "runFork", "resolveSymbol", "httpApp", "toWeb", "withoutBody", "method", "context", "Promise", "resolve", "contextMap", "Map", "unsafeMap", "isContext", "key", "set", "httpServerRequest", "fromWeb", "locally", "unsafeMake", "signal", "addEventListener", "unsafeInterruptAsFork", "clientAbortFiberId", "once", "toWebHandler", "defaultRuntime", "toWebHandlerLayer", "layer", "runSync", "runPromise", "build", "map", "toRuntime", "_", "runner", "then", "all", "hasBody", "method", "Set", "isHttpMethod", "u", "has", "SpanNameGenerator", "cors", "currentTracerDisabledWhen", "logger", "loggerDisabled", "make", "searchParamsParser", "withLoggerDisabled", "withSpanNameGenerator", "withTracerDisabledForUrls", "withTracerDisabledWhen", "withTracerDisabledWhenEffect", "xForwardedHeaders", "make", "logger", "loggerDisabled", "withLoggerDisabled", "currentTracerDisabledWhen", "withTracerDisabledWhen", "withTracerDisabledWhenEffect", "withTracerDisabledForUrls", "xForwardedHeaders", "searchParamsParser", "cors", "SpanNameGenerator", "withSpanNameGenerator", "SpanNameGenerator", "TypeId", "catchAll", "catchTag", "catchTags", "currentTracerDisabledWhen", "currentTracerPropagation", "del", "execute", "filterOrElse", "filterOrFail", "filterStatus", "filterStatusOk", "followRedirects", "get", "head", "layerMergedContext", "make", "makeWith", "mapRequest", "mapRequestEffect", "mapRequestInput", "mapRequestInputEffect", "options", "patch", "post", "put", "retry", "retryTransient", "tap", "tapError", "tapRequest", "transform", "transformResponse", "withCookiesRef", "withScope", "withSpanNameGenerator", "withTracerDisabledWhen", "withTracerPropagation", "TypeId", "Symbol", "for", "Proto", "BaseProto", "toJSON", "_id", "method", "url", "urlParams", "hash", "headers", "redact", "body", "pipe", "pipeArguments", "arguments", "makeInternal", "self", "Object", "create", "isClientRequest", "u", "empty", "none", "make", "options", "modify", "undefined", "get", "post", "put", "patch", "del", "head", "dual", "result", "setMethod", "setUrl", "setHeaders", "setUrlParams", "setHash", "setBody", "accept", "acceptJson", "setHeader", "key", "value", "set", "input", "setAll", "stringOrRedacted", "basicAuth", "username", "password", "btoa", "bearerToken", "token", "mediaType", "clone", "URL", "toString", "fromInput", "searchParams", "some", "slice", "search", "appendUrl", "endsWith", "startsWith", "prependUrl", "updateUrl", "f", "appendUrlParam", "append", "appendUrlParams", "appendAll", "setUrlParam", "removeHash", "toUrl", "getRight", "makeUrl", "_tag", "remove", "contentType", "contentLength", "bodyUint8Array", "args", "uint8Array", "bodyText", "text", "bodyJson", "map", "json", "bodyUnsafeJson", "unsafeJson", "bodyFile", "path", "file", "bodyFileWeb", "fileWeb", "schemaBodyJson", "schema", "encode", "jsonSchema", "bodyUrlParams", "bodyFormData", "formData", "bodyFormDataRecord", "entries", "formDataRecord", "bodyStream", "stream", "TypeId", "Symbol", "for", "fromWeb", "request", "source", "ClientResponseImpl", "Class", "constructor", "toJSON", "inspect", "_id", "status", "headers", "fromInput", "cachedCookies", "cookies", "fromSetCookie", "getSetCookie", "remoteAddress", "none", "stream", "body", "fromReadableStream", "cause", "ResponseError", "response", "reason", "fail", "description", "json", "tryMap", "text", "try", "JSON", "parse", "catch", "textBody", "tryPromise", "pipe", "cached", "runSync", "urlParamsBody", "flatMap", "_", "URLSearchParams", "formDataBody", "formData", "arrayBufferBody", "arrayBuffer", "schemaJson", "schema", "options", "decodeUnknown", "self", "schemaNoBody", "effect", "unwrap", "map", "matchStatus", "dual", "cases", "orElse", "filterStatus", "f", "suspend", "succeed", "filterStatusOk", "TypeId", "Symbol", "for", "tag", "GenericTag", "currentTracerDisabledWhen", "globalValue", "unsafeMake", "constFalse", "withTracerDisabledWhen", "dual", "self", "pred", "transformResponse", "locally", "currentTracerPropagation", "withTracerPropagation", "enabled", "SpanNameGenerator", "Reference", "defaultValue", "request", "method", "withSpanNameGenerator", "f", "provideService", "ClientProto", "pipe", "pipeArguments", "arguments", "BaseProto", "toJSON", "_id", "get", "url", "options", "execute", "head", "post", "put", "patch", "del", "isClient", "u", "hasProperty", "makeWith", "postprocess", "preprocess", "Object", "create", "responseRegistry", "globalThis", "FinalizationRegistry", "registry", "controller", "abort", "register", "response", "unregister", "timers", "Map", "set", "setTimeout", "timer", "undefined", "clearTimeout", "delete", "scopedRequests", "WeakMap", "make", "effect", "flatMap", "withFiberRuntime", "fiber", "scopedController", "AbortController", "urlResult", "makeUrl", "urlParams", "hash", "_tag", "fail", "RequestError", "reason", "cause", "left", "right", "tracerDisabled", "getFiberRef", "currentTracerEnabled", "signal", "uninterruptibleMask", "restore", "matchCauseEffect", "onSuccess", "succeed", "InterruptibleResponse", "onFailure", "isInterrupted", "failCause", "nameGenerator", "currentContext", "useSpan", "kind", "captureStackTrace", "span", "attribute", "origin", "port", "toString", "pathname", "protocol", "slice", "query", "search", "redactedHeaderNames", "currentRedactedNames", "redactedHeaders", "redact", "headers", "name", "String", "setHeaders", "toHeaders", "withParentSpan", "status", "original", "constructor", "applyInterrupt", "suspend", "onInterrupt", "sync", "cookies", "remoteAddress", "formData", "text", "json", "urlParamsBody", "arrayBuffer", "stream", "ensuringWith", "exit", "void", "NodeInspectSymbol", "withScope", "transform", "zipRight", "scopeWith", "scope", "addFinalizer", "serviceFunctions", "client", "filterStatus", "filterStatusOk", "catchTag", "catchTags", "cases", "catchAll", "filterOrElse", "orElse", "filterOrFail", "orFailWith", "mapRequest", "map", "mapRequestEffect", "mapRequestInput", "mapRequestInputEffect", "retry", "policy", "retryTransient", "while", "ScheduleTypeId", "isTransientError", "or", "schedule", "times", "error", "TimeoutExceptionTypeId", "isTransientHttpError", "isHttpClientError", "tap", "tapError", "tapRequest", "withCookiesRef", "ref", "update", "merge", "isEmpty", "setHeader", "toCookieHeader", "followRedirects", "args", "maxRedirects", "loop", "redirects", "location", "setUrl", "URL", "layerMergedContext", "context", "mapInputContext", "input", "TypeId", "HttpClient", "tag", "execute", "get", "head", "post", "patch", "put", "del", "options", "catchAll", "catchTag", "catchTags", "filterOrElse", "filterOrFail", "filterStatus", "filterStatusOk", "makeWith", "make", "transform", "transformResponse", "mapRequest", "mapRequestEffect", "mapRequestInput", "mapRequestInputEffect", "retry", "retryTransient", "tap", "tapError", "tapRequest", "withCookiesRef", "followRedirects", "currentTracerDisabledWhen", "withTracerDisabledWhen", "currentTracerPropagation", "withTracerPropagation", "layerMergedContext", "SpanNameGenerator", "withSpanNameGenerator", "withScope", "TypeId", "accept", "acceptJson", "appendUrl", "appendUrlParam", "appendUrlParams", "basicAuth", "bearerToken", "bodyFile", "bodyFileWeb", "bodyFormData", "bodyFormDataRecord", "bodyJson", "bodyStream", "bodyText", "bodyUint8Array", "bodyUnsafeJson", "bodyUrlParams", "del", "get", "head", "make", "modify", "options", "patch", "post", "prependUrl", "put", "removeHash", "schemaBodyJson", "setBody", "setHash", "setHeader", "setHeaders", "setMethod", "setUrl", "setUrlParam", "setUrlParams", "toUrl", "updateUrl", "TypeId", "Symbol", "for", "make", "get", "post", "patch", "put", "del", "head", "options", "modify", "setMethod", "setHeader", "setHeaders", "basicAuth", "bearerToken", "accept", "acceptJson", "setUrl", "prependUrl", "appendUrl", "updateUrl", "setUrlParam", "setUrlParams", "appendUrlParam", "appendUrlParams", "setHash", "removeHash", "toUrl", "setBody", "bodyUint8Array", "bodyText", "bodyJson", "bodyUnsafeJson", "schemaBodyJson", "bodyUrlParams", "bodyFormData", "bodyFormDataRecord", "bodyStream", "bodyFile", "bodyFileWeb", "TypeId", "addressFormattedWith", "addressWith", "formatAddress", "layerContext", "layerTestClient", "logAddress", "make", "serve", "serveEffect", "withLogAddress", "TypeId", "Symbol", "for", "tag", "GenericTag", "make", "impl", "gen", "fs", "FileSystem", "etagGen", "Generator", "of", "fileResponse", "path", "options", "pipe", "bindTo", "stat", "bind", "info", "fromFileInfo", "map", "etag", "start", "Number", "offset", "end", "bytesToRead", "undefined", "headers", "set", "fromInput", "empty", "toString", "mtime", "_tag", "value", "toUTCString", "contentLength", "size", "status", "statusText", "fileWebResponse", "file", "fromFileWeb", "merge", "unsafeFromRecord", "Date", "lastModified", "layer", "effect", "flatMap", "stream", "_options", "fromReadableStream", "identity", "provide", "layerWeak", "TypeId", "Symbol", "for", "serverTag", "GenericTag", "serverProto", "make", "options", "Object", "assign", "create", "serverProto", "serve", "dual", "args", "isEffect", "httpApp", "middleware", "scopedDiscard", "flatMap", "serverTag", "server", "serveEffect", "formatAddress", "address", "_tag", "path", "hostname", "port", "addressWith", "effect", "addressFormattedWith", "logAddress", "_", "log", "withLogAddress", "layer", "effectDiscard", "pipe", "provideMerge", "makeTestClient", "HttpClient", "client", "die", "Error", "host", "url", "succeed", "mapRequest", "prependUrl", "layerTestClient", "layerContext", "mergeAll", "layerWeak", "layerNoop", "TypeId", "HttpServer", "serverTag", "make", "serve", "serveEffect", "formatAddress", "addressWith", "addressFormattedWith", "logAddress", "withLogAddress", "layerTestClient", "layerContext", "RouteContext", "RouteContextTypeId", "RouteTypeId", "Tag", "TypeId", "all", "append", "catchAll", "catchAllCause", "catchTag", "catchTags", "concat", "concatAll", "currentRouterConfig", "del", "empty", "fromIterable", "get", "head", "makeRoute", "mount", "mountApp", "options", "params", "patch", "post", "prefixAll", "prefixPath", "provideService", "provideServiceEffect", "put", "route", "schemaJson", "schemaNoBody", "schemaParams", "schemaPathParams", "setRouterConfig", "transform", "use", "withRouterConfig", "esm_exports", "make", "plusRegex", "Empty", "prototype", "Object", "create", "parse", "input", "result", "inputLength", "length", "key", "value", "startingIndex", "equalityIndex", "shouldDecodeKey", "shouldDecodeValue", "keyHasPlus", "valueHasPlus", "hasBothKeyValuePair", "c", "i", "charCodeAt", "slice", "replace", "decodeURIComponent", "currentValue", "undefined", "pop", "push", "hexTable", "Array", "from", "length", "_", "i", "toString", "toUpperCase", "noEscape", "Int8Array", "FULL_PATH_REGEXP", "OPTIONAL_PARAM_REGEXP", "make", "options", "RouterImpl", "constructor", "ignoreTrailingSlash", "ignoreDuplicateSlashes", "caseSensitive", "maxParamLength", "routes", "trees", "on", "method", "path", "handler", "optionalParamMatch", "match", "index", "undefined", "assert", "length", "pathFull", "replace", "pathOptional", "removeDuplicateSlashes", "trimLastSlash", "methods", "_on", "all", "httpMethods", "StaticNode", "pattern", "prefix", "currentRoot", "staticChildren", "parentNodePathIndex", "currentNode", "params", "i", "charCodeAt", "isParametricNode", "isWildcardNode", "staticNodePath", "slice", "toLowerCase", "split", "join", "createStaticChild", "isRegexNode", "regexps", "lastParamStartIndex", "j", "charCode", "isRegexParam", "isStaticPart", "isEndOfNode", "paramName", "push", "endOfRegexIndex", "getClosingParenthensePosition", "regexString", "trimRegExpStartAndEnd", "staticPartStartIndex", "nextCharCode", "staticPart", "escapeRegExp", "nodePattern", "nodePath", "regex", "RegExp", "createParametricChild", "createWildcardChild", "Error", "existRoute", "route", "addRoute", "has", "node", "staticNode", "getStaticChild", "isLeafNode", "find", "sanitizedUrl", "querystring", "shouldDecodeParam", "safeDecodeURI", "error", "originPath", "pathIndex", "pathLen", "brothersNodesStack", "handle", "handlerStorage", "createParams", "searchParams", "parse", "getNextNode", "brotherNodeState", "pop", "brotherPathIndex", "splice", "paramsCount", "brotherNode", "_tag", "param", "safeDecodeURIComponent", "paramEndIndex", "indexOf", "matchedParameters", "exec", "matchedParam", "HandlerStorage", "handlers", "unconstrainedHandler", "add", "compileCreateParams", "NodeBase", "ParentNode", "findStaticMatchingChild", "staticChild", "charAt", "matchPrefix", "label", "setPrefix", "parametricChildren", "wildcardChild", "_path", "_pathIndex", "len", "getParametricChild", "child", "isRegex", "source", "staticSuffix", "nodePaths", "ParametricNode", "sort", "child1", "child2", "endsWith", "WildcardNode", "parentNode", "parentPrefix", "childPrefix", "nodeStack", "parametricBrotherNodeIndex", "Set", "_nodeStack", "_paramsCount", "condition", "message", "paramsArray", "paramsObject", "idx", "parentheses", "TypeError", "string", "decodeComponentChar", "highCharCode", "lowCharCode", "shouldDecode", "decodedPath", "decodeURI", "uriComponent", "startIndex", "decoded", "lastIndex", "decodedChar", "make", "TypeId", "Symbol", "for", "RouteTypeId", "RouteContextTypeId", "RouteContext", "GenericTag", "isRouter", "u", "hasProperty", "params", "map", "_", "schemaJson", "schema", "options", "parse", "decodeUnknown", "flatMap", "context", "request", "get", "HttpServerRequest", "searchParams", "ParsedSearchParams", "routeContext", "json", "body", "method", "url", "headers", "cookies", "pathParams", "schemaNoBody", "schemaParams", "schemaPathParams", "currentRouterConfig", "globalValue", "unsafeMake", "withRouterConfig", "dual", "effect", "config", "locally", "setRouterConfig", "locallyScoped", "RouterImpl", "StructuralClass", "routes", "mounts", "constructor", "httpApp", "pipe", "toHttpApp", "commit", "toJSON", "_id", "toString", "format", "NodeInspectSymbol", "self", "router", "make", "toReadonlyArray", "path", "app", "RouteContextImpl", "RouteImpl", "includePrefix", "none", "some", "mountsLen", "length", "Chunk", "forEach", "route", "all", "on", "withFiberRuntime", "fiber", "Map", "getFiberRef", "currentContext", "unsafeMap", "unsafeGet", "searchIndex", "indexOf", "pathname", "slice", "i", "startsWith", "set", "key", "sliceRequestUrl", "handler", "toResponse", "result", "find", "undefined", "fail", "RouteNotFound", "prefix", "_tag", "value", "span", "getOption", "ParentSpan", "attribute", "handlerResponse", "uninterruptible", "interruptible", "prefexLen", "modify", "Class", "empty", "fromIterable", "makeRoute", "append", "concat", "that", "concatAll", "routers", "reduce", "cur", "acc", "appendAll", "removeTrailingSlash", "endsWith", "prefixPath", "prefixAll", "orElse", "mount", "mountApp", "args", "post", "put", "patch", "del", "head", "use", "f", "transform", "catchAll", "catchAllCause", "catchTag", "k", "catchTags", "cases", "provideService", "tag", "service", "provideServiceEffect", "makeService", "addRoute", "sync", "opts", "Tag", "id", "Err", "globalThis", "Error", "limit", "stackTraceLimit", "creationError", "TagClass", "TagClass_", "Object", "setPrototypeOf", "getPrototypeOf", "defineProperty", "stack", "Live", "scopedDiscard", "provide", "unwrap", "unwrapEffect", "serve", "middleware", "TypeId", "RouteTypeId", "RouteContextTypeId", "RouteContext", "params", "schemaJson", "schemaNoBody", "schemaParams", "schemaPathParams", "currentRouterConfig", "withRouterConfig", "setRouterConfig", "empty", "fromIterable", "makeRoute", "prefixPath", "prefixAll", "append", "concat", "concatAll", "mount", "mountApp", "route", "all", "get", "post", "patch", "put", "del", "head", "options", "use", "transform", "catchAll", "catchAllCause", "catchTag", "catchTags", "provideService", "provideServiceEffect", "Tag", "Default", "fromAST", "make", "make", "schema", "defs", "out", "makeWithDefs", "isEmptyRecord", "$defs", "options", "fromAST", "ast", "jsonSchema", "definitions", "definitionPath", "defsPath", "target", "topLevelReferenceStrategy", "additionalPropertiesStrategy", "annotations", "Identifier", "Tag", "Title", "Version", "Description", "License", "ExternalDocs", "Servers", "Format", "Summary", "Deprecated", "Override", "Exclude", "Reference", "defaultValue", "constFalse", "Transform", "contextPartial", "tags", "entries", "Object", "options", "context", "empty", "key", "tag", "undefined", "add", "annotations", "identifier", "title", "version", "description", "license", "summary", "deprecated", "externalDocs", "servers", "format", "override", "exclude", "transform", "apiCache", "globalValue", "WeakMap", "processAnnotation", "ctx", "f", "o", "getOption", "isSome", "value", "fromApi", "api", "cached", "get", "jsonSchemaDefs", "spec", "openapi", "info", "getOrElse", "paths", "components", "schemas", "securitySchemes", "security", "processAST", "ast", "fromAST", "defs", "additionalPropertiesStrategy", "processHttpApiSecurity", "name", "makeSecurityScheme", "AdditionalSchemas", "componentSchemas", "forEach", "componentSchema", "middlewares", "middleware", "isSecurity", "push", "HttpApi", "reflect", "onGroup", "group", "assign", "transformFn", "onEndpoint", "endpoint", "errors", "mergedAnnotations", "payloads", "successes", "op", "operationId", "topLevel", "parameters", "responses", "processResponseMap", "map", "defaultDescription", "status", "pipe", "filter", "getEmptyDecodeable", "encoding", "getEncoding", "content", "contentType", "schema", "processParameters", "i", "jsonSchema", "properties", "psJsonSchema", "in", "required", "includes", "hasBody", "method", "size", "requestBody", "pathSchema", "payloadSchema", "headersSchema", "urlParamsSchema", "path", "replace", "toLowerCase", "set", "meta", "_tag", "type", "scheme", "bearerFormat", "getOrUndefined", "serve", "toWebHandler", "Router", "Tag", "api", "effect", "Api", "map", "context", "serve", "middleware", "httpApp", "pipe", "app", "unwrapEffect", "provide", "Live", "Middleware", "layer", "gen", "makeMiddlewareMap", "middlewares", "router", "applyMiddleware", "apiMiddlewareService", "apiMiddleware", "retrieve", "errorSchema", "makeErrorSchema", "encodeError", "encodeUnknown", "catchAllCause", "cause", "matchEffect", "squash", "onFailure", "failCause", "onSuccess", "succeed", "buildMiddleware", "fnUntraced", "middlewareMap", "toWebHandler", "options", "runtime", "make", "mergeAll", "memoMap", "handlerCached", "handlerPromise", "rt", "runtimeEffect", "handler", "toWebHandlerRuntime", "runPromise", "request", "undefined", "then", "dispose", "HandlersTypeId", "Symbol", "for", "HandlersProto", "_Endpoints", "identity", "pipeArguments", "arguments", "handle", "name", "endpoint", "group", "endpoints", "makeHandlers", "handlers", "append", "withFullRequest", "uninterruptible", "handleRaw", "self", "Object", "create", "groupName", "build", "use", "groups", "result", "empty", "isEffect", "groupMiddleware", "routes", "item", "push", "handlerToRoute", "mapInputContext", "input", "merge", "concat", "fromIterable", "_api", "_groupName", "_name", "f", "requestPayload", "urlParams", "multipartLimits", "hasBody", "method", "contentType", "headers", "toLowerCase", "trim", "includes", "orDie", "json", "match", "onNone", "multipart", "onSome", "limits", "withLimits", "urlParamsBody", "toRecord", "startsWith", "text", "arrayBuffer", "buffer", "Uint8Array", "initial", "Map", "forEach", "tag", "set", "key", "unsafeGet", "isSingleStringType", "ast", "_tag", "ps", "propertySignatures", "find", "type", "indexSignatures", "some", "is", "parameter", "types", "from", "normalizeUrlParams", "params", "out", "value", "Array", "isArray", "endpoint_", "isFullRequest", "isMultipartStream", "payloadSchema", "getMultipartStream", "getOrElse", "constFalse", "flatMapNullable", "getMultipart", "decodePath", "pathSchema", "decodeUnknown", "decodePayload", "none", "decodeHeaders", "headersSchema", "encodeSuccess", "encode", "makeSuccessSchema", "successSchema", "makeRoute", "path", "fiber", "getOrThrow", "getCurrentFiber", "currentContext", "httpRequest", "HttpServerRequest", "routeContext", "RouteContext", "ParsedSearchParams", "payload", "flatMap", "multipartStream", "withLimitsStream", "urlParamsSchema", "schema", "response", "isServerResponse", "catchIf", "isParseError", "HttpApiDecodeError", "refailParseError", "entry", "values", "SecurityTypeId", "makeSecurityMiddleware", "optional", "previous", "provides", "provideService", "_", "provideServiceEffect", "zipRight", "securityMiddlewareCache", "globalValue", "WeakMap", "has", "get", "security", "entries", "decode", "securityDecode", "catchAll", "void", "responseSchema", "declare", "schemas", "Set", "HttpApiSchema", "deunionize", "Union", "toResponseSuccess", "toResponseError", "decodeForbidden", "__", "fail", "Forbidden", "toResponseSchema", "getStatus", "cache", "schemaToResponse", "data", "isEmpty", "isVoid", "to", "status", "encoding", "getEncoding", "kind", "mapError", "error", "Type", "uint8Array", "transform", "transformOrFail", "getStatusSuccessAST", "getStatusErrorAST", "sync", "of", "add", "prev", "middlewareAdd", "service", "middlewareAddNoContext", "args", "apiFirst", "isHttpApi", "withContext", "scopedDiscard", "middlewareCors", "cors", "middlewareOpenApi", "spec", "fromApi", "additionalPropertiesStrategy", "bearerLen", "length", "basicLen", "authorization", "slice", "in", "Struct", "String", "unify", "schemaSearchParams", "schemaCookies", "schemaHeaders", "username", "password", "decodeBase64String", "header", "parts", "split", "securitySetCookie", "stringValue", "appendPreResponseHandler", "_req", "setCookie", "secure", "httpOnly", "esm_exports", "RouteContext", "RouteTypeId", "TypeId", "add", "cors", "layer", "make", "middleware", "params", "prefixPath", "route", "schemaJson", "schemaNoBody", "schemaParams", "schemaPathParams", "serve", "toWebHandler", "use", "TypeId", "Symbol", "for", "HttpRouter", "GenericTag", "make", "gen", "router", "RouterConfig", "middleware", "Set", "addAll", "routes", "contextWith", "context", "getMiddleware", "applyMiddleware", "effect", "i", "length", "route", "makeRoute", "handler", "method", "all", "path", "on", "of", "prefixed", "prefix", "newPrefix", "prefixPath", "map", "prefixRoute", "add", "options", "isEffect", "flatMap", "HttpServerRequest", "uninterruptible", "some", "addGlobalMiddleware", "middleware_", "sync", "asHttpEffect", "withFiberRuntime", "fiber", "contextMap", "Map", "currentContext", "unsafeMap", "request", "get", "key", "result", "find", "url", "undefined", "fail", "RouteNotFound", "_tag", "set", "sliceRequestUrl", "value", "ParsedSearchParams", "searchParams", "RouteContext", "RouteContextTypeId", "params", "span", "ParentSpan", "attribute", "locally", "interruptible", "unsafeMake", "size", "fn", "reverse", "prefexLen", "modify", "slice", "Reference", "defaultValue", "constant", "use", "f", "scopedDiscard", "toAdd", "layer", "toHttpEffect", "appLayer", "scope", "memoMap", "CurrentMemoMap", "buildWithMemoMap", "provideMerge", "RouteTypeId", "none", "removeTrailingSlash", "endsWith", "dual", "self", "match", "onNone", "onSome", "existingPrefix", "MiddlewareTypeId", "arguments", "makeMiddleware", "global", "MiddlewareImpl", "scopedContext", "fnContextKey", "succeedContext", "middlewareId", "layerFn", "dependencies", "constructor", "contextKey", "stack", "Scope", "depsContext", "push", "pipe", "provide", "combine", "other", "middlewareCache", "WeakMap", "arr", "topLevel", "empty", "maxLength", "startsWith", "fromIterable", "cors", "disableLogger", "withLoggerDisabled", "addHttpApi", "api", "ApiMiddleware", "buildMiddleware", "Router", "unwrap", "fnUntraced", "router_", "openapiPath", "spec", "fromApi", "succeed", "unsafeJson", "effectDiscard", "serve", "compose", "logger", "RouterLayer", "routerConfig", "unwrapScoped", "disableListenLog", "identity", "withLogAddress", "toWebHandler", "runtime", "handlerCached", "handlerPromise", "rt", "runtimeEffect", "toWebHandlerRuntime", "runPromise", "then", "dispose", "ErrorTypeId", "duplex", "pack", "schema", "unpack", "addExtension", "decode", "encode", "options", "forEach", "value", "options", "value", "map", "readObject", "map", "value", "target", "decode", "position", "bundledStrings", "options", "referenceMap", "value", "pack", "maxBytes", "json", "key", "newPosition", "seconds", "target", "targetView", "set", "encode", "addExtension", "encode", "options", "value", "ErrorTypeId", "Symbol", "for", "MsgPackError", "TaggedError", "message", "reason", "pack", "suspend", "packr", "Packr", "loop", "readWithCause", "onInput", "input", "zipRight", "flatMap", "try", "of", "toReadonlyArray", "catch", "cause", "write", "onFailure", "failCause", "onDone", "succeed", "packSchema", "schema", "pipeTo", "encode", "unpack", "sync", "Unpackr", "incomplete", "undefined", "value", "buf", "chunk", "Uint8Array", "length", "set", "unsafeFromArray", "unpackMultiple", "flat", "error_", "error", "subarray", "lastPosition", "values", "unpackSchema", "decodeUnknown", "duplex", "self", "duplexSchema", "dual", "options", "duplexUnknown", "transformOrFail", "Uint8ArrayFromSelf", "decode", "fromA", "_", "ast", "Type", "hasProperty", "String", "toI", "ErrorTypeId", "SocketServer", "Tag", "ErrorTypeId", "Symbol", "for", "SocketServerError", "TaggedError", "message", "reason", "Uint8Array", "addAll", "schema", "Collector", "Tag", "unsafeMakeCollector", "tranferables", "unsafeAddAll", "transfers", "push", "unsafeRead", "unsafeClear", "prev", "of", "addAll", "transferables", "sync", "read", "clear", "makeCollector", "flatMap", "serviceOption", "match", "onNone", "void", "onSome", "_", "schema", "dual", "self", "f", "transformOrFail", "encodedSchema", "strict", "decode", "succeed", "encode", "i", "as", "ImageData", "Any", "data", "buffer", "MessagePort", "Uint8Array", "Uint8ArrayFromSelf", "WorkerErrorTypeId", "WorkerErrorTypeId", "Symbol", "for", "WorkerErrorTypeId", "isWorkerError", "u", "hasProperty", "WorkerError", "TaggedError", "reason", "Literal", "cause", "Defect", "Cause", "error", "defect", "encodeCause", "encodeSync", "decodeCause", "decodeSync", "message", "PlatformWorker", "PlatformWorkerTypeId", "Spawner", "WorkerManager", "WorkerManagerTypeId", "layerManager", "layerSpawner", "makeManager", "makePlatform", "makePool", "makePoolLayer", "makePoolSerialized", "makePoolSerializedLayer", "makeSerialized", "PlatformWorkerTypeId", "Symbol", "for", "PlatformWorker", "GenericTag", "WorkerManagerTypeId", "WorkerManager", "Spawner", "makeManager", "gen", "platform", "idCounter", "of", "spawn", "encode", "initialMessage", "id", "requestIdCounter", "requestMap", "Map", "collector", "unsafeMakeCollector", "wrappedEncode", "message", "zipRight", "clear", "provideService", "Collector", "succeed", "readyLatch", "make", "backing", "run", "complete", "void", "handleMessage", "pipe", "onError", "cause", "forEach", "values", "mailbox", "DeferredTypeId", "failCause", "tapErrorCause", "logWarning", "retry", "spaced", "annotateLogs", "package", "module", "interruptible", "forkScoped", "addFinalizer", "interrupt", "end", "discard", "sync", "response", "suspend", "get", "offerAll", "length", "fail", "WorkerError", "decodeCause", "executeAcquire", "request", "makeMailbox", "withFiberRuntime", "fiber", "context", "getFiberRef", "currentContext", "span", "getOption", "ParentSpan", "filter", "_tag", "tap", "set", "payload", "send", "value", "traceId", "spanId", "sampled", "undefined", "unsafeRead", "catchAllCause", "isMailbox", "map", "executeRelease", "exit", "release", "delete", "isFailure", "orDie", "execute", "fromChannel", "acquireUseRelease", "toChannel", "executeEffect", "await", "flatMap", "mapError", "reason", "layerManager", "effect", "makePool", "options", "manager", "workers", "Set", "acquire", "worker", "acquireRelease", "add", "onCreate", "identity", "makeWithTTL", "min", "minSize", "max", "maxSize", "concurrency", "targetUtilization", "timeToLive", "size", "pool", "broadcast", "unwrapScoped", "scoped", "makePoolLayer", "tag", "makeSerialized", "serialize", "parseSuccess", "decode", "successSchema", "parseFailure", "failureSchema", "catchAll", "error", "mapEffect", "matchEffect", "onFailure", "onSuccess", "makePoolSerialized", "makePoolSerializedLayer", "layerSpawner", "spawner", "makePlatform", "currentPort", "buffer", "handler", "uninterruptibleMask", "restore", "scope", "port", "setup", "runtime", "updateContext", "omit", "Scope", "fiberSet", "runFork", "listen", "emit", "data", "FiberSet", "unsafeAdd", "deferred", "transfers", "postMessage", "join", "try", "push", "catch", "PlatformWorkerTypeId", "makePlatform", "PlatformWorker", "Spawner", "WorkerManagerTypeId", "WorkerManager", "makeManager", "layerManager", "makePool", "makePoolLayer", "makeSerialized", "makePoolSerialized", "makePoolSerializedLayer", "layerSpawner", "CloseLatch", "PlatformRunner", "PlatformRunnerTypeId", "launch", "layer", "layerCloseLatch", "layerSerialized", "make", "makeSerialized", "PlatformRunnerTypeId", "Symbol", "for", "PlatformRunner", "GenericTag", "CloseLatch", "Reference", "defaultValue", "unsafeMake", "none", "layerCloseLatch", "effect", "make", "fnUntraced", "process", "options", "fiber", "withFiberRuntime", "succeed", "platform", "closeLatch", "backing", "start", "fiberMap", "Map", "await", "pipe", "onExit", "currentScheduler", "scheduleTask", "unsafeInterruptAsFork", "id", "void", "forkScoped", "run", "portId", "kind", "data", "span", "get", "interrupt", "set", "decode", "flatMap", "input", "collector", "unsafeMakeCollector", "stream", "isEffect", "out", "encodeOutput", "provideService", "Collector", "payload", "send", "unsafeRead", "runForEachChunk", "chunk", "undefined", "toReadonlyArray", "unsafeClear", "forEach", "andThen", "withParentSpan", "_tag", "traceId", "spanId", "sampled", "context", "empty", "uninterruptibleMask", "restore", "catchIf", "isWorkerError", "error", "WorkerError", "encodeCause", "fail", "catchAllCause", "cause", "match", "failureOrCause", "onLeft", "encodeError", "onRight", "ensuring", "sync", "delete", "layer", "scopedDiscard", "provide", "makeSerialized", "schema", "handlers", "gen", "scope", "parseRequest", "decodeUnknown", "request", "result", "isLayer", "buildWithScope", "_", "merge", "provideContext", "message", "mapError", "reason", "serializeFailure", "serializeSuccess", "layerSerialized", "launch", "scopedWith", "provideMerge", "PlatformRunnerTypeId", "PlatformRunner", "CloseLatch", "layerCloseLatch", "make", "layer", "makeSerialized", "layerSerialized", "launch"]
}
