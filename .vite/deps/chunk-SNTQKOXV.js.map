{
  "version": 3,
  "sources": ["../../node_modules/effect/src/ConfigProvider.ts", "../../node_modules/effect/src/ConfigProviderPathPatch.ts", "../../node_modules/effect/src/DefaultServices.ts", "../../node_modules/effect/src/Logger.ts", "../../node_modules/effect/src/internal/logger-circular.ts"],
  "sourcesContent": ["/**\n * @since 2.0.0\n */\nimport type * as Config from \"./Config.js\"\nimport type * as ConfigError from \"./ConfigError.js\"\nimport type * as PathPatch from \"./ConfigProviderPathPatch.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport * as internal from \"./internal/configProvider.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ConfigProviderTypeId: unique symbol = internal.ConfigProviderTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ConfigProviderTypeId = typeof ConfigProviderTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FlatConfigProviderTypeId: unique symbol = internal.FlatConfigProviderTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FlatConfigProviderTypeId = typeof FlatConfigProviderTypeId\n\n/**\n * A ConfigProvider is a service that provides configuration given a description\n * of the structure of that configuration.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface ConfigProvider extends ConfigProvider.Proto, Pipeable {\n  /**\n   * Loads the specified configuration, or fails with a config error.\n   */\n  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>\n  /**\n   * Flattens this config provider into a simplified config provider that knows\n   * only how to deal with flat (key/value) properties.\n   */\n  readonly flattened: ConfigProvider.Flat\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ConfigProvider {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [ConfigProviderTypeId]: ConfigProviderTypeId\n  }\n\n  /**\n   * A simplified config provider that knows only how to deal with flat\n   * (key/value) properties. Because these providers are common, there is\n   * special support for implementing them.\n   *\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Flat {\n    readonly [FlatConfigProviderTypeId]: FlatConfigProviderTypeId\n    readonly patch: PathPatch.PathPatch\n    load<A>(\n      path: ReadonlyArray<string>,\n      config: Config.Config.Primitive<A>,\n      split?: boolean\n    ): Effect.Effect<Array<A>, ConfigError.ConfigError>\n    enumerateChildren(\n      path: ReadonlyArray<string>\n    ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface FromMapConfig {\n    readonly pathDelim: string\n    readonly seqDelim: string\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface FromEnvConfig {\n    readonly pathDelim: string\n    readonly seqDelim: string\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type KeyComponent = KeyName | KeyIndex\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface KeyName {\n    readonly _tag: \"KeyName\"\n    readonly name: string\n  }\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface KeyIndex {\n    readonly _tag: \"KeyIndex\"\n    readonly index: number\n  }\n}\n\n/**\n * The service tag for `ConfigProvider`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const ConfigProvider: Context.Tag<ConfigProvider, ConfigProvider> = internal.configProviderTag\n\n/**\n * Creates a new config provider.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (\n  options: {\n    readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>\n    readonly flattened: ConfigProvider.Flat\n  }\n) => ConfigProvider = internal.make\n\n/**\n * Creates a new flat config provider.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeFlat: (options: {\n  readonly load: <A>(\n    path: ReadonlyArray<string>,\n    config: Config.Config.Primitive<A>,\n    split: boolean\n  ) => Effect.Effect<Array<A>, ConfigError.ConfigError>\n  readonly enumerateChildren: (\n    path: ReadonlyArray<string>\n  ) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>\n  readonly patch: PathPatch.PathPatch\n}) => ConfigProvider.Flat = internal.makeFlat\n\n/**\n * A config provider that loads configuration from context variables\n *\n * **Options**:\n *\n * - `pathDelim`: The delimiter for the path segments (default: `\"_\"`).\n * - `seqDelim`: The delimiter for the sequence of values (default: `\",\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEnv: (options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider = internal.fromEnv\n\n/**\n * Constructs a new `ConfigProvider` from a key/value (flat) provider, where\n * nesting is embedded into the string keys.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider = internal.fromFlat\n\n/**\n * Constructs a new `ConfigProvider` from a JSON object.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromJson: (json: unknown) => ConfigProvider = internal.fromJson\n\n// TODO(4.0): use `_` for nested configs instead of `.` in next major\n/**\n * Constructs a ConfigProvider using a map and the specified delimiter string,\n * which determines how to split the keys in the map into path segments.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromMap: (map: Map<string, string>, config?: Partial<ConfigProvider.FromMapConfig>) => ConfigProvider =\n  internal.fromMap\n\n/**\n * Returns a new config provider that will automatically convert all property\n * names to constant case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const constantCase: (self: ConfigProvider) => ConfigProvider = internal.constantCase\n\n/**\n * Returns a new config provider that will automatically tranform all path\n * configuration names with the specified function. This can be utilized to\n * adapt the names of configuration properties from one naming convention to\n * another.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const mapInputPath: {\n  /**\n   * Returns a new config provider that will automatically tranform all path\n   * configuration names with the specified function. This can be utilized to\n   * adapt the names of configuration properties from one naming convention to\n   * another.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider\n  /**\n   * Returns a new config provider that will automatically tranform all path\n   * configuration names with the specified function. This can be utilized to\n   * adapt the names of configuration properties from one naming convention to\n   * another.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: ConfigProvider, f: (path: string) => string): ConfigProvider\n} = internal.mapInputPath\n\n/**\n * Returns a new config provider that will automatically convert all property\n * names to kebab case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const kebabCase: (self: ConfigProvider) => ConfigProvider = internal.kebabCase\n\n/**\n * Returns a new config provider that will automatically convert all property\n * names to lower case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const lowerCase: (self: ConfigProvider) => ConfigProvider = internal.lowerCase\n\n/**\n * Returns a new config provider that will automatically nest all\n * configuration under the specified property name. This can be utilized to\n * aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const nested: {\n  /**\n   * Returns a new config provider that will automatically nest all\n   * configuration under the specified property name. This can be utilized to\n   * aggregate separate configuration sources that are all required to load a\n   * single configuration value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (name: string): (self: ConfigProvider) => ConfigProvider\n  /**\n   * Returns a new config provider that will automatically nest all\n   * configuration under the specified property name. This can be utilized to\n   * aggregate separate configuration sources that are all required to load a\n   * single configuration value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: ConfigProvider, name: string): ConfigProvider\n} = internal.nested\n\n/**\n * Returns a new config provider that preferentially loads configuration data\n * from this one, but which will fall back to the specified alternate provider\n * if there are any issues loading the configuration from this provider.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const orElse: {\n  /**\n   * Returns a new config provider that preferentially loads configuration data\n   * from this one, but which will fall back to the specified alternate provider\n   * if there are any issues loading the configuration from this provider.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider\n  /**\n   * Returns a new config provider that preferentially loads configuration data\n   * from this one, but which will fall back to the specified alternate provider\n   * if there are any issues loading the configuration from this provider.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider\n} = internal.orElse\n\n/**\n * Returns a new config provider that will automatically un-nest all\n * configuration under the specified property name. This can be utilized to\n * de-aggregate separate configuration sources that are all required to load a\n * single configuration value.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const unnested: {\n  /**\n   * Returns a new config provider that will automatically un-nest all\n   * configuration under the specified property name. This can be utilized to\n   * de-aggregate separate configuration sources that are all required to load a\n   * single configuration value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (name: string): (self: ConfigProvider) => ConfigProvider\n  /**\n   * Returns a new config provider that will automatically un-nest all\n   * configuration under the specified property name. This can be utilized to\n   * de-aggregate separate configuration sources that are all required to load a\n   * single configuration value.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: ConfigProvider, name: string): ConfigProvider\n} = internal.unnested\n\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const snakeCase: (self: ConfigProvider) => ConfigProvider = internal.snakeCase\n\n/**\n * Returns a new config provider that will automatically convert all property\n * names to upper case. This can be utilized to adapt the names of\n * configuration properties from the default naming convention of camel case\n * to the naming convention of a config provider.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const upperCase: (self: ConfigProvider) => ConfigProvider = internal.upperCase\n\n/**\n * Returns a new config provider that transforms the config provider with the\n * specified function within the specified path.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const within: {\n  /**\n   * Returns a new config provider that transforms the config provider with the\n   * specified function within the specified path.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider\n  /**\n   * Returns a new config provider that transforms the config provider with the\n   * specified function within the specified path.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (\n   self: ConfigProvider,\n   path: ReadonlyArray<string>,\n   f: (self: ConfigProvider) => ConfigProvider\n  ): ConfigProvider\n} = internal.within\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/configProvider/pathPatch.js\"\n\n/**\n * Represents a description of how to modify the path to a configuration\n * value.\n *\n * @since 2.0.0\n * @category models\n */\nexport type PathPatch = Empty | AndThen | MapName | Nested | Unnested\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Empty {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface AndThen {\n  readonly _tag: \"AndThen\"\n  readonly first: PathPatch\n  readonly second: PathPatch\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MapName {\n  readonly _tag: \"MapName\"\n  f(string: string): string\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Nested {\n  readonly _tag: \"Nested\"\n  readonly name: string\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Unnested {\n  readonly _tag: \"Unnested\"\n  readonly name: string\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: PathPatch = internal.empty\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const andThen: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (that: PathPatch): (self: PathPatch) => PathPatch\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: PathPatch, that: PathPatch): PathPatch\n} = internal.andThen\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const mapName: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (f: (string: string) => string): (self: PathPatch) => PathPatch\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: PathPatch, f: (string: string) => string): PathPatch\n} = internal.mapName\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const nested: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (name: string): (self: PathPatch) => PathPatch\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: PathPatch, name: string): PathPatch\n} = internal.nested\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unnested: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (name: string): (self: PathPatch) => PathPatch\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (self: PathPatch, name: string): PathPatch\n} = internal.unnested\n", "/**\n * @since 2.0.0\n */\nimport type * as Clock from \"./Clock.js\"\nimport type * as ConfigProvider from \"./ConfigProvider.js\"\nimport type * as Console from \"./Console.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport * as internal from \"./internal/defaultServices.js\"\nimport type * as Random from \"./Random.js\"\nimport type * as Tracer from \"./Tracer.js\"\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type DefaultServices =\n  | Clock.Clock\n  | Console.Console\n  | Random.Random\n  | ConfigProvider.ConfigProvider\n  | Tracer.Tracer\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const liveServices: Context.Context<DefaultServices> = internal.liveServices\n\n/**\n * @since 2.0.0\n * @category fiberRefs\n */\nexport const currentServices: FiberRef.FiberRef<Context.Context<DefaultServices>> = internal.currentServices\n", "/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type { DurationInput } from \"./Duration.js\"\nimport type { Effect } from \"./Effect.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type * as FiberRefs from \"./FiberRefs.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type * as HashMap from \"./HashMap.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as circular from \"./internal/layer/circular.js\"\nimport * as internalCircular from \"./internal/logger-circular.js\"\nimport * as internal from \"./internal/logger.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as List from \"./List.js\"\nimport type * as LogLevel from \"./LogLevel.js\"\nimport type * as LogSpan from \"./LogSpan.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Scope } from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const LoggerTypeId: unique symbol = internal.LoggerTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type LoggerTypeId = typeof LoggerTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Logger<in Message, out Output> extends Logger.Variance<Message, Output>, Pipeable {\n  log(options: Logger.Options<Message>): Output\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Logger {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in Message, out Output> {\n    readonly [LoggerTypeId]: {\n      readonly _Message: Types.Contravariant<Message>\n      readonly _Output: Types.Covariant<Output>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Options<out Message> {\n    readonly fiberId: FiberId.FiberId\n    readonly logLevel: LogLevel.LogLevel\n    readonly message: Message\n    readonly cause: Cause.Cause<unknown>\n    readonly context: FiberRefs.FiberRefs\n    readonly spans: List.List<LogSpan.LogSpan>\n    readonly annotations: HashMap.HashMap<string, unknown>\n    readonly date: Date\n  }\n}\n\n/**\n * Creates a custom logger that formats log messages according to the provided\n * function.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const logger = Logger.make(({ logLevel, message }) => {\n *   globalThis.console.log(`[${logLevel.label}] ${message}`)\n * })\n *\n * const task1 = Effect.logDebug(\"task1 done\")\n * const task2 = Effect.logDebug(\"task2 done\")\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"start\")\n *   yield* task1\n *   yield* task2\n *   yield* Effect.log(\"done\")\n * }).pipe(\n *   Logger.withMinimumLogLevel(LogLevel.Debug),\n *   Effect.provide(Logger.replace(Logger.defaultLogger, logger))\n * )\n *\n * Effect.runFork(program)\n * // [INFO] start\n * // [DEBUG] task1 done\n * // [DEBUG] task2 done\n * // [INFO] done\n * ```\n *\n * @category constructors\n * @since 2.0.0\n */\nexport const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output> =\n  internal.makeLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const add: <B>(logger: Logger<unknown, B>) => Layer.Layer<never> = circular.addLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const addEffect: <A, E, R>(effect: Effect<Logger<unknown, A>, E, R>) => Layer.Layer<never, E, R> =\n  circular.addLoggerEffect\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const addScoped: <A, E, R>(\n  effect: Effect<Logger<unknown, A>, E, R>\n) => Layer.Layer<never, E, Exclude<R, Scope>> = circular.addLoggerScoped\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Message2>(f: (message: Message2) => Message): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Message, Message2>(self: Logger<Message, Output>, f: (message: Message2) => Message): Logger<Message2, Output>\n} = internal.mapInput\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInputOptions: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Message2>(f: (options: Logger.Options<Message2>) => Logger.Options<Message>): <Output>(self: Logger<Message, Output>) => Logger<Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Message, Message2>(\n   self: Logger<Message, Output>,\n   f: (options: Logger.Options<Message2>) => Logger.Options<Message>\n  ): Logger<Message2, Output>\n} = internal.mapInputOptions\n\n/**\n * Returns a version of this logger that only logs messages when the log level\n * satisfies the specified predicate.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterLogLevel: {\n  /**\n   * Returns a version of this logger that only logs messages when the log level\n   * satisfies the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>\n  /**\n   * Returns a version of this logger that only logs messages when the log level\n   * satisfies the specified predicate.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>\n} = internal.filterLogLevel\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, Output2>(f: (output: Output) => Output2): <Message>(self: Logger<Message, Output>) => Logger<Message, Output2>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Output, Output2>(self: Logger<Message, Output>, f: (output: Output) => Output2): Logger<Message, Output2>\n} = internal.map\n\n/**\n * Creates a batched logger that groups log messages together and processes them\n * in intervals.\n *\n * @example\n * ```ts\n * import { Console, Effect, Logger } from \"effect\"\n *\n * const LoggerLive = Logger.replaceScoped(\n *   Logger.defaultLogger,\n *   Logger.logfmtLogger.pipe(\n *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n *   )\n * )\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"one\")\n *   yield* Effect.log(\"two\")\n *   yield* Effect.log(\"three\")\n * }).pipe(Effect.provide(LoggerLive))\n *\n * Effect.runFork(program)\n * // BATCH [\n * // timestamp=... level=INFO fiber=#0 message=one\n * // timestamp=... level=INFO fiber=#0 message=two\n * // timestamp=... level=INFO fiber=#0 message=three\n * // ]\n * ```\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const batched: {\n  /**\n   * Creates a batched logger that groups log messages together and processes them\n   * in intervals.\n   *\n   * @example\n   * ```ts\n   * import { Console, Effect, Logger } from \"effect\"\n   *\n   * const LoggerLive = Logger.replaceScoped(\n   *   Logger.defaultLogger,\n   *   Logger.logfmtLogger.pipe(\n   *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n   *   )\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"one\")\n   *   yield* Effect.log(\"two\")\n   *   yield* Effect.log(\"three\")\n   * }).pipe(Effect.provide(LoggerLive))\n   *\n   * Effect.runFork(program)\n   * // BATCH [\n   * // timestamp=... level=INFO fiber=#0 message=one\n   * // timestamp=... level=INFO fiber=#0 message=two\n   * // timestamp=... level=INFO fiber=#0 message=three\n   * // ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Output, R>(\n   window: DurationInput,\n   f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>\n  ): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>\n  /**\n   * Creates a batched logger that groups log messages together and processes them\n   * in intervals.\n   *\n   * @example\n   * ```ts\n   * import { Console, Effect, Logger } from \"effect\"\n   *\n   * const LoggerLive = Logger.replaceScoped(\n   *   Logger.defaultLogger,\n   *   Logger.logfmtLogger.pipe(\n   *     Logger.batched(\"500 millis\", (messages) => Console.log(\"BATCH\", `[\\n${messages.join(\"\\n\")}\\n]`))\n   *   )\n   * )\n   *\n   * const program = Effect.gen(function*() {\n   *   yield* Effect.log(\"one\")\n   *   yield* Effect.log(\"two\")\n   *   yield* Effect.log(\"three\")\n   * }).pipe(Effect.provide(LoggerLive))\n   *\n   * Effect.runFork(program)\n   * // BATCH [\n   * // timestamp=... level=INFO fiber=#0 message=one\n   * // timestamp=... level=INFO fiber=#0 message=two\n   * // timestamp=... level=INFO fiber=#0 message=three\n   * // ]\n   * ```\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Message, Output, R>(\n   self: Logger<Message, Output>,\n   window: DurationInput,\n   f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>\n  ): Effect<Logger<Message, void>, never, Scope | R>\n} = fiberRuntime.batchedLogger\n\n/**\n * @since 2.0.0\n * @category console\n */\nexport const withConsoleLog: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithConsoleLog\n\n/**\n * Takes a `Logger<M, O>` and returns a logger that calls the respective `Console` method\n * based on the log level.\n *\n * @example\n * ```ts\n * import { Logger, Effect } from \"effect\"\n *\n * const loggerLayer = Logger.replace(\n *   Logger.defaultLogger,\n *   Logger.withLeveledConsole(Logger.stringLogger),\n * )\n *\n * Effect.gen(function* () {\n *   yield* Effect.logError(\"an error\")\n *   yield* Effect.logInfo(\"an info\")\n * }).pipe(Effect.provide(loggerLayer))\n * ```\n *\n * @since 3.8.0\n * @category console\n */\nexport const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithLeveledLog\n\n/**\n * @since 2.0.0\n * @category console\n */\nexport const withConsoleError: <M, O>(self: Logger<M, O>) => Logger<M, void> = fiberRuntime.loggerWithConsoleError\n\n/**\n * A logger that does nothing in response to logging events.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const none: Logger<unknown, void> = internal.none\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const remove: <A>(logger: Logger<unknown, A>) => Layer.Layer<never> = circular.removeLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replace: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B>(that: Logger<unknown, B>): <A>(self: Logger<unknown, A>) => Layer.Layer<never>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B>(self: Logger<unknown, A>, that: Logger<unknown, B>): Layer.Layer<never>\n} = circular.replaceLogger\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replaceEffect: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, R>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, R>\n} = circular.replaceLoggerEffect\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const replaceScoped: {\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <B, E, R>(that: Effect<Logger<unknown, B>, E, R>): <A>(self: Logger<unknown, A>) => Layer.Layer<never, E, Exclude<R, Scope>>\n  /**\n   * @since 2.0.0\n   * @category context\n   */\n  <A, B, E, R>(self: Logger<unknown, A>, that: Effect<Logger<unknown, B>, E, R>): Layer.Layer<never, E, Exclude<R, Scope>>\n} = circular.replaceLoggerScoped\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const simple: <A, B>(log: (a: A) => B) => Logger<A, B> = internal.simple\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <A>(value: A) => Logger<unknown, A> = internal.succeed\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const sync: <A>(evaluate: LazyArg<A>) => Logger<unknown, A> = internal.sync\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const test: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Message>(input: Message): <Output>(self: Logger<Message, Output>) => Output\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Message, Output>(self: Logger<Message, Output>, input: Message): Output\n} = internalCircular.test\n\n/**\n * Sets the minimum log level for subsequent logging operations, allowing\n * control over which log messages are displayed based on their severity.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n *\n * Effect.runFork(program)\n * // timestamp=... level=DEBUG fiber=#0 message=message1\n * ```\n *\n * @since 2.0.0\n * @category context\n */\nexport const withMinimumLogLevel: {\n  /**\n   * Sets the minimum log level for subsequent logging operations, allowing\n   * control over which log messages are displayed based on their severity.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message1\n   * ```\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * Sets the minimum log level for subsequent logging operations, allowing\n   * control over which log messages are displayed based on their severity.\n   *\n   * @example\n   * ```ts\n   * import { Effect, Logger, LogLevel } from \"effect\"\n   *\n   * const program = Effect.logDebug(\"message1\").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))\n   *\n   * Effect.runFork(program)\n   * // timestamp=... level=DEBUG fiber=#0 message=message1\n   * ```\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>\n} = circular.withMinimumLogLevel\n\n/**\n * @since 2.0.0\n * @category tracing\n */\nexport const withSpanAnnotations: <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Output> =\n  fiberRuntime.loggerWithSpanAnnotations\n\n/**\n * Combines this logger with the specified logger to produce a new logger that\n * logs to both this logger and that logger.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Combines this logger with the specified logger to produce a new logger that\n   * logs to both this logger and that logger.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>\n  /**\n   * Combines this logger with the specified logger to produce a new logger that\n   * logs to both this logger and that logger.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>\n} = internal.zip\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output>\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output>\n} = internal.zipLeft\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, Output2>\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, Output2>\n} = internal.zipRight\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const defaultLogger: Logger<unknown, void> = fiberRuntime.defaultLogger\n\n/**\n * The `jsonLogger` logger formats log entries as JSON objects, making them easy to\n * integrate with logging systems that consume JSON data.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n * // {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const jsonLogger: Logger<unknown, string> = internal.jsonLogger\n\n/**\n * This logger outputs logs in a human-readable format that is easy to read\n * during development or in a production console.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n * // timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const logfmtLogger: Logger<unknown, string> = internal.logfmtLogger\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const stringLogger: Logger<unknown, string> = internal.stringLogger\n\n/**\n * The pretty logger utilizes the capabilities of the console API to generate\n * visually engaging and color-enhanced log outputs. This feature is\n * particularly useful for improving the readability of log messages during\n * development and debugging processes.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n * //         green --v                      v-- bold and cyan\n * // [07:51:54.434] INFO (#0) myspan=1ms: message1\n * //   message2\n * //    v-- bold\n * //   key2: value2\n * //   key1: value1\n * ```\n *\n * @since 3.5.0\n * @category constructors\n */\nexport const prettyLogger: (\n  options?: {\n    readonly colors?: \"auto\" | boolean | undefined\n    readonly stderr?: boolean | undefined\n    readonly formatDate?: ((date: Date) => string) | undefined\n    readonly mode?: \"browser\" | \"tty\" | \"auto\" | undefined\n  }\n) => Logger<unknown, void> = internal.prettyLogger\n\n/**\n * A default version of the pretty logger.\n *\n * @since 3.8.0\n * @category constructors\n */\nexport const prettyLoggerDefault: Logger<unknown, void> = internal.prettyLoggerDefault\n\n/**\n * The structured logger provides detailed log outputs, structured in a way that\n * retains comprehensive traceability of the events, suitable for deeper\n * analysis and troubleshooting.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n * // {\n * //   message: [ 'message1', 'message2' ],\n * //   logLevel: 'INFO',\n * //   timestamp: '2024-07-09T14:05:41.623Z',\n * //   cause: undefined,\n * //   annotations: { key2: 'value2', key1: 'value1' },\n * //   spans: { myspan: 0 },\n * //   fiberId: '#0'\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const structuredLogger: Logger<\n  unknown,\n  {\n    readonly logLevel: string\n    readonly fiberId: string\n    readonly timestamp: string\n    readonly message: unknown\n    readonly cause: string | undefined\n    readonly annotations: Record<string, unknown>\n    readonly spans: Record<string, number>\n  }\n> = internal.structuredLogger\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const tracerLogger: Logger<unknown, void> = fiberRuntime.tracerLogger\n\n/**\n * The `json` logger formats log entries as JSON objects, making them easy to\n * integrate with logging systems that consume JSON data.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.json)))\n * // {\"message\":[\"message1\",\"message2\"],\"logLevel\":\"INFO\",\"timestamp\":\"...\",\"annotations\":{\"key2\":\"value2\",\"key1\":\"value1\"},\"spans\":{\"myspan\":0},\"fiberId\":\"#0\"}\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const json: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.jsonLogger)\n\n/**\n * This logger outputs logs in a human-readable format that is easy to read\n * during development or in a production console.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))\n * // timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const logFmt: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.logFmtLogger)\n\n/**\n * The pretty logger utilizes the capabilities of the console API to generate\n * visually engaging and color-enhanced log outputs. This feature is\n * particularly useful for improving the readability of log messages during\n * development and debugging processes.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))\n * //         green --v                      v-- bold and cyan\n * // [07:51:54.434] INFO (#0) myspan=1ms: message1\n * //   message2\n * //    v-- bold\n * //   key2: value2\n * //   key1: value1\n * ```\n *\n * @since 3.5.0\n * @category constructors\n */\nexport const pretty: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.prettyLogger)\n\n/**\n * The structured logger provides detailed log outputs, structured in a way that\n * retains comprehensive traceability of the events, suitable for deeper\n * analysis and troubleshooting.\n *\n * @example\n * ```ts\n * import { Effect, Logger } from \"effect\"\n *\n * const program = Effect.log(\"message1\", \"message2\").pipe(\n *   Effect.annotateLogs({ key1: \"value1\", key2: \"value2\" }),\n *   Effect.withLogSpan(\"myspan\")\n * )\n *\n * Effect.runFork(program.pipe(Effect.provide(Logger.structured)))\n * // {\n * //   message: [ 'message1', 'message2' ],\n * //   logLevel: 'INFO',\n * //   timestamp: '2024-07-09T14:05:41.623Z',\n * //   cause: undefined,\n * //   annotations: { key2: 'value2', key1: 'value1' },\n * //   spans: { myspan: 0 },\n * //   fiberId: '#0'\n * // }\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const structured: Layer.Layer<never> = replace(fiberRuntime.defaultLogger, fiberRuntime.structuredLogger)\n\n/**\n * Sets the minimum log level for logging operations, allowing control over\n * which log messages are displayed based on their severity.\n *\n * @example\n * ```ts\n * import { Effect, Logger, LogLevel } from \"effect\"\n *\n * const program = Effect.gen(function*() {\n *   yield* Effect.log(\"Executing task...\")\n *   yield* Effect.sleep(\"100 millis\")\n *   console.log(\"task done\")\n * })\n *\n * // Logging disabled using a layer\n * Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))\n * // task done\n * ```\n *\n * @since 2.0.0\n * @category context\n */\nexport const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never> = circular.minimumLogLevel\n\n/**\n * Returns `true` if the specified value is a `Logger`, otherwise returns `false`.\n *\n * @since 1.0.0\n * @category guards\n */\nexport const isLogger: (u: unknown) => u is Logger<unknown, unknown> = internal.isLogger\n", "import * as Cause from \"../Cause.js\"\nimport { dual } from \"../Function.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport * as List from \"../List.js\"\nimport type * as Logger from \"../Logger.js\"\nimport * as core from \"./core.js\"\nimport * as fiberId_ from \"./fiberId.js\"\nimport * as fiberRefs from \"./fiberRefs.js\"\n\n/** @internal */\nexport const test = dual<\n  <Message>(input: Message) => <Output>(self: Logger.Logger<Message, Output>) => Output,\n  <Message, Output>(self: Logger.Logger<Message, Output>, input: Message) => Output\n>(2, (self, input) =>\n  self.log({\n    fiberId: fiberId_.none,\n    logLevel: core.logLevelInfo,\n    message: input,\n    cause: Cause.empty,\n    context: fiberRefs.empty(),\n    spans: List.empty(),\n    annotations: HashMap.empty(),\n    date: new Date()\n  }))\n"],
  "mappings": "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",
  "names": ["ConfigProviderTypeId", "FlatConfigProviderTypeId", "constantCase", "fromEnv", "fromFlat", "fromJson", "fromMap", "kebabCase", "lowerCase", "make", "makeFlat", "mapInputPath", "nested", "orElse", "snakeCase", "unnested", "upperCase", "within", "ConfigProviderTypeId", "FlatConfigProviderTypeId", "ConfigProvider", "configProviderTag", "make", "makeFlat", "fromEnv", "fromFlat", "fromJson", "fromMap", "constantCase", "mapInputPath", "kebabCase", "lowerCase", "nested", "orElse", "unnested", "snakeCase", "upperCase", "within", "andThen", "empty", "mapName", "nested", "unnested", "empty", "andThen", "mapName", "nested", "unnested", "currentServices", "liveServices", "liveServices", "currentServices", "LoggerTypeId", "defaultLogger", "filterLogLevel", "isLogger", "jsonLogger", "logfmtLogger", "make", "map", "mapInput", "mapInputOptions", "minimumLogLevel", "none", "prettyLogger", "prettyLoggerDefault", "simple", "stringLogger", "structuredLogger", "succeed", "sync", "test", "tracerLogger", "withMinimumLogLevel", "zip", "zipLeft", "zipRight", "test", "dual", "self", "input", "log", "fiberId", "none", "logLevel", "logLevelInfo", "message", "cause", "empty", "context", "spans", "annotations", "date", "Date", "LoggerTypeId", "make", "makeLogger", "add", "addLogger", "addEffect", "addLoggerEffect", "addScoped", "addLoggerScoped", "mapInput", "mapInputOptions", "filterLogLevel", "map", "batched", "batchedLogger", "withConsoleLog", "loggerWithConsoleLog", "withLeveledConsole", "loggerWithLeveledLog", "withConsoleError", "loggerWithConsoleError", "none", "remove", "removeLogger", "replace", "replaceLogger", "replaceEffect", "replaceLoggerEffect", "replaceScoped", "replaceLoggerScoped", "simple", "succeed", "sync", "test", "withMinimumLogLevel", "withSpanAnnotations", "loggerWithSpanAnnotations", "zip", "zipLeft", "zipRight", "defaultLogger", "jsonLogger", "logfmtLogger", "stringLogger", "prettyLogger", "prettyLoggerDefault", "structuredLogger", "tracerLogger", "json", "logFmt", "logFmtLogger", "pretty", "structured", "minimumLogLevel", "isLogger"]
}
