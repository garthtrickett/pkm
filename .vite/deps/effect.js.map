{
  "version": 3,
  "sources": ["../../node_modules/effect/src/Arbitrary.ts", "../../node_modules/effect/src/Cache.ts", "../../node_modules/effect/src/ChildExecutorDecision.ts", "../../node_modules/effect/src/Console.ts", "../../node_modules/effect/src/ExecutionPlan.ts", "../../node_modules/effect/src/FiberHandle.ts", "../../node_modules/effect/src/FiberMap.ts", "../../node_modules/effect/src/GroupBy.ts", "../../node_modules/effect/dist/esm/HKT.js", "../../node_modules/effect/src/KeyedPool.ts", "../../node_modules/effect/src/internal/keyedPool.ts", "../../node_modules/effect/src/LayerMap.ts", "../../node_modules/effect/src/RcMap.ts", "../../node_modules/effect/src/internal/rcMap.ts", "../../node_modules/effect/src/Match.ts", "../../node_modules/effect/src/internal/matcher.ts", "../../node_modules/effect/src/MergeState.ts", "../../node_modules/effect/src/MergeStrategy.ts", "../../node_modules/effect/src/Metric.ts", "../../node_modules/effect/src/MetricBoundaries.ts", "../../node_modules/effect/src/MetricHook.ts", "../../node_modules/effect/src/MetricKey.ts", "../../node_modules/effect/src/MetricKeyType.ts", "../../node_modules/effect/src/MetricLabel.ts", "../../node_modules/effect/src/MetricPair.ts", "../../node_modules/effect/src/MetricPolling.ts", "../../node_modules/effect/src/internal/metric/polling.ts", "../../node_modules/effect/src/MetricRegistry.ts", "../../node_modules/effect/src/MetricState.ts", "../../node_modules/effect/src/ModuleVersion.ts", "../../node_modules/effect/src/MutableHashSet.ts", "../../node_modules/effect/src/NonEmptyIterable.ts", "../../node_modules/effect/src/Ordering.ts", "../../node_modules/effect/src/Pretty.ts", "../../node_modules/effect/src/RateLimiter.ts", "../../node_modules/effect/src/internal/rateLimiter.ts", "../../node_modules/effect/src/Reloadable.ts", "../../node_modules/effect/src/internal/scopedRef.ts", "../../node_modules/effect/src/internal/reloadable.ts", "../../node_modules/effect/src/RequestBlock.ts", "../../node_modules/effect/src/RequestResolver.ts", "../../node_modules/effect/src/internal/dataSource.ts", "../../node_modules/effect/src/Resource.ts", "../../node_modules/effect/src/internal/resource.ts", "../../node_modules/effect/src/RuntimeFlags.ts", "../../node_modules/effect/src/STM.ts", "../../node_modules/effect/src/ScopedCache.ts", "../../node_modules/effect/src/internal/scopedCache.ts", "../../node_modules/effect/src/ScopedRef.ts", "../../node_modules/effect/src/Secret.ts", "../../node_modules/effect/src/SingleProducerAsyncInput.ts", "../../node_modules/effect/src/SortedMap.ts", "../../node_modules/effect/dist/esm/StreamEmit.js", "../../node_modules/effect/src/Streamable.ts", "../../node_modules/effect/src/Subscribable.ts", "../../node_modules/effect/src/SubscriptionRef.ts", "../../node_modules/effect/src/SynchronizedRef.ts", "../../node_modules/effect/src/internal/subscriptionRef.ts", "../../node_modules/effect/src/Supervisor.ts", "../../node_modules/effect/src/Symbol.ts", "../../node_modules/effect/src/TArray.ts", "../../node_modules/effect/src/internal/stm/tArray.ts", "../../node_modules/effect/src/TDeferred.ts", "../../node_modules/effect/src/internal/stm/tDeferred.ts", "../../node_modules/effect/src/TMap.ts", "../../node_modules/effect/src/internal/stm/tMap.ts", "../../node_modules/effect/src/TPriorityQueue.ts", "../../node_modules/effect/src/internal/stm/tPriorityQueue.ts", "../../node_modules/effect/src/TRandom.ts", "../../node_modules/effect/src/internal/stm/tRandom.ts", "../../node_modules/effect/src/TReentrantLock.ts", "../../node_modules/effect/src/internal/stm/tReentrantLock.ts", "../../node_modules/effect/src/TRef.ts", "../../node_modules/effect/src/TSemaphore.ts", "../../node_modules/effect/src/internal/stm/tSemaphore.ts", "../../node_modules/effect/src/TSet.ts", "../../node_modules/effect/src/internal/stm/tSet.ts", "../../node_modules/effect/src/TSubscriptionRef.ts", "../../node_modules/effect/src/internal/stm/tSubscriptionRef.ts", "../../node_modules/effect/src/Take.ts", "../../node_modules/effect/src/TestAnnotation.ts", "../../node_modules/effect/src/TestAnnotationMap.ts", "../../node_modules/effect/src/TestAnnotations.ts", "../../node_modules/effect/src/TestClock.ts", "../../node_modules/effect/src/internal/testing/suspendedWarningData.ts", "../../node_modules/effect/src/internal/testing/warningData.ts", "../../node_modules/effect/src/TestLive.ts", "../../node_modules/effect/src/TestConfig.ts", "../../node_modules/effect/src/TestContext.ts", "../../node_modules/effect/src/TestServices.ts", "../../node_modules/effect/src/TestSized.ts", "../../node_modules/effect/src/Trie.ts", "../../node_modules/effect/src/internal/trie.ts", "../../node_modules/effect/src/Types.ts", "../../node_modules/effect/src/UpstreamPullRequest.ts", "../../node_modules/effect/src/UpstreamPullStrategy.ts"],
  "sourcesContent": ["/**\n * @since 3.10.0\n */\n\nimport * as Arr from \"./Array.js\"\nimport * as FastCheck from \"./FastCheck.js\"\nimport { globalValue } from \"./GlobalValue.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as schemaId_ from \"./internal/schema/schemaId.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as Option from \"./Option.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as Schema from \"./Schema.js\"\nimport * as SchemaAST from \"./SchemaAST.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface LazyArbitrary<A> {\n  (fc: typeof FastCheck): FastCheck.Arbitrary<A>\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport interface ArbitraryGenerationContext {\n  readonly maxDepth: number\n  readonly depthIdentifier?: string\n  readonly constraints?: StringConstraints | NumberConstraints | BigIntConstraints | DateConstraints | ArrayConstraints\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport type ArbitraryAnnotation<A, TypeParameters extends ReadonlyArray<any> = readonly []> = (\n  ...arbitraries: [\n    ...{ readonly [K in keyof TypeParameters]: LazyArbitrary<TypeParameters[K]> },\n    ctx: ArbitraryGenerationContext\n  ]\n) => LazyArbitrary<A>\n\n/**\n * Returns a LazyArbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 3.10.0\n */\nexport const makeLazy = <A, I, R>(schema: Schema.Schema<A, I, R>): LazyArbitrary<A> => {\n  const description = getDescription(schema.ast, [])\n  return go(description, { maxDepth: 2 })\n}\n\n/**\n * Returns a fast-check Arbitrary for the `A` type of the provided schema.\n *\n * @category arbitrary\n * @since 3.10.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): FastCheck.Arbitrary<A> => makeLazy(schema)(FastCheck)\n\ninterface StringConstraints {\n  readonly _tag: \"StringConstraints\"\n  readonly constraints: FastCheck.StringSharedConstraints\n  readonly pattern?: string\n}\n\n/** @internal */\nexport const makeStringConstraints = (options: {\n  readonly minLength?: number | undefined\n  readonly maxLength?: number | undefined\n  readonly pattern?: string | undefined\n}): StringConstraints => {\n  const out: Types.Mutable<StringConstraints> = {\n    _tag: \"StringConstraints\",\n    constraints: {}\n  }\n  if (Predicate.isNumber(options.minLength)) {\n    out.constraints.minLength = options.minLength\n  }\n  if (Predicate.isNumber(options.maxLength)) {\n    out.constraints.maxLength = options.maxLength\n  }\n  if (Predicate.isString(options.pattern)) {\n    out.pattern = options.pattern\n  }\n  return out\n}\n\ninterface NumberConstraints {\n  readonly _tag: \"NumberConstraints\"\n  readonly constraints: FastCheck.FloatConstraints\n  readonly isInteger: boolean\n}\n\n/** @internal */\nexport const makeNumberConstraints = (options: {\n  readonly isInteger?: boolean | undefined\n  readonly min?: unknown\n  readonly minExcluded?: boolean | undefined\n  readonly max?: unknown\n  readonly maxExcluded?: boolean | undefined\n  readonly noNaN?: boolean | undefined\n  readonly noDefaultInfinity?: boolean | undefined\n}): NumberConstraints => {\n  const out: Types.Mutable<NumberConstraints> = {\n    _tag: \"NumberConstraints\",\n    constraints: {},\n    isInteger: options.isInteger ?? false\n  }\n  if (Predicate.isNumber(options.min)) {\n    out.constraints.min = Math.fround(options.min)\n  }\n  if (Predicate.isBoolean(options.minExcluded)) {\n    out.constraints.minExcluded = options.minExcluded\n  }\n  if (Predicate.isNumber(options.max)) {\n    out.constraints.max = Math.fround(options.max)\n  }\n  if (Predicate.isBoolean(options.maxExcluded)) {\n    out.constraints.maxExcluded = options.maxExcluded\n  }\n  if (Predicate.isBoolean(options.noNaN)) {\n    out.constraints.noNaN = options.noNaN\n  }\n  if (Predicate.isBoolean(options.noDefaultInfinity)) {\n    out.constraints.noDefaultInfinity = options.noDefaultInfinity\n  }\n  return out\n}\n\ninterface BigIntConstraints {\n  readonly _tag: \"BigIntConstraints\"\n  readonly constraints: FastCheck.BigIntConstraints\n}\n\n/** @internal */\nexport const makeBigIntConstraints = (options: {\n  readonly min?: bigint | undefined\n  readonly max?: bigint | undefined\n}): BigIntConstraints => {\n  const out: Types.Mutable<BigIntConstraints> = {\n    _tag: \"BigIntConstraints\",\n    constraints: {}\n  }\n  if (Predicate.isBigInt(options.min)) {\n    out.constraints.min = options.min\n  }\n  if (Predicate.isBigInt(options.max)) {\n    out.constraints.max = options.max\n  }\n  return out\n}\n\ninterface ArrayConstraints {\n  readonly _tag: \"ArrayConstraints\"\n  readonly constraints: FastCheck.ArrayConstraints\n}\n\n/** @internal */\nexport const makeArrayConstraints = (options: {\n  readonly minLength?: unknown\n  readonly maxLength?: unknown\n}): ArrayConstraints => {\n  const out: Types.Mutable<ArrayConstraints> = {\n    _tag: \"ArrayConstraints\",\n    constraints: {}\n  }\n  if (Predicate.isNumber(options.minLength)) {\n    out.constraints.minLength = options.minLength\n  }\n  if (Predicate.isNumber(options.maxLength)) {\n    out.constraints.maxLength = options.maxLength\n  }\n  return out\n}\n\ninterface DateConstraints {\n  readonly _tag: \"DateConstraints\"\n  readonly constraints: FastCheck.DateConstraints\n}\n\n/** @internal */\nexport const makeDateConstraints = (options: {\n  readonly min?: Date | undefined\n  readonly max?: Date | undefined\n  readonly noInvalidDate?: boolean | undefined\n}): DateConstraints => {\n  const out: Types.Mutable<DateConstraints> = {\n    _tag: \"DateConstraints\",\n    constraints: {}\n  }\n  if (Predicate.isDate(options.min)) {\n    out.constraints.min = options.min\n  }\n  if (Predicate.isDate(options.max)) {\n    out.constraints.max = options.max\n  }\n  if (Predicate.isBoolean(options.noInvalidDate)) {\n    out.constraints.noInvalidDate = options.noInvalidDate\n  }\n  return out\n}\n\ntype Refinements = ReadonlyArray<SchemaAST.Refinement>\n\ninterface Base {\n  readonly path: ReadonlyArray<PropertyKey>\n  readonly refinements: Refinements\n  readonly annotations: ReadonlyArray<ArbitraryAnnotation<any, any>>\n}\n\ninterface StringKeyword extends Base {\n  readonly _tag: \"StringKeyword\"\n  readonly constraints: ReadonlyArray<StringConstraints>\n}\n\ninterface NumberKeyword extends Base {\n  readonly _tag: \"NumberKeyword\"\n  readonly constraints: ReadonlyArray<NumberConstraints>\n}\n\ninterface BigIntKeyword extends Base {\n  readonly _tag: \"BigIntKeyword\"\n  readonly constraints: ReadonlyArray<BigIntConstraints>\n}\n\ninterface DateFromSelf extends Base {\n  readonly _tag: \"DateFromSelf\"\n  readonly constraints: ReadonlyArray<DateConstraints>\n}\n\ninterface Declaration extends Base {\n  readonly _tag: \"Declaration\"\n  readonly typeParameters: ReadonlyArray<Description>\n  readonly ast: SchemaAST.AST\n}\n\ninterface TupleType extends Base {\n  readonly _tag: \"TupleType\"\n  readonly constraints: ReadonlyArray<ArrayConstraints>\n  readonly elements: ReadonlyArray<{\n    readonly isOptional: boolean\n    readonly description: Description\n  }>\n  readonly rest: ReadonlyArray<Description>\n}\n\ninterface TypeLiteral extends Base {\n  readonly _tag: \"TypeLiteral\"\n  readonly propertySignatures: ReadonlyArray<{\n    readonly isOptional: boolean\n    readonly name: PropertyKey\n    readonly value: Description\n  }>\n  readonly indexSignatures: ReadonlyArray<{\n    readonly parameter: Description\n    readonly value: Description\n  }>\n}\n\ninterface Union extends Base {\n  readonly _tag: \"Union\"\n  readonly members: ReadonlyArray<Description>\n}\n\ninterface Suspend extends Base {\n  readonly _tag: \"Suspend\"\n  readonly id: string\n  readonly ast: SchemaAST.AST\n  readonly description: () => Description\n}\n\ninterface Ref extends Base {\n  readonly _tag: \"Ref\"\n  readonly id: string\n  readonly ast: SchemaAST.AST\n}\n\ninterface NeverKeyword extends Base {\n  readonly _tag: \"NeverKeyword\"\n  readonly ast: SchemaAST.AST\n}\n\ninterface Keyword extends Base {\n  readonly _tag: \"Keyword\"\n  readonly value:\n    | \"UndefinedKeyword\"\n    | \"VoidKeyword\"\n    | \"UnknownKeyword\"\n    | \"AnyKeyword\"\n    | \"BooleanKeyword\"\n    | \"SymbolKeyword\"\n    | \"ObjectKeyword\"\n}\n\ninterface Literal extends Base {\n  readonly _tag: \"Literal\"\n  readonly literal: SchemaAST.LiteralValue\n}\n\ninterface UniqueSymbol extends Base {\n  readonly _tag: \"UniqueSymbol\"\n  readonly symbol: symbol\n}\n\ninterface Enums extends Base {\n  readonly _tag: \"Enums\"\n  readonly enums: ReadonlyArray<readonly [string, string | number]>\n  readonly ast: SchemaAST.AST\n}\n\ninterface TemplateLiteral extends Base {\n  readonly _tag: \"TemplateLiteral\"\n  readonly head: string\n  readonly spans: ReadonlyArray<{\n    readonly description: Description\n    readonly literal: string\n  }>\n}\n\ntype Description =\n  | Declaration\n  | NeverKeyword\n  | Keyword\n  | Literal\n  | UniqueSymbol\n  | Enums\n  | TemplateLiteral\n  | StringKeyword\n  | NumberKeyword\n  | BigIntKeyword\n  | DateFromSelf\n  | TupleType\n  | TypeLiteral\n  | Union\n  | Suspend\n  | Ref\n\nconst getArbitraryAnnotation = SchemaAST.getAnnotation<ArbitraryAnnotation<any, any>>(SchemaAST.ArbitraryAnnotationId)\n\nconst getASTConstraints = (ast: SchemaAST.AST) => {\n  const TypeAnnotationId = ast.annotations[SchemaAST.SchemaIdAnnotationId]\n  if (Predicate.isPropertyKey(TypeAnnotationId)) {\n    const out = ast.annotations[TypeAnnotationId]\n    if (Predicate.isReadonlyRecord(out)) {\n      return out\n    }\n  }\n}\n\nconst idMemoMap = globalValue(\n  Symbol.for(\"effect/Arbitrary/IdMemoMap\"),\n  () => new Map<SchemaAST.AST, string>()\n)\n\nlet counter = 0\n\nfunction wrapGetDescription(\n  f: (ast: SchemaAST.AST, description: Description) => Description,\n  g: (ast: SchemaAST.AST, path: ReadonlyArray<PropertyKey>) => Description\n): (ast: SchemaAST.AST, path: ReadonlyArray<PropertyKey>) => Description {\n  return (ast, path) => f(ast, g(ast, path))\n}\n\nfunction parseMeta(ast: SchemaAST.AST): [SchemaAST.SchemaIdAnnotation | undefined, Record<string | symbol, unknown>] {\n  const jsonSchema = SchemaAST.getJSONSchemaAnnotation(ast).pipe(\n    Option.filter(Predicate.isReadonlyRecord),\n    Option.getOrUndefined\n  )\n  const schemaId = Option.getOrElse(SchemaAST.getSchemaIdAnnotation(ast), () => undefined)\n  const schemaParams = Option.fromNullable(schemaId).pipe(\n    Option.map((id) => ast.annotations[id]),\n    Option.filter(Predicate.isReadonlyRecord),\n    Option.getOrUndefined\n  )\n  return [schemaId, { ...schemaParams, ...jsonSchema }]\n}\n\n/** @internal */\nexport const getDescription = wrapGetDescription(\n  (ast, description) => {\n    const annotation = getArbitraryAnnotation(ast)\n    if (Option.isSome(annotation)) {\n      return {\n        ...description,\n        annotations: [...description.annotations, annotation.value]\n      }\n    }\n    return description\n  },\n  (ast, path) => {\n    const [schemaId, meta] = parseMeta(ast)\n    switch (ast._tag) {\n      case \"Refinement\": {\n        const from = getDescription(ast.from, path)\n        switch (from._tag) {\n          case \"StringKeyword\":\n            return {\n              ...from,\n              constraints: [...from.constraints, makeStringConstraints(meta)],\n              refinements: [...from.refinements, ast]\n            }\n          case \"NumberKeyword\": {\n            const c = schemaId === schemaId_.NonNaNSchemaId ?\n              makeNumberConstraints({ noNaN: true }) :\n              makeNumberConstraints({\n                isInteger: \"type\" in meta && meta.type === \"integer\",\n                noNaN: \"type\" in meta && meta.type === \"number\" ? true : undefined,\n                noDefaultInfinity: \"type\" in meta && meta.type === \"number\" ? true : undefined,\n                min: meta.exclusiveMinimum ?? meta.minimum,\n                minExcluded: \"exclusiveMinimum\" in meta ? true : undefined,\n                max: meta.exclusiveMaximum ?? meta.maximum,\n                maxExcluded: \"exclusiveMaximum\" in meta ? true : undefined\n              })\n            return {\n              ...from,\n              constraints: [...from.constraints, c],\n              refinements: [...from.refinements, ast]\n            }\n          }\n          case \"BigIntKeyword\": {\n            const c = getASTConstraints(ast)\n            return {\n              ...from,\n              constraints: c !== undefined ? [...from.constraints, makeBigIntConstraints(c)] : from.constraints,\n              refinements: [...from.refinements, ast]\n            }\n          }\n          case \"TupleType\":\n            return {\n              ...from,\n              constraints: [\n                ...from.constraints,\n                makeArrayConstraints({\n                  minLength: meta.minItems,\n                  maxLength: meta.maxItems\n                })\n              ],\n              refinements: [...from.refinements, ast]\n            }\n          case \"DateFromSelf\":\n            return {\n              ...from,\n              constraints: [...from.constraints, makeDateConstraints(meta)],\n              refinements: [...from.refinements, ast]\n            }\n          default:\n            return {\n              ...from,\n              refinements: [...from.refinements, ast]\n            }\n        }\n      }\n      case \"Declaration\": {\n        if (schemaId === schemaId_.DateFromSelfSchemaId) {\n          return {\n            _tag: \"DateFromSelf\",\n            constraints: [makeDateConstraints(meta)],\n            path,\n            refinements: [],\n            annotations: []\n          }\n        }\n        return {\n          _tag: \"Declaration\",\n          typeParameters: ast.typeParameters.map((ast) => getDescription(ast, path)),\n          path,\n          refinements: [],\n          annotations: [],\n          ast\n        }\n      }\n      case \"Literal\": {\n        return {\n          _tag: \"Literal\",\n          literal: ast.literal,\n          path,\n          refinements: [],\n          annotations: []\n        }\n      }\n      case \"UniqueSymbol\": {\n        return {\n          _tag: \"UniqueSymbol\",\n          symbol: ast.symbol,\n          path,\n          refinements: [],\n          annotations: []\n        }\n      }\n      case \"Enums\": {\n        return {\n          _tag: \"Enums\",\n          enums: ast.enums,\n          path,\n          refinements: [],\n          annotations: [],\n          ast\n        }\n      }\n      case \"TemplateLiteral\": {\n        return {\n          _tag: \"TemplateLiteral\",\n          head: ast.head,\n          spans: ast.spans.map((span) => ({\n            description: getDescription(span.type, path),\n            literal: span.literal\n          })),\n          path,\n          refinements: [],\n          annotations: []\n        }\n      }\n      case \"StringKeyword\":\n        return {\n          _tag: \"StringKeyword\",\n          constraints: [],\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"NumberKeyword\":\n        return {\n          _tag: \"NumberKeyword\",\n          constraints: [],\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"BigIntKeyword\":\n        return {\n          _tag: \"BigIntKeyword\",\n          constraints: [],\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"TupleType\":\n        return {\n          _tag: \"TupleType\",\n          constraints: [],\n          elements: ast.elements.map((element, i) => ({\n            isOptional: element.isOptional,\n            description: getDescription(element.type, [...path, i])\n          })),\n          rest: ast.rest.map((element, i) => getDescription(element.type, [...path, i])),\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"TypeLiteral\":\n        return {\n          _tag: \"TypeLiteral\",\n          propertySignatures: ast.propertySignatures.map((ps) => ({\n            isOptional: ps.isOptional,\n            name: ps.name,\n            value: getDescription(ps.type, [...path, ps.name])\n          })),\n          indexSignatures: ast.indexSignatures.map((is) => ({\n            parameter: getDescription(is.parameter, path),\n            value: getDescription(is.type, path)\n          })),\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"Union\":\n        return {\n          _tag: \"Union\",\n          members: ast.types.map((member, i) => getDescription(member, [...path, i])),\n          path,\n          refinements: [],\n          annotations: []\n        }\n      case \"Suspend\": {\n        const memoId = idMemoMap.get(ast)\n        if (memoId !== undefined) {\n          return {\n            _tag: \"Ref\",\n            id: memoId,\n            ast,\n            path,\n            refinements: [],\n            annotations: []\n          }\n        }\n        counter++\n        const id = `__id-${counter}__`\n        idMemoMap.set(ast, id)\n        return {\n          _tag: \"Suspend\",\n          id,\n          ast,\n          description: () => getDescription(ast.f(), path),\n          path,\n          refinements: [],\n          annotations: []\n        }\n      }\n      case \"Transformation\":\n        return getDescription(ast.to, path)\n      case \"NeverKeyword\":\n        return {\n          _tag: \"NeverKeyword\",\n          path,\n          refinements: [],\n          annotations: [],\n          ast\n        }\n      default: {\n        return {\n          _tag: \"Keyword\",\n          value: ast._tag,\n          path,\n          refinements: [],\n          annotations: []\n        }\n      }\n    }\n  }\n)\n\nfunction getMax(n1: Date | undefined, n2: Date | undefined): Date | undefined\nfunction getMax(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMax(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMax(\n  n1: bigint | number | Date | undefined,\n  n2: bigint | number | Date | undefined\n): bigint | number | Date | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n2 : n1\n}\n\nfunction getMin(n1: Date | undefined, n2: Date | undefined): Date | undefined\nfunction getMin(n1: bigint | undefined, n2: bigint | undefined): bigint | undefined\nfunction getMin(n1: number | undefined, n2: number | undefined): number | undefined\nfunction getMin(\n  n1: bigint | number | Date | undefined,\n  n2: bigint | number | Date | undefined\n): bigint | number | Date | undefined {\n  return n1 === undefined ? n2 : n2 === undefined ? n1 : n1 <= n2 ? n1 : n2\n}\n\nconst getOr = (a: boolean | undefined, b: boolean | undefined): boolean | undefined => {\n  return a === undefined ? b : b === undefined ? a : a || b\n}\n\nfunction mergePattern(pattern1: string | undefined, pattern2: string | undefined): string | undefined {\n  if (pattern1 === undefined) {\n    return pattern2\n  }\n  if (pattern2 === undefined) {\n    return pattern1\n  }\n  return `(?:${pattern1})|(?:${pattern2})`\n}\n\nfunction mergeStringConstraints(c1: StringConstraints, c2: StringConstraints): StringConstraints {\n  return makeStringConstraints({\n    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength),\n    pattern: mergePattern(c1.pattern, c2.pattern)\n  })\n}\n\nfunction buildStringConstraints(description: StringKeyword): StringConstraints | undefined {\n  return description.constraints.length === 0\n    ? undefined\n    : description.constraints.reduce(mergeStringConstraints)\n}\n\nfunction mergeNumberConstraints(c1: NumberConstraints, c2: NumberConstraints): NumberConstraints {\n  return makeNumberConstraints({\n    isInteger: c1.isInteger || c2.isInteger,\n    min: getMax(c1.constraints.min, c2.constraints.min),\n    minExcluded: getOr(c1.constraints.minExcluded, c2.constraints.minExcluded),\n    max: getMin(c1.constraints.max, c2.constraints.max),\n    maxExcluded: getOr(c1.constraints.maxExcluded, c2.constraints.maxExcluded),\n    noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),\n    noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)\n  })\n}\n\nfunction buildNumberConstraints(description: NumberKeyword): NumberConstraints | undefined {\n  return description.constraints.length === 0\n    ? undefined\n    : description.constraints.reduce(mergeNumberConstraints)\n}\n\nfunction mergeBigIntConstraints(c1: BigIntConstraints, c2: BigIntConstraints): BigIntConstraints {\n  return makeBigIntConstraints({\n    min: getMax(c1.constraints.min, c2.constraints.min),\n    max: getMin(c1.constraints.max, c2.constraints.max)\n  })\n}\n\nfunction buildBigIntConstraints(description: BigIntKeyword): BigIntConstraints | undefined {\n  return description.constraints.length === 0\n    ? undefined\n    : description.constraints.reduce(mergeBigIntConstraints)\n}\n\nfunction mergeDateConstraints(c1: DateConstraints, c2: DateConstraints): DateConstraints {\n  return makeDateConstraints({\n    min: getMax(c1.constraints.min, c2.constraints.min),\n    max: getMin(c1.constraints.max, c2.constraints.max),\n    noInvalidDate: getOr(c1.constraints.noInvalidDate, c2.constraints.noInvalidDate)\n  })\n}\n\nfunction buildDateConstraints(description: DateFromSelf): DateConstraints | undefined {\n  return description.constraints.length === 0\n    ? undefined\n    : description.constraints.reduce(mergeDateConstraints)\n}\n\nconst constArrayConstraints = makeArrayConstraints({})\n\nfunction mergeArrayConstraints(c1: ArrayConstraints, c2: ArrayConstraints): ArrayConstraints {\n  return makeArrayConstraints({\n    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),\n    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)\n  })\n}\n\nfunction buildArrayConstraints(description: TupleType): ArrayConstraints | undefined {\n  return description.constraints.length === 0\n    ? undefined\n    : description.constraints.reduce(mergeArrayConstraints)\n}\n\nconst arbitraryMemoMap = globalValue(\n  Symbol.for(\"effect/Arbitrary/arbitraryMemoMap\"),\n  () => new WeakMap<SchemaAST.AST, LazyArbitrary<any>>()\n)\n\nfunction applyFilters(filters: ReadonlyArray<Predicate.Predicate<any>>, arb: LazyArbitrary<any>): LazyArbitrary<any> {\n  return (fc) => filters.reduce((arb, filter) => arb.filter(filter), arb(fc))\n}\n\nfunction absurd(message: string): LazyArbitrary<any> {\n  return () => {\n    throw new Error(message)\n  }\n}\n\nfunction getContextConstraints(description: Description): ArbitraryGenerationContext[\"constraints\"] {\n  switch (description._tag) {\n    case \"StringKeyword\":\n      return buildStringConstraints(description)\n    case \"NumberKeyword\":\n      return buildNumberConstraints(description)\n    case \"BigIntKeyword\":\n      return buildBigIntConstraints(description)\n    case \"DateFromSelf\":\n      return buildDateConstraints(description)\n    case \"TupleType\":\n      return buildArrayConstraints(description)\n  }\n}\n\nfunction wrapGo(\n  f: (description: Description, ctx: ArbitraryGenerationContext, lazyArb: LazyArbitrary<any>) => LazyArbitrary<any>,\n  g: (description: Description, ctx: ArbitraryGenerationContext) => LazyArbitrary<any>\n): (description: Description, ctx: ArbitraryGenerationContext) => LazyArbitrary<any> {\n  return (description, ctx) => f(description, ctx, g(description, ctx))\n}\n\nconst go = wrapGo(\n  (description, ctx, lazyArb) => {\n    const annotation: ArbitraryAnnotation<any, any> | undefined =\n      description.annotations[description.annotations.length - 1]\n\n    // error handling\n    if (annotation === undefined) {\n      switch (description._tag) {\n        case \"Declaration\":\n        case \"NeverKeyword\":\n          throw new Error(errors_.getArbitraryMissingAnnotationErrorMessage(description.path, description.ast))\n        case \"Enums\":\n          if (description.enums.length === 0) {\n            throw new Error(errors_.getArbitraryEmptyEnumErrorMessage(description.path))\n          }\n      }\n    }\n\n    const filters = description.refinements.map((ast) => (a: any) =>\n      Option.isNone(ast.filter(a, SchemaAST.defaultParseOption, ast))\n    )\n    if (annotation === undefined) {\n      return applyFilters(filters, lazyArb)\n    }\n\n    const constraints = getContextConstraints(description)\n    if (constraints !== undefined) {\n      ctx = { ...ctx, constraints }\n    }\n\n    if (description._tag === \"Declaration\") {\n      return applyFilters(filters, annotation(...description.typeParameters.map((p) => go(p, ctx)), ctx))\n    }\n    if (description.refinements.length > 0) {\n      // TODO(4.0): remove the `lazyArb` parameter\n      return applyFilters(filters, annotation(lazyArb, ctx))\n    }\n    return annotation(ctx)\n  },\n  (description, ctx) => {\n    switch (description._tag) {\n      case \"DateFromSelf\": {\n        const constraints = buildDateConstraints(description)\n        return (fc) => fc.date(constraints?.constraints)\n      }\n      case \"Declaration\":\n      case \"NeverKeyword\":\n        return absurd(`BUG: cannot generate an arbitrary for ${description._tag}`)\n      case \"Literal\":\n        return (fc) => fc.constant(description.literal)\n      case \"UniqueSymbol\":\n        return (fc) => fc.constant(description.symbol)\n      case \"Keyword\": {\n        switch (description.value) {\n          case \"UndefinedKeyword\":\n            return (fc) => fc.constant(undefined)\n          case \"VoidKeyword\":\n          case \"UnknownKeyword\":\n          case \"AnyKeyword\":\n            return (fc) => fc.anything()\n          case \"BooleanKeyword\":\n            return (fc) => fc.boolean()\n          case \"SymbolKeyword\":\n            return (fc) => fc.string().map((s) => Symbol.for(s))\n          case \"ObjectKeyword\":\n            return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()))\n        }\n      }\n      case \"Enums\":\n        return (fc) => fc.oneof(...description.enums.map(([_, value]) => fc.constant(value)))\n      case \"TemplateLiteral\": {\n        return (fc) => {\n          const string = fc.string({ maxLength: 5 })\n          const number = fc.float({ noDefaultInfinity: true, noNaN: true })\n\n          const getTemplateLiteralArb = (description: TemplateLiteral) => {\n            const components: Array<FastCheck.Arbitrary<string | number>> = description.head !== \"\"\n              ? [fc.constant(description.head)]\n              : []\n\n            const getTemplateLiteralSpanTypeArb = (\n              description: Description\n            ): FastCheck.Arbitrary<string | number> => {\n              switch (description._tag) {\n                case \"StringKeyword\":\n                  return string\n                case \"NumberKeyword\":\n                  return number\n                case \"Literal\":\n                  return fc.constant(String(description.literal))\n                case \"Union\":\n                  return fc.oneof(...description.members.map(getTemplateLiteralSpanTypeArb))\n                case \"TemplateLiteral\":\n                  return getTemplateLiteralArb(description)\n                default:\n                  return fc.constant(\"\")\n              }\n            }\n\n            description.spans.forEach((span) => {\n              components.push(getTemplateLiteralSpanTypeArb(span.description))\n              if (span.literal !== \"\") {\n                components.push(fc.constant(span.literal))\n              }\n            })\n\n            return fc.tuple(...components).map((spans) => spans.join(\"\"))\n          }\n\n          return getTemplateLiteralArb(description)\n        }\n      }\n      case \"StringKeyword\": {\n        const constraints = buildStringConstraints(description)\n        const pattern = constraints?.pattern\n        return pattern !== undefined ?\n          (fc) => fc.stringMatching(new RegExp(pattern)) :\n          (fc) => fc.string(constraints?.constraints)\n      }\n      case \"NumberKeyword\": {\n        const constraints = buildNumberConstraints(description)\n        return constraints?.isInteger ?\n          (fc) => fc.integer(constraints.constraints) :\n          (fc) => fc.float(constraints?.constraints)\n      }\n      case \"BigIntKeyword\": {\n        const constraints = buildBigIntConstraints(description)\n        return (fc) => fc.bigInt(constraints?.constraints ?? {})\n      }\n      case \"TupleType\": {\n        const elements: Array<LazyArbitrary<any>> = []\n        let hasOptionals = false\n        for (const element of description.elements) {\n          elements.push(go(element.description, ctx))\n          if (element.isOptional) {\n            hasOptionals = true\n          }\n        }\n        const rest = description.rest.map((d) => go(d, ctx))\n        return (fc) => {\n          // ---------------------------------------------\n          // handle elements\n          // ---------------------------------------------\n          let output = fc.tuple(...elements.map((arb) => arb(fc)))\n          if (hasOptionals) {\n            const indexes = fc.tuple(\n              ...description.elements.map((element) => element.isOptional ? fc.boolean() : fc.constant(true))\n            )\n            output = output.chain((tuple) =>\n              indexes.map((booleans) => {\n                for (const [i, b] of booleans.reverse().entries()) {\n                  if (!b) {\n                    tuple.splice(booleans.length - i, 1)\n                  }\n                }\n                return tuple\n              })\n            )\n          }\n\n          // ---------------------------------------------\n          // handle rest element\n          // ---------------------------------------------\n          if (Arr.isNonEmptyReadonlyArray(rest)) {\n            const constraints = buildArrayConstraints(description) ?? constArrayConstraints\n            const [head, ...tail] = rest\n            const item = head(fc)\n            output = output.chain((as) => {\n              const len = as.length\n              // We must adjust the constraints for the rest element\n              // because the elements might have generated some values\n              const restArrayConstraints = subtractElementsLength(constraints.constraints, len)\n              if (restArrayConstraints.maxLength === 0) {\n                return fc.constant(as)\n              }\n              /*\n\n              `getSuspendedArray` is used to generate less values in\n              the context of a recursive schema. Without it, the following schema\n              would generate an big amount of values possibly leading to a stack\n              overflow:\n\n              ```ts\n              type A = ReadonlyArray<A | null>\n\n              const schema = S.Array(\n                S.NullOr(S.suspend((): S.Schema<A> => schema))\n              )\n              ```\n\n            */\n              const arr = ctx.depthIdentifier !== undefined\n                ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, restArrayConstraints)\n                : fc.array(item, restArrayConstraints)\n              if (len === 0) {\n                return arr\n              }\n              return arr.map((rest) => [...as, ...rest])\n            })\n            // ---------------------------------------------\n            // handle post rest elements\n            // ---------------------------------------------\n            for (let j = 0; j < tail.length; j++) {\n              output = output.chain((as) => tail[j](fc).map((a) => [...as, a]))\n            }\n          }\n\n          return output\n        }\n      }\n      case \"TypeLiteral\": {\n        const propertySignatures: Array<LazyArbitrary<any>> = []\n        const requiredKeys: Array<PropertyKey> = []\n        for (const ps of description.propertySignatures) {\n          if (!ps.isOptional) {\n            requiredKeys.push(ps.name)\n          }\n          propertySignatures.push(go(ps.value, ctx))\n        }\n        const indexSignatures = description.indexSignatures.map((is) =>\n          [go(is.parameter, ctx), go(is.value, ctx)] as const\n        )\n        return (fc) => {\n          const pps: any = {}\n          for (let i = 0; i < propertySignatures.length; i++) {\n            const ps = description.propertySignatures[i]\n            pps[ps.name] = propertySignatures[i](fc)\n          }\n          let output = fc.record<any, any>(pps, { requiredKeys })\n          // ---------------------------------------------\n          // handle index signatures\n          // ---------------------------------------------\n          for (let i = 0; i < indexSignatures.length; i++) {\n            const key = indexSignatures[i][0](fc)\n            const value = indexSignatures[i][1](fc)\n            output = output.chain((o) => {\n              const item = fc.tuple(key, value)\n              /*\n\n              `getSuspendedArray` is used to generate less key/value pairs in\n              the context of a recursive schema. Without it, the following schema\n              would generate an big amount of values possibly leading to a stack\n              overflow:\n\n              ```ts\n              type A = { [_: string]: A }\n\n              const schema = S.Record({ key: S.String, value: S.suspend((): S.Schema<A> => schema) })\n              ```\n\n            */\n              const arr = ctx.depthIdentifier !== undefined ?\n                getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, { maxLength: 2 }) :\n                fc.array(item)\n              return arr.map((tuples) => ({ ...Object.fromEntries(tuples), ...o }))\n            })\n          }\n\n          return output\n        }\n      }\n      case \"Union\": {\n        const members = description.members.map((member) => go(member, ctx))\n        return (fc) => fc.oneof(...members.map((arb) => arb(fc)))\n      }\n      case \"Suspend\": {\n        const memo = arbitraryMemoMap.get(description.ast)\n        if (memo) {\n          return memo\n        }\n        if (ctx.depthIdentifier === undefined) {\n          ctx = { ...ctx, depthIdentifier: description.id }\n        }\n        const get = util_.memoizeThunk(() => {\n          return go(description.description(), ctx)\n        })\n        const out: LazyArbitrary<any> = (fc) => fc.constant(null).chain(() => get()(fc))\n        arbitraryMemoMap.set(description.ast, out)\n        return out\n      }\n      case \"Ref\": {\n        const memo = arbitraryMemoMap.get(description.ast)\n        if (memo) {\n          return memo\n        }\n        throw new Error(`BUG: Ref ${JSON.stringify(description.id)} not found`)\n      }\n    }\n  }\n)\n\nfunction subtractElementsLength(\n  constraints: FastCheck.ArrayConstraints,\n  len: number\n): FastCheck.ArrayConstraints {\n  if (len === 0 || (constraints.minLength === undefined && constraints.maxLength === undefined)) {\n    return constraints\n  }\n  const out = { ...constraints }\n  if (out.minLength !== undefined) {\n    out.minLength = Math.max(out.minLength - len, 0)\n  }\n  if (out.maxLength !== undefined) {\n    out.maxLength = Math.max(out.maxLength - len, 0)\n  }\n  return out\n}\n\nconst getSuspendedArray = (\n  fc: typeof FastCheck,\n  depthIdentifier: string,\n  maxDepth: number,\n  item: FastCheck.Arbitrary<any>,\n  constraints: FastCheck.ArrayConstraints\n) => {\n  // In the context of a recursive schema, we don't want a `maxLength` greater than 2.\n  // The only exception is when `minLength` is also set, in which case we set\n  // `maxLength` to the minimum value, which is `minLength`.\n  const maxLengthLimit = Math.max(2, constraints.minLength ?? 0)\n  if (constraints.maxLength !== undefined && constraints.maxLength > maxLengthLimit) {\n    constraints = { ...constraints, maxLength: maxLengthLimit }\n  }\n  return fc.oneof(\n    { maxDepth, depthIdentifier },\n    fc.constant([]),\n    fc.array(item, constraints)\n  )\n}\n", "/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type { Either } from \"./Either.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as internal from \"./internal/cache.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Predicate from \"./Predicate.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const CacheTypeId: unique symbol = internal.CacheTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type CacheTypeId = typeof CacheTypeId\n\n/**\n * @since 3.6.4\n * @category symbols\n */\nexport const ConsumerCacheTypeId: unique symbol = internal.ConsumerCacheTypeId\n\n/**\n * @since 3.6.4\n * @category symbols\n */\nexport type ConsumerCacheTypeId = typeof ConsumerCacheTypeId\n\n/**\n * A `Cache` is defined in terms of a lookup function that, given a key of\n * type `Key`, can either fail with an error of type `Error` or succeed with a\n * value of type `Value`. Getting a value from the cache will either return\n * the previous result of the lookup function if it is available or else\n * compute a new result with the lookup function, put it in the cache, and\n * return it.\n *\n * A cache also has a specified capacity and time to live. When the cache is\n * at capacity the least recently accessed values in the cache will be\n * removed to make room for new values. Getting a value with a life older than\n * the specified time to live will result in a new value being computed with\n * the lookup function and returned when available.\n *\n * The cache is safe for concurrent access. If multiple fibers attempt to get\n * the same key the lookup function will only be computed once and the result\n * will be returned to all fibers.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Cache<in out Key, in out Value, out Error = never>\n  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it.\n   */\n  get(key: Key): Effect.Effect<Value, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists as a left.\n   * Otherwise computes the value with the lookup function, puts it in the\n   * cache, and returns it as a right.\n   */\n  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>\n\n  /**\n   * Computes the value associated with the specified key, with the lookup\n   * function, and puts it in the cache. The difference between this and\n   * `get` method is that `refresh` triggers (re)computation of the value\n   * without invalidating it in the cache, so any request to the associated\n   * key can still be served while the value is being re-computed/retrieved\n   * by the lookup function. Additionally, `refresh` always triggers the\n   * lookup function, disregarding the last `Error`.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Associates the specified value with the specified key in the cache.\n   */\n  set(key: Key, value: Value): Effect.Effect<void>\n}\n\n/**\n * A ConsumerCache models a portion of a cache which is safe to share without allowing to create new values or access existing ones.\n *\n * It can be used safely to give over control for request management without leaking writer side details.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface ConsumerCache<in out Key, out Value, out Error = never>\n  extends Cache.ConsumerVariance<Key, Value, Error>\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<CacheStats>\n\n  /**\n   * Returns whether a value associated with the specified key exists in the\n   * cache.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Returns statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<EntryStats>>\n\n  /**\n   * Invalidates the value associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates the value associated with the specified key if the predicate holds.\n   */\n  invalidateWhen(key: Key, predicate: Predicate.Predicate<Value>): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly keys: Effect.Effect<Array<Key>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly values: Effect.Effect<Array<Value>>\n\n  /**\n   * Returns an approximation of the values in the cache.\n   */\n  readonly entries: Effect.Effect<Array<[Key, Value]>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Cache {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out Key, in out Value, out Error> {\n    readonly [CacheTypeId]: {\n      readonly _Key: Types.Invariant<Key>\n      readonly _Error: Types.Covariant<Error>\n      readonly _Value: Types.Invariant<Value>\n    }\n  }\n  /**\n   * @since 3.6.4\n   * @category models\n   */\n  export interface ConsumerVariance<in out Key, out Value, out Error> {\n    readonly [ConsumerCacheTypeId]: {\n      readonly _Key: Types.Invariant<Key>\n      readonly _Error: Types.Covariant<Error>\n      readonly _Value: Types.Covariant<Value>\n    }\n  }\n}\n\n/**\n * Constructs a new cache with the specified capacity, time to live, and\n * lookup function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly timeToLive: Duration.DurationInput\n    readonly lookup: Lookup<Key, Value, Error, Environment>\n  }\n) => Effect.Effect<Cache<Key, Value, Error>, never, Environment> = internal.make\n\n/**\n * Constructs a new cache with the specified capacity, time to live, and\n * lookup function, where the time to live can depend on the `Exit` value\n * returned by the lookup function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWith: <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly lookup: Lookup<Key, Value, Error, Environment>\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n  }\n) => Effect.Effect<Cache<Key, Value, Error>, never, Environment> = internal.makeWith\n\n/**\n * `CacheStats` represents a snapshot of statistics for the cache as of a\n * point in time.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface CacheStats {\n  readonly hits: number\n  readonly misses: number\n  readonly size: number\n}\n\n/**\n * Constructs a new `CacheStats` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeCacheStats: (\n  options: {\n    readonly hits: number\n    readonly misses: number\n    readonly size: number\n  }\n) => CacheStats = internal.makeCacheStats\n\n/**\n * Represents a snapshot of statistics for an entry in the cache.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface EntryStats {\n  readonly loadedMillis: number\n}\n\n/**\n * Constructs a new `EntryStats` from the specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeEntryStats: (loadedMillis: number) => EntryStats = internal.makeEntryStats\n\n/**\n * A `Lookup` represents a lookup function that, given a key of type `Key`, can\n * return an effect that will either produce a value of type `Value` or fail\n * with an error of type `Error` using an environment of type `Environment`.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Lookup<Key, Value, Error = never, Environment = never> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment>\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/channel/childExecutorDecision.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ChildExecutorDecisionTypeId: unique symbol = internal.ChildExecutorDecisionTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ChildExecutorDecisionTypeId = typeof ChildExecutorDecisionTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type ChildExecutorDecision = Continue | Close | Yield\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ChildExecutorDecision {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId\n  }\n}\n\n/**\n * Continue executing the current substream\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Continue extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Continue\"\n}\n\n/**\n * Close the current substream with a given value and pass execution to the\n * next substream\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Close extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Close\"\n  readonly value: unknown\n}\n\n/**\n * Pass execution to the next substream. This either pulls a new element\n * from upstream, or yields to an already created active substream.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Yield extends ChildExecutorDecision.Proto {\n  readonly _tag: \"Yield\"\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Continue: (_: void) => ChildExecutorDecision = internal.Continue\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Close: (value: unknown) => ChildExecutorDecision = internal.Close\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Yield: (_: void) => ChildExecutorDecision = internal.Yield\n\n/**\n * Returns `true` if the specified value is a `ChildExecutorDecision`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision = internal.isChildExecutorDecision\n\n/**\n * Returns `true` if the specified `ChildExecutorDecision` is a `Continue`,\n * `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isContinue: (self: ChildExecutorDecision) => self is Continue = internal.isContinue\n\n/**\n * Returns `true` if the specified `ChildExecutorDecision` is a `Close`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isClose: (self: ChildExecutorDecision) => self is Close = internal.isClose\n\n/**\n * Returns `true` if the specified `ChildExecutorDecision` is a `Yield`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isYield: (self: ChildExecutorDecision) => self is Yield = internal.isYield\n\n/**\n * Folds over a `ChildExecutorDecision` to produce a value of type `A`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds over a `ChildExecutorDecision` to produce a value of type `A`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   options: {\n     readonly onContinue: () => A\n     readonly onClose: (value: unknown) => A\n     readonly onYield: () => A\n   }\n  ): (self: ChildExecutorDecision) => A\n  /**\n   * Folds over a `ChildExecutorDecision` to produce a value of type `A`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   self: ChildExecutorDecision,\n   options: {\n     readonly onContinue: () => A\n     readonly onClose: (value: unknown) => A\n     readonly onYield: () => A\n   }\n  ): A\n} = internal.match\n", "/**\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport type { Effect } from \"./Effect.js\"\nimport * as internal from \"./internal/console.js\"\nimport * as defaultConsole from \"./internal/defaultServices/console.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type { Scope } from \"./Scope.js\"\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = defaultConsole.TypeId\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface Console {\n  readonly [TypeId]: TypeId\n  assert(condition: boolean, ...args: ReadonlyArray<any>): Effect<void>\n  readonly clear: Effect<void>\n  count(label?: string): Effect<void>\n  countReset(label?: string): Effect<void>\n  debug(...args: ReadonlyArray<any>): Effect<void>\n  dir(item: any, options?: any): Effect<void>\n  dirxml(...args: ReadonlyArray<any>): Effect<void>\n  error(...args: ReadonlyArray<any>): Effect<void>\n  group(options?: {\n    readonly label?: string | undefined\n    readonly collapsed?: boolean | undefined\n  }): Effect<void>\n  readonly groupEnd: Effect<void>\n  info(...args: ReadonlyArray<any>): Effect<void>\n  log(...args: ReadonlyArray<any>): Effect<void>\n  table(tabularData: any, properties?: ReadonlyArray<string>): Effect<void>\n  time(label?: string): Effect<void>\n  timeEnd(label?: string): Effect<void>\n  timeLog(label?: string, ...args: ReadonlyArray<any>): Effect<void>\n  trace(...args: ReadonlyArray<any>): Effect<void>\n  warn(...args: ReadonlyArray<any>): Effect<void>\n  readonly unsafe: UnsafeConsole\n}\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface UnsafeConsole {\n  assert(condition: boolean, ...args: ReadonlyArray<any>): void\n  clear(): void\n  count(label?: string): void\n  countReset(label?: string): void\n  debug(...args: ReadonlyArray<any>): void\n  dir(item: any, options?: any): void\n  dirxml(...args: ReadonlyArray<any>): void\n  error(...args: ReadonlyArray<any>): void\n  group(...args: ReadonlyArray<any>): void\n  groupCollapsed(...args: ReadonlyArray<any>): void\n  groupEnd(): void\n  info(...args: ReadonlyArray<any>): void\n  log(...args: ReadonlyArray<any>): void\n  table(tabularData: any, properties?: ReadonlyArray<string>): void\n  time(label?: string): void\n  timeEnd(label?: string): void\n  timeLog(label?: string, ...args: ReadonlyArray<any>): void\n  trace(...args: ReadonlyArray<any>): void\n  warn(...args: ReadonlyArray<any>): void\n}\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const Console: Context.Tag<Console, Console> = defaultConsole.consoleTag\n\n/**\n * @since 2.0.0\n * @category default services\n */\nexport const withConsole: {\n  /**\n   * @since 2.0.0\n   * @category default services\n   */\n  <C extends Console>(console: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category default services\n   */\n  <A, E, R, C extends Console>(effect: Effect<A, E, R>, console: C): Effect<A, E, R>\n} = internal.withConsole\n\n/**\n * @since 2.0.0\n * @category default services\n */\nexport const setConsole: <A extends Console>(console: A) => Layer.Layer<never> = internal.setConsole\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R> = internal.consoleWith\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const assert: (condition: boolean, ...args: ReadonlyArray<any>) => Effect<void> = internal.assert\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const clear: Effect<void> = internal.clear\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const count: (label?: string) => Effect<void> = internal.count\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const countReset: (label?: string) => Effect<void> = internal.countReset\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const debug: (...args: ReadonlyArray<any>) => Effect<void> = internal.debug\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const dir: (item: any, options?: any) => Effect<void> = internal.dir\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const dirxml: (...args: ReadonlyArray<any>) => Effect<void> = internal.dirxml\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const error: (...args: ReadonlyArray<any>) => Effect<void> = internal.error\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const group: (\n  options?: { label?: string | undefined; collapsed?: boolean | undefined } | undefined\n) => Effect<void, never, Scope> = internal.group\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const info: (...args: ReadonlyArray<any>) => Effect<void> = internal.info\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const log: (...args: ReadonlyArray<any>) => Effect<void> = internal.log\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const table: (tabularData: any, properties?: ReadonlyArray<string>) => Effect<void> = internal.table\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const time: (label?: string | undefined) => Effect<void, never, Scope> = internal.time\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const timeLog: (label?: string, ...args: ReadonlyArray<any>) => Effect<void> = internal.timeLog\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const trace: (...args: ReadonlyArray<any>) => Effect<void> = internal.trace\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const warn: (...args: ReadonlyArray<any>) => Effect<void> = internal.warn\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const withGroup: {\n  /**\n   * @since 2.0.0\n   * @category accessor\n   */\n  (\n   options?: {\n     readonly label?: string | undefined\n     readonly collapsed?: boolean | undefined\n   }\n  ): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category accessor\n   */\n  <A, E, R>(\n   self: Effect<A, E, R>,\n   options?: {\n     readonly label?: string | undefined\n     readonly collapsed?: boolean | undefined\n   }\n  ): Effect<A, E, R>\n} = internal.withGroup\n\n/**\n * @since 2.0.0\n * @category accessor\n */\nexport const withTime: {\n  /**\n   * @since 2.0.0\n   * @category accessor\n   */\n  (label?: string): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category accessor\n   */\n  <A, E, R>(self: Effect<A, E, R>, label?: string): Effect<A, E, R>\n} = internal.withTime\n", "/**\n * @since 3.16.0\n * @experimental\n */\nimport type { NonEmptyReadonlyArray } from \"./Array.js\"\nimport type * as Context from \"./Context.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/executionPlan.js\"\nimport * as Layer from \"./Layer.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport type * as Schedule from \"./Schedule.js\"\n\n/**\n * @since 3.16.0\n * @category Symbols\n * @experimental\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 3.16.0\n * @category Symbols\n * @experimental\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 3.16.0\n * @category Guards\n * @experimental\n */\nexport const isExecutionPlan: (u: unknown) => u is ExecutionPlan<any> = internal.isExecutionPlan\n\n/**\n * A `ExecutionPlan` can be used with `Effect.withExecutionPlan` or `Stream.withExecutionPlan`, allowing you to provide different resources for each step of execution until the effect succeeds or the plan is exhausted.\n *\n * ```ts\n * import { type AiLanguageModel } from \"@effect/ai\"\n * import type { Layer } from \"effect\"\n * import { Effect, ExecutionPlan, Schedule } from \"effect\"\n *\n * declare const layerBad: Layer.Layer<AiLanguageModel.AiLanguageModel>\n * declare const layerGood: Layer.Layer<AiLanguageModel.AiLanguageModel>\n *\n * const ThePlan = ExecutionPlan.make(\n *   {\n *     // First try with the bad layer 2 times with a 3 second delay between attempts\n *     provide: layerBad,\n *     attempts: 2,\n *     schedule: Schedule.spaced(3000)\n *   },\n *   // Then try with the bad layer 3 times with a 1 second delay between attempts\n *   {\n *     provide: layerBad,\n *     attempts: 3,\n *     schedule: Schedule.spaced(1000)\n *   },\n *   // Finally try with the good layer.\n *   //\n *   // If `attempts` is omitted, the plan will only attempt once, unless a schedule is provided.\n *   {\n *     provide: layerGood\n *   }\n * )\n *\n * declare const effect: Effect.Effect<\n *   void,\n *   never,\n *   AiLanguageModel.AiLanguageModel\n * >\n * const withPlan: Effect.Effect<void> = Effect.withExecutionPlan(effect, ThePlan)\n * ```\n *\n * @since 3.16.0\n * @category Models\n * @experimental\n */\nexport interface ExecutionPlan<\n  Types extends {\n    provides: any\n    input: any\n    error: any\n    requirements: any\n  }\n> extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly steps: NonEmptyReadonlyArray<{\n    readonly provide:\n      | Context.Context<Types[\"provides\"]>\n      | Layer.Layer<Types[\"provides\"], Types[\"error\"], Types[\"requirements\"]>\n    readonly attempts?: number | undefined\n    readonly while?:\n      | ((input: Types[\"input\"]) => Effect.Effect<boolean, Types[\"error\"], Types[\"requirements\"]>)\n      | undefined\n    readonly schedule?: Schedule.Schedule<any, Types[\"input\"], Types[\"requirements\"]> | undefined\n  }>\n\n  /**\n   * Returns an equivalent `ExecutionPlan` with the requirements satisfied,\n   * using the current context.\n   */\n  readonly withRequirements: Effect.Effect<\n    ExecutionPlan<{\n      provides: Types[\"provides\"]\n      input: Types[\"input\"]\n      error: Types[\"error\"]\n      requirements: never\n    }>,\n    never,\n    Types[\"requirements\"]\n  >\n}\n\n/**\n * @since 3.16.0\n * @experimental\n */\nexport type TypesBase = {\n  provides: any\n  input: any\n  error: any\n  requirements: any\n}\n\n/**\n * Create an `ExecutionPlan`, which can be used with `Effect.withExecutionPlan` or `Stream.withExecutionPlan`, allowing you to provide different resources for each step of execution until the effect succeeds or the plan is exhausted.\n *\n * ```ts\n * import { type AiLanguageModel } from \"@effect/ai\"\n * import type { Layer } from \"effect\"\n * import { Effect, ExecutionPlan, Schedule } from \"effect\"\n *\n * declare const layerBad: Layer.Layer<AiLanguageModel.AiLanguageModel>\n * declare const layerGood: Layer.Layer<AiLanguageModel.AiLanguageModel>\n *\n * const ThePlan = ExecutionPlan.make(\n *   {\n *     // First try with the bad layer 2 times with a 3 second delay between attempts\n *     provide: layerBad,\n *     attempts: 2,\n *     schedule: Schedule.spaced(3000)\n *   },\n *   // Then try with the bad layer 3 times with a 1 second delay between attempts\n *   {\n *     provide: layerBad,\n *     attempts: 3,\n *     schedule: Schedule.spaced(1000)\n *   },\n *   // Finally try with the good layer.\n *   //\n *   // If `attempts` is omitted, the plan will only attempt once, unless a schedule is provided.\n *   {\n *     provide: layerGood\n *   }\n * )\n *\n * declare const effect: Effect.Effect<\n *   void,\n *   never,\n *   AiLanguageModel.AiLanguageModel\n * >\n * const withPlan: Effect.Effect<void> = Effect.withExecutionPlan(effect, ThePlan)\n * ```\n *\n * @since 3.16.0\n * @category Constructors\n * @experimental\n */\nexport const make = <const Steps extends NonEmptyReadonlyArray<make.Step>>(\n  ...steps: Steps & { [K in keyof Steps]: make.Step }\n): ExecutionPlan<{\n  provides: make.StepProvides<Steps>\n  input: make.StepInput<Steps>\n  error:\n    | (Steps[number][\"provide\"] extends Context.Context<infer _P> | Layer.Layer<infer _P, infer E, infer _R> ? E\n      : never)\n    | (Steps[number][\"while\"] extends (input: infer _I) => Effect.Effect<infer _A, infer _E, infer _R> ? _E : never)\n  requirements:\n    | (Steps[number][\"provide\"] extends Layer.Layer<infer _A, infer _E, infer R> ? R : never)\n    | (Steps[number][\"while\"] extends (input: infer _I) => Effect.Effect<infer _A, infer _E, infer R> ? R : never)\n    | (Steps[number][\"schedule\"] extends Schedule.Schedule<infer _O, infer _I, infer R> ? R : never)\n}> =>\n  makeProto(steps.map((options, i) => {\n    if (options.attempts && options.attempts < 1) {\n      throw new Error(`ExecutionPlan.make: step[${i}].attempts must be greater than 0`)\n    }\n    return {\n      schedule: options.schedule,\n      attempts: options.attempts,\n      while: options.while\n        ? (input: any) =>\n          Effect.suspend(() => {\n            const result = options.while!(input)\n            return typeof result === \"boolean\" ? Effect.succeed(result) : result\n          })\n        : undefined,\n      provide: options.provide\n    }\n  }) as any)\n\n/**\n * @since 3.16.0\n * @experimental\n */\nexport declare namespace make {\n  /**\n   * @since 3.16.0\n   * @experimental\n   */\n  export type Step = {\n    readonly provide: Context.Context<any> | Context.Context<never> | Layer.Layer.Any\n    readonly attempts?: number | undefined\n    readonly while?: ((input: any) => boolean | Effect.Effect<boolean, any, any>) | undefined\n    readonly schedule?: Schedule.Schedule<any, any, any> | undefined\n  }\n\n  /**\n   * @since 3.16.1\n   * @experimental\n   */\n  export type StepProvides<Steps extends ReadonlyArray<any>, Out = unknown> = Steps extends\n    readonly [infer Step, ...infer Rest] ? StepProvides<\n      Rest,\n      & Out\n      & (\n        (Step extends { readonly provide: Context.Context<infer P> | Layer.Layer<infer P, infer _E, infer _R> } ? P\n          : unknown)\n      )\n    > :\n    Out\n\n  /**\n   * @since 3.16.1\n   * @experimental\n   */\n  export type PlanProvides<Plans extends ReadonlyArray<any>, Out = unknown> = Plans extends\n    readonly [infer Plan, ...infer Rest] ?\n    PlanProvides<Rest, Out & (Plan extends ExecutionPlan<infer T> ? T[\"provides\"] : unknown)> :\n    Out\n\n  /**\n   * @since 3.16.0\n   * @experimental\n   */\n  export type StepInput<Steps extends ReadonlyArray<any>, Out = unknown> = Steps extends\n    readonly [infer Step, ...infer Rest] ? StepInput<\n      Rest,\n      & Out\n      & (\n        & (Step extends { readonly while: (input: infer I) => infer _ } ? I : unknown)\n        & (Step extends { readonly schedule: Schedule.Schedule<infer _O, infer I, infer _R> } ? I : unknown)\n      )\n    > :\n    Out\n\n  /**\n   * @since 3.16.0\n   * @experimental\n   */\n  export type PlanInput<Plans extends ReadonlyArray<any>, Out = unknown> = Plans extends\n    readonly [infer Plan, ...infer Rest] ?\n    PlanInput<Rest, Out & (Plan extends ExecutionPlan<infer T> ? T[\"input\"] : unknown)> :\n    Out\n}\n\nconst Proto: Omit<ExecutionPlan<any>, \"steps\"> = {\n  [TypeId]: TypeId,\n  get withRequirements() {\n    const self = this as any as ExecutionPlan<any>\n    return Effect.contextWith((context: Context.Context<any>) =>\n      makeProto(self.steps.map((step) => ({\n        ...step,\n        provide: Layer.isLayer(step.provide) ? Layer.provide(step.provide, Layer.succeedContext(context)) : step.provide\n      })) as any)\n    )\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeProto = <Provides, In, PlanE, PlanR>(\n  steps: ExecutionPlan<{\n    provides: Provides\n    input: In\n    error: PlanE\n    requirements: PlanR\n  }>[\"steps\"]\n) => {\n  const self = Object.create(Proto)\n  self.steps = steps\n  return self\n}\n\n/**\n * @since 3.16.0\n * @category Combining\n * @experimental\n */\nexport const merge = <const Plans extends NonEmptyReadonlyArray<ExecutionPlan<any>>>(\n  ...plans: Plans\n): ExecutionPlan<{\n  provides: make.PlanProvides<Plans>\n  input: make.PlanInput<Plans>\n  error: Plans[number] extends ExecutionPlan<infer T> ? T[\"error\"] : never\n  requirements: Plans[number] extends ExecutionPlan<infer T> ? T[\"requirements\"] : never\n}> => makeProto(plans.flatMap((plan) => plan.steps) as any)\n", "/**\n * @since 2.0.0\n */\nimport type { NoSuchElementException } from \"./Cause.js\"\nimport * as Cause from \"./Cause.js\"\nimport * as Deferred from \"./Deferred.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as Exit from \"./Exit.js\"\nimport * as Fiber from \"./Fiber.js\"\nimport * as FiberId from \"./FiberId.js\"\nimport { constFalse, dual } from \"./Function.js\"\nimport * as HashSet from \"./HashSet.js\"\nimport * as Inspectable from \"./Inspectable.js\"\nimport * as Option from \"./Option.js\"\nimport { type Pipeable, pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport * as Runtime from \"./Runtime.js\"\nimport type * as Scope from \"./Scope.js\"\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/FiberHandle\")\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @categories models\n */\nexport interface FiberHandle<out A = unknown, out E = unknown> extends Pipeable, Inspectable.Inspectable {\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    fiber: Fiber.RuntimeFiber<A, E> | undefined\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}\n\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberHandle = (u: unknown): u is FiberHandle => Predicate.hasProperty(u, TypeId)\n\nconst Proto = {\n  [TypeId]: TypeId,\n  toString(this: FiberHandle) {\n    return Inspectable.format(this.toJSON())\n  },\n  toJSON(this: FiberHandle) {\n    return {\n      _id: \"FiberHandle\",\n      state: this.state\n    }\n  },\n  [Inspectable.NodeInspectSymbol](this: FiberHandle) {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst unsafeMake = <A = unknown, E = unknown>(\n  deferred: Deferred.Deferred<void, E>\n): FiberHandle<A, E> => {\n  const self = Object.create(Proto)\n  self.state = { _tag: \"Open\", fiber: undefined }\n  self.deferred = deferred\n  return self\n}\n\n/**\n * A FiberHandle can be used to store a single fiber.\n * When the associated Scope is closed, the contained fiber will be interrupted.\n *\n * You can add a fiber to the handle using `FiberHandle.run`, and the fiber will\n * be automatically removed from the FiberHandle when it completes.\n *\n * @example\n * ```ts\n * import { Effect, FiberHandle } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const handle = yield* FiberHandle.make()\n *\n *   // run some effects\n *   yield* FiberHandle.run(handle, Effect.never)\n *   // this will interrupt the previous fiber\n *   yield* FiberHandle.run(handle, Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fiber will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = <A = unknown, E = unknown>(): Effect.Effect<FiberHandle<A, E>, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.map(Deferred.make<void, E>(), (deferred) => unsafeMake<A, E>(deferred)),\n    (handle) =>\n      Effect.withFiberRuntime((parent) => {\n        const state = handle.state\n        if (state._tag === \"Closed\") return Effect.void\n        handle.state = { _tag: \"Closed\" }\n        return state.fiber ?\n          Effect.intoDeferred(\n            Effect.asVoid(Fiber.interruptAs(state.fiber, FiberId.combine(parent.id(), internalFiberId))),\n            handle.deferred\n          ) :\n          Deferred.done(handle.deferred, Exit.void)\n      })\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberHandle.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = <R, E = unknown, A = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n      }\n      | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<A, E>(),\n    (self) => runtime(self)<R>()\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberHandle.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = <R = never, A = unknown, E = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?: Runtime.RunForkOptions | undefined\n  ) => Promise<XA>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<A, E>(),\n    (self) => runtimePromise(self)<R>()\n  )\n\nconst internalFiberIdId = -1\nconst internalFiberId = FiberId.make(internalFiberIdId, 0)\nconst isInternalInterruption = Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n})\n\n/**\n * Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n * If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeSet: {\n  /**\n   * Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n   * If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): (self: FiberHandle<A, E>) => void\n  /**\n   * Set the fiber in a FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n   * If a fiber is already running, it will be interrupted unless `options.onlyIfMissing` is set.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    self: FiberHandle<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): void\n} = dual((args) => isFiberHandle(args[0]), <A, E, XE extends E, XA extends A>(\n  self: FiberHandle<A, E>,\n  fiber: Fiber.RuntimeFiber<XA, XE>,\n  options?: {\n    readonly interruptAs?: FiberId.FiberId | undefined\n    readonly onlyIfMissing?: boolean | undefined\n    readonly propagateInterruption?: boolean | undefined\n  }\n): void => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n    return\n  } else if (self.state.fiber !== undefined) {\n    if (options?.onlyIfMissing === true) {\n      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n      return\n    } else if (self.state.fiber === fiber) {\n      return\n    }\n    self.state.fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n    self.state.fiber = undefined\n  }\n\n  self.state.fiber = fiber\n  fiber.addObserver((exit) => {\n    if (self.state._tag === \"Open\" && fiber === self.state.fiber) {\n      self.state.fiber = undefined\n    }\n    if (\n      Exit.isFailure(exit) &&\n      (\n        options?.propagateInterruption === true ?\n          !isInternalInterruption(exit.cause) :\n          !Cause.isInterruptedOnly(exit.cause)\n      )\n    ) {\n      Deferred.unsafeDone(self.deferred, exit as any)\n    }\n  })\n})\n\n/**\n * Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n * If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const set: {\n  /**\n   * Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n   * If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): (self: FiberHandle<A, E>) => Effect.Effect<void>\n  /**\n   * Set the fiber in the FiberHandle. When the fiber completes, it will be removed from the FiberHandle.\n   * If a fiber already exists in the FiberHandle, it will be interrupted unless `options.onlyIfMissing` is set.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, XE extends E, XA extends A>(\n    self: FiberHandle<A, E>,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): Effect.Effect<void>\n} = dual((args) => isFiberHandle(args[0]), <A, E, XE extends E, XA extends A>(\n  self: FiberHandle<A, E>,\n  fiber: Fiber.RuntimeFiber<XA, XE>,\n  options?: {\n    readonly onlyIfMissing?: boolean\n    readonly propagateInterruption?: boolean | undefined\n  }\n): Effect.Effect<void> =>\n  Effect.fiberIdWith(\n    (fiberId) =>\n      Effect.sync(() =>\n        unsafeSet(self, fiber, {\n          interruptAs: fiberId,\n          onlyIfMissing: options?.onlyIfMissing,\n          propagateInterruption: options?.propagateInterruption\n        })\n      )\n  ))\n\n/**\n * Retrieve the fiber from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeGet = <A, E>(self: FiberHandle<A, E>): Option.Option<Fiber.RuntimeFiber<A, E>> =>\n  self.state._tag === \"Closed\" ? Option.none() : Option.fromNullable(self.state.fiber)\n\n/**\n * Retrieve the fiber from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const get = <A, E>(self: FiberHandle<A, E>): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException> =>\n  Effect.suspend(() => unsafeGet(self))\n\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = <A, E>(self: FiberHandle<A, E>): Effect.Effect<void> =>\n  Effect.uninterruptibleMask((restore) =>\n    Effect.withFiberRuntime((fiber) => {\n      if (self.state._tag === \"Closed\" || self.state.fiber === undefined) {\n        return Effect.void\n      }\n      return Effect.zipRight(\n        restore(Fiber.interruptAs(self.state.fiber, FiberId.combine(fiber.id(), internalFiberId))),\n        Effect.sync(() => {\n          if (self.state._tag === \"Open\") {\n            self.state.fiber = undefined\n          }\n        })\n      )\n    })\n  )\n\nconst constInterruptedFiber = (function() {\n  let fiber: Fiber.RuntimeFiber<never, never> | undefined = undefined\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt)\n    }\n    return fiber\n  }\n})()\n\n/**\n * Run an Effect and add the forked fiber to the FiberHandle.\n * When the fiber completes, it will be removed from the FiberHandle.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run: {\n  /**\n   * Run an Effect and add the forked fiber to the FiberHandle.\n   * When the fiber completes, it will be removed from the FiberHandle.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E>(\n    self: FiberHandle<A, E>,\n    options?: {\n      readonly onlyIfMissing?: boolean\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): <R, XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>\n  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n  /**\n   * Run an Effect and add the forked fiber to the FiberHandle.\n   * When the fiber completes, it will be removed from the FiberHandle.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <A, E, R, XE extends E, XA extends A>(\n    self: FiberHandle<A, E>,\n    effect: Effect.Effect<XA, XE, R>,\n    options?: {\n      readonly onlyIfMissing?: boolean\n      readonly propagateInterruption?: boolean | undefined\n    }\n  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n} = function() {\n  const self = arguments[0] as FiberHandle\n  if (Effect.isEffect(arguments[1])) {\n    return runImpl(self, arguments[1], arguments[2]) as any\n  }\n  const options = arguments[1]\n  return (effect: Effect.Effect<unknown, unknown, any>) => runImpl(self, effect, options)\n}\n\nconst runImpl = <A, E, R, XE extends E, XA extends A>(\n  self: FiberHandle<A, E>,\n  effect: Effect.Effect<XA, XE, R>,\n  options?: {\n    readonly onlyIfMissing?: boolean\n    readonly propagateInterruption?: boolean | undefined\n  }\n): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R> =>\n  Effect.fiberIdWith((fiberId) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.interrupt\n    } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {\n      return Effect.sync(constInterruptedFiber)\n    }\n    return Effect.tap(\n      Effect.forkDaemon(effect),\n      (fiber) => unsafeSet(self, fiber, { ...options, interruptAs: fiberId })\n    )\n  })\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberHandle } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const handle = yield* FiberHandle.make()\n *   const run = yield* FiberHandle.runtime(handle)<Users>()\n *\n *   // run an effect and set the fiber in the handle\n *   run(Effect.andThen(Users, _ => _.getAll))\n *\n *   // this will interrupt the previous fiber\n *   run(Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fiber will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime: <A, E>(\n  self: FiberHandle<A, E>\n) => <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n        readonly propagateInterruption?: boolean | undefined\n      }\n      | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  R\n> = <A, E>(self: FiberHandle<A, E>) => <R>() =>\n  Effect.map(\n    Effect.runtime<R>(),\n    (runtime) => {\n      const runFork = Runtime.runFork(runtime)\n      return <XE extends E, XA extends A>(\n        effect: Effect.Effect<XA, XE, R>,\n        options?:\n          | Runtime.RunForkOptions & {\n            readonly onlyIfMissing?: boolean | undefined\n            readonly propagateInterruption?: boolean | undefined\n          }\n          | undefined\n      ) => {\n        if (self.state._tag === \"Closed\") {\n          return constInterruptedFiber()\n        } else if (self.state.fiber !== undefined && options?.onlyIfMissing === true) {\n          return constInterruptedFiber()\n        }\n        const fiber = runFork(effect, options)\n        unsafeSet(self, fiber, options)\n        return fiber\n      }\n    }\n  )\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberHandle.\n *\n * The returned run function will return Promise's that will resolve when the\n * fiber completes.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = <A, E>(self: FiberHandle<A, E>): <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n      | undefined\n  ) => Promise<XA>,\n  never,\n  R\n> =>\n<R>() =>\n  Effect.map(\n    runtime(self)<R>(),\n    (runFork) =>\n    <XE extends E, XA extends A>(\n      effect: Effect.Effect<XA, XE, R>,\n      options?:\n        | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n        | undefined\n    ): Promise<XA> =>\n      new Promise((resolve, reject) =>\n        runFork(effect, options).addObserver((exit) => {\n          if (Exit.isSuccess(exit)) {\n            resolve(exit.value)\n          } else {\n            reject(Cause.squash(exit.cause))\n          }\n        })\n      )\n  )\n\n/**\n * If any of the Fiber's in the handle terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberHandle } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const handle = yield* _(FiberHandle.make());\n *   yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberHandle.join(handle));\n * });\n * ```\n */\nexport const join = <A, E>(self: FiberHandle<A, E>): Effect.Effect<void, E> =>\n  Deferred.await(self.deferred as Deferred.Deferred<void, E>)\n\n/**\n * Wait for the fiber in the FiberHandle to complete.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = <A, E>(self: FiberHandle<A, E>): Effect.Effect<void, E> =>\n  Effect.suspend(() => {\n    if (self.state._tag === \"Closed\" || self.state.fiber === undefined) {\n      return Effect.void\n    }\n    return Fiber.await(self.state.fiber)\n  })\n", "/**\n * @since 2.0.0\n */\nimport type { NoSuchElementException } from \"./Cause.js\"\nimport * as Cause from \"./Cause.js\"\nimport * as Deferred from \"./Deferred.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as Exit from \"./Exit.js\"\nimport * as Fiber from \"./Fiber.js\"\nimport * as FiberId from \"./FiberId.js\"\nimport { constFalse, constVoid, dual } from \"./Function.js\"\nimport * as HashSet from \"./HashSet.js\"\nimport * as Inspectable from \"./Inspectable.js\"\nimport * as Iterable from \"./Iterable.js\"\nimport * as MutableHashMap from \"./MutableHashMap.js\"\nimport * as Option from \"./Option.js\"\nimport { type Pipeable, pipeArguments } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport * as Runtime from \"./Runtime.js\"\nimport type * as Scope from \"./Scope.js\"\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/FiberMap\")\n\n/**\n * @since 2.0.0\n * @categories type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @categories models\n */\nexport interface FiberMap<in out K, out A = unknown, out E = unknown>\n  extends Pipeable, Inspectable.Inspectable, Iterable<[K, Fiber.RuntimeFiber<A, E>]>\n{\n  readonly [TypeId]: TypeId\n  readonly deferred: Deferred.Deferred<void, unknown>\n  /** @internal */\n  state: {\n    readonly _tag: \"Open\"\n    readonly backing: MutableHashMap.MutableHashMap<K, Fiber.RuntimeFiber<A, E>>\n  } | {\n    readonly _tag: \"Closed\"\n  }\n}\n\n/**\n * @since 2.0.0\n * @categories refinements\n */\nexport const isFiberMap = (u: unknown): u is FiberMap<unknown> => Predicate.hasProperty(u, TypeId)\n\nconst Proto = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: FiberMap<unknown>) {\n    if (this.state._tag === \"Closed\") {\n      return Iterable.empty()\n    }\n    return this.state.backing[Symbol.iterator]()\n  },\n  toString(this: FiberMap<unknown>) {\n    return Inspectable.format(this.toJSON())\n  },\n  toJSON(this: FiberMap<unknown>) {\n    return {\n      _id: \"FiberMap\",\n      state: this.state\n    }\n  },\n  [Inspectable.NodeInspectSymbol](this: FiberMap<unknown>) {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst unsafeMake = <K, A = unknown, E = unknown>(\n  backing: MutableHashMap.MutableHashMap<K, Fiber.RuntimeFiber<A, E>>,\n  deferred: Deferred.Deferred<void, E>\n): FiberMap<K, A, E> => {\n  const self = Object.create(Proto)\n  self.state = { _tag: \"Open\", backing }\n  self.deferred = deferred\n  return self\n}\n\n/**\n * A FiberMap can be used to store a collection of fibers, indexed by some key.\n * When the associated Scope is closed, all fibers in the map will be interrupted.\n *\n * You can add fibers to the map using `FiberMap.set` or `FiberMap.run`, and the fibers will\n * be automatically removed from the FiberMap when they complete.\n *\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *\n *   // run some effects and add the fibers to the map\n *   yield* FiberMap.run(map, \"fiber a\", Effect.never)\n *   yield* FiberMap.run(map, \"fiber b\", Effect.never)\n *\n *   yield* Effect.sleep(1000)\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const make = <K, A = unknown, E = unknown>(): Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    Effect.map(Deferred.make<void, E>(), (deferred) =>\n      unsafeMake<K, A, E>(\n        MutableHashMap.empty(),\n        deferred\n      )),\n    (map) =>\n      Effect.withFiberRuntime((parent) => {\n        const state = map.state\n        if (state._tag === \"Closed\") return Effect.void\n        map.state = { _tag: \"Closed\" }\n        return Fiber.interruptAllAs(\n          Iterable.map(state.backing, ([, fiber]) => fiber),\n          FiberId.combine(parent.id(), internalFiberId)\n        ).pipe(\n          Effect.intoDeferred(map.deferred)\n        )\n      })\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 2.0.0\n * @categories constructors\n */\nexport const makeRuntime = <R, K, E = unknown, A = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    key: K,\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n      }\n      | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<K, A, E>(),\n    (self) => runtime(self)<R>()\n  )\n\n/**\n * Create an Effect run function that is backed by a FiberMap.\n *\n * @since 3.13.0\n * @categories constructors\n */\nexport const makeRuntimePromise = <R, K, A = unknown, E = unknown>(): Effect.Effect<\n  <XE extends E, XA extends A>(\n    key: K,\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n      }\n      | undefined\n  ) => Promise<XA>,\n  never,\n  Scope.Scope | R\n> =>\n  Effect.flatMap(\n    make<K, A, E>(),\n    (self) => runtimePromise(self)<R>()\n  )\n\nconst internalFiberIdId = -1\nconst internalFiberId = FiberId.make(internalFiberIdId, 0)\nconst isInternalInterruption = Cause.reduceWithContext(undefined, {\n  emptyCase: constFalse,\n  failCase: constFalse,\n  dieCase: constFalse,\n  interruptCase: (_, fiberId) => HashSet.has(FiberId.ids(fiberId), internalFiberIdId),\n  sequentialCase: (_, left, right) => left || right,\n  parallelCase: (_, left, right) => left || right\n})\n\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeSet: {\n  /**\n   * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n   * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E, XE extends E, XA extends A>(\n    key: K,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): (self: FiberMap<K, A, E>) => void\n  /**\n   * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n   * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E, XE extends E, XA extends A>(\n    self: FiberMap<K, A, E>,\n    key: K,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly interruptAs?: FiberId.FiberId | undefined\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): void\n} = dual((args) => isFiberMap(args[0]), <K, A, E, XE extends E, XA extends A>(\n  self: FiberMap<K, A, E>,\n  key: K,\n  fiber: Fiber.RuntimeFiber<XA, XE>,\n  options?: {\n    readonly interruptAs?: FiberId.FiberId | undefined\n    readonly onlyIfMissing?: boolean | undefined\n    readonly propagateInterruption?: boolean | undefined\n  } | undefined\n): void => {\n  if (self.state._tag === \"Closed\") {\n    fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n    return\n  }\n\n  const previous = MutableHashMap.get(self.state.backing, key)\n  if (previous._tag === \"Some\") {\n    if (options?.onlyIfMissing === true) {\n      fiber.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n      return\n    } else if (previous.value === fiber) {\n      return\n    }\n    previous.value.unsafeInterruptAsFork(FiberId.combine(options?.interruptAs ?? FiberId.none, internalFiberId))\n  }\n\n  MutableHashMap.set(self.state.backing, key, fiber)\n  fiber.addObserver((exit) => {\n    if (self.state._tag === \"Closed\") {\n      return\n    }\n    const current = MutableHashMap.get(self.state.backing, key)\n    if (Option.isSome(current) && fiber === current.value) {\n      MutableHashMap.remove(self.state.backing, key)\n    }\n    if (\n      Exit.isFailure(exit) &&\n      (\n        options?.propagateInterruption === true ?\n          !isInternalInterruption(exit.cause) :\n          !Cause.isInterruptedOnly(exit.cause)\n      )\n    ) {\n      Deferred.unsafeDone(self.deferred, exit as any)\n    }\n  })\n})\n\n/**\n * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const set: {\n  /**\n   * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n   * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E, XE extends E, XA extends A>(\n    key: K,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): (self: FiberMap<K, A, E>) => Effect.Effect<void>\n  /**\n   * Add a fiber to the FiberMap. When the fiber completes, it will be removed from the FiberMap.\n   * If the key already exists in the FiberMap, the previous fiber will be interrupted.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E, XE extends E, XA extends A>(\n    self: FiberMap<K, A, E>,\n    key: K,\n    fiber: Fiber.RuntimeFiber<XA, XE>,\n    options?: {\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<void>\n} = dual((args) => isFiberMap(args[0]), <K, A, E, XE extends E, XA extends A>(\n  self: FiberMap<K, A, E>,\n  key: K,\n  fiber: Fiber.RuntimeFiber<XA, XE>,\n  options?: {\n    readonly onlyIfMissing?: boolean | undefined\n    readonly propagateInterruption?: boolean | undefined\n  } | undefined\n): Effect.Effect<void> =>\n  Effect.fiberIdWith(\n    (fiberId) =>\n      Effect.sync(() =>\n        unsafeSet(self, key, fiber, {\n          ...options,\n          interruptAs: fiberId\n        })\n      )\n  ))\n\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeGet: {\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>\n} = dual<\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K) => <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>,\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K) => Option.Option<Fiber.RuntimeFiber<A, E>>\n>(2, (self, key) => self.state._tag === \"Closed\" ? Option.none() : MutableHashMap.get(self.state.backing, key))\n\n/**\n * Retrieve a fiber from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const get: {\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>\n} = dual<\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K) => <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>,\n  /**\n   * Retrieve a fiber from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>\n>(2, (self, key) => Effect.suspend(() => unsafeGet(self, key)))\n\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const unsafeHas: {\n  /**\n   * Check if a key exists in the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean\n  /**\n   * Check if a key exists in the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean\n} = dual(\n  2,\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean =>\n    self.state._tag === \"Closed\" ? false : MutableHashMap.has(self.state.backing, key)\n)\n\n/**\n * Check if a key exists in the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const has: {\n  /**\n   * Check if a key exists in the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>\n  /**\n   * Check if a key exists in the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>\n} = dual(\n  2,\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean> => Effect.sync(() => unsafeHas(self, key))\n)\n\n/**\n * Remove a fiber from the FiberMap, interrupting it if it exists.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const remove: {\n  /**\n   * Remove a fiber from the FiberMap, interrupting it if it exists.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>\n  /**\n   * Remove a fiber from the FiberMap, interrupting it if it exists.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>\n} = dual<\n  /**\n   * Remove a fiber from the FiberMap, interrupting it if it exists.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K>(key: K) => <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>,\n  /**\n   * Remove a fiber from the FiberMap, interrupting it if it exists.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(self: FiberMap<K, A, E>, key: K) => Effect.Effect<void>\n>(2, (self, key) =>\n  Effect.withFiberRuntime((removeFiber) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.void\n    }\n    const fiber = MutableHashMap.get(self.state.backing, key)\n    if (fiber._tag === \"None\") {\n      return Effect.void\n    }\n    // will be removed by the observer\n    return Fiber.interruptAs(fiber.value, FiberId.combine(removeFiber.id(), internalFiberId))\n  }))\n\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const clear = <K, A, E>(self: FiberMap<K, A, E>): Effect.Effect<void> =>\n  Effect.withFiberRuntime((clearFiber) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.void\n    }\n\n    return Effect.forEach(self.state.backing, ([, fiber]) =>\n      // will be removed by the observer\n      Fiber.interruptAs(fiber, FiberId.combine(clearFiber.id(), internalFiberId)))\n  })\n\nconst constInterruptedFiber = (function() {\n  let fiber: Fiber.RuntimeFiber<never, never> | undefined = undefined\n  return () => {\n    if (fiber === undefined) {\n      fiber = Effect.runFork(Effect.interrupt)\n    }\n    return fiber\n  }\n})()\n\n/**\n * Run an Effect and add the forked fiber to the FiberMap.\n * When the fiber completes, it will be removed from the FiberMap.\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const run: {\n  /**\n   * Run an Effect and add the forked fiber to the FiberMap.\n   * When the fiber completes, it will be removed from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E>(\n    self: FiberMap<K, A, E>,\n    key: K,\n    options?: {\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): <R, XE extends E, XA extends A>(\n    effect: Effect.Effect<XA, XE, R>\n  ) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n  /**\n   * Run an Effect and add the forked fiber to the FiberMap.\n   * When the fiber completes, it will be removed from the FiberMap.\n   *\n   * @since 2.0.0\n   * @categories combinators\n   */\n  <K, A, E, R, XE extends E, XA extends A>(\n    self: FiberMap<K, A, E>,\n    key: K,\n    effect: Effect.Effect<XA, XE, R>,\n    options?: {\n      readonly onlyIfMissing?: boolean | undefined\n      readonly propagateInterruption?: boolean | undefined\n    } | undefined\n  ): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>\n} = function() {\n  const self = arguments[0]\n  if (Effect.isEffect(arguments[2])) {\n    return runImpl(self, arguments[1], arguments[2], arguments[3]) as any\n  }\n  const key = arguments[1]\n  const options = arguments[2]\n  return (effect: Effect.Effect<any, any, any>) => runImpl(self, key, effect, options)\n}\n\nconst runImpl = <K, A, E, R, XE extends E, XA extends A>(\n  self: FiberMap<K, A, E>,\n  key: K,\n  effect: Effect.Effect<XA, XE, R>,\n  options?: {\n    readonly onlyIfMissing?: boolean\n    readonly propagateInterruption?: boolean | undefined\n  }\n) =>\n  Effect.fiberIdWith((fiberId) => {\n    if (self.state._tag === \"Closed\") {\n      return Effect.interrupt\n    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n      return Effect.sync(constInterruptedFiber)\n    }\n    return Effect.tap(\n      Effect.forkDaemon(effect),\n      (fiber) => unsafeSet(self, key, fiber, { ...options, interruptAs: fiberId })\n    )\n  })\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @example\n * ```ts\n * import { Context, Effect, FiberMap } from \"effect\"\n *\n * interface Users {\n *   readonly _: unique symbol\n * }\n * const Users = Context.GenericTag<Users, {\n *    getAll: Effect.Effect<Array<unknown>>\n * }>(\"Users\")\n *\n * Effect.gen(function*() {\n *   const map = yield* FiberMap.make<string>()\n *   const run = yield* FiberMap.runtime(map)<Users>()\n *\n *   // run some effects and add the fibers to the map\n *   run(\"effect-a\", Effect.andThen(Users, _ => _.getAll))\n *   run(\"effect-b\", Effect.andThen(Users, _ => _.getAll))\n * }).pipe(\n *   Effect.scoped // The fibers will be interrupted when the scope is closed\n * )\n * ```\n *\n * @since 2.0.0\n * @categories combinators\n */\nexport const runtime: <K, A, E>(\n  self: FiberMap<K, A, E>\n) => <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    key: K,\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n        readonly propagateInterruption?: boolean | undefined\n      }\n      | undefined\n  ) => Fiber.RuntimeFiber<XA, XE>,\n  never,\n  R\n> = <K, A, E>(self: FiberMap<K, A, E>) => <R>() =>\n  Effect.map(\n    Effect.runtime<R>(),\n    (runtime) => {\n      const runFork = Runtime.runFork(runtime)\n      return <XE extends E, XA extends A>(\n        key: K,\n        effect: Effect.Effect<XA, XE, R>,\n        options?:\n          | Runtime.RunForkOptions & {\n            readonly onlyIfMissing?: boolean | undefined\n            readonly propagateInterruption?: boolean | undefined\n          }\n          | undefined\n      ) => {\n        if (self.state._tag === \"Closed\") {\n          return constInterruptedFiber()\n        } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {\n          return constInterruptedFiber()\n        }\n        const fiber = runFork(effect, options)\n        unsafeSet(self, key, fiber, options)\n        return fiber\n      }\n    }\n  )\n\n/**\n * Capture a Runtime and use it to fork Effect's, adding the forked fibers to the FiberMap.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const runtimePromise = <K, A, E>(self: FiberMap<K, A, E>): <R = never>() => Effect.Effect<\n  <XE extends E, XA extends A>(\n    key: K,\n    effect: Effect.Effect<XA, XE, R>,\n    options?:\n      | Runtime.RunForkOptions & {\n        readonly onlyIfMissing?: boolean | undefined\n        readonly propagateInterruption?: boolean | undefined\n      }\n      | undefined\n  ) => Promise<XA>,\n  never,\n  R\n> =>\n<R>() =>\n  Effect.map(\n    runtime(self)<R>(),\n    (runFork) =>\n    <XE extends E, XA extends A>(\n      key: K,\n      effect: Effect.Effect<XA, XE, R>,\n      options?:\n        | Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined }\n        | undefined\n    ): Promise<XA> =>\n      new Promise((resolve, reject) =>\n        runFork(key, effect, options).addObserver((exit) => {\n          if (Exit.isSuccess(exit)) {\n            resolve(exit.value)\n          } else {\n            reject(Cause.squash(exit.cause))\n          }\n        })\n      )\n  )\n\n/**\n * @since 2.0.0\n * @categories combinators\n */\nexport const size = <K, A, E>(self: FiberMap<K, A, E>): Effect.Effect<number> =>\n  Effect.sync(() => self.state._tag === \"Closed\" ? 0 : MutableHashMap.size(self.state.backing))\n\n/**\n * Join all fibers in the FiberMap. If any of the Fiber's in the map terminate with a failure,\n * the returned Effect will terminate with the first failure that occurred.\n *\n * @since 2.0.0\n * @categories combinators\n * @example\n * ```ts\n * import { Effect, FiberMap } from \"effect\";\n *\n * Effect.gen(function* (_) {\n *   const map = yield* _(FiberMap.make());\n *   yield* _(FiberMap.set(map, \"a\", Effect.runFork(Effect.fail(\"error\"))));\n *\n *   // parent fiber will fail with \"error\"\n *   yield* _(FiberMap.join(map));\n * });\n * ```\n */\nexport const join = <K, A, E>(self: FiberMap<K, A, E>): Effect.Effect<void, E> =>\n  Deferred.await(self.deferred as Deferred.Deferred<void, E>)\n\n/**\n * Wait for the FiberMap to be empty.\n *\n * @since 3.13.0\n * @categories combinators\n */\nexport const awaitEmpty = <K, A, E>(self: FiberMap<K, A, E>): Effect.Effect<void, E> =>\n  Effect.whileLoop({\n    while: () => self.state._tag === \"Open\" && MutableHashMap.size(self.state.backing) > 0,\n    body: () => Fiber.await(Iterable.unsafeHead(self)[1]),\n    step: constVoid\n  })\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/groupBy.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport type * as Queue from \"./Queue.js\"\nimport type * as Stream from \"./Stream.js\"\nimport type * as Take from \"./Take.js\"\nimport type { Covariant, NoInfer } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const GroupByTypeId: unique symbol = internal.GroupByTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type GroupByTypeId = typeof GroupByTypeId\n\n/**\n * Representation of a grouped stream. This allows to filter which groups will\n * be processed. Once this is applied all groups will be processed in parallel\n * and the results will be merged in arbitrary order.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {\n  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace GroupBy {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out K, out V, out E, out R> {\n    readonly [GroupByTypeId]: {\n      readonly _K: Covariant<K>\n      readonly _V: Covariant<V>\n      readonly _E: Covariant<E>\n      readonly _R: Covariant<R>\n    }\n  }\n}\n\n/**\n * Run the function across all groups, collecting the results in an\n * arbitrary order.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const evaluate: {\n  /**\n   * Run the function across all groups, collecting the results in an\n   * arbitrary order.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <K, V, E, A, E2, R2>(\n   f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>,\n   options?: { readonly bufferSize?: number | undefined } | undefined\n  ): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>\n  /**\n   * Run the function across all groups, collecting the results in an\n   * arbitrary order.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <K, V, E, R, A, E2, R2>(\n   self: GroupBy<K, V, E, R>,\n   f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>,\n   options?: { readonly bufferSize?: number | undefined } | undefined\n  ): Stream.Stream<A, E | E2, R | R2>\n} = internal.evaluate\n\n/**\n * Filter the groups to be processed.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const filter: {\n  /**\n   * Filter the groups to be processed.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>\n  /**\n   * Filter the groups to be processed.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>\n} = internal.filter\n\n/**\n * Only consider the first `n` groups found in the `Stream`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const first: {\n  /**\n   * Only consider the first `n` groups found in the `Stream`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>\n  /**\n   * Only consider the first `n` groups found in the `Stream`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>\n} = internal.first\n\n/**\n * Constructs a `GroupBy` from a `Stream`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <K, V, E, R>(\n  grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>\n) => GroupBy<K, V, E, R> = internal.make\n", "export {};\n//# sourceMappingURL=HKT.js.map", "/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/keyedPool.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const KeyedPoolTypeId: unique symbol = internal.KeyedPoolTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type KeyedPoolTypeId = typeof KeyedPoolTypeId\n\n/**\n * A `KeyedPool<K, A, E>` is a pool of `Pool`s of items of type `A`. Each pool\n * in the `KeyedPool` is associated with a key of type `K`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   */\n  get(key: K): Effect.Effect<A, E, Scope.Scope>\n\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   */\n  invalidate(item: A): Effect.Effect<void>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace KeyedPool {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in K, in out A, out E> {\n    readonly [KeyedPoolTypeId]: {\n      readonly _K: Types.Contravariant<K>\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n}\n\n/**\n * Makes a new pool of the specified fixed size. The pool is returned in a\n * `Scope`, which governs the lifetime of the pool. When the pool is shutdown\n * because the `Scope` is closed, the individual items allocated by the pool\n * will be released in some unspecified order.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly size: number\n  }\n) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R> = internal.make\n\n/**\n * Makes a new pool of the specified fixed size. The pool is returned in a\n * `Scope`, which governs the lifetime of the pool. When the pool is shutdown\n * because the `Scope` is closed, the individual items allocated by the pool\n * will be released in some unspecified order.\n *\n * The size of the underlying pools can be configured per key.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWith: <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly size: (key: K) => number\n  }\n) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R> = internal.makeWith\n\n/**\n * Makes a new pool with the specified minimum and maximum sizes and time to\n * live before a pool whose excess items are not being used will be shrunk\n * down to the minimum size. The pool is returned in a `Scope`, which governs\n * the lifetime of the pool. When the pool is shutdown because the `Scope` is\n * used, the individual items allocated by the pool will be released in some\n * unspecified order.\n *\n * The size of the underlying pools can be configured per key.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWithTTL: <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly min: (key: K) => number\n    readonly max: (key: K) => number\n    readonly timeToLive: Duration.DurationInput\n  }\n) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R> = internal.makeWithTTL\n\n/**\n * Makes a new pool with the specified minimum and maximum sizes and time to\n * live before a pool whose excess items are not being used will be shrunk\n * down to the minimum size. The pool is returned in a `Scope`, which governs\n * the lifetime of the pool. When the pool is shutdown because the `Scope` is\n * used, the individual items allocated by the pool will be released in some\n * unspecified order.\n *\n * The size of the underlying pools can be configured per key.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWithTTLBy: <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly min: (key: K) => number\n    readonly max: (key: K) => number\n    readonly timeToLive: (key: K) => Duration.DurationInput\n  }\n) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R> = internal.makeWithTTLBy\n\n/**\n * Retrieves an item from the pool belonging to the given key in a scoped\n * effect. Note that if acquisition fails, then the returned effect will fail\n * for that same reason. Retrying a failed acquisition attempt will repeat the\n * acquisition attempt.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>\n  /**\n   * Retrieves an item from the pool belonging to the given key in a scoped\n   * effect. Note that if acquisition fails, then the returned effect will fail\n   * for that same reason. Retrying a failed acquisition attempt will repeat the\n   * acquisition attempt.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>\n} = internal.get\n\n/**\n * Invalidates the specified item. This will cause the pool to eventually\n * reallocate the item, although this reallocation may occur lazily rather\n * than eagerly.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const invalidate: {\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>\n  /**\n   * Invalidates the specified item. This will cause the pool to eventually\n   * reallocate the item, although this reallocation may occur lazily rather\n   * than eagerly.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>\n} = internal.invalidate\n", "import type * as Deferred from \"../Deferred.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Equal from \"../Equal.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport * as HashMap from \"../HashMap.js\"\nimport type * as KeyedPool from \"../KeyedPool.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as Pool from \"../Pool.js\"\nimport * as Predicate from \"../Predicate.js\"\nimport type * as Scope from \"../Scope.js\"\nimport * as core from \"./core.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as pool from \"./pool.js\"\n\n/** @internal */\nconst KeyedPoolSymbolKey = \"effect/KeyedPool\"\n\n/** @internal */\nexport const KeyedPoolTypeId: KeyedPool.KeyedPoolTypeId = Symbol.for(\n  KeyedPoolSymbolKey\n) as KeyedPool.KeyedPoolTypeId\n\nconst KeyedPoolMapValueSymbol = Symbol.for(\"effect/KeyedPool/MapValue\")\ntype KeyedPoolMapValueSymbol = typeof KeyedPoolMapValueSymbol\n\nconst keyedPoolVariance = {\n  /* c8 ignore next */\n  _K: (_: unknown) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\nclass KeyedPoolImpl<in K, in out A, out E = never> implements KeyedPool.KeyedPool<K, A, E> {\n  readonly [KeyedPoolTypeId] = keyedPoolVariance\n  constructor(\n    readonly getOrCreatePool: (key: K) => Effect.Effect<Pool.Pool<A, E>>,\n    readonly activePools: Effect.Effect<Array<Pool.Pool<A, E>>>\n  ) {}\n  get(key: K): Effect.Effect<A, E, Scope.Scope> {\n    return core.flatMap(this.getOrCreatePool(key), pool.get)\n  }\n  invalidate(item: A): Effect.Effect<void> {\n    return core.flatMap(this.activePools, core.forEachSequentialDiscard((pool) => pool.invalidate(item)))\n  }\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\ntype MapValue<A, E> = Complete<A, E> | Pending<A, E>\n\nclass Complete<in out A, out E> implements Equal.Equal {\n  readonly _tag = \"Complete\"\n  readonly [KeyedPoolMapValueSymbol]: KeyedPoolMapValueSymbol = KeyedPoolMapValueSymbol\n  constructor(readonly pool: Pool.Pool<A, E>) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.string(\"effect/KeyedPool/Complete\"),\n      Hash.combine(Hash.hash(this.pool)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](u: unknown): boolean {\n    return isComplete(u) && Equal.equals(this.pool, u.pool)\n  }\n}\n\nconst isComplete = (u: unknown): u is Complete<unknown, unknown> =>\n  Predicate.isTagged(u, \"Complete\") && KeyedPoolMapValueSymbol in u\n\nclass Pending<in out A, in out E> implements Equal.Equal {\n  readonly _tag = \"Pending\"\n  readonly [KeyedPoolMapValueSymbol]: KeyedPoolMapValueSymbol = KeyedPoolMapValueSymbol\n  constructor(readonly deferred: Deferred.Deferred<Pool.Pool<A, E>>) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.string(\"effect/KeyedPool/Pending\"),\n      Hash.combine(Hash.hash(this.deferred)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](u: unknown): boolean {\n    return isPending(u) && Equal.equals(this.deferred, u.deferred)\n  }\n}\n\nconst isPending = (u: unknown): u is Pending<unknown, unknown> =>\n  Predicate.isTagged(u, \"Pending\") && KeyedPoolMapValueSymbol in u\n\nconst makeImpl = <K, A, E, R>(\n  get: (key: K) => Effect.Effect<A, E, R>,\n  min: (key: K) => number,\n  max: (key: K) => number,\n  timeToLive: (key: K) => Option.Option<Duration.Duration>\n): Effect.Effect<KeyedPool.KeyedPool<K, A, E>, never, R | Scope.Scope> =>\n  pipe(\n    fiberRuntime.all([\n      core.context<R>(),\n      core.fiberId,\n      core.sync(() => MutableRef.make(HashMap.empty<K, MapValue<A, E>>())),\n      fiberRuntime.scopeMake()\n    ]),\n    core.map(([context, fiberId, map, scope]) => {\n      const getOrCreatePool = (key: K): Effect.Effect<Pool.Pool<A, E>> =>\n        core.suspend(() => {\n          let value: MapValue<A, E> | undefined = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key))\n          if (value === undefined) {\n            return core.uninterruptibleMask((restore) => {\n              const deferred = core.deferredUnsafeMake<Pool.Pool<A, E>>(fiberId)\n              value = new Pending(deferred)\n              let previous: MapValue<A, E> | undefined = undefined\n              if (HashMap.has(MutableRef.get(map), key)) {\n                previous = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key))\n              } else {\n                MutableRef.update(map, HashMap.set(key, value as MapValue<A, E>))\n              }\n              if (previous === undefined) {\n                return pipe(\n                  restore(\n                    fiberRuntime.scopeExtend(\n                      pool.makeWithTTL({\n                        acquire: core.provideContext(get(key), context),\n                        min: min(key),\n                        max: max(key),\n                        timeToLive: Option.getOrElse(timeToLive(key), () => Duration.infinity)\n                      }),\n                      scope\n                    )\n                  ),\n                  core.matchCauseEffect({\n                    onFailure: (cause) => {\n                      const current = Option.getOrUndefined(HashMap.get(MutableRef.get(map), key))\n                      if (Equal.equals(current, value)) {\n                        MutableRef.update(map, HashMap.remove(key))\n                      }\n                      return core.zipRight(\n                        core.deferredFailCause(deferred, cause),\n                        core.failCause(cause)\n                      )\n                    },\n                    onSuccess: (pool) => {\n                      MutableRef.update(map, HashMap.set(key, new Complete(pool) as MapValue<A, E>))\n                      return core.as(\n                        core.deferredSucceed(deferred, pool),\n                        pool\n                      )\n                    }\n                  })\n                )\n              }\n              switch (previous._tag) {\n                case \"Complete\": {\n                  return core.succeed(previous.pool)\n                }\n                case \"Pending\": {\n                  return restore(core.deferredAwait(previous.deferred))\n                }\n              }\n            })\n          }\n          switch (value._tag) {\n            case \"Complete\": {\n              return core.succeed(value.pool)\n            }\n            case \"Pending\": {\n              return core.deferredAwait(value.deferred)\n            }\n          }\n        })\n      const activePools: Effect.Effect<Array<Pool.Pool<A, E>>> = core.suspend(() =>\n        core.forEachSequential(HashMap.toValues(MutableRef.get(map)), (value) => {\n          switch (value._tag) {\n            case \"Complete\": {\n              return core.succeed(value.pool)\n            }\n            case \"Pending\": {\n              return core.deferredAwait(value.deferred)\n            }\n          }\n        })\n      )\n      return new KeyedPoolImpl(getOrCreatePool, activePools)\n    })\n  )\n\n/** @internal */\nexport const make = <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly size: number\n  }\n): Effect.Effect<KeyedPool.KeyedPool<K, A, E>, never, R | Scope.Scope> =>\n  makeImpl(options.acquire, () => options.size, () => options.size, () => Option.none())\n\n/** @internal */\nexport const makeWith = <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly size: (key: K) => number\n  }\n): Effect.Effect<KeyedPool.KeyedPool<K, A, E>, never, R | Scope.Scope> =>\n  makeImpl(options.acquire, options.size, options.size, () => Option.none())\n\n/** @internal */\nexport const makeWithTTL = <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly min: (key: K) => number\n    readonly max: (key: K) => number\n    readonly timeToLive: Duration.DurationInput\n  }\n): Effect.Effect<KeyedPool.KeyedPool<K, A, E>, never, R | Scope.Scope> => {\n  const timeToLive = Duration.decode(options.timeToLive)\n  return makeImpl(options.acquire, options.min, options.max, () => Option.some(timeToLive))\n}\n\n/** @internal */\nexport const makeWithTTLBy = <K, A, E, R>(\n  options: {\n    readonly acquire: (key: K) => Effect.Effect<A, E, R>\n    readonly min: (key: K) => number\n    readonly max: (key: K) => number\n    readonly timeToLive: (key: K) => Duration.DurationInput\n  }\n): Effect.Effect<KeyedPool.KeyedPool<K, A, E>, never, R | Scope.Scope> =>\n  makeImpl(options.acquire, options.min, options.max, (key) => Option.some(Duration.decode(options.timeToLive(key))))\n\n/** @internal */\nexport const get = dual<\n  <K>(key: K) => <A, E>(self: KeyedPool.KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>,\n  <K, A, E>(self: KeyedPool.KeyedPool<K, A, E>, key: K) => Effect.Effect<A, E, Scope.Scope>\n>(2, (self, key) => self.get(key))\n\n/** @internal */\nexport const invalidate = dual<\n  <A>(item: A) => <K, E>(self: KeyedPool.KeyedPool<K, A, E>) => Effect.Effect<void>,\n  <K, A, E>(self: KeyedPool.KeyedPool<K, A, E>, item: A) => Effect.Effect<void>\n>(2, (self, item) => self.invalidate(item))\n", "/**\n * @since 3.14.0\n * @experimental\n */\nimport * as Context from \"./Context.js\"\nimport type * as Duration from \"./Duration.js\"\nimport * as Effect from \"./Effect.js\"\nimport * as FiberRefsPatch from \"./FiberRefsPatch.js\"\nimport { identity } from \"./Function.js\"\nimport * as core from \"./internal/core.js\"\nimport * as Layer from \"./Layer.js\"\nimport * as RcMap from \"./RcMap.js\"\nimport * as Runtime from \"./Runtime.js\"\nimport * as Scope from \"./Scope.js\"\nimport type { Mutable } from \"./Types.js\"\n\n/**\n * @since 3.14.0\n * @category Symbols\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/LayerMap\")\n\n/**\n * @since 3.14.0\n * @category Symbols\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 3.14.0\n * @category Models\n * @experimental\n */\nexport interface LayerMap<in K, in out I, out E = never> {\n  readonly [TypeId]: TypeId\n\n  /**\n   * The internal RcMap that stores the resources.\n   */\n  readonly rcMap: RcMap.RcMap<K, {\n    readonly layer: Layer.Layer<I, E>\n    readonly runtimeEffect: Effect.Effect<Runtime.Runtime<I>, E, Scope.Scope>\n  }, E>\n\n  /**\n   * Retrieves a Layer for the resources associated with the key.\n   */\n  get(key: K): Layer.Layer<I, E>\n\n  /**\n   * Retrieves a Runtime for the resources associated with the key.\n   */\n  runtime(key: K): Effect.Effect<Runtime.Runtime<I>, E, Scope.Scope>\n\n  /**\n   * Invalidates the resource associated with the key.\n   */\n  invalidate(key: K): Effect.Effect<void>\n}\n\n/**\n * @since 3.14.0\n * @category Constructors\n * @experimental\n *\n * A `LayerMap` allows you to create a map of Layer's that can be used to\n * dynamically access resources based on a key.\n *\n * ```ts\n * import { NodeRuntime } from \"@effect/platform-node\"\n * import { Context, Effect, FiberRef, Layer, LayerMap } from \"effect\"\n *\n * class Greeter extends Context.Tag(\"Greeter\")<Greeter, {\n *   greet: Effect.Effect<string>\n * }>() {}\n *\n * // create a service that wraps a LayerMap\n * class GreeterMap extends LayerMap.Service<GreeterMap>()(\"GreeterMap\", {\n *   // define the lookup function for the layer map\n *   //\n *   // The returned Layer will be used to provide the Greeter service for the\n *   // given name.\n *   lookup: (name: string) =>\n *     Layer.succeed(Greeter, {\n *       greet: Effect.succeed(`Hello, ${name}!`)\n *     }).pipe(\n *       Layer.merge(Layer.locallyScoped(FiberRef.currentConcurrency, 123))\n *     ),\n *\n *   // If a layer is not used for a certain amount of time, it can be removed\n *   idleTimeToLive: \"5 seconds\",\n *\n *   // Supply the dependencies for the layers in the LayerMap\n *   dependencies: []\n * }) {}\n *\n * // usage\n * const program: Effect.Effect<void, never, GreeterMap> = Effect.gen(function*() {\n *   // access and use the Greeter service\n *   const greeter = yield* Greeter\n *   yield* Effect.log(yield* greeter.greet)\n * }).pipe(\n *   // use the GreeterMap service to provide a variant of the Greeter service\n *   Effect.provide(GreeterMap.get(\"John\"))\n * )\n *\n * // run the program\n * program.pipe(\n *   Effect.provide(GreeterMap.Default),\n *   NodeRuntime.runMain\n * )\n * ```\n */\nexport const make: <\n  K,\n  L extends Layer.Layer<any, any, any>\n>(\n  lookup: (key: K) => L,\n  options?: {\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n  } | undefined\n) => Effect.Effect<\n  LayerMap<\n    K,\n    L extends Layer.Layer<infer _A, infer _E, infer _R> ? _A : never,\n    L extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never\n  >,\n  never,\n  Scope.Scope | (L extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)\n> = Effect.fnUntraced(function*<I, K, EL, RL>(\n  lookup: (key: K) => Layer.Layer<I, EL, RL>,\n  options?: {\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n  } | undefined\n) {\n  const context = yield* Effect.context<never>()\n\n  // If we are inside another layer build, use the current memo map,\n  // otherwise create a new one.\n  const memoMap = context.unsafeMap.has(Layer.CurrentMemoMap.key)\n    ? Context.get(context, Layer.CurrentMemoMap)\n    : yield* Layer.makeMemoMap\n\n  const rcMap = yield* RcMap.make({\n    lookup: (key: K) =>\n      Effect.scopeWith((scope) => Effect.diffFiberRefs(Layer.buildWithMemoMap(lookup(key), memoMap, scope))).pipe(\n        Effect.map(([patch, context]) => ({\n          layer: Layer.scopedContext(\n            core.withFiberRuntime<Context.Context<I>, any, Scope.Scope>((fiber) => {\n              const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope)\n              const oldRefs = fiber.getFiberRefs()\n              const newRefs = FiberRefsPatch.patch(patch, fiber.id(), oldRefs)\n              const revert = FiberRefsPatch.diff(newRefs, oldRefs)\n              fiber.setFiberRefs(newRefs)\n              return Effect.as(\n                Scope.addFinalizerExit(scope, () => {\n                  fiber.setFiberRefs(FiberRefsPatch.patch(revert, fiber.id(), fiber.getFiberRefs()))\n                  return Effect.void\n                }),\n                context\n              )\n            })\n          ),\n          runtimeEffect: Effect.withFiberRuntime<Runtime.Runtime<I>, any, Scope.Scope>((fiber) => {\n            const fiberRefs = FiberRefsPatch.patch(patch, fiber.id(), fiber.getFiberRefs())\n            return Effect.succeed(Runtime.make({\n              context,\n              fiberRefs,\n              runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n            }))\n          })\n        } as const))\n      ),\n    idleTimeToLive: options?.idleTimeToLive\n  })\n\n  return identity<LayerMap<K, Exclude<I, Scope.Scope>, any>>({\n    [TypeId]: TypeId,\n    rcMap,\n    get: (key) => Layer.unwrapScoped(Effect.map(RcMap.get(rcMap, key), ({ layer }) => layer)),\n    runtime: (key) => Effect.flatMap(RcMap.get(rcMap, key), ({ runtimeEffect }) => runtimeEffect),\n    invalidate: (key) => RcMap.invalidate(rcMap, key)\n  })\n})\n\n/**\n * @since 3.14.0\n * @category Constructors\n * @experimental\n */\nexport const fromRecord = <\n  const Layers extends Record<string, Layer.Layer<any, any, any>>\n>(\n  layers: Layers,\n  options?: {\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n  } | undefined\n): Effect.Effect<\n  LayerMap<\n    keyof Layers,\n    Layers[keyof Layers] extends Layer.Layer<infer _A, infer _E, infer _R> ? _A : never,\n    Layers[keyof Layers] extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never\n  >,\n  never,\n  Scope.Scope | (Layers[keyof Layers] extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)\n> => make((key: keyof Layers) => layers[key], options)\n\n/**\n * @since 3.14.0\n * @category Service\n */\nexport interface TagClass<\n  in out Self,\n  in out Id extends string,\n  in out K,\n  in out I,\n  in out E,\n  in out R,\n  in out Deps extends Layer.Layer<any, any, any>\n> extends Context.TagClass<Self, Id, LayerMap<K, I, E>> {\n  /**\n   * A default layer for the `LayerMap` service.\n   */\n  readonly Default: Layer.Layer<\n    Self,\n    (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never),\n    | Exclude<R, (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _A : never)>\n    | (Deps extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never)\n  >\n\n  /**\n   * A default layer for the `LayerMap` service without the dependencies provided.\n   */\n  readonly DefaultWithoutDependencies: Layer.Layer<Self, never, R>\n\n  /**\n   * Retrieves a Layer for the resources associated with the key.\n   */\n  readonly get: (key: K) => Layer.Layer<I, E, Self>\n\n  /**\n   * Retrieves a Runtime for the resources associated with the key.\n   */\n  readonly runtime: (key: K) => Effect.Effect<Runtime.Runtime<I>, E, Scope.Scope | Self>\n\n  /**\n   * Invalidates the resource associated with the key.\n   */\n  readonly invalidate: (key: K) => Effect.Effect<void, never, Self>\n}\n\n/**\n * @since 3.14.0\n * @category Service\n * @experimental\n *\n * Create a `LayerMap` service that provides a dynamic set of resources based on\n * a key.\n *\n * ```ts\n * import { NodeRuntime } from \"@effect/platform-node\"\n * import { Context, Effect, FiberRef, Layer, LayerMap } from \"effect\"\n *\n * class Greeter extends Context.Tag(\"Greeter\")<Greeter, {\n *   greet: Effect.Effect<string>\n * }>() {}\n *\n * // create a service that wraps a LayerMap\n * class GreeterMap extends LayerMap.Service<GreeterMap>()(\"GreeterMap\", {\n *   // define the lookup function for the layer map\n *   //\n *   // The returned Layer will be used to provide the Greeter service for the\n *   // given name.\n *   lookup: (name: string) =>\n *     Layer.succeed(Greeter, {\n *       greet: Effect.succeed(`Hello, ${name}!`)\n *     }).pipe(\n *       Layer.merge(Layer.locallyScoped(FiberRef.currentConcurrency, 123))\n *     ),\n *\n *   // If a layer is not used for a certain amount of time, it can be removed\n *   idleTimeToLive: \"5 seconds\",\n *\n *   // Supply the dependencies for the layers in the LayerMap\n *   dependencies: []\n * }) {}\n *\n * // usage\n * const program: Effect.Effect<void, never, GreeterMap> = Effect.gen(function*() {\n *   // access and use the Greeter service\n *   const greeter = yield* Greeter\n *   yield* Effect.log(yield* greeter.greet)\n * }).pipe(\n *   // use the GreeterMap service to provide a variant of the Greeter service\n *   Effect.provide(GreeterMap.get(\"John\"))\n * )\n *\n * // run the program\n * program.pipe(\n *   Effect.provide(GreeterMap.Default),\n *   NodeRuntime.runMain\n * )\n * ```\n */\nexport const Service = <Self>() =>\n<\n  const Id extends string,\n  Lookup extends {\n    readonly lookup: (key: any) => Layer.Layer<any, any, any>\n  } | {\n    readonly layers: Record<string, Layer.Layer<any, any, any>>\n  },\n  const Deps extends ReadonlyArray<Layer.Layer<any, any, any>> = []\n>(\n  id: Id,\n  options: Lookup & {\n    readonly dependencies?: Deps | undefined\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n  }\n): TagClass<\n  Self,\n  Id,\n  Lookup extends { readonly lookup: (key: infer K) => any } ? K\n    : Lookup extends { readonly layers: infer Layers } ? keyof Layers\n    : never,\n  Service.Success<Lookup>,\n  Service.Error<Lookup>,\n  Service.Context<Lookup>,\n  Deps[number]\n> => {\n  const Err = globalThis.Error as any\n  const limit = Err.stackTraceLimit\n  Err.stackTraceLimit = 2\n  const creationError = new Err()\n  Err.stackTraceLimit = limit\n\n  function TagClass() {}\n  const TagClass_ = TagClass as any as Mutable<TagClass<Self, Id, string, any, any, any, any>>\n  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))\n  TagClass.key = id\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n\n  TagClass_.DefaultWithoutDependencies = Layer.scoped(\n    TagClass_,\n    \"lookup\" in options\n      ? make(options.lookup, options)\n      : fromRecord(options.layers as any, options)\n  )\n  TagClass_.Default = options.dependencies && options.dependencies.length > 0 ?\n    Layer.provide(TagClass_.DefaultWithoutDependencies, options.dependencies as any) :\n    TagClass_.DefaultWithoutDependencies\n\n  TagClass_.get = (key: string) => Layer.unwrapScoped(Effect.map(TagClass_, (layerMap) => layerMap.get(key)))\n  TagClass_.runtime = (key: string) => Effect.flatMap(TagClass_, (layerMap) => layerMap.runtime(key))\n  TagClass_.invalidate = (key: string) => Effect.flatMap(TagClass_, (layerMap) => layerMap.invalidate(key))\n\n  return TagClass as any\n}\n\n/**\n * @since 3.14.0\n * @category Service\n * @experimental\n */\nexport declare namespace Service {\n  /**\n   * @since 3.14.0\n   * @category Service\n   * @experimental\n   */\n  export type Key<Options> = Options extends { readonly lookup: (key: infer K) => any } ? K\n    : Options extends { readonly layers: infer Layers } ? keyof Layers\n    : never\n\n  /**\n   * @since 3.14.0\n   * @category Service\n   * @experimental\n   */\n  export type Layers<Options> = Options extends { readonly lookup: (key: infer _K) => infer Layers } ? Layers\n    : Options extends { readonly layers: infer Layers } ? Layers[keyof Layers]\n    : never\n\n  /**\n   * @since 3.14.0\n   * @category Service\n   * @experimental\n   */\n  export type Success<Options> = Layers<Options> extends Layer.Layer<infer _A, infer _E, infer _R> ? _A : never\n\n  /**\n   * @since 3.14.0\n   * @category Service\n   * @experimental\n   */\n  export type Error<Options> = Layers<Options> extends Layer.Layer<infer _A, infer _E, infer _R> ? _E : never\n\n  /**\n   * @since 3.14.0\n   * @category Service\n   * @experimental\n   */\n  export type Context<Options> = Layers<Options> extends Layer.Layer<infer _A, infer _E, infer _R> ? _R : never\n}\n", "/**\n * @since 3.5.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/rcMap.js\"\nimport { type Pipeable } from \"./Pipeable.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.5.0\n * @category type ids\n */\nexport const TypeId: unique symbol = internal.TypeId\n\n/**\n * @since 3.5.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 3.5.0\n * @category models\n */\nexport interface RcMap<in K, out A, out E = never> extends Pipeable {\n  readonly [TypeId]: RcMap.Variance<K, A, E>\n}\n\n/**\n * @since 3.5.0\n * @category models\n */\nexport declare namespace RcMap {\n  /**\n   * @since 3.5.0\n   * @category models\n   */\n  export interface Variance<K, A, E> {\n    readonly _K: Types.Contravariant<K>\n    readonly _A: Types.Covariant<A>\n    readonly _E: Types.Covariant<E>\n  }\n}\n\n/**\n * An `RcMap` can contain multiple reference counted resources that can be indexed\n * by a key. The resources are lazily acquired on the first call to `get` and\n * released when the last reference is released.\n *\n * Complex keys can extend `Equal` and `Hash` to allow lookups by value.\n *\n * **Options**\n *\n * - `capacity`: The maximum number of resources that can be held in the map.\n * - `idleTimeToLive`: When the reference count reaches zero, the resource will be released after this duration.\n *\n * @since 3.5.0\n * @category models\n * @example\n * ```ts\n * import { Effect, RcMap } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const map = yield* RcMap.make({\n *     lookup: (key: string) =>\n *       Effect.acquireRelease(\n *         Effect.succeed(`acquired ${key}`),\n *         () => Effect.log(`releasing ${key}`)\n *       )\n *   })\n *\n *   // Get \"foo\" from the map twice, which will only acquire it once.\n *   // It will then be released once the scope closes.\n *   yield* RcMap.get(map, \"foo\").pipe(\n *     Effect.andThen(RcMap.get(map, \"foo\")),\n *     Effect.scoped\n *   )\n * })\n * ```\n */\nexport const make: {\n  /**\n   * An `RcMap` can contain multiple reference counted resources that can be indexed\n   * by a key. The resources are lazily acquired on the first call to `get` and\n   * released when the last reference is released.\n   *\n   * Complex keys can extend `Equal` and `Hash` to allow lookups by value.\n   *\n   * **Options**\n   *\n   * - `capacity`: The maximum number of resources that can be held in the map.\n   * - `idleTimeToLive`: When the reference count reaches zero, the resource will be released after this duration.\n   *\n   * @since 3.5.0\n   * @category models\n   * @example\n   * ```ts\n   * import { Effect, RcMap } from \"effect\"\n   *\n   * Effect.gen(function*() {\n   *   const map = yield* RcMap.make({\n   *     lookup: (key: string) =>\n   *       Effect.acquireRelease(\n   *         Effect.succeed(`acquired ${key}`),\n   *         () => Effect.log(`releasing ${key}`)\n   *       )\n   *   })\n   *\n   *   // Get \"foo\" from the map twice, which will only acquire it once.\n   *   // It will then be released once the scope closes.\n   *   yield* RcMap.get(map, \"foo\").pipe(\n   *     Effect.andThen(RcMap.get(map, \"foo\")),\n   *     Effect.scoped\n   *   )\n   * })\n   * ```\n   */\n  <K, A, E, R>(\n   options: {\n     readonly lookup: (key: K) => Effect.Effect<A, E, R>\n     readonly idleTimeToLive?: Duration.DurationInput | undefined\n     readonly capacity?: undefined\n   }\n  ): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>\n  /**\n   * An `RcMap` can contain multiple reference counted resources that can be indexed\n   * by a key. The resources are lazily acquired on the first call to `get` and\n   * released when the last reference is released.\n   *\n   * Complex keys can extend `Equal` and `Hash` to allow lookups by value.\n   *\n   * **Options**\n   *\n   * - `capacity`: The maximum number of resources that can be held in the map.\n   * - `idleTimeToLive`: When the reference count reaches zero, the resource will be released after this duration.\n   *\n   * @since 3.5.0\n   * @category models\n   * @example\n   * ```ts\n   * import { Effect, RcMap } from \"effect\"\n   *\n   * Effect.gen(function*() {\n   *   const map = yield* RcMap.make({\n   *     lookup: (key: string) =>\n   *       Effect.acquireRelease(\n   *         Effect.succeed(`acquired ${key}`),\n   *         () => Effect.log(`releasing ${key}`)\n   *       )\n   *   })\n   *\n   *   // Get \"foo\" from the map twice, which will only acquire it once.\n   *   // It will then be released once the scope closes.\n   *   yield* RcMap.get(map, \"foo\").pipe(\n   *     Effect.andThen(RcMap.get(map, \"foo\")),\n   *     Effect.scoped\n   *   )\n   * })\n   * ```\n   */\n  <K, A, E, R>(\n   options: {\n     readonly lookup: (key: K) => Effect.Effect<A, E, R>\n     readonly idleTimeToLive?: Duration.DurationInput | undefined\n     readonly capacity: number\n   }\n  ): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>\n} = internal.make\n\n/**\n * @since 3.5.0\n * @category combinators\n */\nexport const get: {\n  /**\n   * @since 3.5.0\n   * @category combinators\n   */\n  <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<A, E, Scope.Scope>\n  /**\n   * @since 3.5.0\n   * @category combinators\n   */\n  <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>\n} = internal.get\n\n/**\n * @since 3.8.0\n * @category combinators\n */\nexport const keys: <K, A, E>(self: RcMap<K, A, E>) => Effect.Effect<Array<K>, E> = internal.keys\n\n/**\n * @since 3.13.0\n * @category combinators\n */\nexport const invalidate: {\n  /**\n   * @since 3.13.0\n   * @category combinators\n   */\n  <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>\n  /**\n   * @since 3.13.0\n   * @category combinators\n   */\n  <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>\n} = internal.invalidate\n\n/**\n * @since 3.13.0\n * @category combinators\n */\nexport const touch: {\n  /**\n   * @since 3.13.0\n   * @category combinators\n   */\n  <K>(key: K): <A, E>(self: RcMap<K, A, E>) => Effect.Effect<void>\n  /**\n   * @since 3.13.0\n   * @category combinators\n   */\n  <K, A, E>(self: RcMap<K, A, E>, key: K): Effect.Effect<void>\n} = internal.touch\n", "import type * as Cause from \"../Cause.js\"\nimport * as Context from \"../Context.js\"\nimport type * as Deferred from \"../Deferred.js\"\nimport * as Duration from \"../Duration.js\"\nimport type { Effect } from \"../Effect.js\"\nimport type { RuntimeFiber } from \"../Fiber.js\"\nimport { dual, identity } from \"../Function.js\"\nimport * as MutableHashMap from \"../MutableHashMap.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as RcMap from \"../RcMap.js\"\nimport type * as Scope from \"../Scope.js\"\nimport * as coreEffect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as circular from \"./effect/circular.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\n\n/** @internal */\nexport const TypeId: RcMap.TypeId = Symbol.for(\"effect/RcMap\") as RcMap.TypeId\n\ntype State<K, A, E> = State.Open<K, A, E> | State.Closed\n\ndeclare namespace State {\n  interface Open<K, A, E> {\n    readonly _tag: \"Open\"\n    readonly map: MutableHashMap.MutableHashMap<K, Entry<A, E>>\n  }\n\n  interface Closed {\n    readonly _tag: \"Closed\"\n  }\n\n  interface Entry<A, E> {\n    readonly deferred: Deferred.Deferred<A, E>\n    readonly scope: Scope.CloseableScope\n    readonly finalizer: Effect<void>\n    fiber: RuntimeFiber<void, never> | undefined\n    expiresAt: number\n    refCount: number\n  }\n}\n\nconst variance: RcMap.RcMap.Variance<any, any, any> = {\n  _K: identity,\n  _A: identity,\n  _E: identity\n}\n\nclass RcMapImpl<K, A, E> implements RcMap.RcMap<K, A, E> {\n  readonly [TypeId]: RcMap.RcMap.Variance<K, A, E>\n\n  state: State<K, A, E> = {\n    _tag: \"Open\",\n    map: MutableHashMap.empty()\n  }\n  readonly semaphore = circular.unsafeMakeSemaphore(1)\n\n  constructor(\n    readonly lookup: (key: K) => Effect<A, E, Scope.Scope>,\n    readonly context: Context.Context<never>,\n    readonly scope: Scope.Scope,\n    readonly idleTimeToLive: Duration.Duration | undefined,\n    readonly capacity: number\n  ) {\n    this[TypeId] = variance\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/** @internal */\nexport const make: {\n  <K, A, E, R>(options: {\n    readonly lookup: (key: K) => Effect<A, E, R>\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n    readonly capacity?: undefined\n  }): Effect<RcMap.RcMap<K, A, E>, never, Scope.Scope | R>\n  <K, A, E, R>(options: {\n    readonly lookup: (key: K) => Effect<A, E, R>\n    readonly idleTimeToLive?: Duration.DurationInput | undefined\n    readonly capacity: number\n  }): Effect<RcMap.RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>\n} = <K, A, E, R>(options: {\n  readonly lookup: (key: K) => Effect<A, E, R>\n  readonly idleTimeToLive?: Duration.DurationInput | undefined\n  readonly capacity?: number | undefined\n}) =>\n  core.withFiberRuntime<RcMap.RcMap<K, A, E>, never, R | Scope.Scope>((fiber) => {\n    const context = fiber.getFiberRef(core.currentContext) as Context.Context<R | Scope.Scope>\n    const scope = Context.get(context, fiberRuntime.scopeTag)\n    const self = new RcMapImpl<K, A, E>(\n      options.lookup as any,\n      context,\n      scope,\n      options.idleTimeToLive ? Duration.decode(options.idleTimeToLive) : undefined,\n      Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0)\n    )\n    return core.as(\n      scope.addFinalizer(() =>\n        core.suspend(() => {\n          if (self.state._tag === \"Closed\") {\n            return core.void\n          }\n          const map = self.state.map\n          self.state = { _tag: \"Closed\" }\n          return core.forEachSequentialDiscard(\n            map,\n            ([, entry]) => core.scopeClose(entry.scope, core.exitVoid)\n          ).pipe(\n            core.tap(() => {\n              MutableHashMap.clear(map)\n            }),\n            self.semaphore.withPermits(1)\n          )\n        })\n      ),\n      self\n    )\n  })\n\n/** @internal */\nexport const get: {\n  <K>(key: K): <A, E>(self: RcMap.RcMap<K, A, E>) => Effect<A, E, Scope.Scope>\n  <K, A, E>(self: RcMap.RcMap<K, A, E>, key: K): Effect<A, E, Scope.Scope>\n} = dual(2, <K, A, E>(self_: RcMap.RcMap<K, A, E>, key: K): Effect<A, E, Scope.Scope> => {\n  const self = self_ as RcMapImpl<K, A, E>\n  return core.uninterruptibleMask((restore) => getImpl(self, key, restore as any))\n})\n\nconst getImpl = core.fnUntraced(function*<K, A, E>(self: RcMapImpl<K, A, E>, key: K, restore: <A>(a: A) => A) {\n  if (self.state._tag === \"Closed\") {\n    return yield* core.interrupt\n  }\n  const state = self.state\n  const o = MutableHashMap.get(state.map, key)\n  let entry: State.Entry<A, E>\n  if (o._tag === \"Some\") {\n    entry = o.value\n    entry.refCount++\n  } else if (Number.isFinite(self.capacity) && MutableHashMap.size(self.state.map) >= self.capacity) {\n    return yield* core.fail(\n      new core.ExceededCapacityException(`RcMap attempted to exceed capacity of ${self.capacity}`)\n    ) as Effect<never>\n  } else {\n    entry = yield* self.semaphore.withPermits(1)(acquire(self, key, restore))\n  }\n  const scope = yield* fiberRuntime.scopeTag\n  yield* scope.addFinalizer(() => entry.finalizer)\n  return yield* restore(core.deferredAwait(entry.deferred))\n})\n\nconst acquire = core.fnUntraced(function*<K, A, E>(self: RcMapImpl<K, A, E>, key: K, restore: <A>(a: A) => A) {\n  const scope = yield* fiberRuntime.scopeMake()\n  const deferred = yield* core.deferredMake<A, E>()\n  const acquire = self.lookup(key)\n  const contextMap = new Map(self.context.unsafeMap)\n  yield* restore(core.mapInputContext(\n    acquire as Effect<A, E>,\n    (inputContext: Context.Context<never>) => {\n      inputContext.unsafeMap.forEach((value, key) => {\n        contextMap.set(key, value)\n      })\n      contextMap.set(fiberRuntime.scopeTag.key, scope)\n      return Context.unsafeMake(contextMap)\n    }\n  )).pipe(\n    core.exit,\n    core.flatMap((exit) => core.deferredDone(deferred, exit)),\n    circular.forkIn(scope)\n  )\n  const entry: State.Entry<A, E> = {\n    deferred,\n    scope,\n    finalizer: undefined as any,\n    fiber: undefined,\n    expiresAt: 0,\n    refCount: 1\n  }\n  ;(entry as any).finalizer = release(self, key, entry)\n  if (self.state._tag === \"Open\") {\n    MutableHashMap.set(self.state.map, key, entry)\n  }\n  return entry\n})\n\nconst release = <K, A, E>(self: RcMapImpl<K, A, E>, key: K, entry: State.Entry<A, E>) =>\n  coreEffect.clockWith((clock) => {\n    entry.refCount--\n    if (entry.refCount > 0) {\n      return core.void\n    } else if (\n      self.state._tag === \"Closed\"\n      || !MutableHashMap.has(self.state.map, key)\n      || self.idleTimeToLive === undefined\n    ) {\n      if (self.state._tag === \"Open\") {\n        MutableHashMap.remove(self.state.map, key)\n      }\n      return core.scopeClose(entry.scope, core.exitVoid)\n    }\n\n    if (!Duration.isFinite(self.idleTimeToLive)) {\n      return core.void\n    }\n\n    entry.expiresAt = clock.unsafeCurrentTimeMillis() + Duration.toMillis(self.idleTimeToLive)\n    if (entry.fiber) return core.void\n\n    return core.interruptibleMask(function loop(restore): Effect<void> {\n      const now = clock.unsafeCurrentTimeMillis()\n      const remaining = entry.expiresAt - now\n      if (remaining <= 0) {\n        if (self.state._tag === \"Closed\" || entry.refCount > 0) return core.void\n        MutableHashMap.remove(self.state.map, key)\n        return restore(core.scopeClose(entry.scope, core.exitVoid))\n      }\n      return core.flatMap(clock.sleep(Duration.millis(remaining)), () => loop(restore))\n    }).pipe(\n      fiberRuntime.ensuring(core.sync(() => {\n        entry.fiber = undefined\n      })),\n      circular.forkIn(self.scope),\n      core.tap((fiber) => {\n        entry.fiber = fiber\n      }),\n      self.semaphore.withPermits(1)\n    )\n  })\n\n/** @internal */\nexport const keys = <K, A, E>(self: RcMap.RcMap<K, A, E>): Effect<Array<K>> => {\n  const impl = self as RcMapImpl<K, A, E>\n  return core.suspend(() =>\n    impl.state._tag === \"Closed\" ? core.interrupt : core.succeed(MutableHashMap.keys(impl.state.map))\n  )\n}\n\n/** @internal */\nexport const invalidate: {\n  <K>(key: K): <A, E>(self: RcMap.RcMap<K, A, E>) => Effect<void>\n  <K, A, E>(self: RcMap.RcMap<K, A, E>, key: K): Effect<void>\n} = dual(\n  2,\n  core.fnUntraced(function*<K, A, E>(self_: RcMap.RcMap<K, A, E>, key: K) {\n    const self = self_ as RcMapImpl<K, A, E>\n    if (self.state._tag === \"Closed\") return\n    const o = MutableHashMap.get(self.state.map, key)\n    if (o._tag === \"None\") return\n    const entry = o.value\n    MutableHashMap.remove(self.state.map, key)\n    if (entry.refCount > 0) return\n    yield* core.scopeClose(entry.scope, core.exitVoid)\n    if (entry.fiber) yield* core.interruptFiber(entry.fiber)\n  })\n)\n\n/** @internal */\nexport const touch: {\n  <K>(key: K): <A, E>(self: RcMap.RcMap<K, A, E>) => Effect<void>\n  <K, A, E>(self: RcMap.RcMap<K, A, E>, key: K): Effect<void>\n} = dual(\n  2,\n  <K, A, E>(self_: RcMap.RcMap<K, A, E>, key: K) =>\n    coreEffect.clockWith((clock) => {\n      const self = self_ as RcMapImpl<K, A, E>\n      if (!self.idleTimeToLive || self.state._tag === \"Closed\") return core.void\n      const o = MutableHashMap.get(self.state.map, key)\n      if (o._tag === \"None\") return core.void\n      o.value.expiresAt = clock.unsafeCurrentTimeMillis() + Duration.toMillis(self.idleTimeToLive)\n      return core.void\n    })\n)\n", "/**\n * The `effect/match` module provides a type-safe pattern matching system for\n * TypeScript. Inspired by functional programming, it simplifies conditional\n * logic by replacing verbose if/else or switch statements with a structured and\n * expressive API.\n *\n * This module supports matching against types, values, and discriminated unions\n * while enforcing exhaustiveness checking to ensure all cases are handled.\n *\n * Although pattern matching is not yet a native JavaScript feature,\n * `effect/match` offers a reliable implementation that is available today.\n *\n * **How Pattern Matching Works**\n *\n * Pattern matching follows a structured process:\n *\n * - **Creating a matcher**: Define a `Matcher` that operates on either a\n *   specific `Match.type` or `Match.value`.\n *\n * - **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n *   and `Match.tag` to specify matching conditions.\n *\n * - **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n *   `Match.orElse`, or `Match.option` to determine how unmatched cases should\n *   be handled.\n *\n * @since 1.0.0\n */\nimport type * as Either from \"./Either.js\"\nimport * as internal from \"./internal/matcher.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport * as Predicate from \"./Predicate.js\"\nimport type * as T from \"./Types.js\"\nimport type { Unify } from \"./Unify.js\"\n\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport const MatcherTypeId: unique symbol = internal.TypeId\n\n/**\n * @category Symbols\n * @since 1.0.0\n */\nexport type MatcherTypeId = typeof MatcherTypeId\n\n/**\n * Pattern matching follows a structured process:\n *\n * - **Creating a matcher**: Define a `Matcher` that operates on either a\n *   specific `Match.type` or `Match.value`.\n *\n * - **Defining patterns**: Use combinators such as `Match.when`, `Match.not`,\n *   and `Match.tag` to specify matching conditions.\n *\n * - **Completing the match**: Apply a finalizer such as `Match.exhaustive`,\n *   `Match.orElse`, or `Match.option` to determine how unmatched cases should\n *   be handled.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Simulated dynamic input that can be a string or a number\n * const input: string | number = \"some input\"\n *\n * //      ┌─── string\n * //      ▼\n * const result = Match.value(input).pipe(\n *   // Match if the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match if the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are covered\n *   Match.exhaustive\n * )\n *\n * console.log(result)\n * // Output: \"string: some input\"\n * ```\n *\n * @category Model\n * @since 1.0.0\n */\nexport type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return = any> =\n  | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>\n  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface TypeMatcher<in Input, out Filters, out Remaining, out Result, out Return = any> extends Pipeable {\n  readonly _tag: \"TypeMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly cases: ReadonlyArray<Case>\n  add<I, R, RA, A>(_case: Case): TypeMatcher<I, R, RA, A>\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface ValueMatcher<in Input, out Filters, out Remaining, out Result, out Provided, out Return = any>\n  extends Pipeable\n{\n  readonly _tag: \"ValueMatcher\"\n  readonly [MatcherTypeId]: {\n    readonly _input: T.Contravariant<Input>\n    readonly _filters: T.Covariant<Filters>\n    readonly _remaining: T.Covariant<Remaining>\n    readonly _result: T.Covariant<Result>\n    readonly _provided: T.Covariant<Result>\n    readonly _return: T.Covariant<Return>\n  }\n  readonly provided: Provided\n  readonly value: Either.Either<Provided, Remaining>\n  add<I, R, RA, A, Pr>(_case: Case): ValueMatcher<I, R, RA, A, Pr>\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport type Case = When | Not\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface When {\n  readonly _tag: \"When\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface Not {\n  readonly _tag: \"Not\"\n  guard(u: unknown): boolean\n  evaluate(input: unknown): any\n}\n\n/**\n * Creates a matcher for a specific type.\n *\n * **Details**\n *\n * This function defines a `Matcher` that operates on a given type, allowing you\n * to specify conditions for handling different cases. Once the matcher is\n * created, you can use pattern-matching functions like {@link when} to define\n * how different values should be processed.\n *\n * **Example** (Matching Numbers and Strings)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for values that are either strings or numbers\n * //\n * //      ┌─── (u: string | number) => string\n * //      ▼\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Match when the value is a string\n *   Match.when(Match.string, (s) => `string: ${s}`),\n *   // Ensure all possible cases are handled\n *   Match.exhaustive\n * )\n *\n * console.log(match(0))\n * // Output: \"number: 0\"\n *\n * console.log(match(\"hello\"))\n * // Output: \"string: hello\"\n * ```\n *\n * @see {@link value} for creating a matcher from a specific value.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const type: <I>() => Matcher<I, Types.Without<never>, I, never, never> = internal.type\n\n/**\n * Creates a matcher from a specific value.\n *\n * **Details**\n *\n * This function allows you to define a `Matcher` directly from a given value,\n * rather than from a type. This is useful when working with known values,\n * enabling structured pattern matching on objects, primitives, or any data\n * structure.\n *\n * Once the matcher is created, you can use pattern-matching functions like\n * {@link when} to define how different cases should be handled.\n *\n * **Example** (Matching an Object by Property)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const input = { name: \"John\", age: 30 }\n *\n * // Create a matcher for the specific object\n * const result = Match.value(input).pipe(\n *   // Match when the 'name' property is \"John\"\n *   Match.when(\n *     { name: \"John\" },\n *     (user) => `${user.name} is ${user.age} years old`\n *   ),\n *   // Provide a fallback if no match is found\n *   Match.orElse(() => \"Oh, not John\")\n * )\n *\n * console.log(result)\n * // Output: \"John is 30 years old\"\n * ```\n *\n * @see {@link type} for creating a matcher from a specific type.\n *\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const value: <const I>(\n  i: I\n) => Matcher<I, Types.Without<never>, I, never, I> = internal.value\n\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const valueTags: {\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P): (input: I) => Unify<ReturnType<P[keyof P]>>\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>>\n} = internal.valueTags\n\n/**\n * @category Creating a matcher\n * @since 1.0.0\n */\nexport const typeTags: {\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <I, Ret>(): <\n    P extends\n      & {\n        readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n          _: Extract<I, { readonly _tag: Tag }>\n        ) => Ret\n      }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P) => (input: I) => Ret\n  /**\n   * @category Creating a matcher\n   * @since 1.0.0\n   */\n  <I>(): <\n    P extends\n      & {\n        readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n          _: Extract<I, { readonly _tag: Tag }>\n        ) => any\n      }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P) => (input: I) => Unify<ReturnType<P[keyof P]>>\n} = internal.typeTags\n\n/**\n * Ensures that all branches of a matcher return a specific type.\n *\n * **Details**\n *\n * This function enforces a consistent return type across all pattern-matching\n * branches. By specifying a return type, TypeScript will check that every\n * matching condition produces a value of the expected type.\n *\n * **Important:** This function must be the first step in the matcher pipeline.\n * If used later, TypeScript will not enforce type consistency correctly.\n *\n * **Example** (Validating Return Type Consistency)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * const match = Match.type<{ a: number } | { b: string }>().pipe(\n *   // Ensure all branches return a string\n *   Match.withReturnType<string>(),\n *   // ❌ Type error: 'number' is not assignable to type 'string'\n *   // @ts-expect-error\n *   Match.when({ a: Match.number }, (_) => _.a),\n *   // ✅ Correct: returns a string\n *   Match.when({ b: Match.string }, (_) => _.b),\n *   Match.exhaustive\n * )\n * ```\n *\n * @since 1.0.0\n */\nexport const withReturnType: <Ret>() => <I, F, R, A, Pr, _>(\n  self: Matcher<I, F, R, A, Pr, _>\n) => [Ret] extends [[A] extends [never] ? any : A] ? Matcher<I, F, R, A, Pr, Ret>\n  : \"withReturnType constraint does not extend Result type\" = internal.withReturnType\n\n/**\n * Defines a condition for matching values.\n *\n * **Details**\n *\n * This function enables pattern matching by checking whether a given value\n * satisfies a condition. It supports both direct value comparisons and\n * predicate functions. If the condition is met, the associated function is\n * executed.\n *\n * This function is useful when defining matchers that need to check for\n * specific values or apply logical conditions to determine a match. It works\n * well with structured objects and primitive types.\n *\n * **Example** (Matching with Values and Predicates)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for objects with an \"age\" property\n * const match = Match.type<{ age: number }>().pipe(\n *   // Match when age is greater than 18\n *   Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),\n *   // Match when age is exactly 18\n *   Match.when({ age: 18 }, () => \"You can vote\"),\n *   // Fallback case for all other ages\n *   Match.orElse((user) => `${user.age} is too young`)\n * )\n *\n * console.log(match({ age: 20 }))\n * // Output: \"Age: 20\"\n *\n * console.log(match({ age: 18 }))\n * // Output: \"You can vote\"\n *\n * console.log(match({ age: 4 }))\n * // Output: \"4 is too young\"\n * ```\n *\n * @see {@link whenOr} Use this when multiple patterns should match in a single\n * condition.\n * @see {@link whenAnd} Use this when a value must match all provided patterns.\n * @see {@link orElse} Provides a fallback when no patterns match.\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const when: <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.when\n\n/**\n * Matches one of multiple patterns in a single condition.\n *\n * **Details**\n *\n * This function allows defining a condition where a value matches any of the\n * provided patterns. If a match is found, the associated function is executed.\n * It simplifies cases where multiple patterns share the same handling logic.\n *\n * Unlike {@link when}, which requires separate conditions for each pattern,\n * this function enables combining them into a single statement, making the\n * matcher more concise.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type ErrorType =\n *   | { readonly _tag: \"NetworkError\"; readonly message: string }\n *   | { readonly _tag: \"TimeoutError\"; readonly duration: number }\n *   | { readonly _tag: \"ValidationError\"; readonly field: string }\n *\n * const handleError = Match.type<ErrorType>().pipe(\n *   Match.whenOr(\n *     { _tag: \"NetworkError\" },\n *     { _tag: \"TimeoutError\" },\n *     () => \"Retry the request\"\n *   ),\n *   Match.when({ _tag: \"ValidationError\" }, (_) => `Invalid field: ${_.field}`),\n *   Match.exhaustive\n * )\n *\n * console.log(handleError({ _tag: \"NetworkError\", message: \"No connection\" }))\n * // Output: \"Retry the request\"\n *\n * console.log(handleError({ _tag: \"ValidationError\", field: \"email\" }))\n * // Output: \"Invalid field: email\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenOr: <\n  R,\n  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P[number]>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.whenOr\n\n/**\n * Matches a value that satisfies all provided patterns.\n *\n * **Details**\n *\n * This function allows defining a condition where a value must match all the\n * given patterns simultaneously. If the value satisfies every pattern, the\n * associated function is executed.\n *\n * Unlike {@link when}, which matches a single pattern at a time, this function\n * ensures that multiple conditions are met before executing the callback. It is\n * useful when checking for values that need to fulfill multiple criteria at\n * once.\n *\n * @example\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly age: number; readonly role: \"admin\" | \"user\" }\n *\n * const checkUser = Match.type<User>().pipe(\n *   Match.whenAnd(\n *     { age: (n) => n >= 18 },\n *     { role: \"admin\" },\n *     () => \"Admin access granted\"\n *   ),\n *   Match.orElse(() => \"Access denied\")\n * )\n *\n * console.log(checkUser({ age: 20, role: \"admin\" }))\n * // Output: \"Admin access granted\"\n *\n * console.log(checkUser({ age: 20, role: \"user\" }))\n * // Output: \"Access denied\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const whenAnd: <\n  R,\n  const P extends ReadonlyArray<Types.PatternPrimitive<R> | Types.PatternBase<R>>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, T.UnionToIntersection<P[number]>>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<T.UnionToIntersection<P[number]>>>>,\n  A | ReturnType<Fn>,\n  Pr\n> = internal.whenAnd\n\n/**\n * Matches values based on a specified discriminant field.\n *\n * **Details**\n *\n * This function is used to define pattern matching on objects that follow a\n * **discriminated union** structure, where a specific field (e.g., `type`,\n * `kind`, `_tag`) determines the variant of the object. It allows matching\n * multiple values of the discriminant and provides a function to handle the\n * matched cases.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminator(\"type\")(\"A\", \"B\", (_) => `A or B: ${_.type}`),\n *   Match.discriminator(\"type\")(\"C\", (_) => `C(${_.c})`),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminator: <D extends string>(\n  field: D\n) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(\n  ...pattern: [first: P, ...values: Array<P>, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.discriminator\n\n/**\n * Matches values where a specified field starts with a given prefix.\n *\n * **Details**\n *\n * This function is useful for working with discriminated unions where the\n * discriminant field follows a hierarchical or namespaced structure. It allows\n * you to match values based on whether the specified field starts with a given\n * prefix, making it easier to handle grouped cases.\n *\n * Instead of checking for exact matches, this function lets you match values\n * that share a common prefix. For example, if your discriminant field contains\n * hierarchical names like `\"A\"`, `\"A.A\"`, and `\"B\"`, you can match all values\n * starting with `\"A\"` using a single rule.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\" } | { type: \"B\" } | { type: \"A.A\" } | {}>(),\n *   Match.discriminatorStartsWith(\"type\")(\"A\", (_) => 1 as const),\n *   Match.discriminatorStartsWith(\"type\")(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ type: \"A\" })) // 1\n * console.log(match({ type: \"B\" })) // 2\n * console.log(match({ type: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorStartsWith: <D extends string>(\n  field: D\n) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.discriminatorStartsWith\n\n/**\n * Matches values based on a field that serves as a discriminator, mapping each\n * possible value to a corresponding handler.\n *\n * **Details**\n *\n * This function simplifies working with discriminated unions by letting you\n * define a set of handlers for each possible value of a given field. Instead of\n * chaining multiple calls to {@link discriminator}, this function allows\n * defining all possible cases at once using an object where the keys are the\n * possible values of the field, and the values are the corresponding handler\n * functions.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminators(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminators: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<D, keyof P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>,\n  A | ReturnType<P[keyof P] & {}>,\n  Pr,\n  Ret\n> = internal.discriminators\n\n/**\n * Matches values based on a discriminator field and **ensures all cases are\n * handled**.\n *\n * **Details*+\n *\n * This function is similar to {@link discriminators}, but **requires that all\n * possible cases** are explicitly handled. It is useful when working with\n * discriminated unions, where a specific field (e.g., `\"type\"`) determines the\n * shape of an object. Each possible value of the field must have a\n * corresponding handler, ensuring **exhaustiveness checking** at compile time.\n *\n * This function **does not require** `Match.exhaustive` at the end of the\n * pipeline because it enforces exhaustiveness by design.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ type: \"A\"; a: string } | { type: \"B\"; b: number } | { type: \"C\"; c: boolean }>(),\n *   Match.discriminatorsExhaustive(\"type\")({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const discriminatorsExhaustive: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>> =\n  internal.discriminatorsExhaustive\n\n/**\n * The `Match.tag` function allows pattern matching based on the `_tag` field in\n * a [Discriminated Union](https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes-func.html#discriminated-unions).\n * You can specify multiple tags to match within a single pattern.\n *\n * **Note**\n *\n * The `Match.tag` function relies on the convention within the Effect ecosystem\n * of naming the tag field as `\"_tag\"`. Ensure that your discriminated unions\n * follow this naming convention for proper functionality.\n *\n * **Example** (Matching a Discriminated Union by Tag)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type Event =\n *   | { readonly _tag: \"fetch\" }\n *   | { readonly _tag: \"success\"; readonly data: string }\n *   | { readonly _tag: \"error\"; readonly error: Error }\n *   | { readonly _tag: \"cancel\" }\n *\n * // Create a Matcher for Either<number, string>\n * const match = Match.type<Event>().pipe(\n *   // Match either \"fetch\" or \"success\"\n *   Match.tag(\"fetch\", \"success\", () => `Ok!`),\n *   // Match \"error\" and extract the error message\n *   Match.tag(\"error\", (event) => `Error: ${event.error.message}`),\n *   // Match \"cancel\"\n *   Match.tag(\"cancel\", () => \"Cancelled\"),\n *   Match.exhaustive\n * )\n *\n * console.log(match({ _tag: \"success\", data: \"Hello\" }))\n * // Output: \"Ok!\"\n *\n * console.log(match({ _tag: \"error\", error: new Error(\"Oops!\") }))\n * // Output: \"Error: Oops!\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tag: <\n  R,\n  P extends Types.Tags<\"_tag\", R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret\n>(\n  ...pattern: [first: P, ...values: Array<P>, f: Fn]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = internal.tag\n\n/**\n * Matches values where the `_tag` field starts with a given prefix.\n *\n * **Details**\n *\n * This function allows you to match on values in a **discriminated union**\n * based on whether the `_tag` field starts with a specified prefix. It is\n * useful for handling hierarchical or namespaced tags, where multiple related\n * cases share a common prefix.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\" } | { _tag: \"B\" } | { _tag: \"A.A\" } | {}>(),\n *   Match.tagStartsWith(\"A\", (_) => 1 as const),\n *   Match.tagStartsWith(\"B\", (_) => 2 as const),\n *   Match.orElse((_) => 3 as const)\n * )\n *\n * console.log(match({ _tag: \"A\" })) // 1\n * console.log(match({ _tag: \"B\" })) // 2\n * console.log(match({ _tag: \"A.A\" })) // 1\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagStartsWith: <\n  R,\n  P extends string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", `${P}${string}`>>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", `${P}${string}`>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = internal.tagStartsWith\n\n/**\n * Matches values based on their `_tag` field, mapping each tag to a\n * corresponding handler.\n *\n * **Details**\n *\n * This function provides a way to handle discriminated unions by mapping `_tag`\n * values to specific functions. Each handler receives the matched value and\n * returns a transformed result. If all possible tags are handled, you can\n * enforce exhaustiveness using `Match.exhaustive` to ensure no case is missed.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tags({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   }),\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tags: <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<\"_tag\", R> & string]?: ((_: Extract<R, Record<\"_tag\", Tag>>) => Ret) | undefined }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", keyof P>>>>,\n  A | ReturnType<P[keyof P] & {}>,\n  Pr,\n  Ret\n> = internal.tags\n\n/**\n * Matches values based on their `_tag` field and requires handling of all\n * possible cases.\n *\n * **Details**\n *\n * This function is designed for **discriminated unions** where every possible\n * `_tag` value must have a corresponding handler. Unlike {@link tags}, this\n * function ensures **exhaustiveness**, meaning all cases must be explicitly\n * handled. If a `_tag` value is missing from the mapping, TypeScript will\n * report an error.\n *\n * @example\n * ```ts\n * import { Match, pipe } from \"effect\"\n *\n * const match = pipe(\n *   Match.type<{ _tag: \"A\"; a: string } | { _tag: \"B\"; b: number } | { _tag: \"C\"; c: boolean }>(),\n *   Match.tagsExhaustive({\n *     A: (a) => a.a,\n *     B: (b) => b.b,\n *     C: (c) => c.c\n *   })\n * )\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const tagsExhaustive: <\n  R,\n  Ret,\n  P extends\n    & { readonly [Tag in Types.Tags<\"_tag\", R> & string]: (_: Extract<R, Record<\"_tag\", Tag>>) => Ret }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>> =\n  internal.tagsExhaustive\n\n/**\n * Excludes a specific value from matching while allowing all others.\n *\n * **Details**\n *\n * This function is useful when you need to **handle all values except one or\n * more specific cases**. Instead of listing all possible matches manually, this\n * function simplifies the logic by allowing you to specify values to exclude.\n * Any excluded value will bypass the provided function and continue matching\n * through other cases.\n *\n * **Example** (Ignoring a Specific Value)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match any value except \"hi\", returning \"ok\"\n *   Match.not(\"hi\", () => \"ok\"),\n *   // Fallback case for when the value is \"hi\"\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"hello\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"hi\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Defining patterns\n * @since 1.0.0\n */\nexport const not: <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.NotMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddOnly<F, Types.WhenMatch<R, P>>,\n  Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> = internal.not\n\n/**\n * Matches non-empty strings.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const nonEmptyString: SafeRefinement<string, never> = internal.nonEmptyString\n\n/**\n * Matches a specific set of literal values (e.g., `Match.is(\"a\", 42, true)`).\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const is: <\n  Literals extends ReadonlyArray<string | number | bigint | boolean | null>\n>(...literals: Literals) => SafeRefinement<Literals[number]> = internal.is\n\n/**\n * Matches values of type `string`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const string: Predicate.Refinement<unknown, string> = Predicate.isString\n\n/**\n * Matches values of type `number`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const number: Predicate.Refinement<unknown, number> = Predicate.isNumber\n\n/**\n * Matches any value without restrictions.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const any: SafeRefinement<unknown, any> = internal.any\n\n/**\n * Matches any defined (non-null and non-undefined) value.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const defined: <A>(u: A) => u is A & {} = internal.defined\n\n/**\n * Matches values of type `boolean`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const boolean: Predicate.Refinement<unknown, boolean> = Predicate.isBoolean\n\nconst _undefined: Predicate.Refinement<unknown, undefined> = Predicate.isUndefined\nexport {\n  /**\n   * Matches the value `undefined`.\n   *\n   * @category Predicates\n   * @since 1.0.0\n   */\n  _undefined as undefined\n}\n\nconst _null: Predicate.Refinement<unknown, null> = Predicate.isNull\nexport {\n  /**\n   * Matches the value `null`.\n   *\n   * @category Predicates\n   * @since 1.0.0\n   */\n  _null as null\n}\n\n/**\n * Matches values of type `bigint`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const bigint: Predicate.Refinement<unknown, bigint> = Predicate.isBigInt\n\n/**\n * Matches values of type `symbol`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const symbol: Predicate.Refinement<unknown, symbol> = Predicate.isSymbol\n\n/**\n * Matches values that are instances of `Date`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const date: Predicate.Refinement<unknown, Date> = Predicate.isDate\n\n/**\n * Matches objects where keys are `string` or `symbol` and values are `unknown`.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const record: Predicate.Refinement<unknown, { [x: string | symbol]: unknown }> = Predicate.isRecord\n\n/**\n * Matches instances of a given class.\n *\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOf: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, never> = internal.instanceOf\n\n/**\n * @category Predicates\n * @since 1.0.0\n */\nexport const instanceOfUnsafe: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, InstanceType<A>> = internal.instanceOf\n\n/**\n * Provides a fallback value when no patterns match.\n *\n * **Details**\n *\n * This function ensures that a matcher always returns a valid result, even if\n * no defined patterns match. It acts as a default case, similar to the\n * `default` clause in a `switch` statement or the final `else` in an `if-else`\n * chain.\n *\n * **Example** (Providing a Default Value When No Patterns Match)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is \"a\"\n *   Match.when(\"a\", () => \"ok\"),\n *   // Fallback when no patterns match\n *   Match.orElse(() => \"fallback\")\n * )\n *\n * console.log(match(\"a\"))\n * // Output: \"ok\"\n *\n * console.log(match(\"b\"))\n * // Output: \"fallback\"\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElse: <RA, Ret, F extends (_: RA) => Ret>(\n  f: F\n) => <I, R, A, Pr>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A> = internal.orElse\n\n// TODO(4.0): Rename to \"orThrow\"? Like Either.getOrThrow\n/**\n * Throws an error if no pattern matches.\n *\n * **Details**\n *\n * This function finalizes a matcher by ensuring that if no patterns match, an\n * error is thrown. It is useful when all cases should be covered, and any\n * unexpected input should trigger an error instead of returning a default\n * value.\n *\n * When used, this function removes the need for an explicit fallback case and\n * ensures that an unmatched value is never silently ignored.\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const orElseAbsurd: <I, R, RA, A, Pr, Ret>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A> = internal.orElseAbsurd\n\n/**\n * Wraps the match result in an `Either`, distinguishing matched and unmatched\n * cases.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is always wrapped in an\n * `Either`, allowing clear differentiation between successful matches\n * (`Right(value)`) and cases where no pattern matched (`Left(unmatched\n * value)`).\n *\n * This approach is particularly useful when handling optional values or when an\n * unmatched case should be explicitly handled rather than returning a default\n * value or throwing an error.\n *\n * **Example** (Extracting a User Role with `Match.either`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.either // Wrap the result in an Either\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const either: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R> = internal.either\n\n/**\n * Wraps the match result in an `Option`, representing an optional match.\n *\n * **Details**\n *\n * This function ensures that the result of a matcher is wrapped in an `Option`,\n * making it easy to handle cases where no pattern matches. If a match is found,\n * it returns `Some(value)`, otherwise, it returns `None`.\n *\n * This is useful in cases where a missing match is expected and should be\n * handled explicitly rather than throwing an error or returning a default\n * value.\n *\n * **Example** (Extracting a User Role with `Match.option`)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * type User = { readonly role: \"admin\" | \"editor\" | \"viewer\" }\n *\n * // Create a matcher to extract user roles\n * const getRole = Match.type<User>().pipe(\n *   Match.when({ role: \"admin\" }, () => \"Has full access\"),\n *   Match.when({ role: \"editor\" }, () => \"Can edit content\"),\n *   Match.option // Wrap the result in an Option\n * )\n *\n * console.log(getRole({ role: \"admin\" }))\n * // Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }\n *\n * console.log(getRole({ role: \"viewer\" }))\n * // Output: { _id: 'Option', _tag: 'None' }\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const option: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>> = internal.option\n\n/**\n * The `Match.exhaustive` method finalizes the pattern matching process by\n * ensuring that all possible cases are accounted for. If any case is missing,\n * TypeScript will produce a type error. This is particularly useful when\n * working with unions, as it helps prevent unintended gaps in pattern matching.\n *\n * **Example** (Ensuring All Cases Are Covered)\n *\n * ```ts\n * import { Match } from \"effect\"\n *\n * // Create a matcher for string or number values\n * const match = Match.type<string | number>().pipe(\n *   // Match when the value is a number\n *   Match.when(Match.number, (n) => `number: ${n}`),\n *   // Mark the match as exhaustive, ensuring all cases are handled\n *   // TypeScript will throw an error if any case is missing\n *   // @ts-expect-error Type 'string' is not assignable to type 'never'\n *   Match.exhaustive\n * )\n * ```\n *\n * @category Completion\n * @since 1.0.0\n */\nexport const exhaustive: <I, F, A, Pr, Ret>(\n  self: Matcher<I, F, never, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A> = internal.exhaustive\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport const SafeRefinementId = Symbol.for(\"effect/SafeRefinement\")\n\n/**\n * @since 1.0.0\n * @category Symbols\n */\nexport type SafeRefinementId = typeof SafeRefinementId\n\n/**\n * @category Model\n * @since 1.0.0\n */\nexport interface SafeRefinement<in A, out R = A> {\n  readonly [SafeRefinementId]: (a: A) => R\n}\n\nconst Fail = Symbol.for(\"effect/Fail\")\ntype Fail = typeof Fail\n\n/**\n * @since 1.0.0\n */\nexport declare namespace Types {\n  /**\n   * @since 1.0.0\n   */\n  export type WhenMatch<R, P> =\n    // check for any\n    [0] extends [1 & R] ? ResolvePred<P> :\n      P extends SafeRefinement<infer SP, never> ? SP\n      : P extends Predicate.Refinement<infer _R, infer RP>\n      // try to narrow refinement\n        ? [Extract<R, RP>] extends [infer X] ? [X] extends [never]\n            // fallback to original refinement\n            ? RP\n          : X\n        : never\n      : P extends PredicateA<infer PP> ? PP\n      : ExtractMatch<R, P>\n\n  /**\n   * @since 1.0.0\n   */\n  export type NotMatch<R, P> = Exclude<R, ExtractMatch<R, PForNotMatch<P>>>\n\n  type PForNotMatch<P> = [ToInvertedRefinement<P>] extends [infer X] ? X\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PForMatch<P> = [ResolvePred<P>] extends [infer X] ? X\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PForExclude<P> = [SafeRefinementR<ToSafeRefinement<P>>] extends [infer X] ? X\n    : never\n\n  // utilities\n  type PredicateA<A> = Predicate.Predicate<A> | Predicate.Refinement<A, A>\n\n  type SafeRefinementR<A> = A extends never ? never\n    : A extends SafeRefinement<infer _, infer R> ? R\n    : A extends Function ? A\n    : A extends Record<string, any> ? { [K in keyof A]: SafeRefinementR<A[K]> }\n    : A\n\n  type ResolvePred<A, Input = any> = A extends never ? never\n    : A extends SafeRefinement<infer _A, infer _R> ? _A\n    : A extends Predicate.Refinement<Input, infer P> ? P\n    : A extends Predicate.Predicate<infer P> ? P\n    : A extends Record<string, any> ? { [K in keyof A]: ResolvePred<A[K]> }\n    : A\n\n  type ToSafeRefinement<A> = A extends never ? never\n    : A extends Predicate.Refinement<any, infer P> ? SafeRefinement<P, P>\n    : A extends Predicate.Predicate<infer P> ? SafeRefinement<P, never>\n    : A extends SafeRefinement<any> ? A\n    : A extends Record<string, any> ? { [K in keyof A]: ToSafeRefinement<A[K]> }\n    : NonLiteralsTo<A, never>\n\n  type ToInvertedRefinement<A> = A extends never ? never\n    : A extends Predicate.Refinement<any, infer P> ? SafeRefinement<P>\n    : A extends Predicate.Predicate<infer _P> ? SafeRefinement<never>\n    : A extends SafeRefinement<infer _A, infer _R> ? SafeRefinement<_R>\n    : A extends Record<string, any> ? { [K in keyof A]: ToInvertedRefinement<A[K]> }\n    : NonLiteralsTo<A, never>\n\n  type NonLiteralsTo<A, T> = [A] extends [string | number | boolean | bigint] ? [string] extends [A] ? T\n    : [number] extends [A] ? T\n    : [boolean] extends [A] ? T\n    : [bigint] extends [A] ? T\n    : A\n    : A\n\n  /**\n   * @since 1.0.0\n   */\n  export type PatternBase<A> = A extends ReadonlyArray<infer _T> ? ReadonlyArray<any> | PatternPrimitive<A>\n    : A extends Record<string, any> ? Partial<\n        { [K in keyof A]: PatternPrimitive<A[K] & {}> | PatternBase<A[K] & {}> }\n      >\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type PatternPrimitive<A> = PredicateA<A> | A | SafeRefinement<any>\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Without<out X> {\n    readonly _tag: \"Without\"\n    readonly _X: X\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export interface Only<out X> {\n    readonly _tag: \"Only\"\n    readonly _X: X\n  }\n\n  /**\n   * @since 1.0.0\n   */\n  export type AddWithout<A, X> = [A] extends [Without<infer WX>] ? Without<X | WX>\n    : [A] extends [Only<infer OX>] ? Only<Exclude<OX, X>>\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type AddOnly<A, X> = [A] extends [Without<infer WX>] ? [X] extends [WX] ? never\n    : Only<X>\n    : [A] extends [Only<infer OX>] ? [X] extends [OX] ? Only<X>\n      : never\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type ApplyFilters<I, A> = A extends Only<infer X> ? X\n    : A extends Without<infer X> ? Exclude<I, X>\n    : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type Tags<D extends string, P> = P extends Record<D, infer X> ? X : never\n\n  /**\n   * @since 1.0.0\n   */\n  export type ArrayToIntersection<A extends ReadonlyArray<any>> = T.UnionToIntersection<\n    A[number]\n  >\n\n  /**\n   * @since 1.0.0\n   */\n  export type ExtractMatch<I, P> = [ExtractAndNarrow<I, P>] extends [infer EI] ? EI\n    : never\n\n  type Replace<A, B> = A extends Function ? A\n    : A extends Record<string | number, any> ? { [K in keyof A]: K extends keyof B ? Replace<A[K], B[K]> : A[K] }\n    : [B] extends [A] ? B\n    : A\n\n  type MaybeReplace<I, P> = [P] extends [I] ? P\n    : [I] extends [P] ? Replace<I, P>\n    : Fail\n\n  type BuiltInObjects =\n    | Function\n    | Date\n    | RegExp\n    | Generator\n    | { readonly [Symbol.toStringTag]: string }\n\n  type IsPlainObject<T> = T extends BuiltInObjects ? false\n    : T extends Record<string, any> ? true\n    : false\n\n  type Simplify<A> = { [K in keyof A]: A[K] } & {}\n\n  type ExtractAndNarrow<Input, P> = P extends Predicate.Refinement<infer _In, infer _Out> ?\n    _Out extends Input ? Extract<_Out, Input>\n    : Extract<Input, _Out> :\n    P extends SafeRefinement<infer _In, infer _R> ? [0] extends [1 & _R] ? Input\n      : _In extends Input ? Extract<_In, Input>\n      : Extract<Input, _In>\n    : P extends Predicate.Predicate<infer _In> ? Extract<Input, _In>\n    : Input extends infer I ? Exclude<\n        I extends ReadonlyArray<any> ? P extends ReadonlyArray<any> ? {\n              readonly [K in keyof I]: K extends keyof P ? ExtractAndNarrow<I[K], P[K]>\n                : I[K]\n            } extends infer R ? Fail extends R[keyof R] ? never\n              : R\n            : never\n          : never\n          : IsPlainObject<I> extends true ? string extends keyof I ? I extends P ? I\n              : never\n            : symbol extends keyof I ? I extends P ? I\n              : never\n            : Simplify<\n              & { [RK in Extract<keyof I, keyof P>]-?: ExtractAndNarrow<I[RK], P[RK]> }\n              & Omit<I, keyof P>\n            > extends infer R ? keyof P extends NonFailKeys<R> ? R\n              : never\n            : never\n          : MaybeReplace<I, P> extends infer R ? [I] extends [R] ? I\n            : R\n          : never,\n        Fail\n      > :\n    never\n\n  type NonFailKeys<A> = keyof A & {} extends infer K ? K extends keyof A ? A[K] extends Fail ? never : K\n    : never :\n    never\n}\n", "import * as Either from \"../Either.js\"\nimport { dual, identity } from \"../Function.js\"\nimport type {\n  Case,\n  Matcher,\n  MatcherTypeId,\n  Not,\n  SafeRefinement,\n  TypeMatcher,\n  Types,\n  ValueMatcher,\n  When\n} from \"../Match.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport type * as Predicate from \"../Predicate.js\"\nimport type { Unify } from \"../Unify.js\"\n\n/** @internal */\nexport const TypeId: MatcherTypeId = Symbol.for(\n  \"@effect/matcher/Matcher\"\n) as MatcherTypeId\n\nconst TypeMatcherProto: Omit<TypeMatcher<any, any, any, any>, \"cases\"> = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _remaining: identity,\n    _result: identity,\n    _return: identity\n  },\n  _tag: \"TypeMatcher\",\n  add<I, R, RA, A>(\n    this: TypeMatcher<any, any, any, any>,\n    _case: Case\n  ): TypeMatcher<I, R, RA, A> {\n    return makeTypeMatcher([...this.cases, _case])\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeTypeMatcher<I, R, RA, A>(\n  cases: ReadonlyArray<Case>\n): TypeMatcher<I, R, RA, A> {\n  const matcher = Object.create(TypeMatcherProto)\n  matcher.cases = cases\n  return matcher\n}\n\nconst ValueMatcherProto: Omit<\n  ValueMatcher<any, any, any, any, any>,\n  \"provided\" | \"value\"\n> = {\n  [TypeId]: {\n    _input: identity,\n    _filters: identity,\n    _remaining: identity,\n    _result: identity,\n    _provided: identity,\n    _return: identity\n  },\n  _tag: \"ValueMatcher\",\n  add<I, R, RA, A, Pr>(\n    this: ValueMatcher<any, any, any, any, any>,\n    _case: Case\n  ): ValueMatcher<I, R, RA, A, Pr> {\n    if (this.value._tag === \"Right\") {\n      return this\n    }\n\n    if (_case._tag === \"When\" && _case.guard(this.provided) === true) {\n      return makeValueMatcher(\n        this.provided,\n        Either.right(_case.evaluate(this.provided))\n      )\n    } else if (_case._tag === \"Not\" && _case.guard(this.provided) === false) {\n      return makeValueMatcher(\n        this.provided,\n        Either.right(_case.evaluate(this.provided))\n      )\n    }\n\n    return this\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nfunction makeValueMatcher<I, R, RA, A, Pr>(\n  provided: Pr,\n  value: Either.Either<Pr, RA>\n): ValueMatcher<I, R, RA, A, Pr> {\n  const matcher = Object.create(ValueMatcherProto)\n  matcher.provided = provided\n  matcher.value = value\n  return matcher\n}\n\nconst makeWhen = (\n  guard: (u: unknown) => boolean,\n  evaluate: (input: unknown) => any\n): When => ({\n  _tag: \"When\",\n  guard,\n  evaluate\n})\n\nconst makeNot = (\n  guard: (u: unknown) => boolean,\n  evaluate: (input: unknown) => any\n): Not => ({\n  _tag: \"Not\",\n  guard,\n  evaluate\n})\n\nconst makePredicate = (pattern: unknown): Predicate.Predicate<unknown> => {\n  if (typeof pattern === \"function\") {\n    return pattern as Predicate.Predicate<unknown>\n  } else if (Array.isArray(pattern)) {\n    const predicates = pattern.map(makePredicate)\n    const len = predicates.length\n\n    return (u: unknown) => {\n      if (!Array.isArray(u)) {\n        return false\n      }\n\n      for (let i = 0; i < len; i++) {\n        if (predicates[i](u[i]) === false) {\n          return false\n        }\n      }\n\n      return true\n    }\n  } else if (pattern !== null && typeof pattern === \"object\") {\n    const keysAndPredicates = Object.entries(pattern).map(\n      ([k, p]) => [k, makePredicate(p)] as const\n    )\n    const len = keysAndPredicates.length\n\n    return (u: unknown) => {\n      if (typeof u !== \"object\" || u === null) {\n        return false\n      }\n\n      for (let i = 0; i < len; i++) {\n        const [key, predicate] = keysAndPredicates[i]\n        if (!(key in u) || predicate((u as any)[key]) === false) {\n          return false\n        }\n      }\n\n      return true\n    }\n  }\n\n  return (u: unknown) => u === pattern\n}\n\nconst makeOrPredicate = (\n  patterns: ReadonlyArray<unknown>\n): Predicate.Predicate<unknown> => {\n  const predicates = patterns.map(makePredicate)\n  const len = predicates.length\n\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === true) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nconst makeAndPredicate = (\n  patterns: ReadonlyArray<unknown>\n): Predicate.Predicate<unknown> => {\n  const predicates = patterns.map(makePredicate)\n  const len = predicates.length\n\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (predicates[i](u) === false) {\n        return false\n      }\n    }\n\n    return true\n  }\n}\n\n/** @internal */\nexport const type = <I>(): Matcher<\n  I,\n  Types.Without<never>,\n  I,\n  never,\n  never\n> => makeTypeMatcher([])\n\n/** @internal */\nexport const value = <const I>(\n  i: I\n): Matcher<I, Types.Without<never>, I, never, I> => makeValueMatcher(i, Either.left(i))\n\n/** @internal */\nexport const valueTags: {\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(fields: P): (input: I) => Unify<ReturnType<P[keyof P]>>\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>>\n} = dual(\n  2,\n  <\n    const I,\n    P extends\n      & { readonly [Tag in Types.Tags<\"_tag\", I> & string]: (_: Extract<I, { readonly _tag: Tag }>) => any }\n      & { readonly [Tag in Exclude<keyof P, Types.Tags<\"_tag\", I>>]: never }\n  >(input: I, fields: P): Unify<ReturnType<P[keyof P]>> => {\n    const match: any = tagsExhaustive(fields as any)(makeTypeMatcher([]))\n    return match(input)\n  }\n)\n\n/** @internal */\nexport const typeTags = <I>() =>\n<\n  P extends {\n    readonly [Tag in Types.Tags<\"_tag\", I> & string]: (\n      _: Extract<I, { readonly _tag: Tag }>\n    ) => any\n  }\n>(\n  fields: P\n) => {\n  const match: any = tagsExhaustive(fields as any)(makeTypeMatcher([]))\n  return (input: I): Unify<ReturnType<P[keyof P]>> => match(input)\n}\n\n/** @internal */\nexport const withReturnType = <Ret>() =>\n<I, F, R, A, Pr, _>(self: Matcher<I, F, R, A, Pr, _>): [Ret] extends [\n  [A] extends [never] ? any : A\n] ? Matcher<I, F, R, A, Pr, Ret>\n  : \"withReturnType constraint does not extend Result type\" => self as any\n\n/** @internal */\nexport const when = <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => (self as any).add(makeWhen(makePredicate(pattern), f as any))\n\n/** @internal */\nexport const whenOr = <\n  R,\n  const P extends ReadonlyArray<\n    Types.PatternPrimitive<R> | Types.PatternBase<R>\n  >,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, P[number]>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<P[number]>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P[number]>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => {\n  const onMatch = args[args.length - 1] as any\n  const patterns = args.slice(0, -1) as unknown as P\n  return (self as any).add(makeWhen(makeOrPredicate(patterns), onMatch))\n}\n\n/** @internal */\nexport const whenAnd = <\n  R,\n  const P extends ReadonlyArray<\n    Types.PatternPrimitive<R> | Types.PatternBase<R>\n  >,\n  Ret,\n  Fn extends (_: Types.WhenMatch<R, Types.ArrayToIntersection<P>>) => Ret\n>(\n  ...args: [...patterns: P, f: Fn]\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddWithout<F, Types.PForExclude<Types.ArrayToIntersection<P>>>,\n  Types.ApplyFilters<\n    I,\n    Types.AddWithout<F, Types.PForExclude<Types.ArrayToIntersection<P>>>\n  >,\n  A | ReturnType<Fn>,\n  Pr\n> => {\n  const onMatch = args[args.length - 1] as any\n  const patterns = args.slice(0, -1) as unknown as P\n  return (self as any).add(makeWhen(makeAndPredicate(patterns), onMatch))\n}\n\n/** @internal */\nexport const discriminator = <D extends string>(field: D) =>\n<\n  R,\n  P extends Types.Tags<D, R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<D, P>>) => Ret\n>(\n  ...pattern: [\n    first: P,\n    ...values: Array<P>,\n    f: Fn\n  ]\n) => {\n  const f = pattern[pattern.length - 1]\n  const values: Array<P> = pattern.slice(0, -1) as any\n  const pred = values.length === 1\n    ? (_: any) => _[field] === values[0]\n    : (_: any) => values.includes(_[field])\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, P>>>,\n    Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>,\n    A | ReturnType<Fn>,\n    Pr,\n    Ret\n  > => (self as any).add(makeWhen(pred, f as any)) as any\n}\n\n/** @internal */\nexport const discriminatorStartsWith = <D extends string>(field: D) =>\n<\n  R,\n  P extends string,\n  Ret,\n  Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) => {\n  const pred = (_: any) => typeof _[field] === \"string\" && _[field].startsWith(pattern)\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>,\n    Types.ApplyFilters<\n      I,\n      Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>\n    >,\n    A | ReturnType<Fn>,\n    Pr,\n    Ret\n  > => (self as any).add(makeWhen(pred, f as any)) as any\n}\n\n/** @internal */\nexport const discriminators = <D extends string>(field: D) =>\n<\n  R,\n  Ret,\n  P extends\n    & {\n      readonly [Tag in Types.Tags<D, R> & string]?:\n        | ((_: Extract<R, Record<D, Tag>>) => Ret)\n        | undefined\n    }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => {\n  const predicate = makeWhen(\n    (arg: any) => arg != null && arg[field] in fields,\n    (data: any) => (fields as any)[data[field]](data)\n  )\n\n  return <I, F, A, Pr>(\n    self: Matcher<I, F, R, A, Pr, Ret>\n  ): Matcher<\n    I,\n    Types.AddWithout<F, Extract<R, Record<D, keyof P>>>,\n    Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>,\n    A | ReturnType<P[keyof P] & {}>,\n    Pr,\n    Ret\n  > => (self as any).add(predicate)\n}\n\n/** @internal */\nexport const discriminatorsExhaustive: <D extends string>(\n  field: D\n) => <\n  R,\n  Ret,\n  P extends\n    & {\n      readonly [Tag in Types.Tags<D, R> & string]: (\n        _: Extract<R, Record<D, Tag>>\n      ) => Ret\n    }\n    & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never }\n>(\n  fields: P\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>>\n  : Unify<A | ReturnType<P[keyof P]>> = (field: string) => (fields: object) => {\n    const addCases = discriminators(field)(fields)\n    return (matcher: any) => exhaustive(addCases(matcher))\n  }\n\n/** @internal */\nexport const tag: <\n  R,\n  P extends Types.Tags<\"_tag\", R> & string,\n  Ret,\n  Fn extends (_: Extract<R, Record<\"_tag\", P>>) => Ret\n>(\n  ...pattern: [\n    first: P,\n    ...values: Array<P>,\n    f: Fn\n  ]\n) => <I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => Matcher<\n  I,\n  Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>,\n  Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<\"_tag\", P>>>>,\n  ReturnType<Fn> | A,\n  Pr,\n  Ret\n> = discriminator(\"_tag\")\n\n/** @internal */\nexport const tagStartsWith = discriminatorStartsWith(\"_tag\")\n\n/** @internal */\nexport const tags = discriminators(\"_tag\")\n\n/** @internal */\nexport const tagsExhaustive = discriminatorsExhaustive(\"_tag\")\n\n/** @internal */\nexport const not = <\n  R,\n  const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>,\n  Ret,\n  Fn extends (_: Types.NotMatch<R, P>) => Ret\n>(\n  pattern: P,\n  f: Fn\n) =>\n<I, F, A, Pr>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n): Matcher<\n  I,\n  Types.AddOnly<F, Types.WhenMatch<R, P>>,\n  Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>,\n  A | ReturnType<Fn>,\n  Pr,\n  Ret\n> => (self as any).add(makeNot(makePredicate(pattern), f as any))\n\n/** @internal */\nexport const nonEmptyString: SafeRefinement<string, never> =\n  ((u: unknown) => typeof u === \"string\" && u.length > 0) as any\n\n/** @internal */\nexport const is: <\n  Literals extends ReadonlyArray<string | number | boolean | null | bigint>\n>(\n  ...literals: Literals\n) => SafeRefinement<Literals[number]> = (...literals): any => {\n  const len = literals.length\n  return (u: unknown) => {\n    for (let i = 0; i < len; i++) {\n      if (u === literals[i]) {\n        return true\n      }\n    }\n    return false\n  }\n}\n\n/** @internal */\nexport const any: SafeRefinement<unknown, any> = (() => true) as any\n\n/** @internal */\nexport const defined = <A>(u: A): u is A & {} => (u !== undefined && u !== null) as any\n\n/** @internal */\nexport const instanceOf = <A extends abstract new(...args: any) => any>(\n  constructor: A\n): SafeRefinement<InstanceType<A>, never> => ((u: unknown) => u instanceof constructor) as any\n\n/** @internal */\nexport const instanceOfUnsafe: <A extends abstract new(...args: any) => any>(\n  constructor: A\n) => SafeRefinement<InstanceType<A>, InstanceType<A>> = instanceOf\n\n/** @internal */\nexport const orElse =\n  <RA, Ret, F extends (_: RA) => Ret>(f: F) =>\n  <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>): [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A>\n    : Unify<ReturnType<F> | A> =>\n  {\n    const result = either(self)\n\n    if (Either.isEither(result)) {\n      // @ts-expect-error\n      return result._tag === \"Right\" ? result.right : f(result.left)\n    }\n\n    // @ts-expect-error\n    return (input: I) => {\n      const a = result(input)\n      return a._tag === \"Right\" ? a.right : f(a.left)\n    }\n  }\n\n/** @internal */\nexport const orElseAbsurd = <I, R, RA, A, Pr, Ret>(\n  self: Matcher<I, R, RA, A, Pr, Ret>\n): [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A> =>\n  orElse(() => {\n    throw new Error(\"effect/Match/orElseAbsurd: absurd\")\n  })(self)\n\n/** @internal */\nexport const either: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R>\n  : Either.Either<Unify<A>, R> = (<I, R, RA, A>(self: Matcher<I, R, RA, A, I>) => {\n    if (self._tag === \"ValueMatcher\") {\n      return self.value\n    }\n\n    const len = self.cases.length\n    if (len === 1) {\n      const _case = self.cases[0]\n      return (input: I): Either.Either<A, RA> => {\n        if (_case._tag === \"When\" && _case.guard(input) === true) {\n          return Either.right(_case.evaluate(input))\n        } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n          return Either.right(_case.evaluate(input))\n        }\n        return Either.left(input as any)\n      }\n    }\n    return (input: I): Either.Either<A, RA> => {\n      for (let i = 0; i < len; i++) {\n        const _case = self.cases[i]\n        if (_case._tag === \"When\" && _case.guard(input) === true) {\n          return Either.right(_case.evaluate(input))\n        } else if (_case._tag === \"Not\" && _case.guard(input) === false) {\n          return Either.right(_case.evaluate(input))\n        }\n      }\n\n      return Either.left(input as any)\n    }\n  }) as any\n\n/** @internal */\nexport const option: <I, F, R, A, Pr, Ret>(\n  self: Matcher<I, F, R, A, Pr, Ret>\n) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>>\n  : Option.Option<Unify<A>> = (<I, A>(self: Matcher<I, any, any, A, I>) => {\n    const toEither = either(self)\n    if (Either.isEither(toEither)) {\n      return Either.match(toEither, {\n        onLeft: () => Option.none(),\n        onRight: Option.some\n      })\n    }\n    return (input: I): Option.Option<A> =>\n      Either.match((toEither as any)(input), {\n        onLeft: () => Option.none(),\n        onRight: Option.some as any\n      })\n  }) as any\n\nconst getExhaustiveAbsurdErrorMessage = \"effect/Match/exhaustive: absurd\"\n\n/** @internal */\nexport const exhaustive: <I, F, A, Pr, Ret>(\n  self: Matcher<I, F, never, A, Pr, Ret>\n) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A> = (<I, F, A>(\n  self: Matcher<I, F, never, A, I>\n) => {\n  const toEither = either(self as any)\n\n  if (Either.isEither(toEither)) {\n    if (toEither._tag === \"Right\") {\n      return toEither.right\n    }\n\n    throw new Error(getExhaustiveAbsurdErrorMessage)\n  }\n\n  return (u: I): A => {\n    // @ts-expect-error\n    const result = toEither(u)\n\n    if (result._tag === \"Right\") {\n      return result.right as any\n    }\n\n    throw new Error(getExhaustiveAbsurdErrorMessage)\n  }\n}) as any\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport * as internal from \"./internal/channel/mergeState.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MergeStateTypeId: unique symbol = internal.MergeStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MergeStateTypeId = typeof MergeStateTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> =\n  | BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n  | RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MergeState {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [MergeStateTypeId]: MergeStateTypeId\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface BothRunning<_Env, out Err, out Err1, _Err2, out Elem, out Done, out Done1, _Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"BothRunning\"\n  readonly left: Fiber.Fiber<Either.Either<Elem, Done>, Err>\n  readonly right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface LeftDone<out Env, _Err, in Err1, out Err2, _Elem, _Done, in Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"LeftDone\"\n  f(exit: Exit.Exit<Done1, Err1>): Effect.Effect<Done2, Err2, Env>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface RightDone<out Env, in Err, _Err1, out Err2, _Elem, in Done, _Done1, out Done2>\n  extends MergeState.Proto\n{\n  readonly _tag: \"RightDone\"\n  f(exit: Exit.Exit<Done, Err>): Effect.Effect<Done2, Err2, Env>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const BothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  left: Fiber.Fiber<Either.Either<Elem, Done>, Err>,\n  right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.BothRunning\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const LeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>\n) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.LeftDone\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const RightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>\n) => MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.RightDone\n\n/**\n * Returns `true` if the specified value is a `MergeState`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isMergeState: (\n  u: unknown\n) => u is MergeState<unknown, unknown, unknown, unknown, unknown, unknown, unknown, unknown> = internal.isMergeState\n\n/**\n * Returns `true` if the specified `MergeState` is a `BothRunning`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.isBothRunning\n\n/**\n * Returns `true` if the specified `MergeState` is a `LeftDone`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.isLeftDone\n\n/**\n * Returns `true` if the specified `MergeState` is a `RightDone`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(\n  self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>\n) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2> = internal.isRightDone\n\n/**\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(\n    options: {\n      readonly onBothRunning: (\n        left: Fiber.Fiber<Either.Either<Elem, Done>, Err>,\n        right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n      ) => Z\n      readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z\n      readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z\n    }\n  ): (self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => Z\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <Env, Err, Err1, Err2, Elem, Done, Done1, Done2, Z>(\n    self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>,\n    options: {\n      readonly onBothRunning: (\n        left: Fiber.Fiber<Either.Either<Elem, Done>, Err>,\n        right: Fiber.Fiber<Either.Either<Elem, Done1>, Err1>\n      ) => Z\n      readonly onLeftDone: (f: (exit: Exit.Exit<Done1, Err1>) => Effect.Effect<Done2, Err2, Env>) => Z\n      readonly onRightDone: (f: (exit: Exit.Exit<Done, Err>) => Effect.Effect<Done2, Err2, Env>) => Z\n    }\n  ): Z\n} = internal.match\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/channel/mergeStrategy.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MergeStrategyTypeId: unique symbol = internal.MergeStrategyTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MergeStrategyTypeId = typeof MergeStrategyTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type MergeStrategy = BackPressure | BufferSliding\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MergeStrategy {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [MergeStrategyTypeId]: MergeStrategyTypeId\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface BackPressure extends MergeStrategy.Proto {\n  readonly _tag: \"BackPressure\"\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface BufferSliding extends MergeStrategy.Proto {\n  readonly _tag: \"BufferSliding\"\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const BackPressure: (_: void) => MergeStrategy = internal.BackPressure\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const BufferSliding: (_: void) => MergeStrategy = internal.BufferSliding\n\n/**\n * Returns `true` if the specified value is a `MergeStrategy`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isMergeStrategy: (u: unknown) => u is MergeStrategy = internal.isMergeStrategy\n\n/**\n * Returns `true` if the specified `MergeStrategy` is a `BackPressure`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isBackPressure: (self: MergeStrategy) => self is BackPressure = internal.isBackPressure\n\n/**\n * Returns `true` if the specified `MergeStrategy` is a `BufferSliding`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isBufferSliding: (self: MergeStrategy) => self is BufferSliding = internal.isBufferSliding\n\n/**\n * Folds an `MergeStrategy` into a value of type `A`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds an `MergeStrategy` into a value of type `A`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   options: {\n     readonly onBackPressure: () => A\n     readonly onBufferSliding: () => A\n   }\n  ): (self: MergeStrategy) => A\n  /**\n   * Folds an `MergeStrategy` into a value of type `A`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(\n   self: MergeStrategy,\n   options: {\n     readonly onBackPressure: () => A\n     readonly onBufferSliding: () => A\n   }\n  ): A\n} = internal.match\n", "/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as internal from \"./internal/metric.js\"\nimport type * as MetricBoundaries from \"./MetricBoundaries.js\"\nimport type * as MetricKey from \"./MetricKey.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as MetricLabel from \"./MetricLabel.js\"\nimport type * as MetricPair from \"./MetricPair.js\"\nimport type * as MetricRegistry from \"./MetricRegistry.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricTypeId: unique symbol = internal.MetricTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricTypeId = typeof MetricTypeId\n\n/**\n * A `Metric<Type, In, Out>` represents a concurrent metric which accepts\n * updates of type `In` and are aggregated to a stateful value of type `Out`.\n *\n * For example, a counter metric would have type `Metric<number, number>`,\n * representing the fact that the metric can be updated with numbers (the amount\n * to increment or decrement the counter by), and the state of the counter is a\n * number.\n *\n * There are five primitive metric types supported by Effect:\n *\n *   - Counters\n *   - Frequencies\n *   - Gauges\n *   - Histograms\n *   - Summaries\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {\n  /**\n   * The type of the underlying primitive metric. For example, this could be\n   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.\n   */\n  readonly keyType: Type\n  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out\n  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void\n  register(): this\n  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricApply {\n  <Type, In, Out>(\n    keyType: Type,\n    unsafeUpdate: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void,\n    unsafeValue: (extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => Out,\n    unsafeModify: (input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>) => void\n  ): Metric<Type, In, Out>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Metric {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Counter<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Counter<In>, In, MetricState.MetricState.Counter<In>>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Gauge<In extends number | bigint>\n    extends Metric<MetricKeyType.MetricKeyType.Gauge<In>, In, MetricState.MetricState.Gauge<In>>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Frequency<In>\n    extends Metric<MetricKeyType.MetricKeyType.Frequency, In, MetricState.MetricState.Frequency>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Histogram<In>\n    extends Metric<MetricKeyType.MetricKeyType.Histogram, In, MetricState.MetricState.Histogram>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Summary<In>\n    extends Metric<MetricKeyType.MetricKeyType.Summary, In, MetricState.MetricState.Summary>\n  {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out Type, in In, out Out> {\n    readonly [MetricTypeId]: {\n      readonly _Type: Types.Invariant<Type>\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category globals\n */\nexport const globalMetricRegistry: MetricRegistry.MetricRegistry = internal.globalMetricRegistry\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: MetricApply = internal.make\n\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of the specified new type, which must be transformable to the input type of\n * this metric.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapInput: {\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of the specified new type, which must be transformable to the input type of\n   * this metric.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of the specified new type, which must be transformable to the input type of\n   * this metric.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>\n} = internal.mapInput\n\n/**\n * Represents a Counter metric that tracks cumulative numerical values over time.\n * Counters can be incremented and decremented and provide a running total of changes.\n *\n * **Options**\n *\n * - description - A description of the counter.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberCounter = Metric.counter(\"count\", {\n *   description: \"A number counter\"\n * });\n *\n * const bigintCounter = Metric.counter(\"count\", {\n *   description: \"A bigint counter\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: {\n  /**\n   * Represents a Counter metric that tracks cumulative numerical values over time.\n   * Counters can be incremented and decremented and provide a running total of changes.\n   *\n   * **Options**\n   *\n   * - description - A description of the counter.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberCounter = Metric.counter(\"count\", {\n   *   description: \"A number counter\"\n   * });\n   *\n   * const bigintCounter = Metric.counter(\"count\", {\n   *   description: \"A bigint counter\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n      readonly incremental?: boolean | undefined\n    }\n  ): Metric.Counter<number>\n  /**\n   * Represents a Counter metric that tracks cumulative numerical values over time.\n   * Counters can be incremented and decremented and provide a running total of changes.\n   *\n   * **Options**\n   *\n   * - description - A description of the counter.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   * - incremental - Set to 'true' for a counter that only increases. With this configuration, Effect ensures that non-incremental updates have no impact on the counter, making it exclusively suitable for counting upwards.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberCounter = Metric.counter(\"count\", {\n   *   description: \"A number counter\"\n   * });\n   *\n   * const bigintCounter = Metric.counter(\"count\", {\n   *   description: \"A bigint counter\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n      readonly incremental?: boolean | undefined\n    }\n  ): Metric.Counter<bigint>\n} = internal.counter\n\n/**\n * Creates a Frequency metric to count occurrences of events.\n * Frequency metrics are used to count the number of times specific events or incidents occur.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const errorFrequency = Metric.frequency(\"error_frequency\", {\n *    description: \"Counts the occurrences of errors.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (\n  name: string,\n  options?:\n    | { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined }\n    | undefined\n) => Metric.Frequency<string> = internal.frequency\n\n/**\n * Returns a new metric that is powered by this one, but which accepts updates\n * of any type, and translates them to updates with the specified constant\n * update value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const withConstantInput: {\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of any type, and translates them to updates with the specified constant\n   * update value.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, unknown, Out>\n  /**\n   * Returns a new metric that is powered by this one, but which accepts updates\n   * of any type, and translates them to updates with the specified constant\n   * update value.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Metric<Type, unknown, Out>\n} = internal.withConstantInput\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const fromMetricKey: <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  key: MetricKey.MetricKey<Type>\n) => Metric<Type, MetricKeyType.MetricKeyType.InType<Type>, MetricKeyType.MetricKeyType.OutType<Type>> =\n  internal.fromMetricKey\n\n/**\n * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n *\n * **Options**\n *\n * - description - A description of the gauge metric.\n * - bigint - Indicates if the counter uses 'bigint' data type.\n *\n * @example\n * ```ts\n * import { Metric } from \"effect\"\n *\n * const numberGauge = Metric.gauge(\"memory_usage\", {\n *   description: \"A gauge for memory usage\"\n * });\n *\n * const bigintGauge = Metric.gauge(\"cpu_load\", {\n *   description: \"A gauge for CPU load\",\n *   bigint: true\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n   * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n   *\n   * **Options**\n   *\n   * - description - A description of the gauge metric.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberGauge = Metric.gauge(\"memory_usage\", {\n   *   description: \"A gauge for memory usage\"\n   * });\n   *\n   * const bigintGauge = Metric.gauge(\"cpu_load\", {\n   *   description: \"A gauge for CPU load\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n    }\n  ): Metric.Gauge<number>\n  /**\n   * Represents a Gauge metric that tracks and reports a single numerical value at a specific moment.\n   * Gauges are suitable for metrics that represent instantaneous values, such as memory usage or CPU load.\n   *\n   * **Options**\n   *\n   * - description - A description of the gauge metric.\n   * - bigint - Indicates if the counter uses 'bigint' data type.\n   *\n   * @example\n   * ```ts\n   * import { Metric } from \"effect\"\n   *\n   * const numberGauge = Metric.gauge(\"memory_usage\", {\n   *   description: \"A gauge for memory usage\"\n   * });\n   *\n   * const bigintGauge = Metric.gauge(\"cpu_load\", {\n   *   description: \"A gauge for CPU load\",\n   *   bigint: true\n   * });\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n    }\n  ): Metric.Gauge<bigint>\n} = internal.gauge\n\n/**\n * Represents a Histogram metric that records observations in specified value boundaries.\n * Histogram metrics are useful for measuring the distribution of values within a range.\n *\n * @example\n * ```ts\n * import { Metric, MetricBoundaries } from \"effect\"\n *\n * const latencyHistogram = Metric.histogram(\"latency_histogram\",\n *   MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),\n *   \"Measures the distribution of request latency.\"\n * );\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (\n  name: string,\n  boundaries: MetricBoundaries.MetricBoundaries,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram> = internal.histogram\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const increment: (\n  self: Metric.Counter<number> | Metric.Counter<bigint> | Metric.Gauge<number> | Metric.Gauge<bigint>\n) => Effect.Effect<void> = internal.increment\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const incrementBy: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (amount: number): (self: Metric.Counter<number> | Metric.Counter<number>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (amount: bigint): (self: Metric.Counter<bigint> | Metric.Gauge<bigint>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (self: Metric.Counter<number> | Metric.Gauge<number>, amount: number): Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  (self: Metric.Counter<bigint> | Metric.Gauge<bigint>, amount: bigint): Effect.Effect<void>\n} = internal.incrementBy\n\n/**\n * Returns a new metric that is powered by this one, but which outputs a new\n * state type, determined by transforming the state type of this metric by the\n * specified function.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Returns a new metric that is powered by this one, but which outputs a new\n   * state type, determined by transforming the state type of this metric by the\n   * specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>\n  /**\n   * Returns a new metric that is powered by this one, but which outputs a new\n   * state type, determined by transforming the state type of this metric by the\n   * specified function.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>\n} = internal.map\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const mapType: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, Type2>(f: (type: Type) => Type2): <In, Out>(self: Metric<Type, In, Out>) => Metric<Type2, In, Out>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <Type, In, Out, Type2>(self: Metric<Type, In, Out>, f: (type: Type) => Type2): Metric<Type2, In, Out>\n} = internal.mapType\n\n/**\n * Modifies the metric with the specified update message. For example, if the\n * metric were a gauge, the update would increment the method by the provided\n * amount.\n *\n * @since 3.6.5\n * @category utils\n */\nexport const modify: {\n  /**\n   * Modifies the metric with the specified update message. For example, if the\n   * metric were a gauge, the update would increment the method by the provided\n   * amount.\n   *\n   * @since 3.6.5\n   * @category utils\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>\n  /**\n   * Modifies the metric with the specified update message. For example, if the\n   * metric were a gauge, the update would increment the method by the provided\n   * amount.\n   *\n   * @since 3.6.5\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category aspects\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (value: number): (self: Metric.Gauge<number>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (value: bigint): (self: Metric.Gauge<bigint>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (self: Metric.Gauge<number>, value: number): Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category aspects\n   */\n  (self: Metric.Gauge<bigint>, value: bigint): Effect.Effect<void>\n} = internal.set\n\n/**\n * Captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>> = internal.snapshot\n\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <Out>(out: Out) => Metric<void, unknown, Out> = internal.succeed\n\n/**\n * Creates a metric that ignores input and produces constant output.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out> = internal.sync\n\n/**\n * Creates a Summary metric that records observations and calculates quantiles.\n * Summary metrics provide statistical information about a set of values, including quantiles.\n *\n * **Options**\n *\n * - name - The name of the Summary metric.\n * - maxAge - The maximum age of observations to retain.\n * - maxSize - The maximum number of observations to keep.\n * - error - The error percentage when calculating quantiles.\n * - quantiles - An `Chunk` of quantiles to calculate (e.g., [0.5, 0.9]).\n * - description - An optional description of the Summary metric.\n *\n * @example\n * ```ts\n * import { Metric, Chunk } from \"effect\"\n *\n * const responseTimesSummary = Metric.summary({\n *   name: \"response_times_summary\",\n *   maxAge: \"60 seconds\", // Retain observations for 60 seconds.\n *   maxSize: 1000, // Keep a maximum of 1000 observations.\n *   error: 0.01, // Allow a 1% error when calculating quantiles.\n *   quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.\n *   description: \"Measures the distribution of response times.\"\n * });\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n) => Metric.Summary<number> = internal.summary\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summaryTimestamp: (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n) => Metric.Summary<readonly [value: number, timestamp: number]> // readonly because contravariant\n = internal.summaryTimestamp\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const tagged: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>\n} = internal.tagged\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * dynamic tags are added based on the update values. Note that the metric\n * returned by this method does not return any useful information, due to the\n * dynamic nature of the added tags.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabelsInput: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * dynamic tags are added based on the update values. Note that the metric\n   * returned by this method does not return any useful information, due to the\n   * dynamic nature of the added tags.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * dynamic tags are added based on the update values. Note that the metric\n   * returned by this method does not return any useful information, due to the\n   * dynamic nature of the added tags.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(\n    self: Metric<Type, In, Out>,\n    f: (input: In) => Iterable<MetricLabel.MetricLabel>\n  ): Metric<Type, In, void>\n} = internal.taggedWithLabelsInput\n\n/**\n * Returns a new metric, which is identical in every way to this one, except\n * the specified tags have been added to the tags of this metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const taggedWithLabels: {\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>\n  /**\n   * Returns a new metric, which is identical in every way to this one, except\n   * the specified tags have been added to the tags of this metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): Metric<Type, In, Out>\n} = internal.taggedWithLabels\n\n/**\n * Creates a timer metric, based on a histogram, which keeps track of\n * durations in milliseconds. The unit of time will automatically be added to\n * the metric as a tag (i.e. `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timer: (\n  name: string,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram> =\n  internal.timer\n\n/**\n * Creates a timer metric, based on a histogram created from the provided\n * boundaries, which keeps track of durations in milliseconds. The unit of time\n * will automatically be added to the metric as a tag (i.e.\n * `\"time_unit: milliseconds\"`).\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const timerWithBoundaries: (\n  name: string,\n  boundaries: ReadonlyArray<number>,\n  description?: string\n) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram> =\n  internal.timerWithBoundaries\n\n/**\n * Returns an aspect that will update this metric with the specified constant\n * value every time the aspect is applied to an effect, regardless of whether\n * that effect fails or succeeds.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackAll: {\n  /**\n   * Returns an aspect that will update this metric with the specified constant\n   * value every time the aspect is applied to an effect, regardless of whether\n   * that effect fails or succeeds.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the specified constant\n   * value every time the aspect is applied to an effect, regardless of whether\n   * that effect fails or succeeds.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n} = internal.trackAll\n\n/**\n * Returns an aspect that will update this metric with the defects of the\n * effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefect: {\n  /**\n   * Returns an aspect that will update this metric with the defects of the\n   * effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the defects of the\n   * effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>\n} = internal.trackDefect\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the defect throwables of the effects that the\n * aspect is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDefectWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the defect throwables of the effects that the\n   * aspect is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the defect throwables of the effects that the\n   * aspect is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (defect: unknown) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackDefectWith\n\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, the input type of the metric\n * must be `Duration`.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDuration: {\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, the input type of the metric\n   * must be `Duration`.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, the input type of the metric\n   * must be `Duration`.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>\n} = internal.trackDuration\n\n/**\n * Returns an aspect that will update this metric with the duration that the\n * effect takes to execute. To call this method, you must supply a function\n * that can convert the `Duration` to the input type of this metric.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackDurationWith: {\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, you must supply a function\n   * that can convert the `Duration` to the input type of this metric.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the duration that the\n   * effect takes to execute. To call this method, you must supply a function\n   * that can convert the `Duration` to the input type of this metric.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E, R, Type, In, Out>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (duration: Duration.Duration) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackDurationWith\n\n/**\n * Returns an aspect that will update this metric with the failure value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackError: {\n  /**\n   * Returns an aspect that will update this metric with the failure value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the failure value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>\n} = internal.trackError\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the error value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackErrorWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the error value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the error value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A, E extends In2, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (error: In2) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackErrorWith\n\n/**\n * Returns an aspect that will update this metric with the success value of\n * the effects that it is applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccess: {\n  /**\n   * Returns an aspect that will update this metric with the success value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out>(metric: Metric<Type, In, Out>): <A extends In, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the success value of\n   * the effects that it is applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A extends In, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>\n} = internal.trackSuccess\n\n/**\n * Returns an aspect that will update this metric with the result of applying\n * the specified function to the success value of the effects that the aspect is\n * applied to.\n *\n * @since 2.0.0\n * @category aspects\n */\nexport const trackSuccessWith: {\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the success value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (value: In2) => In): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Returns an aspect that will update this metric with the result of applying\n   * the specified function to the success value of the effects that the aspect is\n   * applied to.\n   *\n   * @since 2.0.0\n   * @category aspects\n   */\n  <A extends In2, E, R, Type, In, Out, In2>(\n    self: Effect.Effect<A, E, R>,\n    metric: Metric<Type, In, Out>,\n    f: (value: In2) => In\n  ): Effect.Effect<A, E, R>\n} = internal.trackSuccessWith\n\n/**\n * Updates the metric with the specified update message. For example, if the\n * metric were a counter, the update would increment the method by the\n * provided amount.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * Updates the metric with the specified update message. For example, if the\n   * metric were a counter, the update would increment the method by the\n   * provided amount.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>\n  /**\n   * Updates the metric with the specified update message. For example, if the\n   * metric were a counter, the update would increment the method by the\n   * provided amount.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>\n} = internal.update\n\n/**\n * Retrieves a snapshot of the value of the metric at this moment in time.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out> = internal.value\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const withNow: <Type, In, Out>(self: Metric<Type, readonly [In, number], Out>) => Metric<Type, In, Out> =\n  internal.withNow\n\n/**\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Type2, In2, Out2>(that: Metric<Type2, In2, Out2>): <Type, In, Out>(\n    self: Metric<Type, In, Out>\n  ) => Metric<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    [Out, Out2]\n  >\n  /**\n   * @since 2.0.0\n   * @category zipping\n   */\n  <Type, In, Out, Type2, In2, Out2>(self: Metric<Type, In, Out>, that: Metric<Type2, In2, Out2>): Metric<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    [Out, Out2]\n  >\n} = internal.zip\n\n/**\n * Unsafely captures a snapshot of all metrics recorded by the application.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped> = internal.unsafeSnapshot\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberStarted: Metric.Counter<number> = fiberRuntime.fiberStarted\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberSuccesses: Metric.Counter<number> = fiberRuntime.fiberSuccesses\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberFailures: Metric.Counter<number> = fiberRuntime.fiberFailures\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberLifetimes: Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram> =\n  fiberRuntime.fiberLifetimes\n\n/**\n * @since 2.0.0\n * @category metrics\n */\nexport const fiberActive: Metric.Counter<number> = fiberRuntime.fiberActive\n", "/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/boundaries.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricBoundariesTypeId: unique symbol = internal.MetricBoundariesTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricBoundariesTypeId = typeof MetricBoundariesTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricBoundaries extends Equal.Equal, Pipeable {\n  readonly [MetricBoundariesTypeId]: MetricBoundariesTypeId\n  readonly values: ReadonlyArray<number>\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricBoundaries: (u: unknown) => u is MetricBoundaries = internal.isMetricBoundaries\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: (iterable: Iterable<number>) => MetricBoundaries = internal.fromIterable\n\n/**\n * A helper method to create histogram bucket boundaries for a histogram\n * with linear increasing values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const linear: (\n  options: {\n    readonly start: number\n    readonly width: number\n    readonly count: number\n  }\n) => MetricBoundaries = internal.linear\n\n/**\n * A helper method to create histogram bucket boundaries for a histogram\n * with exponentially increasing values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const exponential: (\n  options: {\n    readonly start: number\n    readonly factor: number\n    readonly count: number\n  }\n) => MetricBoundaries = internal.exponential\n", "/**\n * @since 2.0.0\n */\nimport type { LazyArg } from \"./Function.js\"\nimport * as internal from \"./internal/metric/hook.js\"\nimport type * as MetricKey from \"./MetricKey.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricHookTypeId: unique symbol = internal.MetricHookTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricHookTypeId = typeof MetricHookTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricHook<in In, out Out> extends MetricHook.Variance<In, Out>, Pipeable {\n  get(): Out\n  update(input: In): void\n  modify(input: In): void\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricHook {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Root = MetricHook<any, MetricState.MetricState.Untyped>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Untyped = MetricHook<any, any>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Counter<A extends (number | bigint)> = MetricHook<A, MetricState.MetricState.Counter<A>>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Gauge<A extends (number | bigint)> = MetricHook<A, MetricState.MetricState.Gauge<A>>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Frequency = MetricHook<string, MetricState.MetricState.Frequency>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Histogram = MetricHook<number, MetricState.MetricState.Histogram>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Summary = MetricHook<readonly [number, number], MetricState.MetricState.Summary>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in In, out Out> {\n    readonly [MetricHookTypeId]: {\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <In, Out>(options: {\n  readonly get: LazyArg<Out>\n  readonly update: (input: In) => void\n  readonly modify: (input: In) => void\n}) => MetricHook<In, Out> = internal.make\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: <A extends (number | bigint)>(key: MetricKey.MetricKey.Counter<A>) => MetricHook.Counter<A> =\n  internal.counter\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (_key: MetricKey.MetricKey.Frequency) => MetricHook.Frequency = internal.frequency\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (key: MetricKey.MetricKey.Gauge<number>, startAt: number): MetricHook.Gauge<number>\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (key: MetricKey.MetricKey.Gauge<bigint>, startAt: bigint): MetricHook.Gauge<bigint>\n} = internal.gauge\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (key: MetricKey.MetricKey.Histogram) => MetricHook.Histogram = internal.histogram\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (key: MetricKey.MetricKey.Summary) => MetricHook.Summary = internal.summary\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const onUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>\n} = internal.onUpdate\n\n/**\n * @since 3.6.5\n * @category utils\n */\nexport const onModify: {\n  /**\n   * @since 3.6.5\n   * @category utils\n   */\n  <In, Out>(f: (input: In) => void): (self: MetricHook<In, Out>) => MetricHook<In, Out>\n  /**\n   * @since 3.6.5\n   * @category utils\n   */\n  <In, Out>(self: MetricHook<In, Out>, f: (input: In) => void): MetricHook<In, Out>\n} = internal.onModify\n", "/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/key.js\"\nimport type * as MetricBoundaries from \"./MetricBoundaries.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as MetricLabel from \"./MetricLabel.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricKeyTypeId: unique symbol = internal.MetricKeyTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricKeyTypeId = typeof MetricKeyTypeId\n\n/**\n * A `MetricKey` is a unique key associated with each metric. The key is based\n * on a combination of the metric type, the name and tags associated with the\n * metric, an optional description of the key, and any other information to\n * describe a metric, such as the boundaries of a histogram. In this way, it is\n * impossible to ever create different metrics with conflicting keys.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable\n{\n  readonly name: string\n  readonly keyType: Type\n  readonly description: Option.Option<string>\n  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricKey {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Untyped = MetricKey<any>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Counter<A extends (number | bigint)> = MetricKey<MetricKeyType.MetricKeyType.Counter<A>>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Gauge<A extends (number | bigint)> = MetricKey<MetricKeyType.MetricKeyType.Gauge<A>>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Frequency = MetricKey<MetricKeyType.MetricKeyType.Frequency>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Histogram = MetricKey<MetricKeyType.MetricKeyType.Histogram>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Summary = MetricKey<MetricKeyType.MetricKeyType.Summary>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out Type> {\n    readonly [MetricKeyTypeId]: {\n      _Type: Types.Covariant<Type>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricKey: (u: unknown) => u is MetricKey<MetricKeyType.MetricKeyType<unknown, unknown>> =\n  internal.isMetricKey\n\n/**\n * Creates a metric key for a counter, with the specified name.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: {\n  /**\n   * Creates a metric key for a counter, with the specified name.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n      readonly incremental?: boolean | undefined\n    }\n  ): MetricKey.Counter<number>\n  /**\n   * Creates a metric key for a counter, with the specified name.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n      readonly incremental?: boolean | undefined\n    }\n  ): MetricKey.Counter<bigint>\n} = internal.counter\n\n/**\n * Creates a metric key for a categorical frequency table, with the specified\n * name.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (\n  name: string,\n  options?:\n    | {\n      readonly description?: string | undefined\n      readonly preregisteredWords?: ReadonlyArray<string> | undefined\n    }\n    | undefined\n) => MetricKey.Frequency = internal.frequency\n\n/**\n * Creates a metric key for a gauge, with the specified name.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * Creates a metric key for a gauge, with the specified name.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options?: {\n      readonly description?: string | undefined\n      readonly bigint?: false | undefined\n    }\n  ): MetricKey.Gauge<number>\n  /**\n   * Creates a metric key for a gauge, with the specified name.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (\n    name: string,\n    options: {\n      readonly description?: string | undefined\n      readonly bigint: true\n    }\n  ): MetricKey.Gauge<bigint>\n} = internal.gauge\n\n/**\n * Creates a metric key for a histogram, with the specified name and boundaries.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (\n  name: string,\n  boundaries: MetricBoundaries.MetricBoundaries,\n  description?: string\n) => MetricKey.Histogram = internal.histogram\n\n/**\n * Creates a metric key for a summary, with the specified name, maxAge,\n * maxSize, error, and quantiles.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly name: string\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n    readonly description?: string | undefined\n  }\n) => MetricKey.Summary = internal.summary\n\n/**\n * Returns a new `MetricKey` with the specified tag appended.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const tagged: {\n  /**\n   * Returns a new `MetricKey` with the specified tag appended.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>\n  /**\n   * Returns a new `MetricKey` with the specified tag appended.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>\n} = internal.tagged\n\n/**\n * Returns a new `MetricKey` with the specified tags appended.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const taggedWithLabels: {\n  /**\n   * Returns a new `MetricKey` with the specified tags appended.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>\n  /**\n   * Returns a new `MetricKey` with the specified tags appended.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>\n} = internal.taggedWithLabels\n", "/**\n * @since 2.0.0\n */\nimport type * as Duration from \"./Duration.js\"\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/keyType.js\"\nimport type * as MetricBoundaries from \"./MetricBoundaries.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricKeyTypeTypeId: unique symbol = internal.MetricKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricKeyTypeTypeId = typeof MetricKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const CounterKeyTypeTypeId: unique symbol = internal.CounterKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type CounterKeyTypeTypeId = typeof CounterKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FrequencyKeyTypeTypeId: unique symbol = internal.FrequencyKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FrequencyKeyTypeTypeId = typeof FrequencyKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const GaugeKeyTypeTypeId: unique symbol = internal.GaugeKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type GaugeKeyTypeTypeId = typeof GaugeKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const HistogramKeyTypeTypeId: unique symbol = internal.HistogramKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type HistogramKeyTypeTypeId = typeof HistogramKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SummaryKeyTypeTypeId: unique symbol = internal.SummaryKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SummaryKeyTypeTypeId = typeof SummaryKeyTypeTypeId\n\n/**\n * @since 2.0.0\n * @category modelz\n */\nexport interface MetricKeyType<in In, out Out> extends MetricKeyType.Variance<In, Out>, Equal.Equal, Pipeable {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricKeyType {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Untyped = MetricKeyType<any, any>\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Counter<A extends (number | bigint)> = MetricKeyType<A, MetricState.MetricState.Counter<A>> & {\n    readonly [CounterKeyTypeTypeId]: CounterKeyTypeTypeId\n    readonly incremental: boolean\n    readonly bigint: boolean\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Frequency = MetricKeyType<string, MetricState.MetricState.Frequency> & {\n    readonly [FrequencyKeyTypeTypeId]: FrequencyKeyTypeTypeId\n    readonly preregisteredWords: ReadonlyArray<string>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Gauge<A extends (number | bigint)> = MetricKeyType<A, MetricState.MetricState.Gauge<A>> & {\n    readonly [GaugeKeyTypeTypeId]: GaugeKeyTypeTypeId\n    readonly bigint: boolean\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Histogram = MetricKeyType<number, MetricState.MetricState.Histogram> & {\n    readonly [HistogramKeyTypeTypeId]: HistogramKeyTypeTypeId\n    readonly boundaries: MetricBoundaries.MetricBoundaries\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type Summary = MetricKeyType<readonly [number, number], MetricState.MetricState.Summary> & {\n    readonly [SummaryKeyTypeTypeId]: SummaryKeyTypeTypeId\n    readonly maxAge: Duration.Duration\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in In, out Out> {\n    readonly [MetricKeyTypeTypeId]: {\n      readonly _In: Types.Contravariant<In>\n      readonly _Out: Types.Covariant<Out>\n    }\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type InType<Type extends MetricKeyType<any, any>> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _In: (_: infer In) => void\n      }\n    }\n  ] ? In\n    : never\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export type OutType<Type extends MetricKeyType<any, any>> = [Type] extends [\n    {\n      readonly [MetricKeyTypeTypeId]: {\n        readonly _Out: (_: never) => infer Out\n      }\n    }\n  ] ? Out\n    : never\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: <A extends number | bigint>() => MetricKeyType.Counter<A> = internal.counter\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (\n  options?: {\n    readonly preregisteredWords?: ReadonlyArray<string> | undefined\n  } | undefined\n) => MetricKeyType.Frequency = internal.frequency\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: <A extends number | bigint>() => MetricKeyType.Gauge<A> = internal.gauge\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (boundaries: MetricBoundaries.MetricBoundaries) => MetricKeyType.Histogram = internal.histogram\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly maxAge: Duration.DurationInput\n    readonly maxSize: number\n    readonly error: number\n    readonly quantiles: ReadonlyArray<number>\n  }\n) => MetricKeyType.Summary = internal.summary\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricKeyType: (u: unknown) => u is MetricKeyType<unknown, unknown> = internal.isMetricKeyType\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isCounterKey: (u: unknown) => u is MetricKeyType.Counter<number | bigint> = internal.isCounterKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isFrequencyKey: (u: unknown) => u is MetricKeyType.Frequency = internal.isFrequencyKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isGaugeKey: (u: unknown) => u is MetricKeyType.Gauge<number | bigint> = internal.isGaugeKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHistogramKey: (u: unknown) => u is MetricKeyType.Histogram = internal.isHistogramKey\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSummaryKey: (u: unknown) => u is MetricKeyType.Summary = internal.isSummaryKey\n", "/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/label.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricLabelTypeId: unique symbol = internal.MetricLabelTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricLabelTypeId = typeof MetricLabelTypeId\n\n/**\n * A `MetricLabel` represents a key value pair that allows analyzing metrics at\n * an additional level of granularity.\n *\n * For example if a metric tracks the response time of a service labels could\n * be used to create separate versions that track response times for different\n * clients.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface MetricLabel extends Equal.Equal, Pipeable {\n  readonly [MetricLabelTypeId]: MetricLabelTypeId\n  readonly key: string\n  readonly value: string\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (key: string, value: string) => MetricLabel = internal.make\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricLabel: (u: unknown) => u is MetricLabel = internal.isMetricLabel\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/metric/pair.js\"\nimport type * as MetricKey from \"./MetricKey.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as MetricState from \"./MetricState.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricPairTypeId: unique symbol = internal.MetricPairTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricPairTypeId = typeof MetricPairTypeId\n\n/**\n * @since 2.0.0\n * @category model\n */\nexport interface MetricPair<out Type extends MetricKeyType.MetricKeyType<any, any>>\n  extends MetricPair.Variance<Type>, Pipeable\n{\n  readonly metricKey: MetricKey.MetricKey<Type>\n  readonly metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricPair {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Untyped extends MetricPair<MetricKeyType.MetricKeyType<any, any>> {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out Type extends MetricKeyType.MetricKeyType<any, any>> {\n    readonly [MetricPairTypeId]: {\n      readonly _Type: Types.Covariant<Type>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  metricKey: MetricKey.MetricKey<Type>,\n  metricState: MetricState.MetricState<MetricKeyType.MetricKeyType.OutType<Type>>\n) => MetricPair.Untyped = internal.make\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: <Type extends MetricKeyType.MetricKeyType<any, any>>(\n  metricKey: MetricKey.MetricKey<Type>,\n  metricState: MetricState.MetricState.Untyped\n) => MetricPair.Untyped = internal.unsafeMake\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport * as internal from \"./internal/metric/polling.js\"\nimport type * as Metric from \"./Metric.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Schedule from \"./Schedule.js\"\nimport type * as Scope from \"./Scope.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricPollingTypeId: unique symbol = internal.MetricPollingTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricPollingTypeId = typeof MetricPollingTypeId\n\n/**\n * A `MetricPolling` is a combination of a metric and an effect that polls for\n * updates to the metric.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {\n  readonly [MetricPollingTypeId]: MetricPollingTypeId\n  /**\n   * The metric that this `MetricPolling` polls to update.\n   */\n  readonly metric: Metric.Metric<Type, In, Out>\n  /**\n   * An effect that polls a value that may be fed to the metric.\n   */\n  readonly poll: Effect.Effect<In, E, R>\n}\n\n/**\n * Constructs a new polling metric from a metric and poll effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Type, In, Out, R, E>(\n  metric: Metric.Metric<Type, In, Out>,\n  poll: Effect.Effect<In, E, R>\n) => MetricPolling<Type, In, R, E, Out> = internal.make\n\n/**\n * Collects all of the polling metrics into a single polling metric, which\n * polls for, updates, and produces the outputs of all individual metrics.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const collectAll: <R, E, Out>(\n  iterable: Iterable<MetricPolling<any, any, R, E, Out>>\n) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>> = internal.collectAll\n\n/**\n * Returns an effect that will launch the polling metric in a background\n * fiber, using the specified schedule.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const launch: {\n  /**\n   * Returns an effect that will launch the polling metric in a background\n   * fiber, using the specified schedule.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>): <Type, In, R, E, Out>(\n    self: MetricPolling<Type, In, R, E, Out>\n  ) => Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>\n  /**\n   * Returns an effect that will launch the polling metric in a background\n   * fiber, using the specified schedule.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, R, E, Out, A2, R2>(\n    self: MetricPolling<Type, In, R, E, Out>,\n    schedule: Schedule.Schedule<A2, unknown, R2>\n  ): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>\n} = internal.launch\n\n/**\n * An effect that polls a value that may be fed to the metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R> =\n  internal.poll\n\n/**\n * An effect that polls for a value and uses the value to update the metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const pollAndUpdate: <Type, In, R, E, Out>(\n  self: MetricPolling<Type, In, R, E, Out>\n) => Effect.Effect<void, E, R> = internal.pollAndUpdate\n\n/**\n * Returns a new polling metric whose poll function will be retried with the\n * specified retry policy.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const retry: {\n  /**\n   * Returns a new polling metric whose poll function will be retried with the\n   * specified retry policy.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>\n  /**\n   * Returns a new polling metric whose poll function will be retried with the\n   * specified retry policy.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Type, In, R, E, Out, X, R2>(\n    self: MetricPolling<Type, In, R, E, Out>,\n    policy: Schedule.Schedule<X, E, R2>\n  ): MetricPolling<Type, In, R | R2, E, Out>\n} = internal.retry\n\n/**\n * Zips this polling metric with the specified polling metric.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const zip: {\n  /**\n   * Zips this polling metric with the specified polling metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): <Type, In, R, E, Out>(\n    self: MetricPolling<Type, In, R, E, Out>\n  ) => MetricPolling<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    R2 | R,\n    E2 | E,\n    [Out, Out2]\n  >\n  /**\n   * Zips this polling metric with the specified polling metric.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(\n    self: MetricPolling<Type, In, R, E, Out>,\n    that: MetricPolling<Type2, In2, R2, E2, Out2>\n  ): MetricPolling<\n    readonly [Type, Type2], // readonly because invariant\n    readonly [In, In2], // readonly because contravariant\n    R | R2,\n    E | E2,\n    [Out, Out2]\n  >\n} = internal.zip\n", "import type * as Effect from \"../../Effect.js\"\nimport type * as Fiber from \"../../Fiber.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport type * as Metric from \"../../Metric.js\"\nimport type * as MetricPolling from \"../../MetricPolling.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport type * as Schedule from \"../../Schedule.js\"\nimport type * as Scope from \"../../Scope.js\"\nimport * as core from \"../core.js\"\nimport * as metric from \"../metric.js\"\nimport * as schedule_ from \"../schedule.js\"\n\n/** @internal */\nconst MetricPollingSymbolKey = \"effect/MetricPolling\"\n\n/** @internal */\nexport const MetricPollingTypeId: MetricPolling.MetricPollingTypeId = Symbol.for(\n  MetricPollingSymbolKey\n) as MetricPolling.MetricPollingTypeId\n\n/** @internal */\nexport const make = <Type, In, Out, R, E>(\n  metric: Metric.Metric<Type, In, Out>,\n  poll: Effect.Effect<In, E, R>\n): MetricPolling.MetricPolling<Type, In, R, E, Out> => {\n  return {\n    [MetricPollingTypeId]: MetricPollingTypeId,\n    pipe() {\n      return pipeArguments(this, arguments)\n    },\n    metric,\n    poll\n  }\n}\n\n/** @internal */\nexport const collectAll = <R, E, Out>(\n  iterable: Iterable<MetricPolling.MetricPolling<any, any, R, E, Out>>\n): MetricPolling.MetricPolling<Array<any>, Array<any>, R, E, Array<Out>> => {\n  const metrics = Array.from(iterable)\n  return {\n    [MetricPollingTypeId]: MetricPollingTypeId,\n    pipe() {\n      return pipeArguments(this, arguments)\n    },\n    metric: metric.make(\n      Array.of<any>(void 0) as Array<any>,\n      (inputs: Array<any>, extraTags) => {\n        for (let i = 0; i < inputs.length; i++) {\n          const pollingMetric = metrics[i]!\n          const input = pipe(inputs, (x) => x[i])\n          pollingMetric.metric.unsafeUpdate(input, extraTags)\n        }\n      },\n      (extraTags) =>\n        Array.from(\n          metrics.map((pollingMetric) => pollingMetric.metric.unsafeValue(extraTags))\n        ),\n      (inputs: Array<any>, extraTags) => {\n        for (let i = 0; i < inputs.length; i++) {\n          const pollingMetric = metrics[i]!\n          const input = pipe(inputs, (x) => x[i])\n          pollingMetric.metric.unsafeModify(input, extraTags)\n        }\n      }\n    ),\n    poll: core.forEachSequential(metrics, (metric) => metric.poll)\n  }\n}\n\n/** @internal */\nexport const launch = dual<\n  <A2, R2>(\n    schedule: Schedule.Schedule<A2, unknown, R2>\n  ) => <Type, In, R, E, Out>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>\n  ) => Effect.Effect<Fiber.Fiber<A2, E>, never, R | R2 | Scope.Scope>,\n  <Type, In, R, E, Out, A2, R2>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>,\n    schedule: Schedule.Schedule<A2, unknown, R2>\n  ) => Effect.Effect<Fiber.Fiber<A2, E>, never, R | R2 | Scope.Scope>\n>(2, (self, schedule) =>\n  pipe(\n    pollAndUpdate(self),\n    core.zipRight(metric.value(self.metric)),\n    schedule_.scheduleForked(schedule)\n  ))\n\n/** @internal */\nexport const poll = <Type, In, R, E, Out>(\n  self: MetricPolling.MetricPolling<Type, In, R, E, Out>\n): Effect.Effect<In, E, R> => self.poll\n\n/** @internal */\nexport const pollAndUpdate = <Type, In, R, E, Out>(\n  self: MetricPolling.MetricPolling<Type, In, R, E, Out>\n): Effect.Effect<void, E, R> => core.flatMap(self.poll, (value) => metric.update(self.metric, value))\n\n/** @internal */\nexport const retry = dual<\n  <X, E, R2>(\n    policy: Schedule.Schedule<X, E, R2>\n  ) => <Type, In, R, Out>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>\n  ) => MetricPolling.MetricPolling<Type, In, R | R2, E, Out>,\n  <Type, In, R, E, Out, X, R2>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>,\n    policy: Schedule.Schedule<X, E, R2>\n  ) => MetricPolling.MetricPolling<Type, In, R | R2, E, Out>\n>(2, (self, policy) => ({\n  [MetricPollingTypeId]: MetricPollingTypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  metric: self.metric,\n  poll: schedule_.retry_Effect(self.poll, policy)\n}))\n\n/** @internal */\nexport const zip = dual<\n  <Type2, In2, R2, E2, Out2>(\n    that: MetricPolling.MetricPolling<Type2, In2, R2, E2, Out2>\n  ) => <Type, In, R, E, Out>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>\n  ) => MetricPolling.MetricPolling<\n    readonly [Type, Type2],\n    readonly [In, In2],\n    R | R2,\n    E | E2,\n    [Out, Out2]\n  >,\n  <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(\n    self: MetricPolling.MetricPolling<Type, In, R, E, Out>,\n    that: MetricPolling.MetricPolling<Type2, In2, R2, E2, Out2>\n  ) => MetricPolling.MetricPolling<\n    readonly [Type, Type2],\n    readonly [In, In2],\n    R | R2,\n    E | E2,\n    [Out, Out2]\n  >\n>(2, (self, that) => ({\n  [MetricPollingTypeId]: MetricPollingTypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  metric: pipe(self.metric, metric.zip(that.metric)),\n  poll: core.zip(self.poll, that.poll)\n}))\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/metric/registry.js\"\nimport type * as MetricHook from \"./MetricHook.js\"\nimport type * as MetricKey from \"./MetricKey.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as MetricPair from \"./MetricPair.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricRegistryTypeId: unique symbol = internal.MetricRegistryTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricRegistryTypeId = typeof MetricRegistryTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MetricRegistry {\n  readonly [MetricRegistryTypeId]: MetricRegistryTypeId\n  snapshot(): Array<MetricPair.MetricPair.Untyped>\n  get<Type extends MetricKeyType.MetricKeyType<any, any>>(\n    key: MetricKey.MetricKey<Type>\n  ): MetricHook.MetricHook<\n    MetricKeyType.MetricKeyType.InType<typeof key[\"keyType\"]>,\n    MetricKeyType.MetricKeyType.OutType<typeof key[\"keyType\"]>\n  >\n  getCounter<A extends (number | bigint)>(\n    key: MetricKey.MetricKey.Counter<A>\n  ): MetricHook.MetricHook.Counter<A>\n  getFrequency(key: MetricKey.MetricKey.Frequency): MetricHook.MetricHook.Frequency\n  getGauge<A extends (number | bigint)>(key: MetricKey.MetricKey.Gauge<A>): MetricHook.MetricHook.Gauge<A>\n  getHistogram(key: MetricKey.MetricKey.Histogram): MetricHook.MetricHook.Histogram\n  getSummary(key: MetricKey.MetricKey.Summary): MetricHook.MetricHook.Summary\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (_: void) => MetricRegistry = internal.make\n", "/**\n * @since 2.0.0\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as internal from \"./internal/metric/state.js\"\nimport type * as MetricKeyType from \"./MetricKeyType.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const MetricStateTypeId: unique symbol = internal.MetricStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type MetricStateTypeId = typeof MetricStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const CounterStateTypeId: unique symbol = internal.CounterStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type CounterStateTypeId = typeof CounterStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const FrequencyStateTypeId: unique symbol = internal.FrequencyStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type FrequencyStateTypeId = typeof FrequencyStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const GaugeStateTypeId: unique symbol = internal.GaugeStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type GaugeStateTypeId = typeof GaugeStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const HistogramStateTypeId: unique symbol = internal.HistogramStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type HistogramStateTypeId = typeof HistogramStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SummaryStateTypeId: unique symbol = internal.SummaryStateTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SummaryStateTypeId = typeof SummaryStateTypeId\n\n/**\n * A `MetricState` describes the state of a metric. The type parameter of a\n * metric state corresponds to the type of the metric key (`MetricStateType`).\n * This phantom type parameter is used to tie keys to their expected states.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace MetricState {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Untyped extends MetricState<any> {}\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Counter<in out A extends (number | bigint)>\n    extends MetricState<MetricKeyType.MetricKeyType.Counter<A>>\n  {\n    readonly [CounterStateTypeId]: CounterStateTypeId\n    readonly count: A\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Frequency extends MetricState<MetricKeyType.MetricKeyType.Frequency> {\n    readonly [FrequencyStateTypeId]: FrequencyStateTypeId\n    readonly occurrences: ReadonlyMap<string, number>\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Gauge<in out A extends (number | bigint)> extends MetricState<MetricKeyType.MetricKeyType.Gauge<A>> {\n    readonly [GaugeStateTypeId]: GaugeStateTypeId\n    readonly value: A\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Histogram extends MetricState<MetricKeyType.MetricKeyType.Histogram> {\n    readonly [HistogramStateTypeId]: HistogramStateTypeId\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Summary extends MetricState<MetricKeyType.MetricKeyType.Summary> {\n    readonly [SummaryStateTypeId]: SummaryStateTypeId\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in A> {\n    readonly [MetricStateTypeId]: {\n      readonly _A: Types.Contravariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const counter: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: number): MetricState.Counter<number>\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: bigint): MetricState.Counter<bigint>\n} = internal.counter\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const frequency: (occurrences: ReadonlyMap<string, number>) => MetricState.Frequency = internal.frequency\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gauge: {\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: number): MetricState.Gauge<number>\n  /**\n   * @since 2.0.0\n   * @category constructors\n   */\n  (count: bigint): MetricState.Gauge<bigint>\n} = internal.gauge\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const histogram: (\n  options: {\n    readonly buckets: ReadonlyArray<readonly [number, number]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n) => MetricState.Histogram = internal.histogram\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const summary: (\n  options: {\n    readonly error: number\n    readonly quantiles: ReadonlyArray<readonly [number, Option.Option<number>]>\n    readonly count: number\n    readonly min: number\n    readonly max: number\n    readonly sum: number\n  }\n) => MetricState.Summary = internal.summary\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isMetricState: (u: unknown) => u is MetricState.Counter<number | bigint> = internal.isMetricState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isCounterState: (u: unknown) => u is MetricState.Counter<number | bigint> = internal.isCounterState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isFrequencyState: (u: unknown) => u is MetricState.Frequency = internal.isFrequencyState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isGaugeState: (u: unknown) => u is MetricState.Gauge<number | bigint> = internal.isGaugeState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isHistogramState: (u: unknown) => u is MetricState.Histogram = internal.isHistogramState\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSummaryState: (u: unknown) => u is MetricState.Summary = internal.isSummaryState\n", "/**\n * @since 2.0.0\n *\n * Enables low level framework authors to run on their own isolated effect version\n */\nimport * as internal from \"./internal/version.js\"\n\n/**\n * @since 2.0.0\n * @category version\n */\nexport const getCurrentVersion: () => string = internal.getCurrentVersion\n\n/**\n * @since 2.0.0\n * @category version\n */\nexport const setCurrentVersion: (version: string) => void = internal.setCurrentVersion\n", "/**\n * # MutableHashSet\n *\n * A mutable `MutableHashSet` provides a collection of unique values with\n * efficient lookup, insertion and removal. Unlike its immutable sibling\n * {@link module:HashSet}, a `MutableHashSet` can be modified in-place;\n * operations like add, remove, and clear directly modify the original set\n * rather than creating a new one. This mutability offers benefits like improved\n * performance in scenarios where you need to build or modify a set\n * incrementally.\n *\n * ## What Problem Does It Solve?\n *\n * `MutableHashSet` solves the problem of maintaining an unsorted collection\n * where each value appears exactly once, with fast operations for checking\n * membership and adding/removing values, in contexts where mutability is\n * preferred for performance or implementation simplicity.\n *\n * ## When to Use\n *\n * Use `MutableHashSet` when you need:\n *\n * - A collection with no duplicate values\n * - Efficient membership testing (**`O(1)`** average complexity)\n * - In-place modifications for better performance\n * - A set that will be built or modified incrementally\n * - Local mutability in otherwise immutable code\n *\n * ## Advanced Features\n *\n * MutableHashSet provides operations for:\n *\n * - Adding and removing elements with direct mutation\n * - Checking for element existence\n * - Clearing all elements at once\n * - Converting to/from other collection types\n *\n * ## Performance Characteristics\n *\n * - **Lookup** operations ({@link module:MutableHashSet.has}): **`O(1)`** average\n *   time complexity\n * - **Insertion** operations ({@link module:MutableHashSet.add}): **`O(1)`**\n *   average time complexity\n * - **Removal** operations ({@link module:MutableHashSet.remove}): **`O(1)`**\n *   average time complexity\n * - **Iteration**: **`O(n)`** where n is the size of the set\n *\n * The MutableHashSet data structure implements the following traits:\n *\n * - {@link Iterable}: allows iterating over the values in the set\n * - {@link Pipeable}: allows chaining operations with the pipe operator\n * - {@link Inspectable}: allows inspecting the contents of the set\n *\n * ## Operations Reference\n *\n * | Category     | Operation                                  | Description                         | Complexity |\n * | ------------ | ------------------------------------------ | ----------------------------------- | ---------- |\n * | constructors | {@link module:MutableHashSet.empty}        | Creates an empty MutableHashSet     | O(1)       |\n * | constructors | {@link module:MutableHashSet.fromIterable} | Creates a set from an iterable      | O(n)       |\n * | constructors | {@link module:MutableHashSet.make}         | Creates a set from multiple values  | O(n)       |\n * |              |                                            |                                     |            |\n * | elements     | {@link module:MutableHashSet.has}          | Checks if a value exists in the set | O(1) avg   |\n * | elements     | {@link module:MutableHashSet.add}          | Adds a value to the set             | O(1) avg   |\n * | elements     | {@link module:MutableHashSet.remove}       | Removes a value from the set        | O(1) avg   |\n * | elements     | {@link module:MutableHashSet.size}         | Gets the number of elements         | O(1)       |\n * | elements     | {@link module:MutableHashSet.clear}        | Removes all values from the set     | O(1)       |\n *\n * ## Notes\n *\n * ### Mutability Considerations:\n *\n * Unlike most data structures in the Effect ecosystem, `MutableHashSet` is\n * mutable. This means that operations like `add`, `remove`, and `clear` modify\n * the original set rather than creating a new one. This can lead to more\n * efficient code in some scenarios, but requires careful handling to avoid\n * unexpected side effects.\n *\n * ### When to Choose `MutableHashSet` vs {@link module:HashSet}:\n *\n * - Use `MutableHashSet` when you need to build or modify a set incrementally and\n *   performance is a priority\n * - Use `HashSet` when you want immutability guarantees and functional\n *   programming patterns\n * - Consider using {@link module:HashSet}'s bounded mutation context (via\n *   {@link module:HashSet.beginMutation}, {@link module:HashSet.endMutation}, and\n *   {@link module:HashSet.mutate} methods) when you need temporary mutability\n *   within an otherwise immutable context - this approach might be sufficient\n *   for many use cases without requiring a separate `MutableHashSet`\n * - `MutableHashSet` is often useful for local operations where the mutability is\n *   contained and doesn't leak into the broader application\n *\n * @module MutableHashSet\n * @since 2.0.0\n */\nimport * as Dual from \"./Function.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport * as MutableHashMap from \"./MutableHashMap.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/MutableHashSet\") as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface MutableHashSet<out V> extends Iterable<V>, Pipeable, Inspectable {\n  readonly [TypeId]: TypeId\n\n  /** @internal */\n  readonly keyMap: MutableHashMap.MutableHashMap<V, boolean>\n}\n\nconst MutableHashSetProto: Omit<MutableHashSet<unknown>, \"keyMap\"> = {\n  [TypeId]: TypeId,\n  [Symbol.iterator](this: MutableHashSet<unknown>): Iterator<unknown> {\n    return Array.from(this.keyMap)\n      .map(([_]) => _)[Symbol.iterator]()\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"MutableHashSet\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst fromHashMap = <V>(\n  keyMap: MutableHashMap.MutableHashMap<V, boolean>\n): MutableHashSet<V> => {\n  const set = Object.create(MutableHashSetProto)\n  set.keyMap = keyMap\n  return set\n}\n\n/**\n * Creates an empty mutable hash set.\n *\n * This function initializes and returns an empty `MutableHashSet` instance,\n * which allows for efficient storage and manipulation of unique elements.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { MutableHashSet } from \"effect\"\n *\n * type T = unknown // replace with your type\n *\n * // in places where the type can't be inferred, replace with your type\n * const set: MutableHashSet.MutableHashSet<T> = MutableHashSet.empty<T>()\n * ```\n *\n * @template K - The type of the elements to be stored in the hash set. Defaults\n *   to `never` if not specified.\n * @returns A new mutable instance of `MutableHashSet` containing no elements\n *   for the specified type `K`.\n * @see Other `MutableHashSet` constructors are {@link module:MutableHashSet.make} {@link module:MutableHashSet.fromIterable}\n */\nexport const empty = <K = never>(): MutableHashSet<K> => fromHashMap(MutableHashMap.empty())\n\n/**\n * Creates a new `MutableHashSet` from an iterable collection of values.\n * Duplicate values are omitted.\n *\n * Time complexity: **`O(n)`** where n is the number of elements in the iterable\n *\n * Creating a `MutableHashSet` from an {@link Array}\n *\n * ```ts\n * import { MutableHashSet } from \"effect\"\n *\n * const array: Iterable<number> = [1, 2, 3, 4, 5, 1, 2, 3] // Array<T> is also Iterable<T>\n * const mutableHashSet: MutableHashSet.MutableHashSet<number> =\n *   MutableHashSet.fromIterable(array)\n *\n * console.log(\n *   // MutableHashSet.MutableHashSet<T> is also an Iterable<T>\n *   Array.from(mutableHashSet)\n * ) // Output: [1, 2, 3, 4, 5]\n * ```\n *\n * Creating a `MutableHashSet` from a {@link Set}\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     // Set<string> is an Iterable<string>\n *     new Set([\"apple\", \"banana\", \"orange\", \"apple\"]),\n *     // constructs MutableHashSet from an Iterable Set\n *     MutableHashSet.fromIterable,\n *     // since MutableHashSet it is itself an Iterable, we can pass it to other functions expecting an Iterable\n *     Array.from\n *   )\n * ) // Output: [\"apple\", \"banana\", \"orange\"]\n * ```\n *\n * Creating a `MutableHashSet` from a {@link Generator}\n *\n * ```ts\n * import { MutableHashSet } from \"effect\"\n *\n * // Generator functions return iterables\n * function* fibonacci(n: number): Generator<number, void, never> {\n *   let [a, b] = [0, 1]\n *   for (let i = 0; i < n; i++) {\n *     yield a\n *     ;[a, b] = [b, a + b]\n *   }\n * }\n *\n * // Create a MutableHashSet from the first 10 Fibonacci numbers\n * const fibonacciSet = MutableHashSet.fromIterable(fibonacci(10))\n *\n * console.log(Array.from(fibonacciSet))\n * // Outputs: [0, 1, 2, 3, 5, 8, 13, 21, 34] but in unsorted order\n * ```\n *\n * Creating a `MutableHashSet` from another {@link module:MutableHashSet}\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     MutableHashSet.make(1, 2, 3, 4),\n *     MutableHashSet.fromIterable,\n *     Array.from\n *   )\n * ) // Output: [1, 2, 3, 4]\n * ```\n *\n * Creating a `MutableHashSet` from an {@link module:HashSet}\n *\n * ```ts\n * import { HashSet, MutableHashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     HashSet.make(1, 2, 3, 4), // it works also with its immutable HashSet sibling\n *     MutableHashSet.fromIterable,\n *     Array.from\n *   )\n * ) // Output: [1, 2, 3, 4]\n * ```\n *\n * Creating a `MutableHashSet` from other Effect's data structures like\n * {@link Chunk}\n *\n * ```ts\n * import { Chunk, MutableHashSet, pipe } from \"effect\"\n *\n * console.log(\n *   pipe(\n *     Chunk.make(1, 2, 3, 4), //  Chunk is also an Iterable<T>\n *     MutableHashSet.fromIterable,\n *     Array.from\n *   )\n * ) // Outputs: [1, 2, 3, 4]\n * ```\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category constructors\n * @template K - The type of elements to be stored in the resulting\n *   `MutableHashSet`.\n * @param keys - An `Iterable` collection containing the keys to be added to the\n *   `MutableHashSet`.\n * @returns A new `MutableHashSet` containing just the unique elements from the\n *   provided iterable.\n * @see Other `MutableHashSet` constructors are {@link module:MutableHashSet.empty} {@link module:MutableHashSet.make}\n */\nexport const fromIterable = <K = never>(keys: Iterable<K>): MutableHashSet<K> =>\n  fromHashMap(\n    MutableHashMap.fromIterable(Array.from(keys).map((k) => [k, true]))\n  )\n\n/**\n * Construct a new `MutableHashSet` from a variable number of values.\n *\n * Time complexity: **`O(n)`** where n is the number of elements\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category constructors\n * @example\n *\n * ```ts\n * import { Equal, Hash, MutableHashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * class Character implements Equal.Equal {\n *   readonly name: string\n *   readonly trait: string\n *\n *   constructor(name: string, trait: string) {\n *     this.name = name\n *     this.trait = trait\n *   }\n *\n *   // Define equality based on name, and trait\n *   [Equal.symbol](that: Equal.Equal): boolean {\n *     if (that instanceof Character) {\n *       return (\n *         Equal.equals(this.name, that.name) &&\n *         Equal.equals(this.trait, that.trait)\n *       )\n *     }\n *     return false\n *   }\n *\n *   // Generate a hash code based on the sum of the character's name and trait\n *   [Hash.symbol](): number {\n *     return Hash.hash(this.name + this.trait)\n *   }\n *\n *   static readonly of = (name: string, trait: string): Character => {\n *     return new Character(name, trait)\n *   }\n * }\n *\n * const mutableCharacterHashSet = MutableHashSet.make(\n *   Character.of(\"Alice\", \"Curious\"),\n *   Character.of(\"Alice\", \"Curious\"),\n *   Character.of(\"White Rabbit\", \"Always late\"),\n *   Character.of(\"Mad Hatter\", \"Tea enthusiast\")\n * )\n *\n * assert.equal(\n *   MutableHashSet.has(\n *     mutableCharacterHashSet,\n *     Character.of(\"Alice\", \"Curious\")\n *   ),\n *   true\n * )\n * assert.equal(\n *   MutableHashSet.has(\n *     mutableCharacterHashSet,\n *     Character.of(\"Fluffy\", \"Kind\")\n *   ),\n *   false\n * )\n * ```\n *\n * @see Other `MutableHashSet` constructors are {@link module:MutableHashSet.fromIterable} {@link module:MutableHashSet.empty}\n */\nexport const make = <Keys extends ReadonlyArray<unknown>>(\n  ...keys: Keys\n): MutableHashSet<Keys[number]> => fromIterable(keys)\n\n/**\n * **Checks** whether the `MutableHashSet` contains the given element, and\n * **adds** it if not.\n *\n * Time complexity: **`O(1)`** average\n *\n * **Syntax**\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n *\n * // with data-last, a.k.a. pipeable API\n * pipe(\n *   MutableHashSet.empty(),\n *   MutableHashSet.add(0),\n *   MutableHashSet.add(0)\n * )\n *\n * // or piped with the pipe function\n * MutableHashSet.empty().pipe(MutableHashSet.add(0))\n *\n * // or with data-first API\n * MutableHashSet.add(MutableHashSet.empty(), 0)\n * ```\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category elements\n * @see Other `MutableHashSet` elements are {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear} {@link module:MutableHashSet.has}\n */\nexport const add: {\n  /**\n   * `data-last` a.k.a. `pipeable` API\n   *\n   * ```ts\n   * import { MutableHashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const mutableHashSet = pipe(\n   *   MutableHashSet.empty<number>(), // MutableHashSet.MutableHashSet<number>\n   *   MutableHashSet.add(0),\n   *   MutableHashSet.add(1),\n   *   MutableHashSet.add(1),\n   *   MutableHashSet.add(2)\n   * )\n   *\n   * assert.deepStrictEqual(\n   *   Array.from(mutableHashSet), // remember that MutableHashSet is also an Iterable\n   *   Array.of(0, 1, 2)\n   * )\n   * ```\n   *\n   * @template V - The type of elements stored in the `MutableHashSet`.\n   * @param key - The key to be added to the `MutableHashSet` if not already\n   *   present.\n   * @returns A function that accepts a `MutableHashSet` and returns the\n   *   reference of the updated `MutableHashSet` including the key.\n   */\n  <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>\n\n  /**\n   * `data-first` API\n   *\n   * ```ts\n   * import { MutableHashSet } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const empty = MutableHashSet.empty<number>()\n   * const withZero = MutableHashSet.add(empty, 0)\n   * const withOne = MutableHashSet.add(withZero, 1)\n   * const withTwo = MutableHashSet.add(withOne, 2)\n   * const withTwoTwo = MutableHashSet.add(withTwo, 2)\n   *\n   * assert(Object.is(withTwoTwo, empty)) // proof that it does mutate the original set\n   *\n   * assert.deepStrictEqual(\n   *   Array.from(withTwoTwo), // remember that MutableHashSet is also an Iterable\n   *   Array.of(0, 1, 2)\n   * )\n   * ```\n   *\n   * @template V - The type of elements stored in the `MutableHashSet`.\n   * @param self - The `MutableHashSet` instance from which the key should be\n   *   added to.\n   * @param key - The key to be added to the `MutableHashSet` if not already\n   *   present.\n   * @returns The reference of the updated `MutableHashSet` including the key.\n   */\n  <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>\n} = Dual.dual<\n  <V>(key: V) => (self: MutableHashSet<V>) => MutableHashSet<V>,\n  <V>(self: MutableHashSet<V>, key: V) => MutableHashSet<V>\n>(2, (self, key) => (MutableHashMap.set(self.keyMap, key, true), self))\n\n/**\n * Checks if the specified value exists in the `MutableHashSet`.\n *\n * Time complexity: `O(1)` average\n *\n * **Syntax**\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.equal(\n *   // with `data-last`, a.k.a. `pipeable` API\n *   pipe(MutableHashSet.make(0, 1, 2), MutableHashSet.has(3)),\n *   false\n * )\n *\n * assert.equal(\n *   // or piped with the pipe function\n *   MutableHashSet.make(0, 1, 2).pipe(MutableHashSet.has(3)),\n *   false\n * )\n *\n * assert.equal(\n *   // or with `data-first` API\n *   MutableHashSet.has(MutableHashSet.make(0, 1, 2), 3),\n *   false\n * )\n * ```\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category elements\n * @see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear}\n */\nexport const has: {\n  /**\n   * `data-last` a.k.a. `pipeable` API\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { MutableHashSet, pipe } from \"effect\"\n   *\n   * const set = MutableHashSet.make(0, 1, 2)\n   *\n   * assert.equal(pipe(set, MutableHashSet.has(0)), true)\n   * assert.equal(pipe(set, MutableHashSet.has(1)), true)\n   * assert.equal(pipe(set, MutableHashSet.has(2)), true)\n   * assert.equal(pipe(set, MutableHashSet.has(3)), false)\n   * ```\n   */\n  <V>(key: V): (self: MutableHashSet<V>) => boolean\n\n  /**\n   * `data-first` API\n   *\n   * ```ts\n   * import * as assert from \"node:assert/strict\"\n   * import { MutableHashSet, pipe } from \"effect\"\n   *\n   * const set = MutableHashSet.make(0, 1, 2)\n   *\n   * assert.equal(MutableHashSet.has(set, 0), true)\n   * assert.equal(MutableHashSet.has(set, 1), true)\n   * assert.equal(MutableHashSet.has(set, 2), true)\n   * assert.equal(MutableHashSet.has(set, 3), false)\n   * ```\n   */\n  <V>(self: MutableHashSet<V>, key: V): boolean\n} = Dual.dual<\n  <V>(key: V) => (self: MutableHashSet<V>) => boolean,\n  <V>(self: MutableHashSet<V>, key: V) => boolean\n>(2, (self, key) => MutableHashMap.has(self.keyMap, key))\n\n/**\n * Removes a value from the `MutableHashSet`.\n *\n * Time complexity: **`O(1)`** average\n *\n * **Syntax**\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.equal(\n *   // with `data-last`, a.k.a. `pipeable` API\n *   pipe(\n *     MutableHashSet.make(0, 1, 2),\n *     MutableHashSet.remove(0),\n *     MutableHashSet.has(0)\n *   ),\n *   false\n * )\n *\n * assert.equal(\n *   // or piped with the pipe function\n *   MutableHashSet.make(0, 1, 2).pipe(\n *     MutableHashSet.remove(0),\n *     MutableHashSet.has(0)\n *   ),\n *   false\n * )\n *\n * assert.equal(\n *   // or with `data-first` API\n *   MutableHashSet.remove(MutableHashSet.make(0, 1, 2), 0).pipe(\n *     MutableHashSet.has(0)\n *   ),\n *   false\n * )\n * ```\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category elements\n * @see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.size} {@link module:MutableHashSet.clear}\n */\nexport const remove: {\n  /**\n   * `data-last` a.k.a. `pipeable` API\n   *\n   * ```ts\n   * import { MutableHashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const set: MutableHashSet.MutableHashSet<number> = MutableHashSet.make(\n   *   0,\n   *   1,\n   *   2\n   * )\n   * const result: MutableHashSet.MutableHashSet<number> = pipe(\n   *   set,\n   *   MutableHashSet.remove(0)\n   * )\n   *\n   * assert(Object.is(set, result)) // set and result have the same identity\n   * assert.equal(pipe(result, MutableHashSet.has(0)), false) // it has correctly removed 0\n   * assert.equal(pipe(set, MutableHashSet.has(0)), false) // another proof that we are mutating the original MutableHashSet\n   * assert.equal(pipe(result, MutableHashSet.has(1)), true)\n   * assert.equal(pipe(result, MutableHashSet.has(2)), true)\n   * ```\n   *\n   * @template V - The type of the elements in the `MutableHashSet`.\n   * @param key - The key to be removed from the `MutableHashSet`.\n   * @returns A function that takes a `MutableHashSet` as input and returns the\n   *   reference to the same `MutableHashSet` with the specified key removed.\n   */\n  <V>(key: V): (self: MutableHashSet<V>) => MutableHashSet<V>\n\n  /**\n   * `data-first` API\n   *\n   * ```ts\n   * import { MutableHashSet, pipe } from \"effect\"\n   * import assert from \"node:assert/strict\"\n   *\n   * const set = MutableHashSet.make(0, 1, 2)\n   * const result = MutableHashSet.remove(set, 0)\n   *\n   * assert(Object.is(set, result)) // set and result have the same identity\n   * assert.equal(MutableHashSet.has(result, 0), false) // it has correctly removed 0\n   * assert.equal(MutableHashSet.has(set, 0), false) // it mutates the original MutableHashSet\n   * assert.equal(MutableHashSet.has(result, 1), true)\n   * assert.equal(MutableHashSet.has(result, 2), true)\n   * ```\n   *\n   * @template V - The type of the elements in the `MutableHashSet`.\n   * @param self - The `MutableHashSet` to which the key will be removed from.\n   * @param key - The value to be removed from the `MutableHashSet` if present.\n   * @returns The reference to the updated `MutableHashSet`.\n   */\n  <V>(self: MutableHashSet<V>, key: V): MutableHashSet<V>\n} = Dual.dual<\n  <V>(key: V) => (self: MutableHashSet<V>) => MutableHashSet<V>,\n  <V>(self: MutableHashSet<V>, key: V) => MutableHashSet<V>\n>(2, (self, key) => (MutableHashMap.remove(self.keyMap, key), self))\n\n/**\n * Calculates the number of values in the `HashSet`.\n *\n * Time complexity: **`O(1)`**\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * import { MutableHashSet } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.equal(MutableHashSet.size(MutableHashSet.empty()), 0)\n *\n * assert.equal(\n *   MutableHashSet.size(MutableHashSet.make(1, 2, 2, 3, 4, 3)),\n *   4\n * )\n * ```\n *\n * @template V - The type of the elements to be stored in the `MutableHashSet`.\n * @param self - The `MutableHashSet` instance for which the size is to be\n *   determined.\n * @returns The total number of elements within the `MutableHashSet`.\n * @see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.clear}\n */\nexport const size = <V>(self: MutableHashSet<V>): number => MutableHashMap.size(self.keyMap)\n\n/**\n * Removes all values from the `MutableHashSet`.\n *\n * This function operates by delegating the clearing action to the underlying\n * key map associated with the given `MutableHashSet`. It ensures that the hash\n * set becomes empty while maintaining its existence and structure.\n *\n * @memberof MutableHashSet\n * @since 2.0.0\n * @category elements\n * @example\n *\n * ```ts\n * import { MutableHashSet, pipe } from \"effect\"\n * import assert from \"node:assert/strict\"\n *\n * assert.deepStrictEqual(\n *   pipe(\n *     MutableHashSet.make(1, 2, 3, 4),\n *     MutableHashSet.clear,\n *     MutableHashSet.size\n *   ),\n *   0\n * )\n * ```\n *\n * @param self - The `MutableHashSet` to clear.\n * @returns The same `MutableHashSet` after all elements have been removed.\n * @see Other `MutableHashSet` elements are {@link module:MutableHashSet.add} {@link module:MutableHashSet.has} {@link module:MutableHashSet.remove} {@link module:MutableHashSet.size}\n */\nexport const clear = <V>(self: MutableHashSet<V>): MutableHashSet<V> => (\n  MutableHashMap.clear(self.keyMap), self\n)\n", "/**\n * @since 2.0.0\n */\n\n/**\n * @category symbol\n * @since 2.0.0\n */\nexport declare const nonEmpty: unique symbol\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport interface NonEmptyIterable<out A> extends Iterable<A> {\n  readonly [nonEmpty]: A\n}\n\n/**\n * @category getters\n * @since 2.0.0\n */\nexport const unprepend = <A>(self: NonEmptyIterable<A>): [firstElement: A, remainingElements: Iterator<A>] => {\n  const iterator = self[Symbol.iterator]()\n  const next = iterator.next()\n  if (next.done) {\n    throw new Error(\n      \"BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  return [next.value, iterator]\n}\n", "/**\n * @since 2.0.0\n */\nimport type { LazyArg } from \"./Function.js\"\nimport { dual } from \"./Function.js\"\n\n/**\n * @category model\n * @since 2.0.0\n */\nexport type Ordering = -1 | 0 | 1\n\n/**\n * Inverts the ordering of the input `Ordering`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { reverse } from \"effect/Ordering\"\n *\n * assert.deepStrictEqual(reverse(1), -1)\n * assert.deepStrictEqual(reverse(-1), 1)\n * assert.deepStrictEqual(reverse(0), 0)\n * ```\n *\n * @since 2.0.0\n */\nexport const reverse = (o: Ordering): Ordering => (o === -1 ? 1 : o === 1 ? -1 : 0)\n\n/**\n * Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Ordering } from \"effect\"\n * import { constant } from \"effect/Function\"\n *\n * const toMessage = Ordering.match({\n *   onLessThan: constant('less than'),\n *   onEqual: constant('equal'),\n *   onGreaterThan: constant('greater than')\n * })\n *\n * assert.deepStrictEqual(toMessage(-1), \"less than\")\n * assert.deepStrictEqual(toMessage(0), \"equal\")\n * assert.deepStrictEqual(toMessage(1), \"greater than\")\n * ```\n *\n * @category pattern matching\n * @since 2.0.0\n */\nexport const match: {\n  /**\n   * Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Ordering } from \"effect\"\n   * import { constant } from \"effect/Function\"\n   *\n   * const toMessage = Ordering.match({\n   *   onLessThan: constant('less than'),\n   *   onEqual: constant('equal'),\n   *   onGreaterThan: constant('greater than')\n   * })\n   *\n   * assert.deepStrictEqual(toMessage(-1), \"less than\")\n   * assert.deepStrictEqual(toMessage(0), \"equal\")\n   * assert.deepStrictEqual(toMessage(1), \"greater than\")\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    options: {\n      readonly onLessThan: LazyArg<A>\n      readonly onEqual: LazyArg<B>\n      readonly onGreaterThan: LazyArg<C>\n    }\n  ): (self: Ordering) => A | B | C\n  /**\n   * Depending on the `Ordering` parameter given to it, returns a value produced by one of the 3 functions provided as parameters.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Ordering } from \"effect\"\n   * import { constant } from \"effect/Function\"\n   *\n   * const toMessage = Ordering.match({\n   *   onLessThan: constant('less than'),\n   *   onEqual: constant('equal'),\n   *   onGreaterThan: constant('greater than')\n   * })\n   *\n   * assert.deepStrictEqual(toMessage(-1), \"less than\")\n   * assert.deepStrictEqual(toMessage(0), \"equal\")\n   * assert.deepStrictEqual(toMessage(1), \"greater than\")\n   * ```\n   *\n   * @category pattern matching\n   * @since 2.0.0\n   */\n  <A, B, C = B>(\n    o: Ordering,\n    options: {\n      readonly onLessThan: LazyArg<A>\n      readonly onEqual: LazyArg<B>\n      readonly onGreaterThan: LazyArg<C>\n    }\n  ): A | B | C\n} = dual(2, <A, B, C = B>(\n  self: Ordering,\n  { onEqual, onGreaterThan, onLessThan }: {\n    readonly onLessThan: LazyArg<A>\n    readonly onEqual: LazyArg<B>\n    readonly onGreaterThan: LazyArg<C>\n  }\n): A | B | C => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan())\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combine: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  (that: Ordering): (self: Ordering) => Ordering\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  (self: Ordering, that: Ordering): Ordering\n} = dual(2, (self: Ordering, that: Ordering): Ordering => self !== 0 ? self : that)\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineMany: {\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  (collection: Iterable<Ordering>): (self: Ordering) => Ordering\n  /**\n   * @category combining\n   * @since 2.0.0\n   */\n  (self: Ordering, collection: Iterable<Ordering>): Ordering\n} = dual(2, (self: Ordering, collection: Iterable<Ordering>): Ordering => {\n  let ordering = self\n  if (ordering !== 0) {\n    return ordering\n  }\n  for (ordering of collection) {\n    if (ordering !== 0) {\n      return ordering\n    }\n  }\n  return ordering\n})\n\n/**\n * @category combining\n * @since 2.0.0\n */\nexport const combineAll = (collection: Iterable<Ordering>): Ordering => combineMany(0, collection)\n", "/**\n * @since 3.10.0\n */\nimport * as Arr from \"./Array.js\"\nimport * as errors_ from \"./internal/schema/errors.js\"\nimport * as util_ from \"./internal/schema/util.js\"\nimport * as Option from \"./Option.js\"\nimport * as ParseResult from \"./ParseResult.js\"\nimport type * as Schema from \"./Schema.js\"\nimport * as AST from \"./SchemaAST.js\"\n\n/**\n * @category model\n * @since 3.10.0\n */\nexport interface Pretty<To> {\n  (a: To): string\n}\n\n/**\n * @category annotations\n * @since 3.10.0\n */\nexport type PrettyAnnotation<A, TypeParameters extends ReadonlyArray<any> = readonly []> = (\n  ...pretties: { readonly [K in keyof TypeParameters]: Pretty<TypeParameters[K]> }\n) => Pretty<A>\n\n/**\n * @category prettify\n * @since 3.10.0\n */\nexport const make = <A, I, R>(schema: Schema.Schema<A, I, R>): (a: A) => string => compile(schema.ast, [])\n\nconst getPrettyAnnotation = AST.getAnnotation<PrettyAnnotation<any, any>>(AST.PrettyAnnotationId)\n\nconst getMatcher = (defaultPretty: Pretty<any>) => (ast: AST.AST): Pretty<any> =>\n  Option.match(getPrettyAnnotation(ast), {\n    onNone: () => defaultPretty,\n    onSome: (handler) => handler()\n  })\n\nconst toString = getMatcher((a) => String(a))\n\nconst stringify = getMatcher((a) => JSON.stringify(a))\n\nconst formatUnknown = getMatcher(util_.formatUnknown)\n\n/**\n * @since 3.10.0\n */\nexport const match: AST.Match<Pretty<any>> = {\n  \"Declaration\": (ast, go, path) => {\n    const annotation = getPrettyAnnotation(ast)\n    if (Option.isSome(annotation)) {\n      return annotation.value(...ast.typeParameters.map((tp) => go(tp, path)))\n    }\n    throw new Error(errors_.getPrettyMissingAnnotationErrorMessage(path, ast))\n  },\n  \"VoidKeyword\": getMatcher(() => \"void(0)\"),\n  \"NeverKeyword\": getMatcher(() => {\n    throw new Error(errors_.getPrettyNeverErrorMessage)\n  }),\n  \"Literal\": getMatcher((literal: AST.LiteralValue): string =>\n    typeof literal === \"bigint\" ?\n      `${String(literal)}n` :\n      JSON.stringify(literal)\n  ),\n  \"SymbolKeyword\": toString,\n  \"UniqueSymbol\": toString,\n  \"TemplateLiteral\": stringify,\n  \"UndefinedKeyword\": toString,\n  \"UnknownKeyword\": formatUnknown,\n  \"AnyKeyword\": formatUnknown,\n  \"ObjectKeyword\": formatUnknown,\n  \"StringKeyword\": stringify,\n  \"NumberKeyword\": toString,\n  \"BooleanKeyword\": toString,\n  \"BigIntKeyword\": getMatcher((a) => `${String(a)}n`),\n  \"Enums\": stringify,\n  \"TupleType\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const elements = ast.elements.map((e, i) => go(e.type, path.concat(i)))\n    const rest = ast.rest.map((annotatedAST) => go(annotatedAST.type, path))\n    return (input: ReadonlyArray<unknown>) => {\n      const output: Array<string> = []\n      let i = 0\n      // ---------------------------------------------\n      // handle elements\n      // ---------------------------------------------\n      for (; i < elements.length; i++) {\n        if (input.length < i + 1) {\n          if (ast.elements[i].isOptional) {\n            continue\n          }\n        } else {\n          output.push(elements[i](input[i]))\n        }\n      }\n      // ---------------------------------------------\n      // handle rest element\n      // ---------------------------------------------\n      if (Arr.isNonEmptyReadonlyArray(rest)) {\n        const [head, ...tail] = rest\n        for (; i < input.length - tail.length; i++) {\n          output.push(head(input[i]))\n        }\n        // ---------------------------------------------\n        // handle post rest elements\n        // ---------------------------------------------\n        for (let j = 0; j < tail.length; j++) {\n          i += j\n          output.push(tail[j](input[i]))\n        }\n      }\n\n      return \"[\" + output.join(\", \") + \"]\"\n    }\n  },\n  \"TypeLiteral\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go(ps.type, path.concat(ps.name)))\n    const indexSignatureTypes = ast.indexSignatures.map((is) => go(is.type, path))\n    const expectedKeys: any = {}\n    for (let i = 0; i < propertySignaturesTypes.length; i++) {\n      expectedKeys[ast.propertySignatures[i].name] = null\n    }\n    return (input: { readonly [x: PropertyKey]: unknown }) => {\n      const output: Array<string> = []\n      // ---------------------------------------------\n      // handle property signatures\n      // ---------------------------------------------\n      for (let i = 0; i < propertySignaturesTypes.length; i++) {\n        const ps = ast.propertySignatures[i]\n        const name = ps.name\n        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {\n          continue\n        }\n        output.push(\n          `${util_.formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`\n        )\n      }\n      // ---------------------------------------------\n      // handle index signatures\n      // ---------------------------------------------\n      if (indexSignatureTypes.length > 0) {\n        for (let i = 0; i < indexSignatureTypes.length; i++) {\n          const type = indexSignatureTypes[i]\n          const keys = util_.getKeysForIndexSignature(input, ast.indexSignatures[i].parameter)\n          for (const key of keys) {\n            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {\n              continue\n            }\n            output.push(`${util_.formatPropertyKey(key)}: ${type(input[key])}`)\n          }\n        }\n      }\n\n      return Arr.isNonEmptyReadonlyArray(output) ? \"{ \" + output.join(\", \") + \" }\" : \"{}\"\n    }\n  },\n  \"Union\": (ast, go, path) => {\n    const hook = getPrettyAnnotation(ast)\n    if (Option.isSome(hook)) {\n      return hook.value()\n    }\n    const types = ast.types.map((ast) => [ParseResult.is({ ast } as any), go(ast, path)] as const)\n    return (a) => {\n      const index = types.findIndex(([is]) => is(a))\n      if (index === -1) {\n        throw new Error(errors_.getPrettyNoMatchingSchemaErrorMessage(a, path, ast))\n      }\n      return types[index][1](a)\n    }\n  },\n  \"Suspend\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => {\n        const get = util_.memoizeThunk(() => go(ast.f(), path))\n        return (a) => get()(a)\n      },\n      onSome: (handler) => handler()\n    })\n  },\n  \"Refinement\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => go(ast.from, path),\n      onSome: (handler) => handler()\n    })\n  },\n  \"Transformation\": (ast, go, path) => {\n    return Option.match(getPrettyAnnotation(ast), {\n      onNone: () => go(ast.to, path),\n      onSome: (handler) => handler()\n    })\n  }\n}\n\nconst compile = AST.getCompiler(match)\n", "/**\n * Limits the number of calls to a resource to a maximum amount in some interval.\n *\n * @since 2.0.0\n */\nimport type { DurationInput } from \"./Duration.js\"\nimport type { Effect } from \"./Effect.js\"\nimport * as internal from \"./internal/rateLimiter.js\"\nimport type { Scope } from \"./Scope.js\"\n\n/**\n * Limits the number of calls to a resource to a maximum amount in some interval.\n *\n * Note that only the moment of starting the effect is rate limited: the number\n * of concurrent executions is not bounded.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface RateLimiter {\n  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace RateLimiter {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Options {\n    /**\n     * The maximum number of requests that should be allowed.\n     */\n    readonly limit: number\n    /**\n     * The interval to utilize for rate-limiting requests. The semantics of the\n     * specified `interval` vary depending on the chosen `algorithm`:\n     *\n     * `token-bucket`: The maximum number of requests will be spread out over\n     * the provided interval if no tokens are available.\n     *\n     * For example, for a `RateLimiter` using the `token-bucket` algorithm with\n     * a `limit` of `10` and an `interval` of `1 seconds`, `1` request can be\n     * made every `100 millis`.\n     *\n     * `fixed-window`: The maximum number of requests will be reset during each\n     * interval. For example, for a `RateLimiter` using the `fixed-window`\n     * algorithm with a `limit` of `10` and an `interval` of `1 seconds`, a\n     * maximum of `10` requests can be made each second.\n     */\n    readonly interval: DurationInput\n    /**\n     * The algorithm to utilize for rate-limiting requests.\n     *\n     * Defaults to `token-bucket`.\n     */\n    readonly algorithm?: \"fixed-window\" | \"token-bucket\"\n  }\n}\n\n/**\n * Constructs a new `RateLimiter` which will utilize the specified algorithm\n * to limit requests (defaults to `token-bucket`).\n *\n * Notes\n * - Only the moment of starting the effect is rate limited. The number of concurrent executions is not bounded.\n * - Instances of `RateLimiter` can be composed.\n * - The \"cost\" per effect can be changed. See {@link withCost}\n *\n * @example\n * ```ts\n * import { Effect, RateLimiter } from \"effect\";\n * import { compose } from \"effect/Function\"\n *\n * const program = Effect.scoped(\n *   Effect.gen(function* ($) {\n *     const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: \"1 minutes\" }))\n *     const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: \"1 seconds\" }))\n *\n *     // This rate limiter respects both the 30 calls per minute\n *     // and the 2 calls per second constraints.\n *      const rateLimit = compose(perMinuteRL, perSecondRL)\n *\n *     // simulate repeated calls\n *     for (let n = 0; n < 100; n++) {\n *       // wrap the effect we want to limit with rateLimit\n *       yield* $(rateLimit(Effect.log(\"Calling RateLimited Effect\")));\n *     }\n *   })\n * );\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope> = internal.make\n\n/**\n * Alters the per-effect cost of the rate-limiter.\n *\n * This can be used for \"credit\" based rate-limiting where different API endpoints\n * cost a different number of credits within a time window.\n * Eg: 1000 credits / hour, where a query costs 1 credit and a mutation costs 5 credits.\n *\n * @example\n * ```ts\n * import { Effect, RateLimiter } from \"effect\";\n * import { compose } from \"effect/Function\";\n *\n * const program = Effect.scoped(\n *   Effect.gen(function* ($) {\n *     // Create a rate limiter that has an hourly limit of 1000 credits\n *     const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: \"1 hours\" }));\n *     // Query API costs 1 credit per call ( 1 is the default cost )\n *     const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));\n *     // Mutation API costs 5 credits per call\n *     const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));\n\n *     // Use the pre-defined rate limiters\n *     yield* $(queryAPIRL(Effect.log(\"Sample Query\")));\n *     yield* $(mutationAPIRL(Effect.log(\"Sample Mutation\")));\n *\n *     // Or set a cost on-the-fly\n *     yield* $(\n *       rateLimiter(Effect.log(\"Another query with a different cost\")).pipe(\n *         RateLimiter.withCost(3)\n *       )\n *     );\n *   })\n * );\n * ```\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R> = internal.withCost\n", "import type { DurationInput } from \"../Duration.js\"\nimport * as Duration from \"../Duration.js\"\nimport * as Effect from \"../Effect.js\"\nimport * as FiberRef from \"../FiberRef.js\"\nimport { pipe } from \"../Function.js\"\nimport { globalValue } from \"../GlobalValue.js\"\nimport type * as RateLimiter from \"../RateLimiter.js\"\nimport type * as Scope from \"../Scope.js\"\n\n/** @internal */\nexport const make = ({\n  algorithm = \"token-bucket\",\n  interval,\n  limit\n}: RateLimiter.RateLimiter.Options): Effect.Effect<\n  RateLimiter.RateLimiter,\n  never,\n  Scope.Scope\n> => {\n  switch (algorithm) {\n    case \"fixed-window\": {\n      return fixedWindow(limit, interval)\n    }\n    case \"token-bucket\": {\n      return tokenBucket(limit, interval)\n    }\n  }\n}\n\nconst tokenBucket = (limit: number, window: DurationInput): Effect.Effect<\n  RateLimiter.RateLimiter,\n  never,\n  Scope.Scope\n> =>\n  Effect.gen(function*() {\n    const millisPerToken = Math.ceil(Duration.toMillis(window) / limit)\n    const semaphore = yield* Effect.makeSemaphore(limit)\n    const latch = yield* Effect.makeSemaphore(0)\n    const refill: Effect.Effect<void> = Effect.sleep(millisPerToken).pipe(\n      Effect.zipRight(latch.releaseAll),\n      Effect.zipRight(semaphore.release(1)),\n      Effect.flatMap((free) => free === limit ? Effect.void : refill)\n    )\n    yield* pipe(\n      latch.take(1),\n      Effect.zipRight(refill),\n      Effect.forever,\n      Effect.forkScoped,\n      Effect.interruptible\n    )\n    const take = Effect.uninterruptibleMask((restore) =>\n      Effect.flatMap(\n        FiberRef.get(currentCost),\n        (cost) => Effect.zipRight(restore(semaphore.take(cost)), latch.release(1))\n      )\n    )\n    return (effect) => Effect.zipRight(take, effect)\n  })\n\nconst fixedWindow = (limit: number, window: DurationInput): Effect.Effect<\n  RateLimiter.RateLimiter,\n  never,\n  Scope.Scope\n> =>\n  Effect.gen(function*() {\n    const semaphore = yield* Effect.makeSemaphore(limit)\n    const latch = yield* Effect.makeSemaphore(0)\n    yield* pipe(\n      latch.take(1),\n      Effect.zipRight(Effect.sleep(window)),\n      Effect.zipRight(latch.releaseAll),\n      Effect.zipRight(semaphore.releaseAll),\n      Effect.forever,\n      Effect.forkScoped,\n      Effect.interruptible\n    )\n    const take = Effect.uninterruptibleMask((restore) =>\n      Effect.flatMap(\n        FiberRef.get(currentCost),\n        (cost) => Effect.zipRight(restore(semaphore.take(cost)), latch.release(1))\n      )\n    )\n    return (effect) => Effect.zipRight(take, effect)\n  })\n\n/** @internal */\nconst currentCost = globalValue(\n  Symbol.for(\"effect/RateLimiter/currentCost\"),\n  () => FiberRef.unsafeMake(1)\n)\n\n/** @internal */\nexport const withCost = (cost: number) => Effect.locally(currentCost, cost)\n", "/**\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/reloadable.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as Schedule from \"./Schedule.js\"\nimport type * as ScopedRef from \"./ScopedRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ReloadableTypeId: unique symbol = internal.ReloadableTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ReloadableTypeId = typeof ReloadableTypeId\n\n/**\n * A `Reloadable` is an implementation of some service that can be dynamically\n * reloaded, or swapped out for another implementation on-the-fly.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Reloadable<in out A> extends Reloadable.Variance<A> {\n  /**\n   * @internal\n   */\n  readonly scopedRef: ScopedRef.ScopedRef<A>\n  /**\n   * @internal\n   */\n  readonly reload: Effect.Effect<void, unknown>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Reloadable {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [ReloadableTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * Makes a new reloadable service from a layer that describes the construction\n * of a static service. The service is automatically reloaded according to the\n * provided schedule.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const auto: <I, S, E, In, R>(\n  tag: Context.Tag<I, S>,\n  options: { readonly layer: Layer.Layer<I, E, In>; readonly schedule: Schedule.Schedule<unknown, unknown, R> }\n) => Layer.Layer<Reloadable<I>, E, R | In> = internal.auto\n\n/**\n * Makes a new reloadable service from a layer that describes the construction\n * of a static service. The service is automatically reloaded according to a\n * schedule, which is extracted from the input to the layer.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const autoFromConfig: <I, S, E, In, R>(\n  tag: Context.Tag<I, S>,\n  options: {\n    readonly layer: Layer.Layer<I, E, In>\n    readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>\n  }\n) => Layer.Layer<Reloadable<I>, E, R | In> = internal.autoFromConfig\n\n/**\n * Retrieves the current version of the reloadable service.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>> = internal.get\n\n/**\n * Makes a new reloadable service from a layer that describes the construction\n * of a static service.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const manual: <I, S, In, E>(\n  tag: Context.Tag<I, S>,\n  options: { readonly layer: Layer.Layer<I, E, In> }\n) => Layer.Layer<Reloadable<I>, E, In> = internal.manual\n\n/**\n * Reloads the specified service.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>> = internal.reload\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const tag: <I, S>(tag: Context.Tag<I, S>) => Context.Tag<Reloadable<I>, Reloadable<S>> = internal.reloadableTag\n\n/**\n * Forks the reload of the service in the background, ignoring any errors.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>> =\n  internal.reloadFork\n", "import * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport type { LazyArg } from \"../Function.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport type * as Scope from \"../Scope.js\"\nimport type * as ScopedRef from \"../ScopedRef.js\"\nimport * as core from \"./core.js\"\nimport * as circular from \"./effect/circular.js\"\nimport * as effectable from \"./effectable.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as ref from \"./ref.js\"\nimport * as synchronized from \"./synchronizedRef.js\"\n\n/** @internal */\nconst ScopedRefSymbolKey = \"effect/ScopedRef\"\n\n/** @internal */\nexport const ScopedRefTypeId: ScopedRef.ScopedRefTypeId = Symbol.for(\n  ScopedRefSymbolKey\n) as ScopedRef.ScopedRefTypeId\n\n/** @internal */\nconst scopedRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal  */\nconst proto: ThisType<ScopedRef.ScopedRef<any>> = {\n  ...effectable.CommitPrototype,\n  commit() {\n    return get(this)\n  },\n  [ScopedRefTypeId]: scopedRefVariance\n}\n\n/** @internal  */\nconst close = <A>(self: ScopedRef.ScopedRef<A>): Effect.Effect<void> =>\n  core.flatMap(ref.get(self.ref), (tuple) => tuple[0].close(core.exitVoid))\n\n/** @internal */\nexport const fromAcquire = <A, E, R>(\n  acquire: Effect.Effect<A, E, R>\n): Effect.Effect<ScopedRef.ScopedRef<A>, E, R | Scope.Scope> =>\n  core.uninterruptible(\n    fiberRuntime.scopeMake().pipe(core.flatMap((newScope) =>\n      acquire.pipe(\n        core.mapInputContext<R, Scope.Scope | R>(Context.add(fiberRuntime.scopeTag, newScope)),\n        core.onError((cause) => newScope.close(core.exitFail(cause))),\n        core.flatMap((value) =>\n          circular.makeSynchronized([newScope, value] as const).pipe(\n            core.flatMap((ref) => {\n              const scopedRef = Object.create(proto)\n              scopedRef.ref = ref\n              return pipe(\n                fiberRuntime.addFinalizer(() => close(scopedRef)),\n                core.as(scopedRef)\n              )\n            })\n          )\n        )\n      )\n    ))\n  )\n\n/** @internal */\nexport const get = <A>(self: ScopedRef.ScopedRef<A>): Effect.Effect<A> =>\n  core.map(ref.get(self.ref), (tuple) => tuple[1])\n\n/** @internal */\nexport const make = <A>(evaluate: LazyArg<A>): Effect.Effect<ScopedRef.ScopedRef<A>, never, Scope.Scope> =>\n  fromAcquire(core.sync(evaluate))\n\n/** @internal */\nexport const set = dual<\n  <A, R, E>(\n    acquire: Effect.Effect<A, E, R>\n  ) => (self: ScopedRef.ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>,\n  <A, R, E>(\n    self: ScopedRef.ScopedRef<A>,\n    acquire: Effect.Effect<A, E, R>\n  ) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>\n>(2, <A, R, E>(\n  self: ScopedRef.ScopedRef<A>,\n  acquire: Effect.Effect<A, E, R>\n) =>\n  core.flatten(\n    synchronized.modifyEffect(self.ref, ([oldScope, value]) =>\n      core.uninterruptible(\n        core.scopeClose(oldScope, core.exitVoid).pipe(\n          core.zipRight(fiberRuntime.scopeMake()),\n          core.flatMap((newScope) =>\n            core.exit(fiberRuntime.scopeExtend(acquire, newScope)).pipe(\n              core.flatMap((exit) =>\n                core.exitMatch(exit, {\n                  onFailure: (cause) =>\n                    core.scopeClose(newScope, core.exitVoid).pipe(\n                      core.as(\n                        [\n                          core.failCause(cause) as Effect.Effect<void, E>,\n                          [oldScope, value] as const\n                        ] as const\n                      )\n                    ),\n                  onSuccess: (value) =>\n                    core.succeed(\n                      [\n                        core.void as Effect.Effect<void, E>,\n                        [newScope, value] as const\n                      ] as const\n                    )\n                })\n              )\n            )\n          )\n        )\n      ))\n  ))\n", "import * as Context from \"../Context.js\"\nimport type * as Effect from \"../Effect.js\"\nimport { pipe } from \"../Function.js\"\nimport type * as Layer from \"../Layer.js\"\nimport type * as Reloadable from \"../Reloadable.js\"\nimport type * as Schedule from \"../Schedule.js\"\nimport * as effect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as layer_ from \"./layer.js\"\nimport * as schedule_ from \"./schedule.js\"\nimport * as scopedRef from \"./scopedRef.js\"\n\n/** @internal */\nconst ReloadableSymbolKey = \"effect/Reloadable\"\n\n/** @internal */\nexport const ReloadableTypeId: Reloadable.ReloadableTypeId = Symbol.for(\n  ReloadableSymbolKey\n) as Reloadable.ReloadableTypeId\n\nconst reloadableVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nexport const auto = <I, S, E, In, R>(\n  tag: Context.Tag<I, S>,\n  options: {\n    readonly layer: Layer.Layer<I, E, In>\n    readonly schedule: Schedule.Schedule<unknown, unknown, R>\n  }\n): Layer.Layer<Reloadable.Reloadable<I>, E, R | In> =>\n  layer_.scoped(\n    reloadableTag(tag),\n    pipe(\n      layer_.build(manual(tag, { layer: options.layer })),\n      core.map(Context.unsafeGet(reloadableTag(tag))),\n      core.tap((reloadable) =>\n        fiberRuntime.acquireRelease(\n          pipe(\n            reloadable.reload,\n            effect.ignoreLogged,\n            schedule_.schedule_Effect(options.schedule),\n            fiberRuntime.forkDaemon\n          ),\n          core.interruptFiber\n        )\n      )\n    )\n  )\n\n/** @internal */\nexport const autoFromConfig = <I, S, E, In, R>(\n  tag: Context.Tag<I, S>,\n  options: {\n    readonly layer: Layer.Layer<I, E, In>\n    readonly scheduleFromConfig: (context: Context.Context<In>) => Schedule.Schedule<unknown, unknown, R>\n  }\n): Layer.Layer<Reloadable.Reloadable<I>, E, R | In> =>\n  layer_.scoped(\n    reloadableTag(tag),\n    pipe(\n      core.context<In>(),\n      core.flatMap((env) =>\n        pipe(\n          layer_.build(auto(tag, {\n            layer: options.layer,\n            schedule: options.scheduleFromConfig(env)\n          })),\n          core.map(Context.unsafeGet(reloadableTag(tag)))\n        )\n      )\n    )\n  )\n\n/** @internal */\nexport const get = <I, S>(\n  tag: Context.Tag<I, S>\n): Effect.Effect<S, never, Reloadable.Reloadable<I>> =>\n  core.flatMap(\n    reloadableTag(tag),\n    (reloadable) => scopedRef.get(reloadable.scopedRef)\n  )\n\n/** @internal */\nexport const manual = <I, S, In, E>(\n  tag: Context.Tag<I, S>,\n  options: {\n    readonly layer: Layer.Layer<I, E, In>\n  }\n): Layer.Layer<Reloadable.Reloadable<I>, E, In> =>\n  layer_.scoped(\n    reloadableTag(tag),\n    pipe(\n      core.context<In>(),\n      core.flatMap((env) =>\n        pipe(\n          scopedRef.fromAcquire(pipe(layer_.build(options.layer), core.map(Context.unsafeGet(tag)))),\n          core.map((ref) => ({\n            [ReloadableTypeId]: reloadableVariance,\n            scopedRef: ref,\n            reload: pipe(\n              scopedRef.set(ref, pipe(layer_.build(options.layer), core.map(Context.unsafeGet(tag)))),\n              core.provideContext(env)\n            )\n          }))\n        )\n      )\n    )\n  )\n\n/** @internal */\nexport const reloadableTag = <I, S>(\n  tag: Context.Tag<I, S>\n): Context.Tag<Reloadable.Reloadable<I>, Reloadable.Reloadable<S>> => {\n  return Context.GenericTag<Reloadable.Reloadable<I>, Reloadable.Reloadable<S>>(`effect/Reloadable<${tag.key}>`)\n}\n\n/** @internal */\nexport const reload = <I, S>(\n  tag: Context.Tag<I, S>\n): Effect.Effect<void, unknown, Reloadable.Reloadable<I>> =>\n  core.flatMap(\n    reloadableTag(tag),\n    (reloadable) => reloadable.reload\n  )\n\n/** @internal */\nexport const reloadFork = <I, S>(\n  tag: Context.Tag<I, S>\n): Effect.Effect<void, unknown, Reloadable.Reloadable<I>> =>\n  core.flatMap(reloadableTag(tag), (reloadable) =>\n    pipe(\n      reloadable.reload,\n      effect.ignoreLogged,\n      fiberRuntime.forkDaemon,\n      core.asVoid\n    ))\n", "/**\n * @since 2.0.0\n */\nimport * as RequestBlock_ from \"./internal/blockedRequests.js\"\nimport type * as Request from \"./Request.js\"\nimport type * as RequestResolver from \"./RequestResolver.js\"\n\n/**\n * `RequestBlock` captures a collection of blocked requests as a data\n * structure. By doing this the library is able to preserve information about\n * which requests must be performed sequentially and which can be performed in\n * parallel, allowing for maximum possible batching and pipelining while\n * preserving ordering guarantees.\n *\n * @since 2.0.0\n * @category models\n */\nexport type RequestBlock = Empty | Par | Seq | Single\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport declare namespace RequestBlock {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Reducer<in out Z> {\n    emptyCase(): Z\n    parCase(left: Z, right: Z): Z\n    singleCase(\n      dataSource: RequestResolver.RequestResolver<unknown>,\n      blockedRequest: Request.Entry<unknown>\n    ): Z\n    seqCase(left: Z, right: Z): Z\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Empty {\n  readonly _tag: \"Empty\"\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Par {\n  readonly _tag: \"Par\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Seq {\n  readonly _tag: \"Seq\"\n  readonly left: RequestBlock\n  readonly right: RequestBlock\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Single {\n  readonly _tag: \"Single\"\n  readonly dataSource: RequestResolver.RequestResolver<unknown>\n  readonly blockedRequest: Request.Entry<unknown>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const single: <A>(\n  dataSource: RequestResolver.RequestResolver<A>,\n  blockedRequest: Request.Entry<A>\n) => RequestBlock = RequestBlock_.single\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: RequestBlock = RequestBlock_.empty\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const mapRequestResolvers: <A>(\n  self: RequestBlock,\n  f: (dataSource: RequestResolver.RequestResolver<A>) => RequestResolver.RequestResolver<A>\n) => RequestBlock = RequestBlock_.mapRequestResolvers\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const parallel: (self: RequestBlock, that: RequestBlock) => RequestBlock = RequestBlock_.par\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const reduce: <Z>(self: RequestBlock, reducer: RequestBlock.Reducer<Z>) => Z = RequestBlock_.reduce\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const sequential: (self: RequestBlock, that: RequestBlock) => RequestBlock = RequestBlock_.seq\n", "/**\n * @since 2.0.0\n */\n\nimport type { NonEmptyArray } from \"./Array.js\"\nimport * as Context from \"./Context.js\"\nimport * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as Equal from \"./Equal.js\"\nimport type { FiberRef } from \"./FiberRef.js\"\nimport * as core from \"./internal/core.js\"\nimport * as internal from \"./internal/dataSource.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Request from \"./Request.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const RequestResolverTypeId: unique symbol = core.RequestResolverTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type RequestResolverTypeId = typeof RequestResolverTypeId\n\n/**\n * The `RequestResolver<A, R>` interface requires an environment `R` and handles\n * the execution of requests of type `A`.\n *\n * Implementations must provide a `runAll` method, which processes a collection\n * of requests and produces an effect that fulfills these requests. Requests are\n * organized into a `Array<Array<A>>`, where the outer `Array` groups requests\n * into batches that are executed sequentially, and each inner `Array` contains\n * requests that can be executed in parallel. This structure allows\n * implementations to analyze all incoming requests collectively and optimize\n * query execution accordingly.\n *\n * Implementations are typically specialized for a subtype of `Request<A, E>`.\n * However, they are not strictly limited to these subtypes as long as they can\n * map any given request type to `Request<A, E>`. Implementations should inspect\n * the collection of requests to identify the needed information and execute the\n * corresponding queries. It is imperative that implementations resolve all the\n * requests they receive. Failing to do so will lead to a `QueryFailure` error\n * during query execution.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {\n  /**\n   * Execute a collection of requests. The outer `Array` represents batches\n   * of requests that must be performed sequentially. The inner `Array`\n   * represents a batch of requests that can be performed in parallel.\n   */\n  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>\n\n  /**\n   * Identify the data source using the specific identifier\n   */\n  identified(...identifiers: Array<unknown>): RequestResolver<A, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace RequestResolver {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in A, out R> {\n    readonly [RequestResolverTypeId]: {\n      readonly _A: Types.Contravariant<A>\n      readonly _R: Types.Covariant<R>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const contextFromEffect = <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>) =>\n  Effect.contextWith((_: Context.Context<R>) => provideContext(self, _))\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const contextFromServices =\n  <Services extends Array<Context.Tag<any, any>>>(...services: Services) =>\n  <R, A extends Request.Request<any, any>>(\n    self: RequestResolver<A, R>\n  ): Effect.Effect<\n    RequestResolver<A, Exclude<R, { [k in keyof Services]: Effect.Effect.Context<Services[k]> }[number]>>,\n    never,\n    { [k in keyof Services]: Effect.Effect.Context<Services[k]> }[number]\n  > => Effect.contextWith((_) => provideContext(self as any, Context.pick(...services)(_ as any)))\n\n/**\n * Returns `true` if the specified value is a `RequestResolver`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown> = core.isRequestResolver\n\n/**\n * Constructs a data source with the specified identifier and method to run\n * requests.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A, R>(\n  runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>\n) => RequestResolver<A, R> = internal.make\n\n/**\n * Constructs a data source with the specified identifier and method to run\n * requests.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWithEntry: <A, R>(\n  runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>\n) => RequestResolver<A, R> = internal.makeWithEntry\n\n/**\n * Constructs a data source from a function taking a collection of requests.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeBatched: <A extends Request.Request<any, any>, R>(\n  run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>\n) => RequestResolver<A, R> = internal.makeBatched\n\n/**\n * A data source aspect that executes requests between two effects, `before`\n * and `after`, where the result of `before` can be used by `after`.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const around: {\n  /**\n   * A data source aspect that executes requests between two effects, `before`\n   * and `after`, where the result of `before` can be used by `after`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A2, R2, X, R3>(\n    before: Effect.Effect<A2, never, R2>,\n    after: (a: A2) => Effect.Effect<X, never, R3>\n  ): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>\n  /**\n   * A data source aspect that executes requests between two effects, `before`\n   * and `after`, where the result of `before` can be used by `after`.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, R, A2, R2, X, R3>(\n    self: RequestResolver<A, R>,\n    before: Effect.Effect<A2, never, R2>,\n    after: (a: A2) => Effect.Effect<X, never, R3>\n  ): RequestResolver<A, R | R2 | R3>\n} = internal.around\n\n/**\n * A data source aspect that executes requests between two effects, `before`\n * and `after`, where the result of `before` can be used by `after`.\n *\n * The `before` and `after` effects are provided with the requests being executed.\n *\n * @since 2.0.0\n * @category combinators\n * @example\n * ```ts\n * import { Effect, Request, RequestResolver } from \"effect\"\n *\n * interface GetUserById extends Request.Request<unknown> {\n *   readonly id: number\n * }\n *\n * const resolver = RequestResolver.fromFunction(\n *   (request: GetUserById) => ({ id: request.id, name: \"John\" })\n * )\n *\n * RequestResolver.aroundRequests(\n *   resolver,\n *   (requests) => Effect.log(`got ${requests.length} requests`),\n *   (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n * )\n * ```\n */\nexport const aroundRequests: {\n  /**\n   * A data source aspect that executes requests between two effects, `before`\n   * and `after`, where the result of `before` can be used by `after`.\n   *\n   * The `before` and `after` effects are provided with the requests being executed.\n   *\n   * @since 2.0.0\n   * @category combinators\n   * @example\n   * ```ts\n   * import { Effect, Request, RequestResolver } from \"effect\"\n   *\n   * interface GetUserById extends Request.Request<unknown> {\n   *   readonly id: number\n   * }\n   *\n   * const resolver = RequestResolver.fromFunction(\n   *   (request: GetUserById) => ({ id: request.id, name: \"John\" })\n   * )\n   *\n   * RequestResolver.aroundRequests(\n   *   resolver,\n   *   (requests) => Effect.log(`got ${requests.length} requests`),\n   *   (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n   * )\n   * ```\n   */\n  <A, A2, R2, X, R3>(\n    before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>,\n    after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>\n  ): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>\n  /**\n   * A data source aspect that executes requests between two effects, `before`\n   * and `after`, where the result of `before` can be used by `after`.\n   *\n   * The `before` and `after` effects are provided with the requests being executed.\n   *\n   * @since 2.0.0\n   * @category combinators\n   * @example\n   * ```ts\n   * import { Effect, Request, RequestResolver } from \"effect\"\n   *\n   * interface GetUserById extends Request.Request<unknown> {\n   *   readonly id: number\n   * }\n   *\n   * const resolver = RequestResolver.fromFunction(\n   *   (request: GetUserById) => ({ id: request.id, name: \"John\" })\n   * )\n   *\n   * RequestResolver.aroundRequests(\n   *   resolver,\n   *   (requests) => Effect.log(`got ${requests.length} requests`),\n   *   (requests, _) => Effect.log(`finised running ${requests.length} requests`)\n   * )\n   * ```\n   */\n  <A, R, A2, R2, X, R3>(\n    self: RequestResolver<A, R>,\n    before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>,\n    after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>\n  ): RequestResolver<A, R | R2 | R3>\n} = internal.aroundRequests\n\n/**\n * Returns a data source that executes at most `n` requests in parallel.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const batchN: {\n  /**\n   * Returns a data source that executes at most `n` requests in parallel.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>\n  /**\n   * Returns a data source that executes at most `n` requests in parallel.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>\n} = internal.batchN\n\n/**\n * Provides this data source with part of its required context.\n *\n * @since 2.0.0\n * @category context\n */\nexport const mapInputContext: {\n  /**\n   * Provides this data source with part of its required context.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>\n  /**\n   * Provides this data source with part of its required context.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R, A extends Request.Request<any, any>, R0>(\n    self: RequestResolver<A, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ): RequestResolver<A, R0>\n} = internal.mapInputContext\n\n/**\n * Returns a new data source that executes requests of type `C` using the\n * specified function to transform `C` requests into requests that either this\n * data source or that data source can execute.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const eitherWith: {\n  /**\n   * Returns a new data source that executes requests of type `C` using the\n   * specified function to transform `C` requests into requests that either this\n   * data source or that data source can execute.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A extends Request.Request<any, any>, R2, B extends Request.Request<any, any>, C extends Request.Request<any, any>>(\n    that: RequestResolver<B, R2>,\n    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>\n  ): <R>(self: RequestResolver<A, R>) => RequestResolver<C, R2 | R>\n  /**\n   * Returns a new data source that executes requests of type `C` using the\n   * specified function to transform `C` requests into requests that either this\n   * data source or that data source can execute.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <\n    R,\n    A extends Request.Request<any, any>,\n    R2,\n    B extends Request.Request<any, any>,\n    C extends Request.Request<any, any>\n  >(\n    self: RequestResolver<A, R>,\n    that: RequestResolver<B, R2>,\n    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>\n  ): RequestResolver<C, R | R2>\n} = internal.eitherWith\n\n/**\n * Constructs a data source from a pure function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromFunction: <A extends Request.Request<any>>(\n  f: (request: A) => Request.Request.Success<A>\n) => RequestResolver<A> = internal.fromFunction\n\n/**\n * Constructs a data source from a pure function that takes a list of requests\n * and returns a list of results of the same size. Each item in the result\n * list must correspond to the item at the same index in the request list.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromFunctionBatched: <A extends Request.Request<any>>(\n  f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>\n) => RequestResolver<A> = internal.fromFunctionBatched\n\n/**\n * Constructs a data source from an effectual function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEffect: <R, A extends Request.Request<any, any>>(\n  f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>\n) => RequestResolver<A, R> = internal.fromEffect\n\n/**\n * Constructs a data source from a list of tags paired to functions, that takes\n * a list of requests and returns a list of results of the same size. Each item\n * in the result list must correspond to the item at the same index in the\n * request list.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string }>() => <\n  Fns extends {\n    readonly [Tag in A[\"_tag\"]]: [Extract<A, { readonly _tag: Tag }>] extends [infer Req]\n      ? Req extends Request.Request<infer ReqA, infer ReqE>\n        ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any>\n      : never\n      : never\n  }\n>(\n  fns: Fns\n) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never> =\n  internal.fromEffectTagged\n\n/**\n * A data source that never executes requests.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const never: RequestResolver<never> = internal.never\n\n/**\n * Provides this data source with its required context.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideContext: {\n  /**\n   * Provides this data source with its required context.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>\n  /**\n   * Provides this data source with its required context.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>\n} = internal.provideContext\n\n/**\n * Returns a new data source that executes requests by sending them to this\n * data source and that data source, returning the results from the first data\n * source to complete and safely interrupting the loser.\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const race: {\n  /**\n   * Returns a new data source that executes requests by sending them to this\n   * data source and that data source, returning the results from the first data\n   * source to complete and safely interrupting the loser.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>\n  /**\n   * Returns a new data source that executes requests by sending them to this\n   * data source and that data source, returning the results from the first data\n   * source to complete and safely interrupting the loser.\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>\n} = internal.race\n\n/**\n * Returns a new data source with a localized FiberRef\n *\n * @since 2.0.0\n * @category combinators\n */\nexport const locally: {\n  /**\n   * Returns a new data source with a localized FiberRef\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>\n  /**\n   * Returns a new data source with a localized FiberRef\n   *\n   * @since 2.0.0\n   * @category combinators\n   */\n  <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>\n} = core.resolverLocally\n", "import * as RA from \"../Array.js\"\nimport * as Cause from \"../Cause.js\"\nimport * as Chunk from \"../Chunk.js\"\nimport type * as Context from \"../Context.js\"\nimport * as Effect from \"../Effect.js\"\nimport type * as Either from \"../Either.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport type * as Request from \"../Request.js\"\nimport type * as RequestResolver from \"../RequestResolver.js\"\nimport type { NoInfer } from \"../Types.js\"\nimport * as core from \"./core.js\"\nimport { invokeWithInterrupt, zipWithOptions } from \"./fiberRuntime.js\"\nimport { complete } from \"./request.js\"\n\n/** @internal */\nexport const make = <A, R>(\n  runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>\n): RequestResolver.RequestResolver<A, R> =>\n  new core.RequestResolverImpl((requests) => runAll(requests.map((_) => _.map((_) => _.request))))\n\n/** @internal */\nexport const makeWithEntry = <A, R>(\n  runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>\n): RequestResolver.RequestResolver<A, R> => new core.RequestResolverImpl((requests) => runAll(requests))\n\n/** @internal */\nexport const makeBatched = <A extends Request.Request<any, any>, R>(\n  run: (requests: RA.NonEmptyArray<A>) => Effect.Effect<void, never, R>\n): RequestResolver.RequestResolver<A, R> =>\n  new core.RequestResolverImpl<A, R>(\n    (requests) => {\n      if (requests.length > 1) {\n        return core.forEachSequentialDiscard(requests, (block) => {\n          const filtered = block.filter((_) => !_.state.completed).map((_) => _.request)\n          if (!RA.isNonEmptyArray(filtered)) {\n            return core.void\n          }\n          return invokeWithInterrupt(run(filtered), block)\n        })\n      } else if (requests.length === 1) {\n        const filtered = requests[0].filter((_) => !_.state.completed).map((_) => _.request)\n        if (!RA.isNonEmptyArray(filtered)) {\n          return core.void\n        }\n        return run(filtered)\n      }\n      return core.void\n    }\n  )\n\n/** @internal */\nexport const around = dual<\n  <A2, R2, X, R3>(\n    before: Effect.Effect<A2, never, R2>,\n    after: (a: A2) => Effect.Effect<X, never, R3>\n  ) => <A, R>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A, R | R2 | R3>,\n  <A, R, A2, R2, X, R3>(\n    self: RequestResolver.RequestResolver<A, R>,\n    before: Effect.Effect<A2, never, R2>,\n    after: (a: A2) => Effect.Effect<X, never, R3>\n  ) => RequestResolver.RequestResolver<A, R | R2 | R3>\n>(3, (self, before, after) =>\n  new core.RequestResolverImpl(\n    (requests) =>\n      core.acquireUseRelease(\n        before,\n        () => self.runAll(requests),\n        after\n      ),\n    Chunk.make(\"Around\", self, before, after)\n  ))\n\n/** @internal */\nexport const aroundRequests = dual<\n  <A, A2, R2, X, R3>(\n    before: (requests: ReadonlyArray<NoInfer<A>>) => Effect.Effect<A2, never, R2>,\n    after: (requests: ReadonlyArray<NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>\n  ) => <R>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A, R | R2 | R3>,\n  <A, R, A2, R2, X, R3>(\n    self: RequestResolver.RequestResolver<A, R>,\n    before: (requests: ReadonlyArray<NoInfer<A>>) => Effect.Effect<A2, never, R2>,\n    after: (requests: ReadonlyArray<NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>\n  ) => RequestResolver.RequestResolver<A, R | R2 | R3>\n>(3, (self, before, after) =>\n  new core.RequestResolverImpl(\n    (requests) => {\n      const flatRequests = requests.flatMap((chunk) => chunk.map((entry) => entry.request))\n      return core.acquireUseRelease(\n        before(flatRequests),\n        () => self.runAll(requests),\n        (a2) => after(flatRequests, a2)\n      )\n    },\n    Chunk.make(\"AroundRequests\", self, before, after)\n  ))\n\n/** @internal */\nexport const batchN = dual<\n  (n: number) => <A, R>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A, R>,\n  <A, R>(\n    self: RequestResolver.RequestResolver<A, R>,\n    n: number\n  ) => RequestResolver.RequestResolver<A, R>\n>(2, <A, R>(\n  self: RequestResolver.RequestResolver<A, R>,\n  n: number\n): RequestResolver.RequestResolver<A, R> =>\n  new core.RequestResolverImpl(\n    (requests) => {\n      return n < 1\n        ? core.die(new Cause.IllegalArgumentException(\"RequestResolver.batchN: n must be at least 1\"))\n        : self.runAll(\n          Array.from(Chunk.map(\n            RA.reduce(\n              requests,\n              Chunk.empty<Chunk.Chunk<Request.Entry<A>>>(),\n              (acc, chunk) => Chunk.appendAll(acc, Chunk.chunksOf(Chunk.unsafeFromArray(chunk), n))\n            ),\n            (chunk) => Array.from(chunk)\n          ))\n        )\n    },\n    Chunk.make(\"BatchN\", self, n)\n  ))\n\n/** @internal */\nexport const mapInputContext = dual<\n  <R0, R>(\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => <A extends Request.Request<any, any>>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A, R0>,\n  <R, A extends Request.Request<any, any>, R0>(\n    self: RequestResolver.RequestResolver<A, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ) => RequestResolver.RequestResolver<A, R0>\n>(2, <R, A extends Request.Request<any, any>, R0>(\n  self: RequestResolver.RequestResolver<A, R>,\n  f: (context: Context.Context<R0>) => Context.Context<R>\n) =>\n  new core.RequestResolverImpl<A, R0>(\n    (requests) =>\n      core.mapInputContext(\n        self.runAll(requests),\n        (context: Context.Context<R0>) => f(context)\n      ),\n    Chunk.make(\"MapInputContext\", self, f)\n  ))\n\n/** @internal */\nexport const eitherWith = dual<\n  <\n    A extends Request.Request<any, any>,\n    R2,\n    B extends Request.Request<any, any>,\n    C extends Request.Request<any, any>\n  >(\n    that: RequestResolver.RequestResolver<B, R2>,\n    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>\n  ) => <R>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<C, R | R2>,\n  <\n    R,\n    A extends Request.Request<any, any>,\n    R2,\n    B extends Request.Request<any, any>,\n    C extends Request.Request<any, any>\n  >(\n    self: RequestResolver.RequestResolver<A, R>,\n    that: RequestResolver.RequestResolver<B, R2>,\n    f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>\n  ) => RequestResolver.RequestResolver<C, R | R2>\n>(3, <\n  R,\n  A extends Request.Request<any, any>,\n  R2,\n  B extends Request.Request<any, any>,\n  C extends Request.Request<any, any>\n>(\n  self: RequestResolver.RequestResolver<A, R>,\n  that: RequestResolver.RequestResolver<B, R2>,\n  f: (_: Request.Entry<C>) => Either.Either<Request.Entry<B>, Request.Entry<A>>\n) =>\n  new core.RequestResolverImpl<C, R | R2>(\n    (batch) =>\n      pipe(\n        core.forEachSequential(batch, (requests) => {\n          const [as, bs] = pipe(\n            requests,\n            RA.partitionMap(f)\n          )\n          return zipWithOptions(\n            self.runAll(Array.of(as)),\n            that.runAll(Array.of(bs)),\n            () => void 0,\n            { concurrent: true }\n          )\n        })\n      ),\n    Chunk.make(\"EitherWith\", self, that, f)\n  ))\n\n/** @internal */\nexport const fromFunction = <A extends Request.Request<any>>(\n  f: (request: A) => Request.Request.Success<A>\n): RequestResolver.RequestResolver<A> =>\n  makeBatched((requests: RA.NonEmptyArray<A>) =>\n    core.forEachSequentialDiscard(\n      requests,\n      (request) => complete(request, core.exitSucceed(f(request)) as any)\n    )\n  ).identified(\"FromFunction\", f)\n\n/** @internal */\nexport const fromFunctionBatched = <A extends Request.Request<any>>(\n  f: (chunk: RA.NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>\n): RequestResolver.RequestResolver<A> =>\n  makeBatched((as: RA.NonEmptyArray<A>) =>\n    Effect.forEach(\n      f(as),\n      (res, i) => complete(as[i], core.exitSucceed(res) as any),\n      { discard: true }\n    )\n  ).identified(\"FromFunctionBatched\", f)\n\n/** @internal */\nexport const fromEffect = <R, A extends Request.Request<any, any>>(\n  f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>\n): RequestResolver.RequestResolver<A, R> =>\n  makeBatched((requests: RA.NonEmptyArray<A>) =>\n    Effect.forEach(\n      requests,\n      (a) => Effect.flatMap(Effect.exit(f(a)), (e) => complete(a, e as any)),\n      { concurrency: \"unbounded\", discard: true }\n    )\n  ).identified(\"FromEffect\", f)\n\n/** @internal */\nexport const fromEffectTagged = <\n  A extends Request.Request<any, any> & {\n    readonly _tag: string\n  }\n>() =>\n<\n  Fns extends {\n    readonly [Tag in A[\"_tag\"]]: [Extract<A, { readonly _tag: Tag }>] extends [infer Req] ?\n      Req extends Request.Request<infer ReqA, infer ReqE> ?\n        (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any>\n      : never\n      : never\n  }\n>(\n  fns: Fns\n): RequestResolver.RequestResolver<\n  A,\n  ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never\n> =>\n  makeBatched<A, any>((requests: RA.NonEmptyArray<A>) => {\n    const grouped: Record<string, Array<A>> = {}\n    const tags: Array<A[\"_tag\"]> = []\n    for (let i = 0, len = requests.length; i < len; i++) {\n      if (tags.includes(requests[i]._tag)) {\n        grouped[requests[i]._tag].push(requests[i])\n      } else {\n        grouped[requests[i]._tag] = [requests[i]]\n        tags.push(requests[i]._tag)\n      }\n    }\n    return Effect.forEach(\n      tags,\n      (tag) =>\n        Effect.matchCauseEffect((fns[tag] as any)(grouped[tag]) as Effect.Effect<Array<any>, unknown, unknown>, {\n          onFailure: (cause) =>\n            Effect.forEach(grouped[tag], (req) => complete(req, core.exitFail(cause) as any), { discard: true }),\n          onSuccess: (res) =>\n            Effect.forEach(grouped[tag], (req, i) => complete(req, core.exitSucceed(res[i]) as any), { discard: true })\n        }),\n      { concurrency: \"unbounded\", discard: true }\n    )\n  }).identified(\"FromEffectTagged\", fns)\n\n/** @internal */\nexport const never: RequestResolver.RequestResolver<never> = make(() => Effect.never).identified(\"Never\")\n\n/** @internal */\nexport const provideContext = dual<\n  <R>(\n    context: Context.Context<R>\n  ) => <A extends Request.Request<any, any>>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A>,\n  <R, A extends Request.Request<any, any>>(\n    self: RequestResolver.RequestResolver<A, R>,\n    context: Context.Context<R>\n  ) => RequestResolver.RequestResolver<A>\n>(2, (self, context) =>\n  mapInputContext(\n    self,\n    (_: Context.Context<never>) => context\n  ).identified(\"ProvideContext\", self, context))\n\n/** @internal */\nexport const race = dual<\n  <A2 extends Request.Request<any, any>, R2>(\n    that: RequestResolver.RequestResolver<A2, R2>\n  ) => <A extends Request.Request<any, any>, R>(\n    self: RequestResolver.RequestResolver<A, R>\n  ) => RequestResolver.RequestResolver<A | A2, R | R2>,\n  <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>(\n    self: RequestResolver.RequestResolver<A, R>,\n    that: RequestResolver.RequestResolver<A2, R2>\n  ) => RequestResolver.RequestResolver<A | A2, R | R2>\n>(2, <A, R, A2, R2>(\n  self: RequestResolver.RequestResolver<A, R>,\n  that: RequestResolver.RequestResolver<A2, R2>\n) =>\n  new core.RequestResolverImpl((requests) =>\n    Effect.race(\n      self.runAll(requests as Array<Array<Request.Entry<A>>>),\n      that.runAll(requests as Array<Array<Request.Entry<A2>>>)\n    )\n  ).identified(\"Race\", self, that))\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as internal from \"./internal/resource.js\"\nimport type * as Schedule from \"./Schedule.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as ScopedRef from \"./ScopedRef.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ResourceTypeId: unique symbol = internal.ResourceTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ResourceTypeId = typeof ResourceTypeId\n\n/**\n * A `Resource` is a possibly resourceful value that is loaded into memory, and\n * which can be refreshed either manually or automatically.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {\n  /** @internal */\n  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>\n  /** @internal */\n  readonly acquire: Effect.Effect<A, E, Scope.Scope>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ResourceUnify<this>\n  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ResourceUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  Resource?: () => Extract<A[Unify.typeSymbol], Resource<any, any>>\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ResourceUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Resource {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A, in out E> {\n    readonly [ResourceTypeId]: {\n      _A: Types.Invariant<A>\n      _E: Types.Invariant<E>\n    }\n  }\n}\n\n/**\n * Creates a new `Resource` value that is automatically refreshed according to\n * the specified policy. Note that error retrying is not performed\n * automatically, so if you want to retry on errors, you should first apply\n * retry policies to the acquisition effect before passing it to this\n * constructor.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const auto: <A, E, R, Out, R2>(\n  acquire: Effect.Effect<A, E, R>,\n  policy: Schedule.Schedule<Out, unknown, R2>\n) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope> = internal.auto\n\n/**\n * Retrieves the current value stored in the cache.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E> = internal.get\n\n/**\n * Creates a new `Resource` value that must be manually refreshed by calling\n * the refresh method. Note that error retrying is not performed\n * automatically, so if you want to retry on errors, you should first apply\n * retry policies to the acquisition effect before passing it to this\n * constructor.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const manual: <A, E, R>(\n  acquire: Effect.Effect<A, E, R>\n) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R> = internal.manual\n\n/**\n * Refreshes the cache. This method will not return until either the refresh\n * is successful, or the refresh operation fails.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E> = internal.refresh\n", "import type * as Effect from \"../Effect.js\"\nimport { identity, pipe } from \"../Function.js\"\nimport type * as Resource from \"../Resource.js\"\nimport type * as Schedule from \"../Schedule.js\"\nimport type * as Scope from \"../Scope.js\"\nimport * as core from \"./core.js\"\nimport * as effectable from \"./effectable.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\nimport * as schedule_ from \"./schedule.js\"\nimport * as scopedRef from \"./scopedRef.js\"\n\n/** @internal */\nconst ResourceSymbolKey = \"effect/Resource\"\n\n/** @internal */\nexport const ResourceTypeId: Resource.ResourceTypeId = Symbol.for(\n  ResourceSymbolKey\n) as Resource.ResourceTypeId\n\nconst resourceVariance = {\n  /* c8 ignore next */\n  _E: (_: any) => _,\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal  */\nconst proto: ThisType<Resource.Resource<any, any>> = {\n  ...effectable.CommitPrototype,\n  commit() {\n    return get(this)\n  },\n  [ResourceTypeId]: resourceVariance\n}\n\n/** @internal */\nexport const auto = <A, E, R, Out, R2>(\n  acquire: Effect.Effect<A, E, R>,\n  policy: Schedule.Schedule<Out, unknown, R2>\n): Effect.Effect<Resource.Resource<A, E>, never, R | R2 | Scope.Scope> =>\n  core.tap(manual(acquire), (manual) =>\n    fiberRuntime.acquireRelease(\n      pipe(\n        refresh(manual),\n        schedule_.schedule_Effect(policy),\n        core.interruptible,\n        fiberRuntime.forkDaemon\n      ),\n      core.interruptFiber\n    ))\n\n/** @internal */\nexport const manual = <A, E, R>(\n  acquire: Effect.Effect<A, E, R>\n): Effect.Effect<Resource.Resource<A, E>, never, R | Scope.Scope> =>\n  core.flatMap(core.context<R>(), (env) =>\n    pipe(\n      scopedRef.fromAcquire(core.exit(acquire)),\n      core.map((ref) => {\n        const resource = Object.create(proto)\n        resource.scopedRef = ref\n        resource.acquire = core.provideContext(acquire, env)\n        return resource\n      })\n    ))\n\n/** @internal */\nexport const get = <A, E>(self: Resource.Resource<A, E>): Effect.Effect<A, E> =>\n  core.flatMap(scopedRef.get(self.scopedRef), identity)\n\n/** @internal */\nexport const refresh = <A, E>(self: Resource.Resource<A, E>): Effect.Effect<void, E> =>\n  scopedRef.set(\n    self.scopedRef,\n    core.map(self.acquire, core.exitSucceed)\n  )\n", "/**\n * @since 2.0.0\n */\n\nimport type * as Differ from \"./Differ.js\"\nimport * as circular from \"./internal/layer/circular.js\"\nimport * as internal from \"./internal/runtimeFlags.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as RuntimeFlagsPatch from \"./RuntimeFlagsPatch.js\"\n\n/**\n * Represents a set of `RuntimeFlag`s. `RuntimeFlag`s affect the operation of\n * the Effect runtime system. They are exposed to application-level code because\n * they affect the behavior and performance of application code.\n *\n * @since 2.0.0\n * @category models\n */\nexport type RuntimeFlags = number & {\n  readonly RuntimeFlags: unique symbol\n}\n\n/**\n * Represents a flag that can be set to enable or disable a particular feature\n * of the Effect runtime.\n *\n * @since 2.0.0\n * @category models\n */\nexport type RuntimeFlag = number & {\n  readonly RuntimeFlag: unique symbol\n}\n\n/**\n * No runtime flags.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const None: RuntimeFlag = internal.None\n\n/**\n * The interruption flag determines whether or not the Effect runtime system will\n * interrupt a fiber.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const Interruption: RuntimeFlag = internal.Interruption\n\n/**\n * The op supervision flag determines whether or not the Effect runtime system\n * will supervise all operations of the Effect runtime. Use of this flag will\n * negatively impact performance, but is required for some operations, such as\n * profiling.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const OpSupervision: RuntimeFlag = internal.OpSupervision\n\n/**\n * The runtime metrics flag determines whether or not the Effect runtime system\n * will collect metrics about the Effect runtime. Use of this flag will have a\n * very small negative impact on performance, but generates very helpful\n * operational insight into running Effect applications that can be exported to\n * Prometheus or other tools via Effect Metrics.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const RuntimeMetrics: RuntimeFlag = internal.RuntimeMetrics\n\n/**\n * The wind down flag determines whether the Effect runtime system will execute\n * effects in wind-down mode. In wind-down mode, even if interruption is\n * enabled and a fiber has been interrupted, the fiber will continue its\n * execution uninterrupted.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const WindDown: RuntimeFlag = internal.WindDown\n\n/**\n * The cooperative yielding flag determines whether the Effect runtime will\n * yield to another fiber.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const CooperativeYielding: RuntimeFlag = internal.CooperativeYielding\n\n/**\n * Returns `true` if the `CooperativeYielding` `RuntimeFlag` is enabled, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const cooperativeYielding: (self: RuntimeFlags) => boolean = internal.cooperativeYielding\n\n/**\n * Creates a `RuntimeFlagsPatch` which describes the difference between `self`\n * and `that`.\n *\n * @since 2.0.0\n * @category diffing\n */\nexport const diff: {\n  /**\n   * Creates a `RuntimeFlagsPatch` which describes the difference between `self`\n   * and `that`.\n   *\n   * @since 2.0.0\n   * @category diffing\n   */\n  (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch\n  /**\n   * Creates a `RuntimeFlagsPatch` which describes the difference between `self`\n   * and `that`.\n   *\n   * @since 2.0.0\n   * @category diffing\n   */\n  (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch\n} = internal.diff\n\n/**\n * Constructs a differ that knows how to diff `RuntimeFlags` values.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch> = internal.differ\n\n/**\n * Disables the specified `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const disable: {\n  /**\n   * Disables the specified `RuntimeFlag`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags\n  /**\n   * Disables the specified `RuntimeFlag`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags\n} = internal.disable\n\n/**\n * Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const disableAll: {\n  /**\n   * Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags\n  /**\n   * Disables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags\n} = internal.disableAll\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const disableCooperativeYielding: Layer.Layer<never> = circular.disableCooperativeYielding\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const disableInterruption: Layer.Layer<never> = circular.disableInterruption\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const disableOpSupervision: Layer.Layer<never> = circular.disableOpSupervision\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const disableRuntimeMetrics: Layer.Layer<never> = circular.disableRuntimeMetrics\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const disableWindDown: Layer.Layer<never> = circular.disableWindDown\n\n/**\n * Enables the specified `RuntimeFlag`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const enable: {\n  /**\n   * Enables the specified `RuntimeFlag`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags\n  /**\n   * Enables the specified `RuntimeFlag`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags\n} = internal.enable\n\n/**\n * Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const enableAll: {\n  /**\n   * Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags\n  /**\n   * Enables all of the `RuntimeFlag`s in the specified set of `RuntimeFlags`.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags\n} = internal.enableAll\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const enableCooperativeYielding: Layer.Layer<never> = circular.enableCooperativeYielding\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const enableInterruption: Layer.Layer<never> = circular.enableInterruption\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const enableOpSupervision: Layer.Layer<never> = circular.enableOpSupervision\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const enableRuntimeMetrics: Layer.Layer<never> = circular.enableRuntimeMetrics\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const enableWindDown: Layer.Layer<never> = circular.enableWindDown\n\n/**\n * Returns true only if the `Interruption` flag is **enabled** and the\n * `WindDown` flag is **disabled**.\n *\n * A fiber is said to be interruptible if interruption is enabled and the fiber\n * is not in its wind-down phase, in which it takes care of cleanup activities\n * related to fiber shutdown.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const interruptible: (self: RuntimeFlags) => boolean = internal.interruptible\n\n/**\n * Returns `true` if the `Interruption` `RuntimeFlag` is enabled, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const interruption: (self: RuntimeFlags) => boolean = internal.interruption\n\n/**\n * Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEnabled: {\n  /**\n   * Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlag): (self: RuntimeFlags) => boolean\n  /**\n   * Returns `true` if the specified `RuntimeFlag` is enabled, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlags, flag: RuntimeFlag): boolean\n} = internal.isEnabled\n\n/**\n * Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isDisabled: {\n  /**\n   * Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (flag: RuntimeFlag): (self: RuntimeFlags) => boolean\n  /**\n   * Returns `true` if the specified `RuntimeFlag` is disabled, `false` otherwise.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (self: RuntimeFlags, flag: RuntimeFlag): boolean\n} = internal.isDisabled\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (...flags: ReadonlyArray<RuntimeFlag>) => RuntimeFlags = internal.make\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const none: RuntimeFlags = internal.none\n\n/**\n * Returns `true` if the `OpSupervision` `RuntimeFlag` is enabled, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const opSupervision: (self: RuntimeFlags) => boolean = internal.opSupervision\n\n/**\n * Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the\n * patched set of `RuntimeFlag`s.\n *\n * @since 2.0.0\n * @category utils\n */\nexport const patch: {\n  /**\n   * Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the\n   * patched set of `RuntimeFlag`s.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags\n  /**\n   * Patches a set of `RuntimeFlag`s with a `RuntimeFlagsPatch`, returning the\n   * patched set of `RuntimeFlag`s.\n   *\n   * @since 2.0.0\n   * @category utils\n   */\n  (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags\n} = internal.patch\n\n/**\n * Converts the provided `RuntimeFlags` into a `string`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const render: (self: RuntimeFlags) => string = internal.render\n\n/**\n * Returns `true` if the `RuntimeMetrics` `RuntimeFlag` is enabled, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const runtimeMetrics: (self: RuntimeFlags) => boolean = internal.runtimeMetrics\n\n/**\n * Converts the provided `RuntimeFlags` into a `ReadonlySet<number>`.\n *\n * @category conversions\n * @since 2.0.0\n */\nexport const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag> = internal.toSet\n\n/**\n * Returns `true` if the `WindDown` `RuntimeFlag` is enabled, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const windDown: (self: RuntimeFlags) => boolean = internal.windDown\n", "/**\n * @since 2.0.0\n */\nimport * as Cause from \"./Cause.js\"\nimport * as Chunk from \"./Chunk.js\"\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type { TypeLambda } from \"./HKT.js\"\nimport * as core from \"./internal/stm/core.js\"\nimport * as stm from \"./internal/stm/stm.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Predicate, Refinement } from \"./Predicate.js\"\nimport type { Covariant, MergeRecord, NoExcessProperties, NoInfer } from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\nimport type { YieldWrap } from \"./Utils.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const STMTypeId: unique symbol = core.STMTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type STMTypeId = typeof STMTypeId\n\n/**\n * `STM<A, E, R>` represents an effect that can be performed transactionally,\n *  resulting in a failure `E` or a value `A` that may require an environment\n *  `R` to execute.\n *\n * Software Transactional Memory is a technique which allows composition of\n * arbitrary atomic operations.  It is the software analog of transactions in\n * database systems.\n *\n * The API is lifted directly from the Haskell package Control.Concurrent.STM\n * although the implementation does not resemble the Haskell one at all.\n *\n * See http://hackage.haskell.org/package/stm-2.5.0.0/docs/Control-Concurrent-STM.html\n *\n * STM in Haskell was introduced in:\n *\n * Composable memory transactions, by Tim Harris, Simon Marlow, Simon Peyton\n * Jones, and Maurice Herlihy, in ACM Conference on Principles and Practice of\n * Parallel Programming 2005.\n *\n * See https://www.microsoft.com/en-us/research/publication/composable-memory-transactions/\n *\n * See also:\n *  Lock Free Data Structures using STMs in Haskell, by Anthony Discolo, Tim\n *  Harris, Simon Marlow, Simon Peyton Jones, Satnam Singh) FLOPS 2006: Eighth\n *  International Symposium on Functional and Logic Programming, Fuji Susono,\n *  JAPAN, April 2006\n *\n *  https://www.microsoft.com/en-us/research/publication/lock-free-data-structures-using-stms-in-haskell/\n *\n * The implemtation is based on the ZIO STM module, while JS environments have\n * no race conditions from multiple threads STM provides greater benefits for\n * synchronization of Fibers and transactional data-types can be quite useful.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface STM<out A, out E = never, out R = never>\n  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable\n{\n  [Unify.typeSymbol]?: unknown\n  [Unify.unifySymbol]?: STMUnify<this>\n  [Unify.ignoreSymbol]?: STMUnifyIgnore\n  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface STMUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  STM?: () => A[Unify.typeSymbol] extends STM<infer A0, infer E0, infer R0> | infer _ ? STM<A0, E0, R0> : never\n}\n\n/**\n * @category models\n * @since 2.0.0\n */\nexport interface STMUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @category type lambdas\n * @since 2.0.0\n */\nexport interface STMTypeLambda extends TypeLambda {\n  readonly type: STM<this[\"Target\"], this[\"Out1\"], this[\"Out2\"]>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\ndeclare module \"./Context.js\" {\n  interface Tag<Id, Value> extends STM<Value, never, Id> {}\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface Reference<Id, Value> extends STM<Value> {}\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\ndeclare module \"./Either.js\" {\n  interface Left<L, R> extends STM<R, L> {\n    readonly _tag: \"Left\"\n  }\n  interface Right<L, R> extends STM<R, L> {\n    readonly _tag: \"Right\"\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\ndeclare module \"./Option.js\" {\n  interface None<A> extends STM<A, Cause.NoSuchElementException> {\n    readonly _tag: \"None\"\n  }\n  interface Some<A> extends STM<A, Cause.NoSuchElementException> {\n    readonly _tag: \"Some\"\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace STM {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A, out E, out R> {\n    readonly [STMTypeId]: {\n      readonly _A: Covariant<A>\n      readonly _E: Covariant<E>\n      readonly _R: Covariant<R>\n    }\n  }\n}\n\n/**\n * Returns `true` if the provided value is an `STM`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown> = core.isSTM\n\n/**\n * Treats the specified `acquire` transaction as the acquisition of a\n * resource. The `acquire` transaction will be executed interruptibly. If it\n * is a success and is committed the specified `release` workflow will be\n * executed uninterruptibly as soon as the `use` workflow completes execution.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const acquireUseRelease: {\n  /**\n   * Treats the specified `acquire` transaction as the acquisition of a\n   * resource. The `acquire` transaction will be executed interruptibly. If it\n   * is a success and is committed the specified `release` workflow will be\n   * executed uninterruptibly as soon as the `use` workflow completes execution.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, A2, E2, R2, A3, E3, R3>(\n    use: (resource: A) => STM<A2, E2, R2>,\n    release: (resource: A) => STM<A3, E3, R3>\n  ): <E, R>(acquire: STM<A, E, R>) => Effect.Effect<A2, E2 | E3 | E, R2 | R3 | R>\n  /**\n   * Treats the specified `acquire` transaction as the acquisition of a\n   * resource. The `acquire` transaction will be executed interruptibly. If it\n   * is a success and is committed the specified `release` workflow will be\n   * executed uninterruptibly as soon as the `use` workflow completes execution.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R, A2, E2, R2, A3, E3, R3>(\n    acquire: STM<A, E, R>,\n    use: (resource: A) => STM<A2, E2, R2>,\n    release: (resource: A) => STM<A3, E3, R3>\n  ): Effect.Effect<A2, E | E2 | E3, R | R2 | R3>\n} = stm.acquireUseRelease\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport declare namespace All {\n  type STMAny = STM<any, any, any>\n\n  type ReturnTuple<T extends ReadonlyArray<STM<any, any, any>>, Discard extends boolean> = STM<\n    Discard extends true ? void\n      : T[number] extends never ? []\n      : { -readonly [K in keyof T]: [T[K]] extends [STM<infer A, infer _E, infer _R>] ? A : never },\n    T[number] extends never ? never\n      : [T[number]] extends [{ [STMTypeId]: { _E: (_: never) => infer E } }] ? E\n      : never,\n    T[number] extends never ? never\n      : [T[number]] extends [{ [STMTypeId]: { _R: (_: never) => infer R } }] ? R\n      : never\n  > extends infer X ? X : never\n\n  type ReturnIterable<T extends Iterable<STMAny>, Discard extends boolean> = [T] extends\n    [Iterable<STM.Variance<infer A, infer E, infer R>>] ? STM<Discard extends true ? void : Array<A>, E, R> : never\n\n  type ReturnObject<T extends Record<string, STMAny>, Discard extends boolean> = STM<\n    Discard extends true ? void\n      : { -readonly [K in keyof T]: [T[K]] extends [STM.Variance<infer A, infer _E, infer _R>] ? A : never },\n    keyof T extends never ? never\n      : [T[keyof T]] extends [{ [STMTypeId]: { _E: (_: never) => infer E } }] ? E\n      : never,\n    keyof T extends never ? never\n      : [T[keyof T]] extends [{ [STMTypeId]: { _R: (_: never) => infer R } }] ? R\n      : never\n  >\n\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  export type Options = {\n    readonly discard?: boolean | undefined\n  }\n  type IsDiscard<A> = [Extract<A, { readonly discard: true }>] extends [never] ? false : true\n  type Narrow<A> = (A extends [] ? [] : never) | A\n\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  export interface Signature {\n    <\n      Arg extends ReadonlyArray<STMAny> | Iterable<STMAny> | Record<string, STMAny>,\n      O extends NoExcessProperties<Options, O>\n    >(\n      arg: Narrow<Arg>,\n      options?: O\n    ): [Arg] extends [ReadonlyArray<STMAny>] ? ReturnTuple<Arg, IsDiscard<O>>\n      : [Arg] extends [Iterable<STMAny>] ? ReturnIterable<Arg, IsDiscard<O>>\n      : [Arg] extends [Record<string, STMAny>] ? ReturnObject<Arg, IsDiscard<O>>\n      : never\n  }\n}\n\n/**\n * Runs all the provided transactional effects in sequence respecting the\n * structure provided in input.\n *\n * Supports multiple arguments, a single argument tuple / array or record /\n * struct.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const all: All.Signature = stm.all\n\n/**\n * Maps the success value of this effect to the specified constant value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const as: {\n  /**\n   * Maps the success value of this effect to the specified constant value.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>\n  /**\n   * Maps the success value of this effect to the specified constant value.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>\n} = stm.as\n\n/**\n * Maps the success value of this effect to an optional value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R> = stm.asSome\n\n/**\n * Maps the error value of this effect to an optional value.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R> = stm.asSomeError\n\n/**\n * This function maps the success value of an `STM` to `void`. If the original\n * `STM` succeeds, the returned `STM` will also succeed. If the original `STM`\n * fails, the returned `STM` will fail with the same error.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R> = stm.asVoid\n\n/**\n * Creates an `STM` value from a partial (but pure) function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown> = stm.attempt\n\n/**\n * Recovers from all errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchAll: {\n  /**\n   * Recovers from all errors.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>\n  /**\n   * Recovers from all errors.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>\n} = core.catchAll\n\n/**\n * Recovers from some or all of the error cases.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchSome: {\n  /**\n   * Recovers from some or all of the error cases.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>\n  /**\n   * Recovers from some or all of the error cases.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>\n} = stm.catchSome\n\n/**\n * Recovers from the specified tagged error.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchTag: {\n  /**\n   * Recovers from the specified tagged error.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <K extends E[\"_tag\"] & string, E extends { _tag: string }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K }>, R1 | R>\n  /**\n   * Recovers from the specified tagged error.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E extends { _tag: string }, R, K extends E[\"_tag\"] & string, A1, E1, R1>(\n    self: STM<A, E, R>,\n    k: K,\n    f: (e: Extract<E, { _tag: K }>) => STM<A1, E1, R1>\n  ): STM<A | A1, E1 | Exclude<E, { _tag: K }>, R | R1>\n} = stm.catchTag\n\n/**\n * Recovers from multiple tagged errors.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const catchTags: {\n  /**\n   * Recovers from multiple tagged errors.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <\n    E extends { _tag: string },\n    Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => STM<any, any, any>) }\n  >(cases: Cases): <A, R>(\n    self: STM<A, E, R>\n  ) => STM<\n    | A\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never }[keyof Cases],\n    | R\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never }[keyof Cases]\n  >\n  /**\n   * Recovers from multiple tagged errors.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <\n    R,\n    E extends { _tag: string },\n    A,\n    Cases extends { [K in E[\"_tag\"]]+?: ((error: Extract<E, { _tag: K }>) => STM<any, any, any>) }\n  >(self: STM<A, E, R>, cases: Cases): STM<\n    | A\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never }[keyof Cases],\n    | Exclude<E, { _tag: keyof Cases }>\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never }[keyof Cases],\n    | R\n    | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never }[keyof Cases]\n  >\n} = stm.catchTags\n\n/**\n * Checks the condition, and if it's true, returns unit, otherwise, retries.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const check: (predicate: LazyArg<boolean>) => STM<void> = stm.check\n\n/**\n * Simultaneously filters and maps the value produced by this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const collect: {\n  /**\n   * Simultaneously filters and maps the value produced by this effect.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>\n  /**\n   * Simultaneously filters and maps the value produced by this effect.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>\n} = stm.collect\n\n/**\n * Simultaneously filters and maps the value produced by this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const collectSTM: {\n  /**\n   * Simultaneously filters and maps the value produced by this effect.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, A2, E2, R2>(pf: (a: A) => Option.Option<STM<A2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A2, E2 | E, R2 | R>\n  /**\n   * Simultaneously filters and maps the value produced by this effect.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<A2, E2, R2>>): STM<A2, E | E2, R | R2>\n} = stm.collectSTM\n\n/**\n * Commits this transaction atomically.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R> = core.commit\n\n/**\n * Commits this transaction atomically, regardless of whether the transaction\n * is a success or a failure.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const commitEither: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R> = stm.commitEither\n\n/**\n * Similar to Either.cond, evaluate the predicate, return the given A as\n * success if predicate returns true, and the given E as error otherwise\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E> = stm.cond\n\n/**\n * Retrieves the environment inside an stm.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const context: <R>() => STM<Context.Context<R>, never, R> = core.context\n\n/**\n * Accesses the environment of the transaction to perform a transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0> = core.contextWith\n\n/**\n * Accesses the environment of the transaction to perform a transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const contextWithSTM: <R0, A, E, R>(\n  f: (environment: Context.Context<R0>) => STM<A, E, R>\n) => STM<A, E, R0 | R> = core.contextWithSTM\n\n/**\n * Transforms the environment being provided to this effect with the specified\n * function.\n *\n * @since 2.0.0\n * @category context\n */\nexport const mapInputContext: {\n  /**\n   * Transforms the environment being provided to this effect with the specified\n   * function.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>\n  /**\n   * Transforms the environment being provided to this effect with the specified\n   * function.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R0, R>(\n    self: STM<A, E, R>,\n    f: (context: Context.Context<R0>) => Context.Context<R>\n  ): STM<A, E, R0>\n} = core.mapInputContext\n\n/**\n * Fails the transactional effect with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const die: (defect: unknown) => STM<never> = core.die\n\n/**\n * Kills the fiber running the effect with a `Cause.RuntimeException` that\n * contains the specified message.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieMessage: (message: string) => STM<never> = core.dieMessage\n\n/**\n * Fails the transactional effect with the specified lazily evaluated defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieSync: (evaluate: LazyArg<unknown>) => STM<never> = core.dieSync\n\n/**\n * Converts the failure channel into an `Either`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R> = stm.either\n\n/**\n * Executes the specified finalization transaction whether or not this effect\n * succeeds. Note that as with all STM transactions, if the full transaction\n * fails, everything will be rolled back.\n *\n * @since 2.0.0\n * @category finalization\n */\nexport const ensuring: {\n  /**\n   * Executes the specified finalization transaction whether or not this effect\n   * succeeds. Note that as with all STM transactions, if the full transaction\n   * fails, everything will be rolled back.\n   *\n   * @since 2.0.0\n   * @category finalization\n   */\n  <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>\n  /**\n   * Executes the specified finalization transaction whether or not this effect\n   * succeeds. Note that as with all STM transactions, if the full transaction\n   * fails, everything will be rolled back.\n   *\n   * @since 2.0.0\n   * @category finalization\n   */\n  <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>\n} = core.ensuring\n\n/**\n * Returns an effect that ignores errors and runs repeatedly until it\n * eventually succeeds.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R> = stm.eventually\n\n/**\n * Determines whether all elements of the `Iterable<A>` satisfy the effectual\n * predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const every: {\n  /**\n   * Determines whether all elements of the `Iterable<A>` satisfy the effectual\n   * predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>\n  /**\n   * Determines whether all elements of the `Iterable<A>` satisfy the effectual\n   * predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>\n} = stm.every\n\n/**\n * Determines whether any element of the `Iterable[A]` satisfies the effectual\n * predicate `f`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const exists: {\n  /**\n   * Determines whether any element of the `Iterable[A]` satisfies the effectual\n   * predicate `f`.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>\n  /**\n   * Determines whether any element of the `Iterable[A]` satisfies the effectual\n   * predicate `f`.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>\n} = stm.exists\n\n/**\n * Fails the transactional effect with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail: <E>(error: E) => STM<never, E> = core.fail\n\n/**\n * Fails the transactional effect with the specified lazily evaluated error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E> = core.failSync\n\n/**\n * Returns the fiber id of the fiber committing the transaction.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fiberId: STM<FiberId.FiberId> = stm.fiberId\n\n/**\n * Filters the collection using the specified effectual predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const filter: {\n  /**\n   * Filters the collection using the specified effectual predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>\n  /**\n   * Filters the collection using the specified effectual predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>\n} = stm.filter\n\n/**\n * Filters the collection using the specified effectual predicate, removing\n * all elements that satisfy the predicate.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const filterNot: {\n  /**\n   * Filters the collection using the specified effectual predicate, removing\n   * all elements that satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>\n  /**\n   * Filters the collection using the specified effectual predicate, removing\n   * all elements that satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>\n} = stm.filterNot\n\n/**\n * Dies with specified defect if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrDie: {\n  /**\n   * Dies with specified defect if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>\n  /**\n   * Dies with specified defect if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Dies with specified defect if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>\n  /**\n   * Dies with specified defect if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>\n} = stm.filterOrDie\n\n/**\n * Dies with a `Cause.RuntimeException` having the specified  message if the\n * predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrDieMessage: {\n  /**\n   * Dies with a `Cause.RuntimeException` having the specified  message if the\n   * predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>\n  /**\n   * Dies with a `Cause.RuntimeException` having the specified  message if the\n   * predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Dies with a `Cause.RuntimeException` having the specified  message if the\n   * predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>\n  /**\n   * Dies with a `Cause.RuntimeException` having the specified  message if the\n   * predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>\n} = stm.filterOrDieMessage\n\n/**\n * Supplies `orElse` if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrElse: {\n  /**\n   * Supplies `orElse` if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A, C, E2, R2>(\n    refinement: Refinement<NoInfer<A>, B>,\n    orElse: (a: NoInfer<A>) => STM<C, E2, R2>\n  ): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>\n  /**\n   * Supplies `orElse` if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B, E2, R2>(\n    predicate: Predicate<NoInfer<A>>,\n    orElse: (a: NoInfer<A>) => STM<B, E2, R2>\n  ): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>\n  /**\n   * Supplies `orElse` if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, B extends A, C, E2, R2>(\n    self: STM<A, E, R>,\n    refinement: Refinement<A, B>,\n    orElse: (a: A) => STM<C, E2, R2>\n  ): STM<B | C, E | E2, R | R2>\n  /**\n   * Supplies `orElse` if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, B, E2, R2>(\n    self: STM<A, E, R>,\n    predicate: Predicate<A>,\n    orElse: (a: A) => STM<B, E2, R2>\n  ): STM<A | B, E | E2, R | R2>\n} = stm.filterOrElse\n\n/**\n * Fails with the specified error if the predicate fails.\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterOrFail: {\n  /**\n   * Fails with the specified error if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>\n  /**\n   * Fails with the specified error if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>\n  /**\n   * Fails with the specified error if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>\n  /**\n   * Fails with the specified error if the predicate fails.\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>\n} = stm.filterOrFail\n\n/**\n * Feeds the value produced by this effect to the specified function, and then\n * runs the returned effect as well to produce its results.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatMap: {\n  /**\n   * Feeds the value produced by this effect to the specified function, and then\n   * runs the returned effect as well to produce its results.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>\n  /**\n   * Feeds the value produced by this effect to the specified function, and then\n   * runs the returned effect as well to produce its results.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>\n} = core.flatMap\n\n/**\n * Flattens out a nested `STM` effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R> = stm.flatten\n\n/**\n * Flips the success and failure channels of this transactional effect. This\n * allows you to use all methods on the error channel, possibly before\n * flipping back.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R> = stm.flip\n\n/**\n * Swaps the error/value parameters, applies the function `f` and flips the\n * parameters back\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const flipWith: {\n  /**\n   * Swaps the error/value parameters, applies the function `f` and flips the\n   * parameters back\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>\n  /**\n   * Swaps the error/value parameters, applies the function `f` and flips the\n   * parameters back\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>\n} = stm.flipWith\n\n/**\n * Folds over the `STM` effect, handling both failure and success, but not\n * retry.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds over the `STM` effect, handling both failure and success, but not\n   * retry.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <E, A2, A, A3>(\n    options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3 }\n  ): <R>(self: STM<A, E, R>) => STM<A2 | A3, never, R>\n  /**\n   * Folds over the `STM` effect, handling both failure and success, but not\n   * retry.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, R, A2, A3>(\n    self: STM<A, E, R>,\n    options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3 }\n  ): STM<A2 | A3, never, R>\n} = stm.match\n\n/**\n * Effectfully folds over the `STM` effect, handling both failure and success.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const matchSTM: {\n  /**\n   * Effectfully folds over the `STM` effect, handling both failure and success.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <E, A1, E1, R1, A, A2, E2, R2>(\n    options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2> }\n  ): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>\n  /**\n   * Effectfully folds over the `STM` effect, handling both failure and success.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, E, R, A1, E1, R1, A2, E2, R2>(\n    self: STM<A, E, R>,\n    options: { readonly onFailure: (e: E) => STM<A1, E1, R1>; readonly onSuccess: (a: A) => STM<A2, E2, R2> }\n  ): STM<A1 | A2, E1 | E2, R | R1 | R2>\n} = core.matchSTM\n\n/**\n * Applies the function `f` to each element of the `Iterable<A>` and returns\n * a transactional effect that produces a new `Chunk<A2>`.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * Applies the function `f` to each element of the `Iterable<A>` and returns\n   * a transactional effect that produces a new `Chunk<A2>`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(\n    f: (a: A) => STM<A2, E, R>,\n    options?: { readonly discard?: false | undefined } | undefined\n  ): (elements: Iterable<A>) => STM<Array<A2>, E, R>\n  /**\n   * Applies the function `f` to each element of the `Iterable<A>` and returns\n   * a transactional effect that produces a new `Chunk<A2>`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true }): (elements: Iterable<A>) => STM<void, E, R>\n  /**\n   * Applies the function `f` to each element of the `Iterable<A>` and returns\n   * a transactional effect that produces a new `Chunk<A2>`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(\n    elements: Iterable<A>,\n    f: (a: A) => STM<A2, E, R>,\n    options?: { readonly discard?: false | undefined } | undefined\n  ): STM<Array<A2>, E, R>\n  /**\n   * Applies the function `f` to each element of the `Iterable<A>` and returns\n   * a transactional effect that produces a new `Chunk<A2>`.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(\n    elements: Iterable<A>,\n    f: (a: A) => STM<A2, E, R>,\n    options: { readonly discard: true }\n  ): STM<void, E, R>\n} = stm.forEach\n\n/**\n * Lifts an `Either` into a `STM`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E> = stm.fromEither\n\n/**\n * Lifts an `Option` into a `STM`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>> = stm.fromOption\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Adapter {\n  <A, E, R>(self: STM<A, E, R>): STM<A, E, R>\n  <A, _R, _E, _A>(a: A, ab: (a: A) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, _R, _E, _A>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => STM<_A, _E, _R>): STM<_A, _E, _R>\n  <A, B, C, D, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: F) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (g: H) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n  <A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, _R, _E, _A>(\n    a: A,\n    ab: (a: A) => B,\n    bc: (b: B) => C,\n    cd: (c: C) => D,\n    de: (d: D) => E,\n    ef: (e: E) => F,\n    fg: (f: F) => G,\n    gh: (g: G) => H,\n    hi: (h: H) => I,\n    ij: (i: I) => J,\n    jk: (j: J) => K,\n    kl: (k: K) => L,\n    lm: (l: L) => M,\n    mn: (m: M) => N,\n    no: (n: N) => O,\n    op: (o: O) => P,\n    pq: (p: P) => Q,\n    qr: (q: Q) => R,\n    rs: (r: R) => S,\n    st: (s: S) => T,\n    tu: (s: T) => STM<_A, _E, _R>\n  ): STM<_A, _E, _R>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const gen: <Self, Eff extends YieldWrap<STM<any, any, any>>, AEff>(\n  ...args:\n    | [\n      self: Self,\n      body: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>\n    ]\n    | [body: (resume: Adapter) => Generator<Eff, AEff, never>]\n) => STM<\n  AEff,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer E, infer _R>>] ? E : never,\n  [Eff] extends [never] ? never : [Eff] extends [YieldWrap<STM<infer _A, infer _E, infer R>>] ? R : never\n> = stm.gen\n\n/**\n * Returns a successful effect with the head of the list if the list is\n * non-empty or fails with the error `None` if the list is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R> = stm.head\n\nconst if_: {\n  <A, E1, R1, A2, E2, R2>(options: {\n    readonly onTrue: STM<A, E1, R1>\n    readonly onFalse: STM<A2, E2, R2> /**\n     * Flattens out a nested `STM` effect.\n     *\n     * @since 2.0.0\n     * @category sequencing\n     */\n  }): <E = never, R = never>(self: boolean | STM<boolean, E, R>) => STM<A | A2, E1 | E2 | E, R1 | R2 | R>\n  <A, E1, R1, A2, E2, R2, E = never, R = never>(\n    self: boolean,\n    options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2> }\n  ): STM<A | A2, E1 | E2 | E, R1 | R2 | R>\n  <E, R, A, E1, R1, A2, E2, R2>(\n    self: STM<boolean, E, R>,\n    options: { readonly onTrue: STM<A, E1, R1>; readonly onFalse: STM<A2, E2, R2> }\n  ): STM<A | A2, E | E1 | E2, R | R1 | R2>\n} = stm.if_\n\nexport {\n  /**\n   * Runs `onTrue` if the result of `b` is `true` and `onFalse` otherwise.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  if_ as if\n}\n\n/**\n * Returns a new effect that ignores the success or failure of this effect.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R> = stm.ignore\n\n/**\n * Interrupts the fiber running the effect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interrupt: STM<never> = core.interrupt\n\n/**\n * Interrupts the fiber running the effect with the specified `FiberId`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const interruptAs: (fiberId: FiberId.FiberId) => STM<never> = core.interruptAs\n\n/**\n * Returns whether this transactional effect is a failure.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R> = stm.isFailure\n\n/**\n * Returns whether this transactional effect is a success.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R> = stm.isSuccess\n\n/**\n * Iterates with the specified transactional function. The moral equivalent\n * of:\n *\n * ```ts skip-type-checking\n * const s = initial\n *\n * while (cont(s)) {\n *   s = body(s)\n * }\n *\n * return s\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const iterate: <Z, E, R>(\n  initial: Z,\n  options: {\n    readonly while: Predicate<Z>\n    readonly body: (z: Z) => STM<Z, E, R>\n  }\n) => STM<Z, E, R> = stm.iterate\n\n/**\n * Loops with the specified transactional function, collecting the results\n * into a list. The moral equivalent of:\n *\n * ```ts skip-type-checking\n * const as = []\n * let s  = initial\n *\n * while (cont(s)) {\n *   as.push(body(s))\n *   s  = inc(s)\n * }\n *\n * return as\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const loop: {\n  /**\n   * Loops with the specified transactional function, collecting the results\n   * into a list. The moral equivalent of:\n   *\n   * ```ts skip-type-checking\n   * const as = []\n   * let s  = initial\n   *\n   * while (cont(s)) {\n   *   as.push(body(s))\n   *   s  = inc(s)\n   * }\n   *\n   * return as\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Z, A, E, R>(\n    initial: Z,\n    options: {\n      readonly while: (z: Z) => boolean\n      readonly step: (z: Z) => Z\n      readonly body: (z: Z) => STM<A, E, R>\n      readonly discard?: false | undefined\n    }\n  ): STM<Array<A>, E, R>\n  /**\n   * Loops with the specified transactional function, collecting the results\n   * into a list. The moral equivalent of:\n   *\n   * ```ts skip-type-checking\n   * const as = []\n   * let s  = initial\n   *\n   * while (cont(s)) {\n   *   as.push(body(s))\n   *   s  = inc(s)\n   * }\n   *\n   * return as\n   * ```\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <Z, A, E, R>(\n    initial: Z,\n    options: {\n      readonly while: (z: Z) => boolean\n      readonly step: (z: Z) => Z\n      readonly body: (z: Z) => STM<A, E, R>\n      readonly discard: true\n    }\n  ): STM<void, E, R>\n} = stm.loop\n\n/**\n * Maps the value produced by the effect.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Maps the value produced by the effect.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>\n  /**\n   * Maps the value produced by the effect.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>\n} = core.map\n\n/**\n * Maps the value produced by the effect with the specified function that may\n * throw exceptions but is otherwise pure, translating any thrown exceptions\n * into typed failed effects.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapAttempt: {\n  /**\n   * Maps the value produced by the effect with the specified function that may\n   * throw exceptions but is otherwise pure, translating any thrown exceptions\n   * into typed failed effects.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>\n  /**\n   * Maps the value produced by the effect with the specified function that may\n   * throw exceptions but is otherwise pure, translating any thrown exceptions\n   * into typed failed effects.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>\n} = stm.mapAttempt\n\n/**\n * Returns an `STM` effect whose failure and success channels have been mapped\n * by the specified pair of functions, `f` and `g`.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapBoth: {\n  /**\n   * Returns an `STM` effect whose failure and success channels have been mapped\n   * by the specified pair of functions, `f` and `g`.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, E2, A, A2>(\n    options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2 }\n  ): <R>(self: STM<A, E, R>) => STM<A2, E2, R>\n  /**\n   * Returns an `STM` effect whose failure and success channels have been mapped\n   * by the specified pair of functions, `f` and `g`.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, R, E2, A2>(\n    self: STM<A, E, R>,\n    options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2 }\n  ): STM<A2, E2, R>\n} = stm.mapBoth\n\n/**\n * Maps from one error type to another.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const mapError: {\n  /**\n   * Maps from one error type to another.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>\n  /**\n   * Maps from one error type to another.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>\n} = stm.mapError\n\n/**\n * Returns a new effect where the error channel has been merged into the\n * success channel to their common combined type.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R> = stm.merge\n\n/**\n * Merges an `Iterable<STM>` to a single `STM`, working sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const mergeAll: {\n  /**\n   * Merges an `Iterable<STM>` to a single `STM`, working sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>\n  /**\n   * Merges an `Iterable<STM>` to a single `STM`, working sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>\n} = stm.mergeAll\n\n/**\n * Returns a new effect where boolean value of this effect is negated.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R> = stm.negate\n\n/**\n * Requires the option produced by this value to be `None`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const none: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<void, Option.Option<E>, R> = stm.none\n\n/**\n * Converts the failure channel into an `Option`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R> = stm.option\n\n/**\n * Translates `STM` effect failure into death of the fiber, making all\n * failures unchecked and not a part of the type of the effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R> = stm.orDie\n\n/**\n * Keeps none of the errors, and terminates the fiber running the `STM` effect\n * with them, using the specified function to convert the `E` into a defect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orDieWith: {\n  /**\n   * Keeps none of the errors, and terminates the fiber running the `STM` effect\n   * with them, using the specified function to convert the `E` into a defect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>\n  /**\n   * Keeps none of the errors, and terminates the fiber running the `STM` effect\n   * with them, using the specified function to convert the `E` into a defect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>\n} = stm.orDieWith\n\n/**\n * Tries this effect first, and if it fails or retries, tries the other\n * effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElse: {\n  /**\n   * Tries this effect first, and if it fails or retries, tries the other\n   * effect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>\n  /**\n   * Tries this effect first, and if it fails or retries, tries the other\n   * effect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>\n} = stm.orElse\n\n/**\n * Returns a transactional effect that will produce the value of this effect\n * in left side, unless it fails or retries, in which case, it will produce\n * the value of the specified effect in right side.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseEither: {\n  /**\n   * Returns a transactional effect that will produce the value of this effect\n   * in left side, unless it fails or retries, in which case, it will produce\n   * the value of the specified effect in right side.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>\n  /**\n   * Returns a transactional effect that will produce the value of this effect\n   * in left side, unless it fails or retries, in which case, it will produce\n   * the value of the specified effect in right side.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>\n} = stm.orElseEither\n\n/**\n * Tries this effect first, and if it fails or retries, fails with the\n * specified error.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseFail: {\n  /**\n   * Tries this effect first, and if it fails or retries, fails with the\n   * specified error.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>\n  /**\n   * Tries this effect first, and if it fails or retries, fails with the\n   * specified error.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>\n} = stm.orElseFail\n\n/**\n * Returns an effect that will produce the value of this effect, unless it\n * fails with the `None` value, in which case it will produce the value of the\n * specified effect.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseOptional: {\n  /**\n   * Returns an effect that will produce the value of this effect, unless it\n   * fails with the `None` value, in which case it will produce the value of the\n   * specified effect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>\n  /**\n   * Returns an effect that will produce the value of this effect, unless it\n   * fails with the `None` value, in which case it will produce the value of the\n   * specified effect.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A2, E2, R2>(\n    self: STM<A, Option.Option<E>, R>,\n    that: LazyArg<STM<A2, Option.Option<E2>, R2>>\n  ): STM<A | A2, Option.Option<E | E2>, R | R2>\n} = stm.orElseOptional\n\n/**\n * Tries this effect first, and if it fails or retries, succeeds with the\n * specified value.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orElseSucceed: {\n  /**\n   * Tries this effect first, and if it fails or retries, succeeds with the\n   * specified value.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>\n  /**\n   * Tries this effect first, and if it fails or retries, succeeds with the\n   * specified value.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>\n} = stm.orElseSucceed\n\n/**\n * Tries this effect first, and if it enters retry, then it tries the other\n * effect. This is an equivalent of Haskell's orElse.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const orTry: {\n  /**\n   * Tries this effect first, and if it enters retry, then it tries the other\n   * effect. This is an equivalent of Haskell's orElse.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>\n  /**\n   * Tries this effect first, and if it enters retry, then it tries the other\n   * effect. This is an equivalent of Haskell's orElse.\n   *\n   * @since 2.0.0\n   * @category error handling\n   */\n  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>\n} = core.orTry\n\n/**\n * Feeds elements of type `A` to a function `f` that returns an effect.\n * Collects all successes and failures in a tupled fashion.\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const partition: {\n  /**\n   * Feeds elements of type `A` to a function `f` that returns an effect.\n   * Collects all successes and failures in a tupled fashion.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>\n  /**\n   * Feeds elements of type `A` to a function `f` that returns an effect.\n   * Collects all successes and failures in a tupled fashion.\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>\n} = stm.partition\n\n/**\n * Provides the transaction its required environment, which eliminates its\n * dependency on `R`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideContext: {\n  /**\n   * Provides the transaction its required environment, which eliminates its\n   * dependency on `R`.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>\n  /**\n   * Provides the transaction its required environment, which eliminates its\n   * dependency on `R`.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>\n} = stm.provideContext\n\n/**\n * Splits the context into two parts, providing one part using the\n * specified layer and leaving the remainder `R0`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideSomeContext: {\n  /**\n   * Splits the context into two parts, providing one part using the\n   * specified layer and leaving the remainder `R0`.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>\n  /**\n   * Splits the context into two parts, providing one part using the\n   * specified layer and leaving the remainder `R0`.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>\n} = stm.provideSomeContext\n\n/**\n * Provides the effect with the single service it requires. If the transactional\n * effect requires more than one service use `provideEnvironment` instead.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideService: {\n  /**\n   * Provides the effect with the single service it requires. If the transactional\n   * effect requires more than one service use `provideEnvironment` instead.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>\n  /**\n   * Provides the effect with the single service it requires. If the transactional\n   * effect requires more than one service use `provideEnvironment` instead.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>\n} = stm.provideService\n\n/**\n * Provides the effect with the single service it requires. If the transactional\n * effect requires more than one service use `provideEnvironment` instead.\n *\n * @since 2.0.0\n * @category context\n */\nexport const provideServiceSTM: {\n  /**\n   * Provides the effect with the single service it requires. If the transactional\n   * effect requires more than one service use `provideEnvironment` instead.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>\n  /**\n   * Provides the effect with the single service it requires. If the transactional\n   * effect requires more than one service use `provideEnvironment` instead.\n   *\n   * @since 2.0.0\n   * @category context\n   */\n  <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>\n} = stm.provideServiceSTM\n\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from left to right.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduce: {\n  /**\n   * Folds an `Iterable<A>` using an effectual function f, working sequentially\n   * from left to right.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>\n  /**\n   * Folds an `Iterable<A>` using an effectual function f, working sequentially\n   * from left to right.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>\n} = stm.reduce\n\n/**\n * Reduces an `Iterable<STM>` to a single `STM`, working sequentially.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduceAll: {\n  /**\n   * Reduces an `Iterable<STM>` to a single `STM`, working sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>\n  /**\n   * Reduces an `Iterable<STM>` to a single `STM`, working sequentially.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R, E2, R2>(\n    iterable: Iterable<STM<A, E, R>>,\n    initial: STM<A, E2, R2>,\n    f: (x: A, y: A) => A\n  ): STM<A, E | E2, R | R2>\n} = stm.reduceAll\n\n/**\n * Folds an `Iterable<A>` using an effectual function f, working sequentially\n * from right to left.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const reduceRight: {\n  /**\n   * Folds an `Iterable<A>` using an effectual function f, working sequentially\n   * from right to left.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>\n  /**\n   * Folds an `Iterable<A>` using an effectual function f, working sequentially\n   * from right to left.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>\n} = stm.reduceRight\n\n/**\n * Keeps some of the errors, and terminates the fiber with the rest.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const refineOrDie: {\n  /**\n   * Keeps some of the errors, and terminates the fiber with the rest.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>\n  /**\n   * Keeps some of the errors, and terminates the fiber with the rest.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>\n} = stm.refineOrDie\n\n/**\n * Keeps some of the errors, and terminates the fiber with the rest, using the\n * specified function to convert the `E` into a `Throwable`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const refineOrDieWith: {\n  /**\n   * Keeps some of the errors, and terminates the fiber with the rest, using the\n   * specified function to convert the `E` into a `Throwable`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>\n  /**\n   * Keeps some of the errors, and terminates the fiber with the rest, using the\n   * specified function to convert the `E` into a `Throwable`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2>(\n    self: STM<A, E, R>,\n    pf: (error: E) => Option.Option<E2>,\n    f: (error: E) => unknown\n  ): STM<A, E2, R>\n} = stm.refineOrDieWith\n\n/**\n * Fail with the returned value if the `PartialFunction` matches, otherwise\n * continue with our held value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const reject: {\n  /**\n   * Fail with the returned value if the `PartialFunction` matches, otherwise\n   * continue with our held value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>\n  /**\n   * Fail with the returned value if the `PartialFunction` matches, otherwise\n   * continue with our held value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>\n} = stm.reject\n\n/**\n * Continue with the returned computation if the specified partial function\n * matches, translating the successful match into a failure, otherwise continue\n * with our held value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const rejectSTM: {\n  /**\n   * Continue with the returned computation if the specified partial function\n   * matches, translating the successful match into a failure, otherwise continue\n   * with our held value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>\n  /**\n   * Continue with the returned computation if the specified partial function\n   * matches, translating the successful match into a failure, otherwise continue\n   * with our held value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>\n} = stm.rejectSTM\n\n/**\n * Repeats this `STM` effect until its result satisfies the specified\n * predicate.\n *\n * **WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\n * consume a thread until it completes (it cannot yield). This is because STM\n * describes a single atomic transaction which must either complete, retry or\n * fail a transaction before yielding back to the Effect runtime.\n *   - Use `retryUntil` instead if you don't need to maintain transaction\n *     state for repeats.\n *   - Ensure repeating the STM effect will eventually satisfy the predicate.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const repeatUntil: {\n  /**\n   * Repeats this `STM` effect until its result satisfies the specified\n   * predicate.\n   *\n   * **WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\n   * consume a thread until it completes (it cannot yield). This is because STM\n   * describes a single atomic transaction which must either complete, retry or\n   * fail a transaction before yielding back to the Effect runtime.\n   *   - Use `retryUntil` instead if you don't need to maintain transaction\n   *     state for repeats.\n   *   - Ensure repeating the STM effect will eventually satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Repeats this `STM` effect until its result satisfies the specified\n   * predicate.\n   *\n   * **WARNING**: `repeatUntil` uses a busy loop to repeat the effect and will\n   * consume a thread until it completes (it cannot yield). This is because STM\n   * describes a single atomic transaction which must either complete, retry or\n   * fail a transaction before yielding back to the Effect runtime.\n   *   - Use `retryUntil` instead if you don't need to maintain transaction\n   *     state for repeats.\n   *   - Ensure repeating the STM effect will eventually satisfy the predicate.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>\n} = stm.repeatUntil\n\n/**\n * Repeats this `STM` effect while its result satisfies the specified\n * predicate.\n *\n * **WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\n * consume a thread until it completes (it cannot yield). This is because STM\n * describes a single atomic transaction which must either complete, retry or\n * fail a transaction before yielding back to the Effect runtime.\n *   - Use `retryWhile` instead if you don't need to maintain transaction\n *     state for repeats.\n *   - Ensure repeating the STM effect will eventually not satisfy the\n *     predicate.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const repeatWhile: {\n  /**\n   * Repeats this `STM` effect while its result satisfies the specified\n   * predicate.\n   *\n   * **WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\n   * consume a thread until it completes (it cannot yield). This is because STM\n   * describes a single atomic transaction which must either complete, retry or\n   * fail a transaction before yielding back to the Effect runtime.\n   *   - Use `retryWhile` instead if you don't need to maintain transaction\n   *     state for repeats.\n   *   - Ensure repeating the STM effect will eventually not satisfy the\n   *     predicate.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Repeats this `STM` effect while its result satisfies the specified\n   * predicate.\n   *\n   * **WARNING**: `repeatWhile` uses a busy loop to repeat the effect and will\n   * consume a thread until it completes (it cannot yield). This is because STM\n   * describes a single atomic transaction which must either complete, retry or\n   * fail a transaction before yielding back to the Effect runtime.\n   *   - Use `retryWhile` instead if you don't need to maintain transaction\n   *     state for repeats.\n   *   - Ensure repeating the STM effect will eventually not satisfy the\n   *     predicate.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>\n} = stm.repeatWhile\n\n/**\n * Replicates the given effect n times. If 0 or negative numbers are given, an\n * empty `Chunk` will be returned.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicate: {\n  /**\n   * Replicates the given effect n times. If 0 or negative numbers are given, an\n   * empty `Chunk` will be returned.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>\n  /**\n   * Replicates the given effect n times. If 0 or negative numbers are given, an\n   * empty `Chunk` will be returned.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>\n} = stm.replicate\n\n/**\n * Performs this transaction the specified number of times and collects the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicateSTM: {\n  /**\n   * Performs this transaction the specified number of times and collects the\n   * results.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>\n  /**\n   * Performs this transaction the specified number of times and collects the\n   * results.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>\n} = stm.replicateSTM\n\n/**\n * Performs this transaction the specified number of times, discarding the\n * results.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const replicateSTMDiscard: {\n  /**\n   * Performs this transaction the specified number of times, discarding the\n   * results.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>\n  /**\n   * Performs this transaction the specified number of times, discarding the\n   * results.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>\n} = stm.replicateSTMDiscard\n\n/**\n * Abort and retry the whole transaction when any of the underlying\n * transactional variables have changed.\n *\n * @since 2.0.0\n * @category error handling\n */\nexport const retry: STM<never> = core.retry\n\n/**\n * Filters the value produced by this effect, retrying the transaction until\n * the predicate returns `true` for the value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retryUntil: {\n  /**\n   * Filters the value produced by this effect, retrying the transaction until\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>\n  /**\n   * Filters the value produced by this effect, retrying the transaction until\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Filters the value produced by this effect, retrying the transaction until\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>\n  /**\n   * Filters the value produced by this effect, retrying the transaction until\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>\n} = stm.retryUntil\n\n/**\n * Filters the value produced by this effect, retrying the transaction while\n * the predicate returns `true` for the value.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retryWhile: {\n  /**\n   * Filters the value produced by this effect, retrying the transaction while\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>\n  /**\n   * Filters the value produced by this effect, retrying the transaction while\n   * the predicate returns `true` for the value.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>\n} = stm.retryWhile\n\n/**\n * Converts an option on values into an option on errors.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R> = stm.some\n\n/**\n * Returns an `STM` effect that succeeds with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeed: <A>(value: A) => STM<A> = core.succeed\n\n/**\n * Returns an effect with the empty value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeedNone: STM<Option.Option<never>> = stm.succeedNone\n\n/**\n * Returns an effect with the optional value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const succeedSome: <A>(value: A) => STM<Option.Option<A>> = stm.succeedSome\n\n/**\n * Summarizes a `STM` effect by computing a provided value before and after\n * execution, and then combining the values to produce a summary, together\n * with the result of execution.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const summarized: {\n  /**\n   * Summarizes a `STM` effect by computing a provided value before and after\n   * execution, and then combining the values to produce a summary, together\n   * with the result of execution.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A2, E2, R2, A3>(summary: STM<A2, E2, R2>, f: (before: A2, after: A2) => A3): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>\n  /**\n   * Summarizes a `STM` effect by computing a provided value before and after\n   * execution, and then combining the values to produce a summary, together\n   * with the result of execution.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, A2, E2, R2, A3>(\n    self: STM<A, E, R>,\n    summary: STM<A2, E2, R2>,\n    f: (before: A2, after: A2) => A3\n  ): STM<[A3, A], E | E2, R | R2>\n} = stm.summarized\n\n/**\n * Suspends creation of the specified transaction lazily.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R> = stm.suspend\n\n/**\n * Returns an `STM` effect that succeeds with the specified lazily evaluated\n * value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const sync: <A>(evaluate: () => A) => STM<A> = core.sync\n\n/**\n * \"Peeks\" at the success of transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tap: {\n  /**\n   * \"Peeks\" at the success of transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>\n  /**\n   * \"Peeks\" at the success of transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>\n} = stm.tap\n\n/**\n * \"Peeks\" at both sides of an transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tapBoth: {\n  /**\n   * \"Peeks\" at both sides of an transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(\n    options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3> }\n  ): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>\n  /**\n   * \"Peeks\" at both sides of an transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(\n    self: STM<A, E, R>,\n    options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3> }\n  ): STM<A, E | E2 | E3, R | R2 | R3>\n} = stm.tapBoth\n\n/**\n * \"Peeks\" at the error of the transactional effect.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tapError: {\n  /**\n   * \"Peeks\" at the error of the transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>\n  /**\n   * \"Peeks\" at the error of the transactional effect.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>\n} = stm.tapError\n\nconst try_: {\n  <A, E>(options: {\n    readonly try: LazyArg<A>\n    readonly catch: (u: unknown) => E\n  }): STM<A, E>\n  <A>(try_: LazyArg<A>): STM<A, unknown>\n} = stm.try_\n\nexport {\n  /**\n   * Imports a synchronous side-effect into a pure value, translating any thrown\n   * exceptions into typed failed effects.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  try_ as try\n}\n\n/**\n * The moral equivalent of `if (!p) exp`\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const unless: {\n  /**\n   * The moral equivalent of `if (!p) exp`\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>\n  /**\n   * The moral equivalent of `if (!p) exp`\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>\n} = stm.unless\n\n/**\n * The moral equivalent of `if (!p) exp` when `p` has side-effects\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const unlessSTM: {\n  /**\n   * The moral equivalent of `if (!p) exp` when `p` has side-effects\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>\n  /**\n   * The moral equivalent of `if (!p) exp` when `p` has side-effects\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>\n} = stm.unlessSTM\n\n/**\n * Converts an option on errors into an option on values.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R> = stm.unsome\n\nconst void_: STM<void> = stm.void\nexport {\n  /**\n   * Returns an `STM` effect that succeeds with `void`.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  void_ as void\n}\n\n/**\n * Feeds elements of type `A` to `f` and accumulates all errors in error\n * channel or successes in success channel.\n *\n * This combinator is lossy meaning that if there are errors all successes\n * will be lost. To retain all information please use `STM.partition`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const validateAll: {\n  /**\n   * Feeds elements of type `A` to `f` and accumulates all errors in error\n   * channel or successes in success channel.\n   *\n   * This combinator is lossy meaning that if there are errors all successes\n   * will be lost. To retain all information please use `STM.partition`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>\n  /**\n   * Feeds elements of type `A` to `f` and accumulates all errors in error\n   * channel or successes in success channel.\n   *\n   * This combinator is lossy meaning that if there are errors all successes\n   * will be lost. To retain all information please use `STM.partition`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>\n} = stm.validateAll\n\n/**\n * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n * or the accumulation of all errors.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const validateFirst: {\n  /**\n   * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n   * or the accumulation of all errors.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>\n  /**\n   * Feeds elements of type `A` to `f` until it succeeds. Returns first success\n   * or the accumulation of all errors.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>\n} = stm.validateFirst\n\n/**\n * The moral equivalent of `if (p) exp`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const when: {\n  /**\n   * The moral equivalent of `if (p) exp`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>\n  /**\n   * The moral equivalent of `if (p) exp`.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>\n} = stm.when\n\n/**\n * The moral equivalent of `if (p) exp` when `p` has side-effects.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const whenSTM: {\n  /**\n   * The moral equivalent of `if (p) exp` when `p` has side-effects.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>\n  /**\n   * The moral equivalent of `if (p) exp` when `p` has side-effects.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>\n} = stm.whenSTM\n\n/**\n * Sequentially zips this value with the specified one.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zip: {\n  /**\n   * Sequentially zips this value with the specified one.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>\n  /**\n   * Sequentially zips this value with the specified one.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<[A, A1], E | E1, R | R1>\n} = core.zip\n\n/**\n * Sequentially zips this value with the specified one, discarding the second\n * element of the tuple.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipLeft: {\n  /**\n   * Sequentially zips this value with the specified one, discarding the second\n   * element of the tuple.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>\n  /**\n   * Sequentially zips this value with the specified one, discarding the second\n   * element of the tuple.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>\n} = core.zipLeft\n\n/**\n * Sequentially zips this value with the specified one, discarding the first\n * element of the tuple.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipRight: {\n  /**\n   * Sequentially zips this value with the specified one, discarding the first\n   * element of the tuple.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>\n  /**\n   * Sequentially zips this value with the specified one, discarding the first\n   * element of the tuple.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>\n} = core.zipRight\n\n/**\n * Sequentially zips this value with the specified one, combining the values\n * using the specified combiner function.\n *\n * @since 2.0.0\n * @category zipping\n */\nexport const zipWith: {\n  /**\n   * Sequentially zips this value with the specified one, combining the values\n   * using the specified combiner function.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>\n  /**\n   * Sequentially zips this value with the specified one, combining the values\n   * using the specified combiner function.\n   *\n   * @since 2.0.0\n   * @category zipping\n   */\n  <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>\n} = core.zipWith\n\n/**\n * This function takes an iterable of `STM` values and returns a new\n * `STM` value that represents the first `STM` value in the iterable\n * that succeeds. If all of the `Effect` values in the iterable fail, then\n * the resulting `STM` value will fail as well.\n *\n * This function is sequential, meaning that the `STM` values in the\n * iterable will be executed in sequence, and the first one that succeeds\n * will determine the outcome of the resulting `STM` value.\n *\n * Returns a new `STM` value that represents the first successful\n * `STM` value in the iterable, or a failed `STM` value if all of the\n * `STM` values in the iterable fail.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const firstSuccessOf = <A, E, R>(effects: Iterable<STM<A, E, R>>): STM<A, E, R> =>\n  suspend<A, E, R>(() => {\n    const list = Chunk.fromIterable(effects)\n    if (!Chunk.isNonEmpty(list)) {\n      return dieSync(() => new Cause.IllegalArgumentException(`Received an empty collection of effects`))\n    }\n    return Chunk.reduce(\n      Chunk.tailNonEmpty(list),\n      Chunk.headNonEmpty(list),\n      (left, right) => orElse(left, () => right)\n    )\n  })\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const Do: STM<{}> = succeed({})\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bind: {\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string, K, A, E2, R2>(tag: Exclude<N, keyof K>, f: (_: NoInfer<K>) => STM<A, E2, R2>): <E, R>(self: STM<K, E, R>) => STM<MergeRecord<K, { [k in N]: A }>, E2 | E, R2 | R>\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  <K, E, R, N extends string, A, E2, R2>(\n    self: STM<K, E, R>,\n    tag: Exclude<N, keyof K>,\n    f: (_: NoInfer<K>) => STM<A, E2, R2>\n  ): STM<MergeRecord<K, { [k in N]: A }>, E | E2, R | R2>\n} = stm.bind\n\nconst let_: {\n  <N extends string, K, A>(\n    tag: Exclude<N, keyof K>,\n    f: (_: NoInfer<K>) => A\n  ): <E, R>(self: STM<K, E, R>) => STM<MergeRecord<K, { [k in N]: A }>, E, R>\n  <K, E, R, N extends string, A>(\n    self: STM<K, E, R>,\n    tag: Exclude<N, keyof K>,\n    f: (_: NoInfer<K>) => A\n  ): STM<MergeRecord<K, { [k in N]: A }>, E, R>\n} = stm.let_\n\nexport {\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  let_ as let\n}\n\n/**\n * @category do notation\n * @since 2.0.0\n */\nexport const bindTo: {\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  <N extends string>(tag: N): <A, E, R>(self: STM<A, E, R>) => STM<Record<N, A>, E, R>\n  /**\n   * @category do notation\n   * @since 2.0.0\n   */\n  <A, E, R, N extends string>(self: STM<A, E, R>, tag: N): STM<Record<N, A>, E, R>\n} = stm.bindTo\n", "/**\n * @since 2.0.0\n */\nimport type * as Cache from \"./Cache.js\"\nimport type * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as internal from \"./internal/scopedCache.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ScopedCacheTypeId: unique symbol = internal.ScopedCacheTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ScopedCacheTypeId = typeof ScopedCacheTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface ScopedCache<in Key, out Value, out Error = never>\n  extends ScopedCache.Variance<Key, Value, Error>, Pipeable\n{\n  /**\n   * Retrieves the value associated with the specified key if it exists.\n   * Otherwise returns `Option.none`.\n   */\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error, Scope.Scope>\n\n  /**\n   * Retrieves the value associated with the specified key if it exists and the\n   * lookup function has completed. Otherwise returns `Option.none`.\n   */\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>, never, Scope.Scope>\n\n  /**\n   * Returns statistics for this cache.\n   */\n  readonly cacheStats: Effect.Effect<Cache.CacheStats>\n\n  /**\n   * Return whether a resource associated with the specified key exists in the\n   * cache. Sometime `contains` can return true if the resource is currently\n   * being created but not yet totally created.\n   */\n  contains(key: Key): Effect.Effect<boolean>\n\n  /**\n   * Return statistics for the specified entry.\n   */\n  entryStats(key: Key): Effect.Effect<Option.Option<Cache.EntryStats>>\n\n  /**\n   * Gets the value from the cache if it exists or otherwise computes it, the\n   * release action signals to the cache that the value is no longer being used\n   * and can potentially be finalized subject to the policies of the cache.\n   */\n  get(key: Key): Effect.Effect<Value, Error, Scope.Scope>\n\n  /**\n   * Invalidates the resource associated with the specified key.\n   */\n  invalidate(key: Key): Effect.Effect<void>\n\n  /**\n   * Invalidates all values in the cache.\n   */\n  readonly invalidateAll: Effect.Effect<void>\n\n  /**\n   * Force the reuse of the lookup function to compute the returned scoped\n   * effect associated with the specified key immediately. Once the new resource\n   * is recomputed, the old resource associated to the key is cleaned (once all\n   * fiber using it are done with it). During the time the new resource is\n   * computed, concurrent call the .get will use the old resource if this one is\n   * not expired.\n   */\n  refresh(key: Key): Effect.Effect<void, Error>\n\n  /**\n   * Returns the approximate number of values in the cache.\n   */\n  readonly size: Effect.Effect<number>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ScopedCache {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in Key, out Value, out Error> {\n    readonly [ScopedCacheTypeId]: {\n      _Key: Types.Contravariant<Key>\n      _Error: Types.Covariant<Error>\n      _Value: Types.Covariant<Value>\n    }\n  }\n}\n\n/**\n * Constructs a new cache with the specified capacity, time to live, and\n * lookup function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly lookup: Lookup<Key, Value, Error, Environment>\n    readonly capacity: number\n    readonly timeToLive: Duration.DurationInput\n  }\n) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment> = internal.make\n\n/**\n * Constructs a new cache with the specified capacity, time to live, and\n * lookup function, where the time to live can depend on the `Exit` value\n * returned by the lookup function.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const makeWith: <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly lookup: Lookup<Key, Value, Error, Environment>\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n  }\n) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment> = internal.makeWith\n\n/**\n * Similar to `Cache.Lookup`, but executes the lookup function within a `Scope`.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Lookup<Key, Value, Error = never, Environment = never> = (\n  key: Key\n) => Effect.Effect<Value, Error, Environment | Scope.Scope>\n", "import type * as Cache from \"../Cache.js\"\nimport type * as Clock from \"../Clock.js\"\nimport * as Context from \"../Context.js\"\nimport * as Data from \"../Data.js\"\nimport * as Duration from \"../Duration.js\"\nimport type * as Effect from \"../Effect.js\"\nimport * as Equal from \"../Equal.js\"\nimport * as Exit from \"../Exit.js\"\nimport { pipe } from \"../Function.js\"\nimport * as HashSet from \"../HashSet.js\"\nimport * as MutableHashMap from \"../MutableHashMap.js\"\nimport * as MutableQueue from \"../MutableQueue.js\"\nimport * as MutableRef from \"../MutableRef.js\"\nimport * as Option from \"../Option.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport * as Scope from \"../Scope.js\"\nimport type * as ScopedCache from \"../ScopedCache.js\"\nimport * as cache_ from \"./cache.js\"\nimport * as effect from \"./core-effect.js\"\nimport * as core from \"./core.js\"\nimport * as fiberRuntime from \"./fiberRuntime.js\"\n\n/**\n * The `CacheState` represents the mutable state underlying the cache.\n *\n * @internal\n */\nexport interface CacheState<in out Key, out Value, out Error = never> {\n  map: MutableHashMap.MutableHashMap<Key, MapValue<Key, Value, Error>> // mutable by design\n  keys: cache_.KeySet<Key> // mutable by design\n  accesses: MutableQueue.MutableQueue<cache_.MapKey<Key>> // mutable by design\n  updating: MutableRef.MutableRef<boolean> // mutable by design\n  hits: number // mutable by design\n  misses: number // mutable by design\n}\n\n/** @internal */\nexport const makeCacheState = <Key, Value, Error = never>(\n  map: MutableHashMap.MutableHashMap<Key, MapValue<Key, Value, Error>>,\n  keys: cache_.KeySet<Key>,\n  accesses: MutableQueue.MutableQueue<cache_.MapKey<Key>>,\n  updating: MutableRef.MutableRef<boolean>,\n  hits: number,\n  misses: number\n): CacheState<Key, Value, Error> => ({\n  map,\n  keys,\n  accesses,\n  updating,\n  hits,\n  misses\n})\n\n/**\n * Constructs an initial cache state.\n *\n * @internal\n */\nexport const initialCacheState = <Key, Value, Error = never>(): CacheState<Key, Value, Error> =>\n  makeCacheState(\n    MutableHashMap.empty(),\n    cache_.makeKeySet(),\n    MutableQueue.unbounded(),\n    MutableRef.make(false),\n    0,\n    0\n  )\n\n/**\n * A `MapValue` represents a value in the cache. A value may either be\n * `Pending` with a `Promise` that will contain the result of computing the\n * lookup function, when it is available, or `Complete` with an `Exit` value\n * that contains the result of computing the lookup function.\n *\n * @internal\n */\nexport type MapValue<Key, Value, Error> =\n  | Complete<Key, Value, Error>\n  | Pending<Key, Value, Error>\n  | Refreshing<Key, Value, Error>\n\n/** @internal */\nexport interface Complete<out Key, out Value, out Error> {\n  readonly _tag: \"Complete\"\n  readonly key: cache_.MapKey<Key>\n  readonly exit: Exit.Exit<readonly [Value, Scope.Scope.Finalizer], Error>\n  readonly ownerCount: MutableRef.MutableRef<number>\n  readonly entryStats: Cache.EntryStats\n  readonly timeToLive: number\n}\n\n/** @internal */\nexport interface Pending<out Key, out Value, out Error> {\n  readonly _tag: \"Pending\"\n  readonly key: cache_.MapKey<Key>\n  readonly scoped: Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>>\n}\n\n/** @internal */\nexport interface Refreshing<out Key, out Value, out Error> {\n  readonly _tag: \"Refreshing\"\n  readonly scoped: Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>>\n  readonly complete: Complete<Key, Value, Error>\n}\n\n/** @internal */\nexport const complete = <Key, Value, Error = never>(\n  key: cache_.MapKey<Key>,\n  exit: Exit.Exit<readonly [Value, Scope.Scope.Finalizer], Error>,\n  ownerCount: MutableRef.MutableRef<number>,\n  entryStats: Cache.EntryStats,\n  timeToLive: number\n): Complete<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Complete\",\n    key,\n    exit,\n    ownerCount,\n    entryStats,\n    timeToLive\n  })\n\n/** @internal */\nexport const pending = <Key, Value, Error = never>(\n  key: cache_.MapKey<Key>,\n  scoped: Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>>\n): Pending<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Pending\",\n    key,\n    scoped\n  })\n\n/** @internal */\nexport const refreshing = <Key, Value, Error = never>(\n  scoped: Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>>,\n  complete: Complete<Key, Value, Error>\n): Refreshing<Key, Value, Error> =>\n  Data.struct({\n    _tag: \"Refreshing\",\n    scoped,\n    complete\n  })\n\n/** @internal */\nexport const toScoped = <Key, Value, Error = never>(\n  self: Complete<Key, Value, Error>\n): Effect.Effect<Value, Error, Scope.Scope> =>\n  Exit.matchEffect(self.exit, {\n    onFailure: (cause) => core.failCause(cause),\n    onSuccess: ([value]) =>\n      fiberRuntime.acquireRelease(\n        core.as(core.sync(() => MutableRef.incrementAndGet(self.ownerCount)), value),\n        () => releaseOwner(self)\n      )\n  })\n\n/** @internal */\nexport const releaseOwner = <Key, Value, Error = never>(\n  self: Complete<Key, Value, Error>\n): Effect.Effect<void> =>\n  Exit.matchEffect(self.exit, {\n    onFailure: () => core.void,\n    onSuccess: ([, finalizer]) =>\n      core.flatMap(\n        core.sync(() => MutableRef.decrementAndGet(self.ownerCount)),\n        (numOwner) => effect.when(finalizer(Exit.void), () => numOwner === 0)\n      )\n  })\n\n/** @internal */\nconst ScopedCacheSymbolKey = \"effect/ScopedCache\"\n\n/** @internal */\nexport const ScopedCacheTypeId: ScopedCache.ScopedCacheTypeId = Symbol.for(\n  ScopedCacheSymbolKey\n) as ScopedCache.ScopedCacheTypeId\n\nconst scopedCacheVariance = {\n  /* c8 ignore next */\n  _Key: (_: unknown) => _,\n  /* c8 ignore next */\n  _Error: (_: never) => _,\n  /* c8 ignore next */\n  _Value: (_: never) => _\n}\n\nclass ScopedCacheImpl<in out Key, in out Environment, in out Error, in out Value>\n  implements ScopedCache.ScopedCache<Key, Value, Error>\n{\n  readonly [ScopedCacheTypeId] = scopedCacheVariance\n  readonly cacheState: CacheState<Key, Value, Error>\n  constructor(\n    readonly capacity: number,\n    readonly scopedLookup: ScopedCache.Lookup<Key, Value, Error, Environment>,\n    readonly clock: Clock.Clock,\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.Duration,\n    readonly context: Context.Context<Environment>\n  ) {\n    this.cacheState = initialCacheState()\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  get cacheStats(): Effect.Effect<Cache.CacheStats> {\n    return core.sync(() =>\n      cache_.makeCacheStats({\n        hits: this.cacheState.hits,\n        misses: this.cacheState.misses,\n        size: MutableHashMap.size(this.cacheState.map)\n      })\n    )\n  }\n\n  getOption(key: Key): Effect.Effect<Option.Option<Value>, Error, Scope.Scope> {\n    return core.suspend(() =>\n      Option.match(MutableHashMap.get(this.cacheState.map, key), {\n        onNone: () => effect.succeedNone,\n        onSome: (value) => core.flatten(this.resolveMapValue(value))\n      })\n    )\n  }\n\n  getOptionComplete(key: Key): Effect.Effect<Option.Option<Value>, never, Scope.Scope> {\n    return core.suspend(() =>\n      Option.match(MutableHashMap.get(this.cacheState.map, key), {\n        onNone: () => effect.succeedNone,\n        onSome: (value) =>\n          core.flatten(this.resolveMapValue(value, true)) as Effect.Effect<Option.Option<Value>, never, Scope.Scope>\n      })\n    )\n  }\n\n  contains(key: Key): Effect.Effect<boolean> {\n    return core.sync(() => MutableHashMap.has(this.cacheState.map, key))\n  }\n\n  entryStats(key: Key): Effect.Effect<Option.Option<Cache.EntryStats>> {\n    return core.sync(() => {\n      const value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n      if (value === undefined) {\n        return Option.none()\n      }\n      switch (value._tag) {\n        case \"Complete\": {\n          return Option.some(cache_.makeEntryStats(value.entryStats.loadedMillis))\n        }\n        case \"Pending\": {\n          return Option.none()\n        }\n        case \"Refreshing\": {\n          return Option.some(cache_.makeEntryStats(value.complete.entryStats.loadedMillis))\n        }\n      }\n    })\n  }\n\n  get(key: Key): Effect.Effect<Value, Error, Scope.Scope> {\n    return pipe(\n      this.lookupValueOf(key),\n      effect.memoize,\n      core.flatMap((lookupValue) =>\n        core.suspend(() => {\n          let k: cache_.MapKey<Key> | undefined = undefined\n          let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n          if (value === undefined) {\n            k = cache_.makeMapKey(key)\n            if (MutableHashMap.has(this.cacheState.map, key)) {\n              value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n            } else {\n              MutableHashMap.set(this.cacheState.map, key, pending(k, lookupValue))\n            }\n          }\n          if (value === undefined) {\n            this.trackMiss()\n            return core.zipRight(\n              this.ensureMapSizeNotExceeded(k!),\n              lookupValue\n            )\n          }\n\n          return core.map(\n            this.resolveMapValue(value),\n            core.flatMap(Option.match({\n              onNone: () => {\n                const val = value as Complete<Key, Value, Error>\n                const current = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n                if (Equal.equals(current, value)) {\n                  MutableHashMap.remove(this.cacheState.map, key)\n                }\n                return pipe(\n                  this.ensureMapSizeNotExceeded(val.key),\n                  core.zipRight(releaseOwner(val)),\n                  core.zipRight(this.get(key))\n                )\n              },\n              onSome: core.succeed\n            }))\n          )\n        })\n      ),\n      core.flatten\n    )\n  }\n\n  invalidate(key: Key): Effect.Effect<void> {\n    return core.suspend(() => {\n      if (MutableHashMap.has(this.cacheState.map, key)) {\n        const mapValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))!\n        MutableHashMap.remove(this.cacheState.map, key)\n        switch (mapValue._tag) {\n          case \"Complete\": {\n            return releaseOwner(mapValue)\n          }\n          case \"Pending\": {\n            return core.void\n          }\n          case \"Refreshing\": {\n            return releaseOwner(mapValue.complete)\n          }\n        }\n      }\n      return core.void\n    })\n  }\n\n  get invalidateAll(): Effect.Effect<void> {\n    return fiberRuntime.forEachConcurrentDiscard(\n      HashSet.fromIterable(Array.from(this.cacheState.map).map(([key]) => key)),\n      (key) => this.invalidate(key),\n      false,\n      false\n    )\n  }\n\n  refresh(key: Key): Effect.Effect<void, Error> {\n    return pipe(\n      this.lookupValueOf(key),\n      effect.memoize,\n      core.flatMap((scoped) => {\n        let value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n        let newKey: cache_.MapKey<Key> | undefined = undefined\n        if (value === undefined) {\n          newKey = cache_.makeMapKey(key)\n          if (MutableHashMap.has(this.cacheState.map, key)) {\n            value = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n          } else {\n            MutableHashMap.set(this.cacheState.map, key, pending(newKey, scoped))\n          }\n        }\n        let finalScoped: Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>>\n        if (value === undefined) {\n          finalScoped = core.zipRight(\n            this.ensureMapSizeNotExceeded(newKey!),\n            scoped\n          )\n        } else {\n          switch (value._tag) {\n            case \"Complete\": {\n              if (this.hasExpired(value.timeToLive)) {\n                finalScoped = core.succeed(this.get(key))\n              } else {\n                const current = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n                if (Equal.equals(current, value)) {\n                  const mapValue = refreshing(scoped, value)\n                  MutableHashMap.set(this.cacheState.map, key, mapValue)\n                  finalScoped = scoped\n                } else {\n                  finalScoped = core.succeed(this.get(key))\n                }\n              }\n              break\n            }\n            case \"Pending\": {\n              finalScoped = value.scoped\n              break\n            }\n            case \"Refreshing\": {\n              finalScoped = value.scoped\n              break\n            }\n          }\n        }\n        return core.flatMap(finalScoped, (s) => fiberRuntime.scopedEffect(core.asVoid(s)))\n      })\n    )\n  }\n\n  get size(): Effect.Effect<number> {\n    return core.sync(() => MutableHashMap.size(this.cacheState.map))\n  }\n\n  resolveMapValue(\n    value: MapValue<Key, Value, Error>,\n    ignorePending = false\n  ): Effect.Effect<Effect.Effect<Option.Option<Value>, Error, Scope.Scope>> {\n    switch (value._tag) {\n      case \"Complete\": {\n        this.trackHit()\n        if (this.hasExpired(value.timeToLive)) {\n          return core.succeed(effect.succeedNone)\n        }\n        return core.as(\n          this.ensureMapSizeNotExceeded(value.key),\n          effect.asSome(toScoped(value))\n        )\n      }\n      case \"Pending\": {\n        this.trackHit()\n\n        if (ignorePending) {\n          return core.succeed(effect.succeedNone)\n        }\n\n        return core.zipRight(\n          this.ensureMapSizeNotExceeded(value.key),\n          core.map(value.scoped, effect.asSome)\n        )\n      }\n      case \"Refreshing\": {\n        this.trackHit()\n        if (this.hasExpired(value.complete.timeToLive)) {\n          if (ignorePending) {\n            return core.succeed(effect.succeedNone)\n          }\n          return core.zipRight(\n            this.ensureMapSizeNotExceeded(value.complete.key),\n            core.map(value.scoped, effect.asSome)\n          )\n        }\n        return core.as(\n          this.ensureMapSizeNotExceeded(value.complete.key),\n          effect.asSome(toScoped(value.complete))\n        )\n      }\n    }\n  }\n\n  lookupValueOf(key: Key): Effect.Effect<Effect.Effect<Value, Error, Scope.Scope>> {\n    return pipe(\n      core.onInterrupt(\n        core.flatMap(Scope.make(), (scope) =>\n          pipe(\n            this.scopedLookup(key),\n            core.provideContext(pipe(this.context, Context.add(Scope.Scope, scope))),\n            core.exit,\n            core.map((exit) => [exit, ((exit) => Scope.close(scope, exit)) as Scope.Scope.Finalizer] as const)\n          )),\n        () => core.sync(() => MutableHashMap.remove(this.cacheState.map, key))\n      ),\n      core.flatMap(([exit, release]) => {\n        const now = this.clock.unsafeCurrentTimeMillis()\n        const expiredAt = now + Duration.toMillis(this.timeToLive(exit))\n        switch (exit._tag) {\n          case \"Success\": {\n            const exitWithFinalizer: Exit.Exit<[Value, Scope.Scope.Finalizer]> = Exit.succeed([\n              exit.value,\n              release\n            ])\n            const completedResult = complete<Key, Value, Error>(\n              cache_.makeMapKey(key),\n              exitWithFinalizer,\n              MutableRef.make(1),\n              cache_.makeEntryStats(now),\n              expiredAt\n            )\n            let previousValue: MapValue<Key, Value, Error> | undefined = undefined\n            if (MutableHashMap.has(this.cacheState.map, key)) {\n              previousValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n            }\n            MutableHashMap.set(this.cacheState.map, key, completedResult)\n            return core.sync(() =>\n              core.flatten(\n                core.as(\n                  this.cleanMapValue(previousValue),\n                  toScoped(completedResult)\n                )\n              )\n            )\n          }\n          case \"Failure\": {\n            const completedResult = complete<Key, Value, Error>(\n              cache_.makeMapKey(key),\n              exit as Exit.Exit<readonly [Value, Scope.Scope.Finalizer], Error>,\n              MutableRef.make(0),\n              cache_.makeEntryStats(now),\n              expiredAt\n            )\n            let previousValue: MapValue<Key, Value, Error> | undefined = undefined\n            if (MutableHashMap.has(this.cacheState.map, key)) {\n              previousValue = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key))\n            }\n            MutableHashMap.set(this.cacheState.map, key, completedResult)\n            return core.zipRight(\n              release(exit),\n              core.sync(() =>\n                core.flatten(\n                  core.as(\n                    this.cleanMapValue(previousValue),\n                    toScoped(completedResult)\n                  )\n                )\n              )\n            )\n          }\n        }\n      }),\n      effect.memoize,\n      core.flatten\n    )\n  }\n\n  hasExpired(timeToLive: number): boolean {\n    return this.clock.unsafeCurrentTimeMillis() > timeToLive\n  }\n\n  trackHit(): void {\n    this.cacheState.hits = this.cacheState.hits + 1\n  }\n\n  trackMiss(): void {\n    this.cacheState.misses = this.cacheState.misses + 1\n  }\n\n  trackAccess(key: cache_.MapKey<Key>): Array<MapValue<Key, Value, Error>> {\n    const cleanedKeys: Array<MapValue<Key, Value, Error>> = []\n    MutableQueue.offer(this.cacheState.accesses, key)\n    if (MutableRef.compareAndSet(this.cacheState.updating, false, true)) {\n      let loop = true\n      while (loop) {\n        const key = MutableQueue.poll(this.cacheState.accesses, MutableQueue.EmptyMutableQueue)\n        if (key === MutableQueue.EmptyMutableQueue) {\n          loop = false\n        } else {\n          this.cacheState.keys.add(key)\n        }\n      }\n      let size = MutableHashMap.size(this.cacheState.map)\n      loop = size > this.capacity\n      while (loop) {\n        const key = this.cacheState.keys.remove()\n        if (key === undefined) {\n          loop = false\n        } else {\n          if (MutableHashMap.has(this.cacheState.map, key.current)) {\n            const removed = Option.getOrUndefined(MutableHashMap.get(this.cacheState.map, key.current))!\n            MutableHashMap.remove(this.cacheState.map, key.current)\n            size = size - 1\n            cleanedKeys.push(removed)\n            loop = size > this.capacity\n          }\n        }\n      }\n      MutableRef.set(this.cacheState.updating, false)\n    }\n    return cleanedKeys\n  }\n\n  cleanMapValue(mapValue: MapValue<Key, Value, Error> | undefined): Effect.Effect<void> {\n    if (mapValue === undefined) {\n      return core.void\n    }\n    switch (mapValue._tag) {\n      case \"Complete\": {\n        return releaseOwner(mapValue)\n      }\n      case \"Pending\": {\n        return core.void\n      }\n      case \"Refreshing\": {\n        return releaseOwner(mapValue.complete)\n      }\n    }\n  }\n\n  ensureMapSizeNotExceeded(key: cache_.MapKey<Key>): Effect.Effect<void> {\n    return fiberRuntime.forEachConcurrentDiscard(\n      this.trackAccess(key),\n      (cleanedMapValue) => this.cleanMapValue(cleanedMapValue),\n      false,\n      false\n    )\n  }\n}\n\n/** @internal */\nexport const make = <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly lookup: ScopedCache.Lookup<Key, Value, Error, Environment>\n    readonly capacity: number\n    readonly timeToLive: Duration.DurationInput\n  }\n): Effect.Effect<ScopedCache.ScopedCache<Key, Value, Error>, never, Environment | Scope.Scope> => {\n  const timeToLive = Duration.decode(options.timeToLive)\n  return makeWith({\n    capacity: options.capacity,\n    lookup: options.lookup,\n    timeToLive: () => timeToLive\n  })\n}\n\n/** @internal */\nexport const makeWith = <Key, Value, Error = never, Environment = never>(\n  options: {\n    readonly capacity: number\n    readonly lookup: ScopedCache.Lookup<Key, Value, Error, Environment>\n    readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput\n  }\n): Effect.Effect<ScopedCache.ScopedCache<Key, Value, Error>, never, Environment | Scope.Scope> =>\n  core.flatMap(\n    effect.clock,\n    (clock) =>\n      buildWith(\n        options.capacity,\n        options.lookup,\n        clock,\n        (exit) => Duration.decode(options.timeToLive(exit))\n      )\n  )\n\nconst buildWith = <Key, Value, Error = never, Environment = never>(\n  capacity: number,\n  scopedLookup: ScopedCache.Lookup<Key, Value, Error, Environment>,\n  clock: Clock.Clock,\n  timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.Duration\n): Effect.Effect<ScopedCache.ScopedCache<Key, Value, Error>, never, Environment | Scope.Scope> =>\n  fiberRuntime.acquireRelease(\n    core.flatMap(\n      core.context<Environment>(),\n      (context) =>\n        core.sync(() =>\n          new ScopedCacheImpl(\n            capacity,\n            scopedLookup,\n            clock,\n            timeToLive,\n            context\n          )\n        )\n    ),\n    (cache) => cache.invalidateAll\n  )\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport * as internal from \"./internal/scopedRef.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as Synchronized from \"./SynchronizedRef.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const ScopedRefTypeId: unique symbol = internal.ScopedRefTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type ScopedRefTypeId = typeof ScopedRefTypeId\n\n/**\n * A `ScopedRef` is a reference whose value is associated with resources,\n * which must be released properly. You can both get the current value of any\n * `ScopedRef`, as well as set it to a new value (which may require new\n * resources). The reference itself takes care of properly releasing resources\n * for the old value whenever a new value is obtained.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {\n  /** @internal */\n  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>\n\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ScopedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Effect.EffectUnify<A> {\n  ScopedRef?: () => Extract<A[Unify.typeSymbol], ScopedRef<any>>\n}\n\n/**\n * @category models\n * @since 3.9.0\n */\nexport interface ScopedRefUnifyIgnore extends Effect.EffectUnifyIgnore {\n  Effect?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace ScopedRef {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [ScopedRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * Creates a new `ScopedRef` from an effect that resourcefully produces a\n * value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromAcquire: <A, E, R>(\n  acquire: Effect.Effect<A, E, R>\n) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R> = internal.fromAcquire\n\n/**\n * Retrieves the current value of the scoped reference.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: ScopedRef<A>) => Effect.Effect<A> = internal.get\n\n/**\n * Creates a new `ScopedRef` from the specified value. This method should\n * not be used for values whose creation require the acquisition of resources.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope> = internal.make\n\n/**\n * Sets the value of this reference to the specified resourcefully-created\n * value. Any resources associated with the old value will be released.\n *\n * This method will not return until either the reference is successfully\n * changed to the new value, with old resources released, or until the attempt\n * to acquire a new value fails.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const set: {\n  /**\n   * Sets the value of this reference to the specified resourcefully-created\n   * value. Any resources associated with the old value will be released.\n   *\n   * This method will not return until either the reference is successfully\n   * changed to the new value, with old resources released, or until the attempt\n   * to acquire a new value fails.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>\n  /**\n   * Sets the value of this reference to the specified resourcefully-created\n   * value. Any resources associated with the old value will be released.\n   *\n   * This method will not return until either the reference is successfully\n   * changed to the new value, with old resources released, or until the attempt\n   * to acquire a new value fails.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>\n} = internal.set\n", "/**\n * @since 2.0.0\n * @deprecated\n */\nimport type * as Equal from \"./Equal.js\"\nimport * as InternalSecret from \"./internal/secret.js\"\nimport type * as Redacted from \"./Redacted.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n * @deprecated\n */\nexport const SecretTypeId: unique symbol = InternalSecret.SecretTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n * @deprecated\n */\nexport type SecretTypeId = typeof SecretTypeId\n\n/**\n * @since 2.0.0\n * @category models\n * @deprecated\n */\nexport interface Secret extends Redacted.Redacted, Secret.Proto, Equal.Equal {\n  /** @internal */\n  readonly raw: Array<number>\n}\n\n/**\n * @since 2.0.0\n * @deprecated\n */\nexport declare namespace Secret {\n  /**\n   * @since 2.0.0\n   * @category models\n   * @deprecated\n   */\n  export interface Proto {\n    readonly [SecretTypeId]: SecretTypeId\n  }\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n * @deprecated\n */\nexport const isSecret: (u: unknown) => u is Secret = InternalSecret.isSecret\n\n/**\n * @since 2.0.0\n * @category constructors\n * @deprecated\n */\nexport const make: (bytes: Array<number>) => Secret = InternalSecret.make\n\n/**\n * @since 2.0.0\n * @category constructors\n * @deprecated\n */\nexport const fromIterable: (iterable: Iterable<string>) => Secret = InternalSecret.fromIterable\n\n/**\n * @since 2.0.0\n * @category constructors\n * @deprecated\n */\nexport const fromString: (text: string) => Secret = InternalSecret.fromString\n\n/**\n * @since 2.0.0\n * @category getters\n * @deprecated\n */\nexport const value: (self: Secret) => string = InternalSecret.value\n\n/**\n * @since 2.0.0\n * @category unsafe\n * @deprecated\n */\nexport const unsafeWipe: (self: Secret) => void = InternalSecret.unsafeWipe\n", "/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Either from \"./Either.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as internal from \"./internal/channel/singleProducerAsyncInput.js\"\n\n/**\n * An MVar-like abstraction for sending data to channels asynchronously which is\n * designed for one producer and multiple consumers.\n *\n * Features the following semantics:\n *   - Buffer of size 1.\n *   - When emitting, the producer waits for a consumer to pick up the value to\n *     prevent \"reading ahead\" too much.\n *   - Once an emitted element is read by a consumer, it is cleared from the\n *     buffer, so that at most one consumer sees every emitted element.\n *   - When sending a done or error signal, the producer does not wait for a\n *     consumer to pick up the signal. The signal stays in the buffer after\n *     being read by a consumer, so it can be propagated to multiple consumers.\n *   - Trying to publish another emit/error/done after an error/done have\n *     already been published results in an interruption.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>\n  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>\n{\n  readonly close: Effect.Effect<unknown>\n  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>\n}\n\n/**\n * Producer-side view of `SingleProducerAsyncInput` for variance purposes.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface AsyncInputProducer<in Err, in Elem, in Done> {\n  awaitRead(): Effect.Effect<unknown>\n  done(value: Done): Effect.Effect<unknown>\n  emit(element: Elem): Effect.Effect<unknown>\n  error(cause: Cause.Cause<Err>): Effect.Effect<unknown>\n}\n\n/**\n * Consumer-side view of `SingleProducerAsyncInput` for variance purposes.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface AsyncInputConsumer<out Err, out Elem, out Done> {\n  takeWith<A>(\n    onError: (cause: Cause.Cause<Err>) => A,\n    onElement: (element: Elem) => A,\n    onDone: (value: Done) => A\n  ): Effect.Effect<A>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Err, Elem, Done>() => Effect.Effect<SingleProducerAsyncInput<Err, Elem, Done>> = internal.make\n", "/**\n * @since 2.0.0\n */\nimport * as Equal from \"./Equal.js\"\nimport * as Dual from \"./Function.js\"\nimport { pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport { format, type Inspectable, NodeInspectSymbol, toJSON } from \"./Inspectable.js\"\nimport * as Option from \"./Option.js\"\nimport type { Order } from \"./Order.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as RBT from \"./RedBlackTree.js\"\nimport type * as Types from \"./Types.js\"\n\nconst TypeId: unique symbol = Symbol.for(\"effect/SortedMap\")\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface SortedMap<in out K, out V> extends Iterable<[K, V]>, Equal.Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _K: Types.Invariant<K>\n    readonly _V: Types.Covariant<V>\n  }\n  /** @internal */\n  readonly tree: RBT.RedBlackTree<K, V>\n}\n\nconst SortedMapProto: Omit<SortedMap<unknown, unknown>, \"tree\"> = {\n  [TypeId]: {\n    _K: (_: any) => _,\n    _V: (_: never) => _\n  },\n  [Hash.symbol]<K, V>(this: SortedMap<K, V>): number {\n    return pipe(\n      Hash.hash(this.tree),\n      Hash.combine(Hash.hash(\"effect/SortedMap\")),\n      Hash.cached(this)\n    )\n  },\n  [Equal.symbol]<K, V>(this: SortedMap<K, V>, that: unknown): boolean {\n    return isSortedMap(that) && Equal.equals(this.tree, that.tree)\n  },\n  [Symbol.iterator]<K, V>(this: SortedMap<K, V>): Iterator<[K, V]> {\n    return this.tree[Symbol.iterator]()\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"SortedMap\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeImpl = <K, V>(tree: RBT.RedBlackTree<K, V>): SortedMap<K, V> => {\n  const self = Object.create(SortedMapProto)\n  self.tree = tree\n  return self\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSortedMap: {\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  <K, V>(u: Iterable<readonly [K, V]>): u is SortedMap<K, V>\n  /**\n   * @since 2.0.0\n   * @category refinements\n   */\n  (u: unknown): u is SortedMap<unknown, unknown>\n} = (u: unknown): u is SortedMap<unknown, unknown> => hasProperty(u, TypeId)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const empty = <K, V = never>(ord: Order<K>): SortedMap<K, V> => makeImpl<K, V>(RBT.empty<K, V>(ord))\n\n/**\n * Creates a new `SortedMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: {\n  /**\n   * Creates a new `SortedMap` from an iterable collection of key/value pairs.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>\n  /**\n   * Creates a new `SortedMap` from an iterable collection of key/value pairs.\n   *\n   * @since 2.0.0\n   * @category constructors\n   */\n  <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>\n} = Dual.dual(\n  2,\n  <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V> =>\n    makeImpl(RBT.fromIterable(iterable, ord))\n)\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make =\n  <K>(ord: Order<K>) =>\n  <Entries extends ReadonlyArray<readonly [K, any]>>(...entries: Entries): SortedMap<\n    K,\n    Entries[number] extends (readonly [any, infer V]) ? V : never\n  > => fromIterable(ord)(entries)\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const isEmpty = <K, V>(self: SortedMap<K, V>): boolean => size(self) === 0\n\n/**\n * @since 2.0.0\n * @category predicates\n */\nexport const isNonEmpty = <K, V>(self: SortedMap<K, V>): boolean => size(self) > 0\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: SortedMap<K, V>) => Option.Option<V>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: SortedMap<K, V>, key: K): Option.Option<V>\n} = Dual.dual<\n  <K>(key: K) => <V>(self: SortedMap<K, V>) => Option.Option<V>,\n  <K, V>(self: SortedMap<K, V>, key: K) => Option.Option<V>\n>(2, (self, key) => RBT.findFirst(self.tree, key))\n\n/**\n * Gets the `Order<K>` that the `SortedMap<K, V>` is using.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const getOrder = <K, V>(self: SortedMap<K, V>): Order<K> => RBT.getOrder(self.tree)\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: SortedMap<K, V>) => boolean\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: SortedMap<K, V>, key: K): boolean\n} = Dual.dual<\n  <K>(key: K) => <V>(self: SortedMap<K, V>) => boolean,\n  <K, V>(self: SortedMap<K, V>, key: K) => boolean\n>(2, (self, key) => Option.isSome(get(self, key)))\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const headOption = <K, V>(self: SortedMap<K, V>): Option.Option<[K, V]> => RBT.first(self.tree)\n\n/**\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, K, B>(f: (a: A, k: K) => B): (self: SortedMap<K, A>) => SortedMap<K, B>\n  /**\n   * @since 2.0.0\n   * @category mapping\n   */\n  <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B): SortedMap<K, B>\n} = Dual.dual<\n  <A, K, B>(f: (a: A, k: K) => B) => (self: SortedMap<K, A>) => SortedMap<K, B>,\n  <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B) => SortedMap<K, B>\n>(2, <K, A, B>(self: SortedMap<K, A>, f: (a: A, k: K) => B) =>\n  reduce(\n    self,\n    empty<K, B>(RBT.getOrder(self.tree)),\n    (acc, v, k) => set(acc, k, f(v, k))\n  ))\n\n/**\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <B, A, K>(zero: B, f: (acc: B, value: A, key: K) => B): (self: SortedMap<K, A>) => B\n  /**\n   * @since 2.0.0\n   * @category folding\n   */\n  <K, A, B>(self: SortedMap<K, A>, zero: B, f: (acc: B, value: A, key: K) => B): B\n} = Dual.dual<\n  <B, A, K>(zero: B, f: (acc: B, value: A, key: K) => B) => (self: SortedMap<K, A>) => B,\n  <K, A, B>(self: SortedMap<K, A>, zero: B, f: (acc: B, value: A, key: K) => B) => B\n>(3, (self, zero, f) => RBT.reduce(self.tree, zero, f))\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const remove: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: SortedMap<K, V>) => SortedMap<K, V>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: SortedMap<K, V>, key: K): SortedMap<K, V>\n} = Dual.dual<\n  <K>(key: K) => <V>(self: SortedMap<K, V>) => SortedMap<K, V>,\n  <K, V>(self: SortedMap<K, V>, key: K) => SortedMap<K, V>\n>(2, (self, key) => makeImpl(RBT.removeFirst(self.tree, key)))\n\n/**\n * @since 2.0.0\n * @category elements\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(key: K, value: V): (self: SortedMap<K, V>) => SortedMap<K, V>\n  /**\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: SortedMap<K, V>, key: K, value: V): SortedMap<K, V>\n} = Dual.dual<\n  <K, V>(key: K, value: V) => (self: SortedMap<K, V>) => SortedMap<K, V>,\n  <K, V>(self: SortedMap<K, V>, key: K, value: V) => SortedMap<K, V>\n>(3, (self, key, value) =>\n  RBT.has(self.tree, key)\n    ? makeImpl(RBT.insert(RBT.removeFirst(self.tree, key), key, value))\n    : makeImpl(RBT.insert(self.tree, key, value)))\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const size = <K, V>(self: SortedMap<K, V>): number => RBT.size(self.tree)\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const keys = <K, V>(self: SortedMap<K, V>): IterableIterator<K> => RBT.keys(self.tree)\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const values = <K, V>(self: SortedMap<K, V>): IterableIterator<V> => RBT.values(self.tree)\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const entries = <K, V>(self: SortedMap<K, V>): IterableIterator<[K, V]> => {\n  const iterator: any = self.tree[Symbol.iterator]()\n  iterator[Symbol.iterator] = () => entries(self)\n  return iterator\n}\n\n/**\n * @since 3.1.0\n * @category elements\n */\nexport const lastOption = <K, V>(self: SortedMap<K, V>): Option.Option<[K, V]> => RBT.last(self.tree)\n\n/**\n * @since 3.1.0\n * @category filtering\n */\nexport const partition: {\n  /**\n   * @since 3.1.0\n   * @category filtering\n   */\n  <K, V>(predicate: (a: Types.NoInfer<K>) => boolean): (self: SortedMap<K, V>) => [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]\n  /**\n   * @since 3.1.0\n   * @category filtering\n   */\n  <K, V>(self: SortedMap<K, V>, predicate: (a: K) => boolean): [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>]\n} = Dual.dual(\n  2,\n  <K, V>(\n    self: SortedMap<K, V>,\n    predicate: (a: K) => boolean\n  ): [excluded: SortedMap<K, V>, satisfying: SortedMap<K, V>] => {\n    const ord = RBT.getOrder(self.tree)\n    let right = empty<K, V>(ord)\n    let left = empty<K, V>(ord)\n    for (const value of self) {\n      if (predicate(value[0])) {\n        right = set(right, value[0], value[1])\n      } else {\n        left = set(left, value[0], value[1])\n      }\n    }\n    return [left, right]\n  }\n)\n", "export {};\n//# sourceMappingURL=StreamEmit.js.map", "/**\n * @since 2.0.0\n */\n\nimport { pipeArguments } from \"./Pipeable.js\"\nimport * as Stream from \"./Stream.js\"\n\nconst streamVariance = {\n  /* c8 ignore next */\n  _R: (_: never) => _,\n  /* c8 ignore next */\n  _E: (_: never) => _,\n  /* c8 ignore next */\n  _A: (_: never) => _\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport abstract class Class<A, E = never, R = never> implements Stream.Stream<A, E, R> {\n  /**\n   * @since 2.0.0\n   */\n  readonly [Stream.StreamTypeId] = streamVariance\n\n  /**\n   * @since 2.0.0\n   */\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  abstract toStream(): Stream.Stream<A, E, R>\n\n  /**\n   * @internal\n   */\n  get channel() {\n    return Stream.toChannel(this.toStream())\n  }\n}\n", "/**\n * @since 2.0.0\n */\nimport * as Effect from \"./Effect.js\"\nimport { dual } from \"./Function.js\"\nimport { pipeArguments } from \"./Pipeable.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as Readable from \"./Readable.js\"\nimport * as Stream from \"./Stream.js\"\nimport type { NoInfer } from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"effect/Subscribable\")\n\n/**\n * @since 2.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Subscribable<A, E = never, R = never> extends Readable.Readable<A, E, R> {\n  readonly [TypeId]: TypeId\n  readonly changes: Stream.Stream<A, E, R>\n}\n\n/**\n * @since 2.0.0\n * @category refinements\n */\nexport const isSubscribable = (u: unknown): u is Subscribable<unknown, unknown, unknown> => hasProperty(u, TypeId)\n\nconst Proto: Omit<Subscribable<any>, \"get\" | \"changes\"> = {\n  [Readable.TypeId]: Readable.TypeId,\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make = <A, E, R>(options: {\n  readonly get: Effect.Effect<A, E, R>\n  readonly changes: Stream.Stream<A, E, R>\n}): Subscribable<A, E, R> => Object.assign(Object.create(Proto), options)\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const map: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B>(f: (a: NoInfer<A>) => B): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R>\n} = dual(2, <A, E, R, B>(self: Subscribable<A, E, R>, f: (a: NoInfer<A>) => B): Subscribable<B, E, R> =>\n  make({\n    get: Effect.map(self.get, f),\n    changes: Stream.map(self.changes, f)\n  }))\n\n/**\n * @since 2.0.0\n * @category combinators\n */\nexport const mapEffect: {\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, B, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>): <E, R>(fa: Subscribable<A, E, R>) => Subscribable<B, E | E2, R | R2>\n  /**\n   * @since 2.0.0\n   * @category combinators\n   */\n  <A, E, R, B, E2, R2>(\n    self: Subscribable<A, E, R>,\n    f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n  ): Subscribable<B, E | E2, R | R2>\n} = dual(2, <A, E, R, B, E2, R2>(\n  self: Subscribable<A, E, R>,\n  f: (a: NoInfer<A>) => Effect.Effect<B, E2, R2>\n): Subscribable<B, E | E2, R | R2> =>\n  make({\n    get: Effect.flatMap(self.get, f),\n    changes: Stream.mapEffect(self.changes, f)\n  }))\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const unwrap = <A, E, R, E1, R1>(\n  effect: Effect.Effect<Subscribable<A, E, R>, E1, R1>\n): Subscribable<A, E | E1, R | R1> =>\n  make({\n    get: Effect.flatMap(effect, (s) => s.get),\n    changes: Stream.unwrap(Effect.map(effect, (s) => s.changes))\n  })\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/subscriptionRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as PubSub from \"./PubSub.js\"\nimport * as Ref from \"./Ref.js\"\nimport type * as Stream from \"./Stream.js\"\nimport type { Subscribable } from \"./Subscribable.js\"\nimport * as Synchronized from \"./SynchronizedRef.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SubscriptionRefTypeId: unique symbol = internal.SubscriptionRefTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SubscriptionRefTypeId = typeof SubscriptionRefTypeId\n\n/**\n * A `SubscriptionRef<A>` is a `Ref` that can be subscribed to in order to\n * receive the current value as well as all changes to the value.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface SubscriptionRef<in out A>\n  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>\n{\n  /** @internal */\n  readonly ref: Ref.Ref<A>\n  /** @internal */\n  readonly pubsub: PubSub.PubSub<A>\n  /** @internal */\n  readonly semaphore: Effect.Semaphore\n  /**\n   * A stream containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: Stream.Stream<A>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SubscriptionRefUnify<A extends { [Unify.typeSymbol]?: any }>\n  extends Synchronized.SynchronizedRefUnify<A>\n{\n  SubscriptionRef?: () => Extract<A[Unify.typeSymbol], SubscriptionRef<any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SubscriptionRefUnifyIgnore extends Synchronized.SynchronizedRefUnifyIgnore {\n  SynchronizedRef?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace SubscriptionRef {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [SubscriptionRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: SubscriptionRef<A>) => Effect.Effect<A> = internal.get\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>\n} = Ref.getAndSet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>\n} = Ref.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = Synchronized.getAndUpdateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = Ref.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: SubscriptionRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = Synchronized.getAndUpdateSomeEffect\n\n/**\n * Creates a new `SubscriptionRef` with the specified value.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>> = internal.make\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: SubscriptionRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: SubscriptionRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifyEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SubscriptionRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(\n    self: SubscriptionRef<A>,\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ): Effect.Effect<B, E, R>\n} = internal.modifyEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: SubscriptionRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(\n    self: SubscriptionRef<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<readonly [B, A]>\n  ): Effect.Effect<B>\n} = Ref.modifySome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    fallback: B,\n    pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): Effect.Effect<B, E, R>\n} = Synchronized.modifySomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<void>\n} = internal.set\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, value: A): Effect.Effect<A>\n} = Ref.setAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<void>\n} = Ref.update\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: Synchronized.SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>\n} = Synchronized.updateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => A): Effect.Effect<A>\n} = Ref.updateAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SubscriptionRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = Synchronized.updateAndGetEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>\n} = Ref.updateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: Synchronized.SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: Synchronized.SynchronizedRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<void, E, R>\n} = Synchronized.updateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: SubscriptionRef<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: SubscriptionRef<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = Ref.updateSomeAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SubscriptionRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n    self: SubscriptionRef<A>,\n    pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = Synchronized.updateSomeAndGetEffect\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as circular from \"./internal/effect/circular.js\"\nimport * as ref from \"./internal/ref.js\"\nimport * as internal from \"./internal/synchronizedRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Ref from \"./Ref.js\"\nimport type * as Types from \"./Types.js\"\nimport type * as Unify from \"./Unify.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SynchronizedRefTypeId: unique symbol = circular.SynchronizedTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SynchronizedRefTypeId = typeof SynchronizedRefTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface SynchronizedRef<in out A> extends SynchronizedRef.Variance<A>, Ref.Ref<A> {\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R>\n  readonly [Unify.typeSymbol]?: unknown\n  readonly [Unify.unifySymbol]?: SynchronizedRefUnify<this>\n  readonly [Unify.ignoreSymbol]?: SynchronizedRefUnifyIgnore\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SynchronizedRefUnify<A extends { [Unify.typeSymbol]?: any }> extends Ref.RefUnify<A> {\n  SynchronizedRef?: () => Extract<A[Unify.typeSymbol], SynchronizedRef<any>>\n}\n\n/**\n * @category models\n * @since 3.8.0\n */\nexport interface SynchronizedRefUnifyIgnore extends Ref.RefUnifyIgnore {\n  Ref?: true\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace SynchronizedRef {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [SynchronizedRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => Effect.Effect<SynchronizedRef<A>> = circular.makeSynchronized\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const get: <A>(self: SynchronizedRef<A>) => Effect.Effect<A> = ref.get\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>\n} = ref.getAndSet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = ref.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = internal.getAndUpdateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = ref.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const getAndUpdateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = internal.getAndUpdateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: SynchronizedRef<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(self: SynchronizedRef<A>, f: (a: A) => readonly [B, A]): Effect.Effect<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifyEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, E, R>(\n   self: SynchronizedRef<A>,\n   f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ): Effect.Effect<B, E, R>\n} = internal.modifyEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <B, A>(fallback: B, pf: (a: A) => Option.Option<readonly [B, A]>): (self: Ref.Ref<A>) => Effect.Effect<B>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B>(\n   self: Ref.Ref<A>,\n   fallback: B,\n   pf: (a: A) => Option.Option<readonly [B, A]>\n  ): Effect.Effect<B>\n} = ref.modifySome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const modifySomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n   fallback: B,\n   pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): (self: SynchronizedRef<A>) => Effect.Effect<B, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, B, R, E>(\n   self: SynchronizedRef<A>,\n   fallback: B,\n   pf: (a: A) => Option.Option<Effect.Effect<readonly [B, A], E, R>>\n  ): Effect.Effect<B, E, R>\n} = internal.modifySomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<void>\n} = ref.set\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(value: A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, value: A): Effect.Effect<A>\n} = ref.setAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<void>\n} = ref.update\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<void, E, R>\n} = internal.updateEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => A): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => A): Effect.Effect<A>\n} = ref.updateAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(f: (a: A) => Effect.Effect<A, E, R>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(self: SynchronizedRef<A>, f: (a: A) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n} = internal.updateAndGetEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<void>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, f: (a: A) => Option.Option<A>): Effect.Effect<void>\n} = ref.updateSome\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<void, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<void, E, R>\n} = internal.updateSomeEffect\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(pf: (a: A) => Option.Option<A>): (self: Ref.Ref<A>) => Effect.Effect<A>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A>(self: Ref.Ref<A>, pf: (a: A) => Option.Option<A>): Effect.Effect<A>\n} = ref.updateSomeAndGet\n\n/**\n * @since 2.0.0\n * @category utils\n */\nexport const updateSomeAndGetEffect: {\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>): (self: SynchronizedRef<A>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category utils\n   */\n  <A, R, E>(\n   self: SynchronizedRef<A>,\n   pf: (a: A) => Option.Option<Effect.Effect<A, E, R>>\n  ): Effect.Effect<A, E, R>\n} = circular.updateSomeAndGetEffectSynchronized\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: <A>(value: A) => SynchronizedRef<A> = circular.unsafeMakeSynchronized\n", "import * as Effect from \"../Effect.js\"\nimport * as Effectable from \"../Effectable.js\"\nimport { dual, pipe } from \"../Function.js\"\nimport * as PubSub from \"../PubSub.js\"\nimport * as Readable from \"../Readable.js\"\nimport * as Ref from \"../Ref.js\"\nimport type { Stream } from \"../Stream.js\"\nimport * as Subscribable from \"../Subscribable.js\"\nimport type * as SubscriptionRef from \"../SubscriptionRef.js\"\nimport * as Synchronized from \"../SynchronizedRef.js\"\nimport * as circular_ from \"./effect/circular.js\"\nimport * as ref_ from \"./ref.js\"\nimport * as stream from \"./stream.js\"\n\n/** @internal */\nconst SubscriptionRefSymbolKey = \"effect/SubscriptionRef\"\n\n/** @internal */\nexport const SubscriptionRefTypeId: SubscriptionRef.SubscriptionRefTypeId = Symbol.for(\n  SubscriptionRefSymbolKey\n) as SubscriptionRef.SubscriptionRefTypeId\n\nconst subscriptionRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nclass SubscriptionRefImpl<in out A> extends Effectable.Class<A> implements SubscriptionRef.SubscriptionRef<A> {\n  readonly [Readable.TypeId]: Readable.TypeId = Readable.TypeId\n  readonly [Subscribable.TypeId]: Subscribable.TypeId = Subscribable.TypeId\n  readonly [Ref.RefTypeId] = ref_.refVariance\n  readonly [Synchronized.SynchronizedRefTypeId] = circular_.synchronizedVariance\n  readonly [SubscriptionRefTypeId] = subscriptionRefVariance\n  constructor(\n    readonly ref: Ref.Ref<A>,\n    readonly pubsub: PubSub.PubSub<A>,\n    readonly semaphore: Effect.Semaphore\n  ) {\n    super()\n    this.get = Ref.get(this.ref)\n  }\n  commit() {\n    return this.get\n  }\n  readonly get: Effect.Effect<A>\n  get changes(): Stream<A> {\n    return pipe(\n      Ref.get(this.ref),\n      Effect.flatMap((a) =>\n        Effect.map(\n          stream.fromPubSub(this.pubsub, { scoped: true }),\n          (s) =>\n            stream.concat(\n              stream.make(a),\n              s\n            )\n        )\n      ),\n      this.semaphore.withPermits(1),\n      stream.unwrapScoped\n    )\n  }\n  modify<B>(f: (a: A) => readonly [B, A]): Effect.Effect<B> {\n    return this.modifyEffect((a) => Effect.succeed(f(a)))\n  }\n  modifyEffect<B, E, R>(f: (a: A) => Effect.Effect<readonly [B, A], E, R>): Effect.Effect<B, E, R> {\n    return pipe(\n      Ref.get(this.ref),\n      Effect.flatMap(f),\n      Effect.flatMap(([b, a]) =>\n        pipe(\n          Ref.set(this.ref, a),\n          Effect.as(b),\n          Effect.zipLeft(PubSub.publish(this.pubsub, a))\n        )\n      ),\n      this.semaphore.withPermits(1)\n    )\n  }\n}\n\n/** @internal */\nexport const get = <A>(self: SubscriptionRef.SubscriptionRef<A>): Effect.Effect<A> => Ref.get(self.ref)\n\n/** @internal */\nexport const make = <A>(value: A): Effect.Effect<SubscriptionRef.SubscriptionRef<A>> =>\n  pipe(\n    Effect.all([\n      PubSub.unbounded<A>(),\n      Ref.make(value),\n      Effect.makeSemaphore(1)\n    ]),\n    Effect.map(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore))\n  )\n\n/** @internal */\nexport const modify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<B>,\n  <A, B>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    f: (a: A) => readonly [B, A]\n  ) => Effect.Effect<B>\n>(2, <A, B>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  f: (a: A) => readonly [B, A]\n): Effect.Effect<B> => self.modify(f))\n\n/** @internal */\nexport const modifyEffect = dual<\n  <B, A, E, R>(\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<B, E, R>,\n  <A, B, E, R>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n  ) => Effect.Effect<B, E, R>\n>(2, <A, B, E, R>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  f: (a: A) => Effect.Effect<readonly [B, A], E, R>\n): Effect.Effect<B, E, R> => self.modifyEffect(f))\n\n/** @internal */\nexport const set = dual<\n  <A>(value: A) => (self: SubscriptionRef.SubscriptionRef<A>) => Effect.Effect<void>,\n  <A>(\n    self: SubscriptionRef.SubscriptionRef<A>,\n    value: A\n  ) => Effect.Effect<void>\n>(2, <A>(\n  self: SubscriptionRef.SubscriptionRef<A>,\n  value: A\n): Effect.Effect<void> =>\n  pipe(\n    Ref.set(self.ref, value),\n    Effect.zipLeft(PubSub.publish(self.pubsub, value)),\n    self.semaphore.withPermits(1)\n  ))\n", "/**\n * A `Supervisor<T>` is allowed to supervise the launching and termination of\n * fibers, producing some visible value of type `T` from the supervision.\n *\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport * as core from \"./internal/core.js\"\nimport * as circular from \"./internal/layer/circular.js\"\nimport * as internal from \"./internal/supervisor.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as MutableRef from \"./MutableRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as SortedSet from \"./SortedSet.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const SupervisorTypeId: unique symbol = internal.SupervisorTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type SupervisorTypeId = typeof SupervisorTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Supervisor<out T> extends Supervisor.Variance<T> {\n  /**\n   * Returns an `Effect` that succeeds with the value produced by this\n   * supervisor. This value may change over time, reflecting what the supervisor\n   * produces as it supervises fibers.\n   */\n  readonly value: Effect.Effect<T>\n\n  /**\n   * Supervises the start of a `Fiber`.\n   */\n  onStart<A, E, R>(\n    context: Context.Context<R>,\n    effect: Effect.Effect<A, E, R>,\n    parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    fiber: Fiber.RuntimeFiber<A, E>\n  ): void\n\n  /**\n   * Supervises the end of a `Fiber`.\n   */\n  onEnd<A, E>(value: Exit.Exit<A, E>, fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the execution of an `Effect` by a `Fiber`.\n   */\n  onEffect<A, E>(fiber: Fiber.RuntimeFiber<A, E>, effect: Effect.Effect<any, any, any>): void\n\n  /**\n   * Supervises the suspension of a computation running within a `Fiber`.\n   */\n  onSuspend<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Supervises the resumption of a computation running within a `Fiber`.\n   */\n  onResume<A, E>(fiber: Fiber.RuntimeFiber<A, E>): void\n\n  /**\n   * Maps this supervisor to another one, which has the same effect, but whose\n   * value has been transformed by the specified function.\n   */\n  map<B>(f: (a: T) => B): Supervisor<B>\n\n  /**\n   * Returns a new supervisor that performs the function of this supervisor, and\n   * the function of the specified supervisor, producing a tuple of the outputs\n   * produced by both supervisors.\n   */\n  zip<A>(right: Supervisor<A>): Supervisor<[T, A]>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Supervisor {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out T> {\n    readonly [SupervisorTypeId]: {\n      readonly _T: Types.Covariant<T>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category context\n */\nexport const addSupervisor: <A>(supervisor: Supervisor<A>) => Layer.Layer<never> = circular.addSupervisor\n\n/**\n * Creates a new supervisor that tracks children in a set.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fibersIn: (\n  ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>\n) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>> = internal.fibersIn\n\n/**\n * Creates a new supervisor that constantly yields effect when polled\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A> = internal.fromEffect\n\n/**\n * A supervisor that doesn't do anything in response to supervision events.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const none: Supervisor<void> = internal.none\n\n/**\n * Creates a new supervisor that tracks children in a set.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const track: Effect.Effect<Supervisor<Array<Fiber.RuntimeFiber<any, any>>>> = internal.track\n\n/**\n * Unsafely creates a new supervisor that tracks children in a set.\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeTrack: () => Supervisor<Array<Fiber.RuntimeFiber<any, any>>> = internal.unsafeTrack\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport abstract class AbstractSupervisor<T> implements Supervisor<T> {\n  /**\n   * @since 2.0.0\n   */\n  abstract value: Effect.Effect<T>\n\n  /**\n   * @since 2.0.0\n   */\n  onStart<A, E, R>(\n    _context: Context.Context<R>,\n    _effect: Effect.Effect<A, E, R>,\n    _parent: Option.Option<Fiber.RuntimeFiber<any, any>>,\n    _fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    //\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  onEnd<A, E>(\n    _value: Exit.Exit<A, E>,\n    _fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    //\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  onEffect<A, E>(\n    _fiber: Fiber.RuntimeFiber<A, E>,\n    _effect: Effect.Effect<any, any, any>\n  ): void {\n    //\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  onSuspend<A, E>(\n    _fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    //\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  onResume<A, E>(\n    _fiber: Fiber.RuntimeFiber<A, E>\n  ): void {\n    //\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  map<B>(f: (a: T) => B): Supervisor<B> {\n    return new internal.ProxySupervisor(this, core.map(this.value, f))\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  zip<A>(\n    right: Supervisor<A>\n  ): Supervisor<[T, A]> {\n    return new internal.Zip(this, right)\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  onRun<E, A, X>(execution: () => X, _fiber: Fiber.RuntimeFiber<A, E>): X {\n    return execution()\n  }\n\n  /**\n   * @since 2.0.0\n   */\n  readonly [SupervisorTypeId]: {\n    _T: (_: never) => never\n  } = internal.supervisorVariance\n}\n", "/**\n * @since 2.0.0\n */\n\nimport * as equivalence from \"./Equivalence.js\"\nimport * as predicate from \"./Predicate.js\"\n\n/**\n * Tests if a value is a `symbol`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Predicate } from \"effect\"\n *\n * assert.deepStrictEqual(Predicate.isSymbol(Symbol.for(\"a\")), true)\n * assert.deepStrictEqual(Predicate.isSymbol(\"a\"), false)\n * ```\n *\n * @category guards\n * @since 2.0.0\n */\nexport const isSymbol: (u: unknown) => u is symbol = predicate.isSymbol\n\n/**\n * @category instances\n * @since 2.0.0\n */\nexport const Equivalence: equivalence.Equivalence<symbol> = equivalence.symbol\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/stm/tArray.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TArrayTypeId: unique symbol = internal.TArrayTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TArrayTypeId = typeof TArrayTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TArray<in out A> extends TArray.Variance<A> {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TArray<in out A> {\n  /** @internal */\n  readonly chunk: Array<TRef.TRef<A>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TArray {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [TArrayTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * Finds the result of applying a partial function to the first value in its\n * domain.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const collectFirst: {\n  /**\n   * Finds the result of applying a partial function to the first value in its\n   * domain.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>\n  /**\n   * Finds the result of applying a partial function to the first value in its\n   * domain.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>\n} = internal.collectFirst\n\n/**\n * Finds the result of applying an transactional partial function to the first\n * value in its domain.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const collectFirstSTM: {\n  /**\n   * Finds the result of applying an transactional partial function to the first\n   * value in its domain.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>\n  /**\n   * Finds the result of applying an transactional partial function to the first\n   * value in its domain.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>\n} = internal.collectFirstSTM\n\n/**\n * Determine if the array contains a specified value.\n *\n * @macro trace\n * @since 2.0.0\n * @category elements\n */\nexport const contains: {\n  /**\n   * Determine if the array contains a specified value.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: TArray<A>) => STM.STM<boolean>\n  /**\n   * Determine if the array contains a specified value.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, value: A): STM.STM<boolean>\n} = internal.contains\n\n/**\n * Count the values in the array matching a predicate.\n *\n * @macro trace\n * @since 2.0.0\n * @category folding\n */\nexport const count: {\n  /**\n   * Count the values in the array matching a predicate.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>\n  /**\n   * Count the values in the array matching a predicate.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>\n} = internal.count\n\n/**\n * Count the values in the array matching a transactional predicate.\n *\n * @macro trace\n * @since 2.0.0\n * @category folding\n */\nexport const countSTM: {\n  /**\n   * Count the values in the array matching a transactional predicate.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<number, E, R>\n  /**\n   * Count the values in the array matching a transactional predicate.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<number, E, R>\n} = internal.countSTM\n\n/**\n * Makes an empty `TArray`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <A>() => STM.STM<TArray<A>> = internal.empty\n\n/**\n * Atomically evaluate the conjunction of a predicate across the members of\n * the array.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const every: {\n  /**\n   * Atomically evaluate the conjunction of a predicate across the members of\n   * the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>\n  /**\n   * Atomically evaluate the conjunction of a predicate across the members of\n   * the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>\n} = internal.every\n\n/**\n * Atomically evaluate the conjunction of a transactional predicate across the\n * members of the array.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const everySTM: {\n  /**\n   * Atomically evaluate the conjunction of a transactional predicate across the\n   * members of the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>\n  /**\n   * Atomically evaluate the conjunction of a transactional predicate across the\n   * members of the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>\n} = internal.everySTM\n\n/**\n * Find the first element in the array matching the specified predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirst: {\n  /**\n   * Find the first element in the array matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>\n  /**\n   * Find the first element in the array matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>\n} = internal.findFirst\n\n/**\n * Get the first index of a specific value in the array.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndex: {\n  /**\n   * Get the first index of a specific value in the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the first index of a specific value in the array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>\n} = internal.findFirstIndex\n\n/**\n * Get the first index of a specific value in the array starting from the\n * specified index.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndexFrom: {\n  /**\n   * Get the first index of a specific value in the array starting from the\n   * specified index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the first index of a specific value in the array starting from the\n   * specified index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>\n} = internal.findFirstIndexFrom\n\n/**\n * Get the index of the first entry in the array matching a predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndexWhere: {\n  /**\n   * Get the index of the first entry in the array matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the index of the first entry in the array matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>\n} = internal.findFirstIndexWhere\n\n/**\n * Get the index of the first entry in the array starting from the specified\n * index, matching a predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndexWhereFrom: {\n  /**\n   * Get the index of the first entry in the array starting from the specified\n   * index, matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the index of the first entry in the array starting from the specified\n   * index, matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>\n} = internal.findFirstIndexWhereFrom\n\n/**\n * Get the index of the next entry that matches a transactional predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndexWhereSTM: {\n  /**\n   * Get the index of the next entry that matches a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>\n  /**\n   * Get the index of the next entry that matches a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>\n} = internal.findFirstIndexWhereSTM\n\n/**\n * Starting at specified index, get the index of the next entry that matches a\n * transactional predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstIndexWhereFromSTM: {\n  /**\n   * Starting at specified index, get the index of the next entry that matches a\n   * transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>\n  /**\n   * Starting at specified index, get the index of the next entry that matches a\n   * transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(\n   self: TArray<A>,\n   predicate: (value: A) => STM.STM<boolean, E, R>,\n   from: number\n  ): STM.STM<Option.Option<number>, E, R>\n} = internal.findFirstIndexWhereFromSTM\n\n/**\n * Find the first element in the array matching a transactional predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findFirstSTM: {\n  /**\n   * Find the first element in the array matching a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>\n  /**\n   * Find the first element in the array matching a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>\n} = internal.findFirstSTM\n\n/**\n * Find the last element in the array matching a predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findLast: {\n  /**\n   * Find the last element in the array matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>\n  /**\n   * Find the last element in the array matching a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>\n} = internal.findLast\n\n/**\n * Get the last index of a specific value in the array bounded above by a\n * specific index.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findLastIndex: {\n  /**\n   * Get the last index of a specific value in the array bounded above by a\n   * specific index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the last index of a specific value in the array bounded above by a\n   * specific index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>\n} = internal.findLastIndex\n\n/**\n * Get the last index of a specific value in the array bounded above by a\n * specific index.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findLastIndexFrom: {\n  /**\n   * Get the last index of a specific value in the array bounded above by a\n   * specific index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A, end: number): (self: TArray<A>) => STM.STM<Option.Option<number>>\n  /**\n   * Get the last index of a specific value in the array bounded above by a\n   * specific index.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, value: A, end: number): STM.STM<Option.Option<number>>\n} = internal.findLastIndexFrom\n\n/**\n * Find the last element in the array matching a transactional predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findLastSTM: {\n  /**\n   * Find the last element in the array matching a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>\n  /**\n   * Find the last element in the array matching a transactional predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>\n} = internal.findLastSTM\n\n/**\n * Atomically performs transactional effect for each item in array.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const forEach: {\n  /**\n   * Atomically performs transactional effect for each item in array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>\n  /**\n   * Atomically performs transactional effect for each item in array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>\n} = internal.forEach\n\n/**\n * Creates a new `TArray` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>> = internal.fromIterable\n\n/**\n * Extracts value from ref in array.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * Extracts value from ref in array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (index: number): <A>(self: TArray<A>) => STM.STM<A>\n  /**\n   * Extracts value from ref in array.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, index: number): STM.STM<A>\n} = internal.get\n\n/**\n * The first entry of the array, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>> = internal.headOption\n\n/**\n * The last entry in the array, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>> = internal.lastOption\n\n/**\n * Makes a new `TArray` that is initialized with specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Elements extends [any, ...Array<any>]>(\n  ...elements: Elements\n) => STM.STM<TArray<Elements[number]>> = internal.make\n\n/**\n * Atomically compute the greatest element in the array, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const maxOption: {\n  /**\n   * Atomically compute the greatest element in the array, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>\n  /**\n   * Atomically compute the greatest element in the array, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>\n} = internal.maxOption\n\n/**\n * Atomically compute the least element in the array, if it exists.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const minOption: {\n  /**\n   * Atomically compute the least element in the array, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>\n  /**\n   * Atomically compute the least element in the array, if it exists.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>\n} = internal.minOption\n\n/**\n * Atomically folds using a pure function.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>\n} = internal.reduce\n\n/**\n * Atomically reduce the array, if non-empty, by a binary operator.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reduceOption: {\n  /**\n   * Atomically reduce the array, if non-empty, by a binary operator.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(f: (x: A, y: A) => A): (self: TArray<A>) => STM.STM<Option.Option<A>>\n  /**\n   * Atomically reduce the array, if non-empty, by a binary operator.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, f: (x: A, y: A) => A): STM.STM<Option.Option<A>>\n} = internal.reduceOption\n\n/**\n * Atomically reduce the non-empty array using a transactional binary\n * operator.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const reduceOptionSTM: {\n  /**\n   * Atomically reduce the non-empty array using a transactional binary\n   * operator.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>\n  /**\n   * Atomically reduce the non-empty array using a transactional binary\n   * operator.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>\n} = internal.reduceOptionSTM\n\n/**\n * Atomically folds using a transactional function.\n *\n * @macro trace\n * @since 2.0.0\n * @category folding\n */\nexport const reduceSTM: {\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A, R, E>(zero: Z, f: (accumulator: Z, current: A) => STM.STM<Z, E, R>): (self: TArray<A>) => STM.STM<Z, E, R>\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @macro trace\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A, R, E>(\n   self: TArray<A>,\n   zero: Z,\n   f: (accumulator: Z, current: A) => STM.STM<Z, E, R>\n  ): STM.STM<Z, E, R>\n} = internal.reduceSTM\n\n/**\n * Returns the size of the `TArray`.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <A>(self: TArray<A>) => number = internal.size\n\n/**\n * Determine if the array contains a value satisfying a predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const some: {\n  /**\n   * Determine if the array contains a value satisfying a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>\n  /**\n   * Determine if the array contains a value satisfying a predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>\n} = internal.some\n\n/**\n * Determine if the array contains a value satisfying a transactional\n * predicate.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const someSTM: {\n  /**\n   * Determine if the array contains a value satisfying a transactional\n   * predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>\n  /**\n   * Determine if the array contains a value satisfying a transactional\n   * predicate.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>\n} = internal.someSTM\n\n/**\n * Collects all elements into a chunk.\n *\n * @since 2.0.0\n * @since 2.0.0\n * @category destructors\n */\nexport const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>> = internal.toArray\n\n/**\n * Atomically updates all elements using a pure function.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const transform: {\n  /**\n   * Atomically updates all elements using a pure function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>\n  /**\n   * Atomically updates all elements using a pure function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>\n} = internal.transform\n\n/**\n * Atomically updates all elements using a transactional effect.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const transformSTM: {\n  /**\n   * Atomically updates all elements using a transactional effect.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>\n  /**\n   * Atomically updates all elements using a transactional effect.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>\n} = internal.transformSTM\n\n/**\n * Updates element in the array with given function.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const update: {\n  /**\n   * Updates element in the array with given function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>\n  /**\n   * Updates element in the array with given function.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>\n} = internal.update\n\n/**\n * Atomically updates element in the array with given transactional effect.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const updateSTM: {\n  /**\n   * Atomically updates element in the array with given transactional effect.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>\n  /**\n   * Atomically updates element in the array with given transactional effect.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>\n} = internal.updateSTM\n", "import * as Equal from \"../../Equal.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport * as Order from \"../../Order.js\"\nimport type { Predicate } from \"../../Predicate.js\"\nimport type * as STM from \"../../STM.js\"\nimport type * as TArray from \"../../TArray.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as core from \"./core.js\"\nimport * as stm from \"./stm.js\"\nimport * as tRef from \"./tRef.js\"\n\n/** @internal */\nconst TArraySymbolKey = \"effect/TArray\"\n\n/** @internal */\nexport const TArrayTypeId: TArray.TArrayTypeId = Symbol.for(TArraySymbolKey) as TArray.TArrayTypeId\n\nconst tArrayVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nexport class TArrayImpl<in out A> implements TArray.TArray<A> {\n  readonly [TArrayTypeId] = tArrayVariance\n  constructor(readonly chunk: Array<TRef.TRef<A>>) {}\n}\n\n/** @internal */\nexport const collectFirst = dual<\n  <A, B>(pf: (a: A) => Option.Option<B>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<B>>,\n  <A, B>(self: TArray.TArray<A>, pf: (a: A) => Option.Option<B>) => STM.STM<Option.Option<B>>\n>(2, (self, pf) =>\n  collectFirstSTM(\n    self,\n    (a) => pipe(pf(a), Option.map(core.succeed))\n  ))\n\n/** @internal */\nexport const collectFirstSTM = dual<\n  <A, B, E, R>(\n    pf: (a: A) => Option.Option<STM.STM<B, E, R>>\n  ) => (\n    self: TArray.TArray<A>\n  ) => STM.STM<Option.Option<B>, E, R>,\n  <A, B, E, R>(\n    self: TArray.TArray<A>,\n    pf: (a: A) => Option.Option<STM.STM<B, E, R>>\n  ) => STM.STM<Option.Option<B>, E, R>\n>(\n  2,\n  <A, B, E, R>(self: TArray.TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>) =>\n    core.withSTMRuntime((runtime) => {\n      let index = 0\n      let result: Option.Option<STM.STM<B, E, R>> = Option.none()\n      while (Option.isNone(result) && index < self.chunk.length) {\n        const element = pipe(self.chunk[index], tRef.unsafeGet(runtime.journal))\n        const option = pf(element)\n        if (Option.isSome(option)) {\n          result = option\n        }\n        index = index + 1\n      }\n      return pipe(\n        result,\n        Option.match({\n          onNone: () => stm.succeedNone,\n          onSome: core.map(Option.some)\n        })\n      )\n    })\n)\n\n/** @internal */\nexport const contains = dual<\n  <A>(value: A) => (self: TArray.TArray<A>) => STM.STM<boolean>,\n  <A>(self: TArray.TArray<A>, value: A) => STM.STM<boolean>\n>(2, (self, value) => some(self, (a) => Equal.equals(a)(value)))\n\n/** @internal */\nexport const count = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<number>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<number>\n>(2, (self, predicate) =>\n  reduce(\n    self,\n    0,\n    (n, a) => predicate(a) ? n + 1 : n\n  ))\n\n/** @internal */\nexport const countSTM = dual<\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>) => (self: TArray.TArray<A>) => STM.STM<number, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>) => STM.STM<number, E, R>\n>(2, (self, predicate) =>\n  reduceSTM(\n    self,\n    0,\n    (n, a) => core.map(predicate(a), (bool) => bool ? n + 1 : n)\n  ))\n\n/** @internal */\nexport const empty = <A>(): STM.STM<TArray.TArray<A>> => fromIterable<A>([])\n\n/** @internal */\nexport const every = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<boolean>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<boolean>\n>(2, (self, predicate) => stm.negate(some(self, (a) => !predicate(a))))\n\n/** @internal */\nexport const everySTM = dual<\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>) => (self: TArray.TArray<A>) => STM.STM<boolean, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>) => STM.STM<boolean, E, R>\n>(2, (self, predicate) =>\n  core.map(\n    countSTM(self, predicate),\n    (count) => count === self.chunk.length\n  ))\n\n/** @internal */\nexport const findFirst = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<Option.Option<A>>\n>(2, (self, predicate) =>\n  collectFirst(self, (a) =>\n    predicate(a)\n      ? Option.some(a)\n      : Option.none()))\n\n/** @internal */\nexport const findFirstIndex = dual<\n  <A>(value: A) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, value: A) => STM.STM<Option.Option<number>>\n>(2, (self, value) => findFirstIndexFrom(self, value, 0))\n\n/** @internal */\nexport const findFirstIndexFrom = dual<\n  <A>(value: A, from: number) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, value: A, from: number) => STM.STM<Option.Option<number>>\n>(3, (self, value, from) =>\n  findFirstIndexWhereFrom(\n    self,\n    (a) => Equal.equals(a)(value),\n    from\n  ))\n\n/** @internal */\nexport const findFirstIndexWhere = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<Option.Option<number>>\n>(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0))\n\n/** @internal */\nexport const findFirstIndexWhereFrom = dual<\n  <A>(\n    predicate: Predicate<A>,\n    from: number\n  ) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>, from: number) => STM.STM<Option.Option<number>>\n>(3, (self, predicate, from) => {\n  if (from < 0) {\n    return stm.succeedNone\n  }\n  return core.effect<never, Option.Option<number>>((journal) => {\n    let index: number = from\n    let found = false\n    while (!found && index < self.chunk.length) {\n      const element = tRef.unsafeGet(self.chunk[index], journal)\n      found = predicate(element)\n      index = index + 1\n    }\n    if (found) {\n      return Option.some(index - 1)\n    }\n    return Option.none()\n  })\n})\n\n/** @internal */\nexport const findFirstIndexWhereSTM = dual<\n  <A, R, E>(\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>, E, R>,\n  <A, R, E>(\n    self: TArray.TArray<A>,\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => STM.STM<Option.Option<number>, E, R>\n>(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0))\n\n/** @internal */\nexport const findFirstIndexWhereFromSTM = dual<\n  <A, R, E>(\n    predicate: (value: A) => STM.STM<boolean, E, R>,\n    from: number\n  ) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>, E, R>,\n  <A, R, E>(\n    self: TArray.TArray<A>,\n    predicate: (value: A) => STM.STM<boolean, E, R>,\n    from: number\n  ) => STM.STM<Option.Option<number>, E, R>\n>(3, <A, R, E>(\n  self: TArray.TArray<A>,\n  predicate: (value: A) => STM.STM<boolean, E, R>,\n  from: number\n) => {\n  const forIndex = (index: number): STM.STM<Option.Option<number>, E, R> =>\n    index < self.chunk.length\n      ? pipe(\n        tRef.get(self.chunk[index]),\n        core.flatMap(predicate),\n        core.flatMap((bool) =>\n          bool ?\n            core.succeed(Option.some(index)) :\n            forIndex(index + 1)\n        )\n      )\n      : stm.succeedNone\n  return from < 0\n    ? stm.succeedNone\n    : forIndex(from)\n})\n\n/** @internal */\nexport const findFirstSTM = dual<\n  <A, R, E>(\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => (\n    self: TArray.TArray<A>\n  ) => STM.STM<Option.Option<A>, E, R>,\n  <A, R, E>(\n    self: TArray.TArray<A>,\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => STM.STM<Option.Option<A>, E, R>\n>(2, <A, R, E>(self: TArray.TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>) => {\n  const init = [Option.none() as Option.Option<A>, 0 as number] as const\n  const cont = (state: readonly [Option.Option<A>, number]) =>\n    Option.isNone(state[0]) && state[1] < self.chunk.length - 1\n  return core.map(\n    stm.iterate(init, {\n      while: cont,\n      body: (state) => {\n        const index = state[1]\n        return pipe(\n          tRef.get(self.chunk[index]),\n          core.flatMap((value) =>\n            core.map(\n              predicate(value),\n              (bool) => [bool ? Option.some(value) : Option.none(), index + 1] as const\n            )\n          )\n        )\n      }\n    }),\n    (state) => state[0]\n  )\n})\n\n/** @internal */\nexport const findLast = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<Option.Option<A>>\n>(2, <A>(self: TArray.TArray<A>, predicate: Predicate<A>) =>\n  core.effect<never, Option.Option<A>>((journal) => {\n    let index = self.chunk.length - 1\n    let result: Option.Option<A> = Option.none()\n    while (Option.isNone(result) && index >= 0) {\n      const element = tRef.unsafeGet(self.chunk[index], journal)\n      if (predicate(element)) {\n        result = Option.some(element)\n      }\n      index = index - 1\n    }\n    return result\n  }))\n\n/** @internal */\nexport const findLastIndex = dual<\n  <A>(value: A) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, value: A) => STM.STM<Option.Option<number>>\n>(2, (self, value) => findLastIndexFrom(self, value, self.chunk.length - 1))\n\n/** @internal */\nexport const findLastIndexFrom = dual<\n  <A>(value: A, end: number) => (self: TArray.TArray<A>) => STM.STM<Option.Option<number>>,\n  <A>(self: TArray.TArray<A>, value: A, end: number) => STM.STM<Option.Option<number>>\n>(3, (self, value, end) => {\n  if (end >= self.chunk.length) {\n    return stm.succeedNone\n  }\n  return core.effect<never, Option.Option<number>>((journal) => {\n    let index: number = end\n    let found = false\n    while (!found && index >= 0) {\n      const element = tRef.unsafeGet(self.chunk[index], journal)\n      found = Equal.equals(element)(value)\n      index = index - 1\n    }\n    if (found) {\n      return Option.some(index + 1)\n    }\n    return Option.none()\n  })\n})\n\n/** @internal */\nexport const findLastSTM = dual<\n  <A, R, E>(\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>, E, R>,\n  <A, R, E>(\n    self: TArray.TArray<A>,\n    predicate: (value: A) => STM.STM<boolean, E, R>\n  ) => STM.STM<Option.Option<A>, E, R>\n>(2, <A, R, E>(self: TArray.TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>) => {\n  const init = [Option.none() as Option.Option<A>, self.chunk.length - 1] as const\n  const cont = (state: readonly [Option.Option<A>, number]) => Option.isNone(state[0]) && state[1] >= 0\n  return core.map(\n    stm.iterate(init, {\n      while: cont,\n      body: (state) => {\n        const index = state[1]\n        return pipe(\n          tRef.get(self.chunk[index]),\n          core.flatMap((value) =>\n            core.map(\n              predicate(value),\n              (bool) => [bool ? Option.some(value) : Option.none(), index - 1] as const\n            )\n          )\n        )\n      }\n    }),\n    (state) => state[0]\n  )\n})\n\n/** @internal */\nexport const forEach = dual<\n  <A, R, E>(f: (value: A) => STM.STM<void, E, R>) => (self: TArray.TArray<A>) => STM.STM<void, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, f: (value: A) => STM.STM<void, E, R>) => STM.STM<void, E, R>\n>(2, (self, f) => reduceSTM(self, void 0 as void, (_, a) => f(a)))\n\n/** @internal */\nexport const fromIterable = <A>(iterable: Iterable<A>): STM.STM<TArray.TArray<A>> =>\n  core.map(\n    stm.forEach(iterable, tRef.make),\n    (chunk) => new TArrayImpl(chunk)\n  )\n\n/** @internal */\nexport const get = dual<\n  (index: number) => <A>(self: TArray.TArray<A>) => STM.STM<A>,\n  <A>(self: TArray.TArray<A>, index: number) => STM.STM<A>\n>(2, (self, index) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\")\n  }\n  return tRef.get(self.chunk[index])\n})\n\n/** @internal */\nexport const headOption = <A>(self: TArray.TArray<A>): STM.STM<Option.Option<A>> =>\n  self.chunk.length === 0 ?\n    core.succeed(Option.none()) :\n    core.map(tRef.get(self.chunk[0]), Option.some)\n\n/** @internal */\nexport const lastOption = <A>(self: TArray.TArray<A>): STM.STM<Option.Option<A>> =>\n  self.chunk.length === 0 ?\n    stm.succeedNone :\n    core.map(tRef.get(self.chunk[self.chunk.length - 1]), Option.some)\n\n/** @internal */\nexport const make = <Elements extends [any, ...Array<any>]>(\n  ...elements: Elements\n): STM.STM<TArray.TArray<Elements[number]>> => fromIterable(elements)\n\n/** @internal */\nexport const maxOption = dual<\n  <A>(order: Order.Order<A>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>>,\n  <A>(self: TArray.TArray<A>, order: Order.Order<A>) => STM.STM<Option.Option<A>>\n>(2, (self, order) => {\n  const greaterThan = Order.greaterThan(order)\n  return reduceOption(self, (acc, curr) => greaterThan(acc)(curr) ? curr : acc)\n})\n\n/** @internal */\nexport const minOption = dual<\n  <A>(order: Order.Order<A>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>>,\n  <A>(self: TArray.TArray<A>, order: Order.Order<A>) => STM.STM<Option.Option<A>>\n>(2, (self, order) => {\n  const lessThan = Order.lessThan(order)\n  return reduceOption(self, (acc, curr) => lessThan(acc)(curr) ? curr : acc)\n})\n\n/** @internal */\nexport const reduce = dual<\n  <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z) => (self: TArray.TArray<A>) => STM.STM<Z>,\n  <Z, A>(self: TArray.TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z) => STM.STM<Z>\n>(\n  3,\n  <Z, A>(self: TArray.TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z) =>\n    core.effect<never, Z>((journal) => {\n      let index = 0\n      let result = zero\n      while (index < self.chunk.length) {\n        const element = tRef.unsafeGet(self.chunk[index], journal)\n        result = f(result, element)\n        index = index + 1\n      }\n      return result\n    })\n)\n\n/** @internal */\nexport const reduceOption = dual<\n  <A>(f: (x: A, y: A) => A) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>>,\n  <A>(self: TArray.TArray<A>, f: (x: A, y: A) => A) => STM.STM<Option.Option<A>>\n>(\n  2,\n  <A>(self: TArray.TArray<A>, f: (x: A, y: A) => A) =>\n    core.effect<never, Option.Option<A>>((journal) => {\n      let index = 0\n      let result: A | undefined = undefined\n      while (index < self.chunk.length) {\n        const element = tRef.unsafeGet(self.chunk[index], journal)\n        result = result === undefined ? element : f(result, element)\n        index = index + 1\n      }\n      return Option.fromNullable(result)\n    })\n)\n\n/** @internal */\nexport const reduceOptionSTM = dual<\n  <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>) => (self: TArray.TArray<A>) => STM.STM<Option.Option<A>, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>) => STM.STM<Option.Option<A>, E, R>\n>(\n  2,\n  <A, R, E>(self: TArray.TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>) =>\n    reduceSTM(self, Option.none<A>(), (acc, curr) =>\n      Option.isSome(acc)\n        ? core.map(f(acc.value, curr), Option.some)\n        : stm.succeedSome(curr))\n)\n\n/** @internal */\nexport const reduceSTM = dual<\n  <Z, A, R, E>(\n    zero: Z,\n    f: (accumulator: Z, current: A) => STM.STM<Z, E, R>\n  ) => (self: TArray.TArray<A>) => STM.STM<Z, E, R>,\n  <Z, A, R, E>(\n    self: TArray.TArray<A>,\n    zero: Z,\n    f: (accumulator: Z, current: A) => STM.STM<Z, E, R>\n  ) => STM.STM<Z, E, R>\n>(3, (self, zero, f) =>\n  core.flatMap(\n    toArray(self),\n    stm.reduce(zero, f)\n  ))\n\n/** @internal */\nexport const size = <A>(self: TArray.TArray<A>): number => self.chunk.length\n\n/** @internal */\nexport const some = dual<\n  <A>(predicate: Predicate<A>) => (self: TArray.TArray<A>) => STM.STM<boolean>,\n  <A>(self: TArray.TArray<A>, predicate: Predicate<A>) => STM.STM<boolean>\n>(2, (self, predicate) =>\n  core.map(\n    findFirst(self, predicate),\n    Option.isSome\n  ))\n\n/** @internal */\nexport const someSTM = dual<\n  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>) => (self: TArray.TArray<A>) => STM.STM<boolean, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>) => STM.STM<boolean, E, R>\n>(2, (self, predicate) => core.map(countSTM(self, predicate), (n) => n > 0))\n\n/** @internal */\nexport const toArray = <A>(self: TArray.TArray<A>): STM.STM<Array<A>> => stm.forEach(self.chunk, tRef.get)\n\n/** @internal */\nexport const transform = dual<\n  <A>(f: (value: A) => A) => (self: TArray.TArray<A>) => STM.STM<void>,\n  <A>(self: TArray.TArray<A>, f: (value: A) => A) => STM.STM<void>\n>(2, (self, f) =>\n  core.effect<never, void>((journal) => {\n    let index = 0\n    while (index < self.chunk.length) {\n      const ref = self.chunk[index]\n      tRef.unsafeSet(ref, f(tRef.unsafeGet(ref, journal)), journal)\n      index = index + 1\n    }\n    return void 0\n  }))\n\n/** @internal */\nexport const transformSTM = dual<\n  <A, R, E>(f: (value: A) => STM.STM<A, E, R>) => (self: TArray.TArray<A>) => STM.STM<void, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, f: (value: A) => STM.STM<A, E, R>) => STM.STM<void, E, R>\n>(2, <A, R, E>(self: TArray.TArray<A>, f: (value: A) => STM.STM<A, E, R>) =>\n  core.flatMap(\n    stm.forEach(\n      self.chunk,\n      (ref) => core.flatMap(tRef.get(ref), f)\n    ),\n    (chunk) =>\n      core.effect<never, void>((journal) => {\n        const iterator = chunk[Symbol.iterator]()\n        let index = 0\n        let next: IteratorResult<A>\n        while ((next = iterator.next()) && !next.done) {\n          tRef.unsafeSet(self.chunk[index], next.value, journal)\n          index = index + 1\n        }\n        return void 0\n      })\n  ))\n\n/** @internal */\nexport const update = dual<\n  <A>(index: number, f: (value: A) => A) => (self: TArray.TArray<A>) => STM.STM<void>,\n  <A>(self: TArray.TArray<A>, index: number, f: (value: A) => A) => STM.STM<void>\n>(3, (self, index, f) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\")\n  }\n  return tRef.update(self.chunk[index], f)\n})\n\n/** @internal */\nexport const updateSTM = dual<\n  <A, R, E>(index: number, f: (value: A) => STM.STM<A, E, R>) => (self: TArray.TArray<A>) => STM.STM<void, E, R>,\n  <A, R, E>(self: TArray.TArray<A>, index: number, f: (value: A) => STM.STM<A, E, R>) => STM.STM<void, E, R>\n>(3, (self, index, f) => {\n  if (index < 0 || index >= self.chunk.length) {\n    return core.dieMessage(\"Index out of bounds\")\n  }\n  return pipe(\n    tRef.get(self.chunk[index]),\n    core.flatMap(f),\n    core.flatMap((updated) => tRef.set(self.chunk[index], updated))\n  )\n})\n", "/**\n * @since 2.0.0\n */\nimport type * as Either from \"./Either.js\"\nimport * as internal from \"./internal/stm/tDeferred.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TDeferredTypeId: unique symbol = internal.TDeferredTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TDeferredTypeId = typeof TDeferredTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TDeferred<in out A, in out E = never> extends TDeferred.Variance<A, E> {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TDeferred<in out A, in out E> {\n  /** @internal */\n  readonly ref: TRef.TRef<Option.Option<Either.Either<A, E>>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TDeferred {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A, in out E> {\n    readonly [TDeferredTypeId]: {\n      readonly _A: Types.Invariant<A>\n      readonly _E: Types.Invariant<E>\n    }\n  }\n}\n\nconst _await: <A, E>(self: TDeferred<A, E>) => STM.STM<A, E> = internal._await\n\nexport {\n  /**\n   * @since 2.0.0\n   * @category getters\n   */\n  _await as await\n}\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const done: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E>(either: Either.Either<A, E>): (self: TDeferred<A, E>) => STM.STM<boolean>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E>(self: TDeferred<A, E>, either: Either.Either<A, E>): STM.STM<boolean>\n} = internal.done\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const fail: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <E>(error: E): <A>(self: TDeferred<A, E>) => STM.STM<boolean>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E>(self: TDeferred<A, E>, error: E): STM.STM<boolean>\n} = internal.fail\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A, E = never>() => STM.STM<TDeferred<A, E>> = internal.make\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const poll: <A, E>(self: TDeferred<A, E>) => STM.STM<Option.Option<Either.Either<A, E>>> = internal.poll\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const succeed: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): <E>(self: TDeferred<A, E>) => STM.STM<boolean>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E>(self: TDeferred<A, E>, value: A): STM.STM<boolean>\n} = internal.succeed\n", "import * as Either from \"../../Either.js\"\nimport { dual } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport type * as STM from \"../../STM.js\"\nimport type * as TDeferred from \"../../TDeferred.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as core from \"./core.js\"\nimport * as stm from \"./stm.js\"\nimport * as tRef from \"./tRef.js\"\n\n/** @internal */\nconst TDeferredSymbolKey = \"effect/TDeferred\"\n\n/** @internal */\nexport const TDeferredTypeId: TDeferred.TDeferredTypeId = Symbol.for(\n  TDeferredSymbolKey\n) as TDeferred.TDeferredTypeId\n\n/** @internal */\nconst tDeferredVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _,\n  /* c8 ignore next */\n  _E: (_: any) => _\n}\n\n/** @internal */\nclass TDeferredImpl<in out A, in out E = never> implements TDeferred.TDeferred<A, E> {\n  readonly [TDeferredTypeId] = tDeferredVariance\n  constructor(readonly ref: TRef.TRef<Option.Option<Either.Either<A, E>>>) {}\n}\n\n/** @internal */\nexport const _await = <A, E>(self: TDeferred.TDeferred<A, E>): STM.STM<A, E> =>\n  stm.flatten(\n    stm.collect(tRef.get(self.ref), (option) =>\n      Option.isSome(option) ?\n        Option.some(stm.fromEither(option.value)) :\n        Option.none())\n  )\n\n/** @internal */\nexport const done = dual<\n  <A, E>(either: Either.Either<A, E>) => (self: TDeferred.TDeferred<A, E>) => STM.STM<boolean>,\n  <A, E>(self: TDeferred.TDeferred<A, E>, either: Either.Either<A, E>) => STM.STM<boolean>\n>(2, (self, either) =>\n  core.flatMap(\n    tRef.get(self.ref),\n    Option.match({\n      onNone: () =>\n        core.zipRight(\n          tRef.set(self.ref, Option.some(either)),\n          core.succeed(true)\n        ),\n      onSome: () => core.succeed(false)\n    })\n  ))\n\n/** @internal */\nexport const fail = dual<\n  <E>(error: E) => <A>(self: TDeferred.TDeferred<A, E>) => STM.STM<boolean>,\n  <A, E>(self: TDeferred.TDeferred<A, E>, error: E) => STM.STM<boolean>\n>(2, (self, error) => done(self, Either.left(error)))\n\n/** @internal */\nexport const make = <A, E = never>(): STM.STM<TDeferred.TDeferred<A, E>> =>\n  core.map(\n    tRef.make<Option.Option<Either.Either<A, E>>>(Option.none()),\n    (ref) => new TDeferredImpl(ref)\n  )\n\n/** @internal */\nexport const poll = <A, E>(\n  self: TDeferred.TDeferred<A, E>\n): STM.STM<Option.Option<Either.Either<A, E>>> => tRef.get(self.ref)\n\n/** @internal */\nexport const succeed = dual<\n  <A>(value: A) => <E>(self: TDeferred.TDeferred<A, E>) => STM.STM<boolean>,\n  <A, E>(self: TDeferred.TDeferred<A, E>, value: A) => STM.STM<boolean>\n>(2, (self, value) => done(self, Either.right(value)))\n", "/**\n * @since 2.0.0\n */\nimport type * as Chunk from \"./Chunk.js\"\nimport type { LazyArg } from \"./Function.js\"\nimport type * as HashMap from \"./HashMap.js\"\nimport * as internal from \"./internal/stm/tMap.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TArray from \"./TArray.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TMapTypeId: unique symbol = internal.TMapTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TMapTypeId = typeof TMapTypeId\n\n/**\n * Transactional map implemented on top of `TRef` and `TArray`. Resolves\n * conflicts via chaining.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface TMap<in out K, in out V> extends TMap.Variance<K, V> {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TMap<in out K, in out V> {\n  /** @internal */\n  readonly tBuckets: TRef.TRef<TArray.TArray<Chunk.Chunk<readonly [K, V]>>>\n  /** @internal */\n  readonly tSize: TRef.TRef<number>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TMap {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out K, in out V> {\n    readonly [TMapTypeId]: {\n      readonly _K: Types.Invariant<K>\n      readonly _V: Types.Invariant<V>\n    }\n  }\n}\n\n/**\n * Makes an empty `TMap`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <K, V>() => STM.STM<TMap<K, V>> = internal.empty\n\n/**\n * Finds the key/value pair matching the specified predicate, and uses the\n * provided function to extract a value out of it.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const find: {\n  /**\n   * Finds the key/value pair matching the specified predicate, and uses the\n   * provided function to extract a value out of it.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>\n  /**\n   * Finds the key/value pair matching the specified predicate, and uses the\n   * provided function to extract a value out of it.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>\n} = internal.find\n\n/**\n * Finds the key/value pair matching the specified predicate, and uses the\n * provided effectful function to extract a value out of it.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findSTM: {\n  /**\n   * Finds the key/value pair matching the specified predicate, and uses the\n   * provided effectful function to extract a value out of it.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>\n  /**\n   * Finds the key/value pair matching the specified predicate, and uses the\n   * provided effectful function to extract a value out of it.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Option.Option<A>, E, R>\n} = internal.findSTM\n\n/**\n * Finds all the key/value pairs matching the specified predicate, and uses\n * the provided function to extract values out them.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findAll: {\n  /**\n   * Finds all the key/value pairs matching the specified predicate, and uses\n   * the provided function to extract values out them.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>\n  /**\n   * Finds all the key/value pairs matching the specified predicate, and uses\n   * the provided function to extract values out them.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>\n} = internal.findAll\n\n/**\n * Finds all the key/value pairs matching the specified predicate, and uses\n * the provided effectful function to extract values out of them..\n *\n * @since 2.0.0\n * @category elements\n */\nexport const findAllSTM: {\n  /**\n   * Finds all the key/value pairs matching the specified predicate, and uses\n   * the provided effectful function to extract values out of them..\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>\n  /**\n   * Finds all the key/value pairs matching the specified predicate, and uses\n   * the provided effectful function to extract values out of them..\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, A, E, R>(\n    self: TMap<K, V>,\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ): STM.STM<Array<A>, E, R>\n} = internal.findAllSTM\n\n/**\n * Atomically performs transactional-effect for each binding present in map.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const forEach: {\n  /**\n   * Atomically performs transactional-effect for each binding present in map.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>\n  /**\n   * Atomically performs transactional-effect for each binding present in map.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>\n} = internal.forEach\n\n/**\n * Creates a new `TMap` from an iterable collection of key/value pairs.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <K, V>(\n  iterable: Iterable<readonly [K, V]>\n) => STM.STM<TMap<K, V>> = internal.fromIterable\n\n/**\n * Retrieves value associated with given key.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * Retrieves value associated with given key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>\n  /**\n   * Retrieves value associated with given key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>\n} = internal.get\n\n/**\n * Retrieves value associated with given key or default value, in case the key\n * isn't present.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const getOrElse: {\n  /**\n   * Retrieves value associated with given key or default value, in case the key\n   * isn't present.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>\n  /**\n   * Retrieves value associated with given key or default value, in case the key\n   * isn't present.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>\n} = internal.getOrElse\n\n/**\n * Tests whether or not map contains a key.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * Tests whether or not map contains a key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>\n  /**\n   * Tests whether or not map contains a key.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>\n} = internal.has\n\n/**\n * Tests if the map is empty or not.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean> = internal.isEmpty\n\n/**\n * Collects all keys stored in map.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>> = internal.keys\n\n/**\n * Makes a new `TMap` that is initialized with specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>> = internal.make\n\n/**\n * If the key is not already associated with a value, stores the provided value,\n * otherwise merge the existing value with the new one using function `f` and\n * store the result.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const merge: {\n  /**\n   * If the key is not already associated with a value, stores the provided value,\n   * otherwise merge the existing value with the new one using function `f` and\n   * store the result.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>\n  /**\n   * If the key is not already associated with a value, stores the provided value,\n   * otherwise merge the existing value with the new one using function `f` and\n   * store the result.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>\n} = internal.merge\n\n/**\n * Atomically folds using a pure function.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>\n} = internal.reduce\n\n/**\n * Atomically folds using a transactional function.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceSTM: {\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V, K, R, E>(\n    self: TMap<K, V>,\n    zero: Z,\n    f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>\n  ): STM.STM<Z, E, R>\n} = internal.reduceSTM\n\n/**\n * Removes binding for given key.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const remove: {\n  /**\n   * Removes binding for given key.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Removes binding for given key.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, key: K): STM.STM<void>\n} = internal.remove\n\n/**\n * Deletes all entries associated with the specified keys.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const removeAll: {\n  /**\n   * Deletes all entries associated with the specified keys.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Deletes all entries associated with the specified keys.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>\n} = internal.removeAll\n\n/**\n * Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n * (or `void` if `discard = true`).\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const removeIf: {\n  /**\n   * Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>\n  /**\n   * Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    self: TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  /**\n   * Removes entries from a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    self: TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<[K, V]>>\n} = internal.removeIf\n\n/**\n * Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n * (or `void` if `discard = true`).\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retainIf: {\n  /**\n   * Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>\n  /**\n   * Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    self: TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  /**\n   * Retains entries in a `TMap` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(\n    self: TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<[K, V]>>\n} = internal.retainIf\n\n/**\n * Stores new binding into the map.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const set: {\n  /**\n   * Stores new binding into the map.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Stores new binding into the map.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>\n} = internal.set\n\n/**\n * Stores new binding in the map if it does not already exist.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const setIfAbsent: {\n  /**\n   * Stores new binding in the map if it does not already exist.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Stores new binding in the map if it does not already exist.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>\n} = internal.setIfAbsent\n\n/**\n * Returns the number of bindings.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <K, V>(self: TMap<K, V>) => STM.STM<number> = internal.size\n\n/**\n * Takes the first matching value, or retries until there is one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeFirst: {\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>\n} = internal.takeFirst\n\n/**\n * Takes the first matching value, or retries until there is one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeFirstSTM: {\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A, E, R>(\n    self: TMap<K, V>,\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ): STM.STM<A, E, R>\n} = internal.takeFirstSTM\n\n/**\n * Takes all matching values, or retries until there is at least one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeSome: {\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>\n} = internal.takeSome\n\n/**\n * Takes all matching values, or retries until there is at least one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeSomeSTM: {\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, A, E, R>(\n    self: TMap<K, V>,\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ): STM.STM<[A, ...Array<A>], E, R>\n} = internal.takeSomeSTM\n\n/**\n * Collects all bindings into a `Chunk`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>> = internal.toChunk\n\n/**\n * Collects all bindings into a `HashMap`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toHashMap: <K, V>(self: TMap<K, V>) => STM.STM<HashMap.HashMap<K, V>> = internal.toHashMap\n\n/**\n * Collects all bindings into an `Array`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>> = internal.toArray\n\n/**\n * Collects all bindings into a `Map`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>> = internal.toMap\n\n/**\n * Atomically updates all bindings using a pure function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transform: {\n  /**\n   * Atomically updates all bindings using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Atomically updates all bindings using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>\n} = internal.transform\n\n/**\n * Atomically updates all bindings using a transactional function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transformSTM: {\n  /**\n   * Atomically updates all bindings using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>\n  /**\n   * Atomically updates all bindings using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>\n} = internal.transformSTM\n\n/**\n * Atomically updates all values using a pure function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transformValues: {\n  /**\n   * Atomically updates all values using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>\n  /**\n   * Atomically updates all values using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>\n} = internal.transformValues\n\n/**\n * Atomically updates all values using a transactional function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transformValuesSTM: {\n  /**\n   * Atomically updates all values using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>\n  /**\n   * Atomically updates all values using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>\n} = internal.transformValuesSTM\n\n/**\n * Updates the mapping for the specified key with the specified function,\n * which takes the current value of the key as an input, if it exists, and\n * either returns `Some` with a new value to indicate to update the value in\n * the map or `None` to remove the value from the map. Returns `Some` with the\n * updated value or `None` if the value was removed from the map.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const updateWith: {\n  /**\n   * Updates the mapping for the specified key with the specified function,\n   * which takes the current value of the key as an input, if it exists, and\n   * either returns `Some` with a new value to indicate to update the value in\n   * the map or `None` to remove the value from the map. Returns `Some` with the\n   * updated value or `None` if the value was removed from the map.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>\n  /**\n   * Updates the mapping for the specified key with the specified function,\n   * which takes the current value of the key as an input, if it exists, and\n   * either returns `Some` with a new value to indicate to update the value in\n   * the map or `None` to remove the value from the map. Returns `Some` with the\n   * updated value or `None` if the value was removed from the map.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>\n} = internal.updateWith\n\n/**\n * Collects all values stored in map.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>> = internal.values\n", "import * as RA from \"../../Array.js\"\nimport * as Chunk from \"../../Chunk.js\"\nimport * as Equal from \"../../Equal.js\"\nimport type { LazyArg } from \"../../Function.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Hash from \"../../Hash.js\"\nimport * as HashMap from \"../../HashMap.js\"\nimport * as Option from \"../../Option.js\"\nimport { hasProperty } from \"../../Predicate.js\"\nimport * as STM from \"../../STM.js\"\nimport type * as TArray from \"../../TArray.js\"\nimport type * as TMap from \"../../TMap.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as core from \"./core.js\"\nimport type * as Journal from \"./journal.js\"\nimport * as stm from \"./stm.js\"\nimport * as tArray from \"./tArray.js\"\nimport * as tRef from \"./tRef.js\"\n\n/** @internal */\nconst TMapSymbolKey = \"effect/TMap\"\n\n/** @internal */\nexport const TMapTypeId: TMap.TMapTypeId = Symbol.for(\n  TMapSymbolKey\n) as TMap.TMapTypeId\n\nconst tMapVariance = {\n  /* c8 ignore next */\n  _K: (_: any) => _,\n  /* c8 ignore next */\n  _V: (_: any) => _\n}\n\n/** @internal */\nclass TMapImpl<in out K, in out V> implements TMap.TMap<K, V> {\n  readonly [TMapTypeId] = tMapVariance\n  constructor(\n    readonly tBuckets: TRef.TRef<TArray.TArray<Chunk.Chunk<readonly [K, V]>>>,\n    readonly tSize: TRef.TRef<number>\n  ) {}\n}\n\nconst isTMap = (u: unknown) => hasProperty(u, TMapTypeId)\n\n/** @internal */\nconst InitialCapacity = 16\nconst LoadFactor = 0.75\n\n/** @internal */\nconst nextPowerOfTwo = (size: number): number => {\n  const n = -1 >>> Math.clz32(size - 1)\n  return n < 0 ? 1 : n + 1\n}\n\n/** @internal */\nconst hash = <K>(key: K): number => {\n  const h = Hash.hash(key)\n  return h ^ (h >>> 16)\n}\n\n/** @internal */\nconst indexOf = <K>(k: K, capacity: number): number => hash(k) & (capacity - 1)\n\n/** @internal */\nconst allocate = <K, V>(\n  capacity: number,\n  data: Chunk.Chunk<readonly [K, V]>\n): STM.STM<TMap.TMap<K, V>> => {\n  const buckets = Array.from({ length: capacity }, () => Chunk.empty<readonly [K, V]>())\n  const distinct = new Map<K, V>(data)\n  let size = 0\n  for (const entry of distinct) {\n    const index = indexOf(entry[0], capacity)\n    buckets[index] = pipe(buckets[index], Chunk.prepend(entry))\n    size = size + 1\n  }\n  return pipe(\n    tArray.fromIterable(buckets),\n    core.flatMap((buckets) =>\n      pipe(\n        tRef.make(buckets),\n        core.flatMap((tBuckets) =>\n          pipe(\n            tRef.make(size),\n            core.map((tSize) => new TMapImpl(tBuckets, tSize))\n          )\n        )\n      )\n    )\n  )\n}\n\n/** @internal */\nexport const empty = <K, V>(): STM.STM<TMap.TMap<K, V>> => fromIterable<K, V>([])\n\n/** @internal */\nexport const find = dual<\n  <K, V, A>(\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Option.Option<A>>,\n  <K, V, A>(\n    self: TMap.TMap<K, V>,\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => STM.STM<Option.Option<A>>\n>(2, (self, pf) =>\n  findSTM(self, (key, value) => {\n    const option = pf(key, value)\n    if (Option.isSome(option)) {\n      return core.succeed(option.value)\n    }\n    return core.fail(Option.none())\n  }))\n\n/** @internal */\nexport const findSTM = dual<\n  <K, V, A, E, R>(\n    f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Option.Option<A>, E, R>,\n  <K, V, A, E, R>(\n    self: TMap.TMap<K, V>,\n    f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => STM.STM<Option.Option<A>, E, R>\n>(2, <K, V, A, E, R>(\n  self: TMap.TMap<K, V>,\n  f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n) =>\n  reduceSTM(self, Option.none<A>(), (acc, value, key) =>\n    Option.isNone(acc) ?\n      core.matchSTM(f(key, value), {\n        onFailure: Option.match({\n          onNone: () => stm.succeedNone,\n          onSome: core.fail\n        }),\n        onSuccess: stm.succeedSome\n      }) :\n      STM.succeed(acc)))\n\n/** @internal */\nexport const findAll = dual<\n  <K, V, A>(\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Array<A>>,\n  <K, V, A>(\n    self: TMap.TMap<K, V>,\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => STM.STM<Array<A>>\n>(2, (self, pf) =>\n  findAllSTM(self, (key, value) => {\n    const option = pf(key, value)\n    if (Option.isSome(option)) {\n      return core.succeed(option.value)\n    }\n    return core.fail(Option.none())\n  }))\n\n/** @internal */\nexport const findAllSTM = dual<\n  <K, V, A, E, R>(\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Array<A>, E, R>,\n  <K, V, A, E, R>(\n    self: TMap.TMap<K, V>,\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => STM.STM<Array<A>, E, R>\n>(2, <K, V, A, E, R>(\n  self: TMap.TMap<K, V>,\n  pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n) =>\n  core.map(\n    reduceSTM(self, Chunk.empty<A>(), (acc, value, key) =>\n      core.matchSTM(pf(key, value), {\n        onFailure: Option.match({\n          onNone: () => core.succeed(acc),\n          onSome: core.fail\n        }),\n        onSuccess: (a) => core.succeed(Chunk.append(acc, a))\n      })),\n    (a) => Array.from(a)\n  ))\n\n/** @internal */\nexport const forEach = dual<\n  <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>) => (self: TMap.TMap<K, V>) => STM.STM<void, E, R>,\n  <K, V, X, E, R>(self: TMap.TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>) => STM.STM<void, E, R>\n>(2, (self, f) =>\n  reduceSTM(\n    self,\n    void 0 as void,\n    (_, value, key) => stm.asVoid(f(key, value))\n  ))\n\n/** @internal */\nexport const fromIterable = <K, V>(iterable: Iterable<readonly [K, V]>): STM.STM<TMap.TMap<K, V>> =>\n  stm.suspend(() => {\n    const data = Chunk.fromIterable(iterable)\n    const capacity = data.length < InitialCapacity\n      ? InitialCapacity\n      : nextPowerOfTwo(data.length)\n    return allocate(capacity, data)\n  })\n\n/** @internal */\nexport const get = dual<\n  <K>(key: K) => <V>(self: TMap.TMap<K, V>) => STM.STM<Option.Option<V>>,\n  <K, V>(self: TMap.TMap<K, V>, key: K) => STM.STM<Option.Option<V>>\n>(2, <K, V>(self: TMap.TMap<K, V>, key: K) =>\n  core.effect<never, Option.Option<V>>((journal) => {\n    const buckets = tRef.unsafeGet(self.tBuckets, journal)\n    const index = indexOf(key, buckets.chunk.length)\n    const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n    return pipe(\n      Chunk.findFirst(bucket, (entry) => Equal.equals(entry[0])(key)),\n      Option.map((entry) => entry[1])\n    )\n  }))\n\n/** @internal */\nexport const getOrElse = dual<\n  <K, V>(key: K, fallback: LazyArg<V>) => (self: TMap.TMap<K, V>) => STM.STM<V>,\n  <K, V>(self: TMap.TMap<K, V>, key: K, fallback: LazyArg<V>) => STM.STM<V>\n>(3, (self, key, fallback) =>\n  core.map(\n    get(self, key),\n    Option.getOrElse(fallback)\n  ))\n\n/** @internal */\nexport const has = dual<\n  <K>(key: K) => <V>(self: TMap.TMap<K, V>) => STM.STM<boolean>,\n  <K, V>(self: TMap.TMap<K, V>, key: K) => STM.STM<boolean>\n>(2, (self, key) => core.map(get(self, key), Option.isSome))\n\n/** @internal */\nexport const isEmpty = <K, V>(self: TMap.TMap<K, V>): STM.STM<boolean> =>\n  core.map(tRef.get(self.tSize), (size) => size === 0)\n\n/** @internal */\nexport const keys = <K, V>(self: TMap.TMap<K, V>): STM.STM<Array<K>> =>\n  core.map(toReadonlyArray(self), RA.map((entry) => entry[0]))\n\n/** @internal */\nexport const make = <K, V>(...entries: Array<readonly [K, V]>): STM.STM<TMap.TMap<K, V>> => fromIterable(entries)\n\n/** @internal */\nexport const merge = dual<\n  <K, V>(key: K, value: V, f: (x: V, y: V) => V) => (self: TMap.TMap<K, V>) => STM.STM<V>,\n  <K, V>(self: TMap.TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V) => STM.STM<V>\n>(4, (self, key, value, f) =>\n  core.flatMap(\n    get(self, key),\n    Option.match({\n      onNone: () => stm.as(set(self, key, value), value),\n      onSome: (v0) => {\n        const v1 = f(v0, value)\n        return stm.as(set(self, key, v1), v1)\n      }\n    })\n  ))\n\n/** @internal */\nexport const reduce = dual<\n  <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z) => (self: TMap.TMap<K, V>) => STM.STM<Z>,\n  <K, V, Z>(self: TMap.TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z) => STM.STM<Z>\n>(\n  3,\n  <K, V, Z>(self: TMap.TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z) =>\n    core.effect<never, Z>((journal) => {\n      const buckets = tRef.unsafeGet(self.tBuckets, journal)\n      let result = zero\n      let index = 0\n      while (index < buckets.chunk.length) {\n        const bucket = buckets.chunk[index]\n        const items = tRef.unsafeGet(bucket, journal)\n        result = Chunk.reduce(items, result, (acc, entry) => f(acc, entry[1], entry[0]))\n        index = index + 1\n      }\n      return result\n    })\n)\n\n/** @internal */\nexport const reduceSTM = dual<\n  <Z, V, K, R, E>(\n    zero: Z,\n    f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Z, E, R>,\n  <Z, V, K, R, E>(\n    self: TMap.TMap<K, V>,\n    zero: Z,\n    f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>\n  ) => STM.STM<Z, E, R>\n>(3, (self, zero, f) =>\n  core.flatMap(\n    toReadonlyArray(self),\n    stm.reduce(zero, (acc, entry) => f(acc, entry[1], entry[0]))\n  ))\n\n/** @internal */\nexport const remove = dual<\n  <K>(key: K) => <V>(self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, key: K) => STM.STM<void>\n>(2, (self, key) =>\n  core.effect<never, void>((journal) => {\n    const buckets = tRef.unsafeGet(self.tBuckets, journal)\n    const index = indexOf(key, buckets.chunk.length)\n    const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n    const [toRemove, toRetain] = Chunk.partition(bucket, (entry) => Equal.equals(entry[1], key))\n    if (Chunk.isNonEmpty(toRemove)) {\n      const currentSize = tRef.unsafeGet(self.tSize, journal)\n      tRef.unsafeSet(buckets.chunk[index], toRetain, journal)\n      tRef.unsafeSet(self.tSize, currentSize - 1, journal)\n    }\n  }))\n\n/** @internal */\nexport const removeAll = dual<\n  <K>(keys: Iterable<K>) => <V>(self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, keys: Iterable<K>) => STM.STM<void>\n>(2, <K, V>(self: TMap.TMap<K, V>, keys: Iterable<K>) =>\n  core.effect<never, void>((journal) => {\n    const iterator = keys[Symbol.iterator]()\n    let next: IteratorResult<K, any>\n    while ((next = iterator.next()) && !next.done) {\n      const buckets = tRef.unsafeGet(self.tBuckets, journal)\n      const index = indexOf(next.value, buckets.chunk.length)\n      const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n      const [toRemove, toRetain] = Chunk.partition(bucket, (entry) => Equal.equals(next.value)(entry[0]))\n      if (Chunk.isNonEmpty(toRemove)) {\n        const currentSize = tRef.unsafeGet(self.tSize, journal)\n        tRef.unsafeSet(buckets.chunk[index], toRetain, journal)\n        tRef.unsafeSet(self.tSize, currentSize - 1, journal)\n      }\n    }\n  }))\n\n/** @internal */\nexport const removeIf: {\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TMap.TMap<K, V>) => STM.STM<void>\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TMap.TMap<K, V>) => STM.STM<Array<[K, V]>>\n  <K, V>(\n    self: TMap.TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  <K, V>(\n    self: TMap.TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<[K, V]>>\n} = dual((args) => isTMap(args[0]), <K, V>(\n  self: TMap.TMap<K, V>,\n  predicate: (key: K, value: V) => boolean,\n  options?: {\n    readonly discard: boolean\n  }\n) =>\n  core.effect((journal) => {\n    const discard = options?.discard === true\n    const buckets = tRef.unsafeGet(self.tBuckets, journal)\n    const capacity = buckets.chunk.length\n    const removed: Array<[K, V]> = []\n    let index = 0\n    let newSize = 0\n    while (index < capacity) {\n      const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n      const iterator = bucket[Symbol.iterator]()\n      let next: IteratorResult<readonly [K, V], any>\n      let newBucket = Chunk.empty<readonly [K, V]>()\n      while ((next = iterator.next()) && !next.done) {\n        const [k, v] = next.value\n        if (!predicate(k, v)) {\n          newBucket = Chunk.prepend(newBucket, next.value)\n          newSize = newSize + 1\n        } else {\n          if (!discard) {\n            removed.push([k, v])\n          }\n        }\n      }\n      tRef.unsafeSet(buckets.chunk[index], newBucket, journal)\n      index = index + 1\n    }\n    tRef.unsafeSet(self.tSize, newSize, journal)\n    if (!discard) {\n      return removed\n    }\n  }))\n\n/** @internal */\nexport const retainIf: {\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TMap.TMap<K, V>) => STM.STM<void>\n  <K, V>(\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TMap.TMap<K, V>) => STM.STM<Array<[K, V]>>\n  <K, V>(\n    self: TMap.TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  <K, V>(\n    self: TMap.TMap<K, V>,\n    predicate: (key: K, value: V) => boolean,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<[K, V]>>\n} = dual(\n  (args) => isTMap(args[0]),\n  (self, predicate, options) => removeIf(self, (key, value) => !predicate(key, value), options)\n)\n\n/** @internal */\nexport const set = dual<\n  <K, V>(key: K, value: V) => (self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, key: K, value: V) => STM.STM<void>\n>(3, <K, V>(self: TMap.TMap<K, V>, key: K, value: V) => {\n  const resize = (journal: Journal.Journal, buckets: TArray.TArray<Chunk.Chunk<readonly [K, V]>>): void => {\n    const capacity = buckets.chunk.length\n    const newCapacity = capacity << 1\n    const newBuckets = Array.from({ length: newCapacity }, () => Chunk.empty<readonly [K, V]>())\n    let index = 0\n    while (index < capacity) {\n      const pairs = tRef.unsafeGet(buckets.chunk[index], journal)\n      const iterator = pairs[Symbol.iterator]()\n      let next: IteratorResult<readonly [K, V], any>\n      while ((next = iterator.next()) && !next.done) {\n        const newIndex = indexOf(next.value[0], newCapacity)\n        newBuckets[newIndex] = Chunk.prepend(newBuckets[newIndex], next.value)\n      }\n      index = index + 1\n    }\n    // insert new pair\n    const newIndex = indexOf(key, newCapacity)\n    newBuckets[newIndex] = Chunk.prepend(newBuckets[newIndex], [key, value] as const)\n\n    const newArray: Array<TRef.TRef<Chunk.Chunk<readonly [K, V]>>> = []\n    index = 0\n    while (index < newCapacity) {\n      newArray[index] = new tRef.TRefImpl(newBuckets[index])\n      index = index + 1\n    }\n    const newTArray: TArray.TArray<Chunk.Chunk<readonly [K, V]>> = new tArray.TArrayImpl(newArray)\n    tRef.unsafeSet(self.tBuckets, newTArray, journal)\n  }\n  return core.effect<never, void>((journal) => {\n    const buckets = tRef.unsafeGet(self.tBuckets, journal)\n    const capacity = buckets.chunk.length\n    const index = indexOf(key, capacity)\n    const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n    const shouldUpdate = Chunk.some(bucket, (entry) => Equal.equals(key)(entry[0]))\n    if (shouldUpdate) {\n      const newBucket = Chunk.map(bucket, (entry) =>\n        Equal.equals(key)(entry[0]) ?\n          [key, value] as const :\n          entry)\n      tRef.unsafeSet(buckets.chunk[index], newBucket, journal)\n    } else {\n      const newSize = tRef.unsafeGet(self.tSize, journal) + 1\n      tRef.unsafeSet(self.tSize, newSize, journal)\n      if (capacity * LoadFactor < newSize) {\n        resize(journal, buckets)\n      } else {\n        const newBucket = Chunk.prepend(bucket, [key, value] as const)\n        tRef.unsafeSet(buckets.chunk[index], newBucket, journal)\n      }\n    }\n  })\n})\n\n/** @internal */\nexport const setIfAbsent = dual<\n  <K, V>(key: K, value: V) => (self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, key: K, value: V) => STM.STM<void>\n>(3, (self, key, value) =>\n  core.flatMap(\n    get(self, key),\n    Option.match({\n      onNone: () => set(self, key, value),\n      onSome: () => stm.void\n    })\n  ))\n\n/** @internal */\nexport const size = <K, V>(self: TMap.TMap<K, V>): STM.STM<number> => tRef.get(self.tSize)\n\n/** @internal */\nexport const takeFirst = dual<\n  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>) => (self: TMap.TMap<K, V>) => STM.STM<A>,\n  <K, V, A>(self: TMap.TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>) => STM.STM<A>\n>(2, <K, V, A>(self: TMap.TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>) =>\n  pipe(\n    core.effect<never, Option.Option<A>>((journal) => {\n      const buckets = tRef.unsafeGet(self.tBuckets, journal)\n      const capacity = buckets.chunk.length\n      const size = tRef.unsafeGet(self.tSize, journal)\n      let result: Option.Option<A> = Option.none()\n      let index = 0\n      while (index < capacity && Option.isNone(result)) {\n        const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n        const recreate = Chunk.some(bucket, (entry) => Option.isSome(pf(entry[0], entry[1])))\n        if (recreate) {\n          const iterator = bucket[Symbol.iterator]()\n          let newBucket = Chunk.empty<readonly [K, V]>()\n          let next: IteratorResult<readonly [K, V], any>\n          while ((next = iterator.next()) && !next.done && Option.isNone(result)) {\n            const option = pf(next.value[0], next.value[1])\n            if (Option.isSome(option) && Option.isNone(result)) {\n              result = option\n            } else {\n              newBucket = Chunk.prepend(newBucket, next.value)\n            }\n          }\n          tRef.unsafeSet(buckets.chunk[index], newBucket, journal)\n        }\n        index = index + 1\n      }\n      if (Option.isSome(result)) {\n        tRef.unsafeSet(self.tSize, size - 1, journal)\n      }\n      return result\n    }),\n    stm.collect((option) =>\n      Option.isSome(option) ?\n        Option.some(option.value) :\n        Option.none<A>()\n    )\n  ))\n\n/** @internal */\nexport const takeFirstSTM = dual<\n  <K, V, A, E, R>(\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<A, E, R>,\n  <K, V, A, E, R>(self: TMap.TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>) => STM.STM<A, E, R>\n>(2, (self, pf) =>\n  pipe(\n    findSTM(self, (key, value) => core.map(pf(key, value), (a) => [key, a] as const)),\n    stm.collect((option) => Option.isSome(option) ? Option.some(option.value) : Option.none()),\n    core.flatMap((entry) => stm.as(remove(self, entry[0]), entry[1]))\n  ))\n\n/** @internal */\nexport const takeSome = dual<\n  <K, V, A>(\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<RA.NonEmptyArray<A>>,\n  <K, V, A>(\n    self: TMap.TMap<K, V>,\n    pf: (key: K, value: V) => Option.Option<A>\n  ) => STM.STM<RA.NonEmptyArray<A>>\n>(2, <K, V, A>(self: TMap.TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>) =>\n  pipe(\n    core.effect<never, Option.Option<RA.NonEmptyArray<A>>>((journal) => {\n      const buckets = tRef.unsafeGet(self.tBuckets, journal)\n      const capacity = buckets.chunk.length\n      const builder: Array<A> = []\n      let newSize = 0\n      let index = 0\n      while (index < capacity) {\n        const bucket = tRef.unsafeGet(buckets.chunk[index], journal)\n        const recreate = Chunk.some(bucket, (entry) => Option.isSome(pf(entry[0], entry[1])))\n        if (recreate) {\n          const iterator = bucket[Symbol.iterator]()\n          let newBucket = Chunk.empty<readonly [K, V]>()\n          let next: IteratorResult<readonly [K, V], any>\n          while ((next = iterator.next()) && !next.done) {\n            const option = pf(next.value[0], next.value[1])\n            if (Option.isSome(option)) {\n              builder.push(option.value)\n            } else {\n              newBucket = Chunk.prepend(newBucket, next.value)\n              newSize = newSize + 1\n            }\n          }\n          tRef.unsafeSet(buckets.chunk[index], newBucket, journal)\n        } else {\n          newSize = newSize + bucket.length\n        }\n        index = index + 1\n      }\n      tRef.unsafeSet(self.tSize, newSize, journal)\n      if (builder.length > 0) {\n        return Option.some(builder as RA.NonEmptyArray<A>)\n      }\n      return Option.none()\n    }),\n    stm.collect((option) =>\n      Option.isSome(option) ?\n        Option.some(option.value) :\n        Option.none<RA.NonEmptyArray<A>>()\n    )\n  ))\n\n/** @internal */\nexport const takeSomeSTM = dual<\n  <K, V, A, E, R>(\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<RA.NonEmptyArray<A>, E, R>,\n  <K, V, A, E, R>(\n    self: TMap.TMap<K, V>,\n    pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n  ) => STM.STM<RA.NonEmptyArray<A>, E, R>\n>(2, <K, V, A, E, R>(\n  self: TMap.TMap<K, V>,\n  pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>\n) =>\n  pipe(\n    findAllSTM(\n      self,\n      (key, value) => core.map(pf(key, value), (a) => [key, a] as const)\n    ),\n    core.map((chunk) =>\n      RA.isNonEmptyArray(chunk) ?\n        Option.some(chunk) :\n        Option.none()\n    ),\n    stm.collect((option) =>\n      Option.isSome(option) ?\n        Option.some(option.value) :\n        Option.none()\n    ),\n    core.flatMap((entries) =>\n      stm.as(\n        removeAll(self, entries.map((entry) => entry[0])),\n        RA.map(entries, (entry) => entry[1]) as RA.NonEmptyArray<A>\n      )\n    )\n  ))\n\nconst toReadonlyArray = <K, V>(self: TMap.TMap<K, V>): STM.STM<ReadonlyArray<readonly [K, V]>> =>\n  core.effect<never, Array<readonly [K, V]>>((journal) => {\n    const buckets = tRef.unsafeGet(self.tBuckets, journal)\n    const capacity = buckets.chunk.length\n    const builder: Array<readonly [K, V]> = []\n    let index = 0\n    while (index < capacity) {\n      const bucket = buckets.chunk[index]\n      for (const entry of tRef.unsafeGet(bucket, journal)) {\n        builder.push(entry)\n      }\n      index = index + 1\n    }\n    return builder\n  })\n\n/** @internal */\nexport const toChunk = <K, V>(self: TMap.TMap<K, V>): STM.STM<Chunk.Chunk<[K, V]>> =>\n  reduce(\n    self,\n    Chunk.empty<[K, V]>(),\n    (acc, value, key) => Chunk.append(acc, [key, value])\n  )\n\n/** @internal */\nexport const toHashMap = <K, V>(self: TMap.TMap<K, V>): STM.STM<HashMap.HashMap<K, V>> =>\n  reduce(\n    self,\n    HashMap.empty<K, V>(),\n    (acc, value, key) => pipe(acc, HashMap.set(key, value))\n  )\n\n/** @internal */\nexport const toArray = <K, V>(self: TMap.TMap<K, V>): STM.STM<Array<[K, V]>> =>\n  reduce(\n    self,\n    [] as Array<[K, V]>,\n    (acc, value, key) => {\n      acc.unshift([key, value])\n      return acc\n    }\n  )\n\n/** @internal */\nexport const toMap = <K, V>(self: TMap.TMap<K, V>): STM.STM<Map<K, V>> =>\n  reduce(\n    self,\n    new Map<K, V>(),\n    (acc, value, key) => acc.set(key, value)\n  )\n\n/** @internal */\nexport const transform = dual<\n  <K, V>(f: (key: K, value: V) => readonly [K, V]) => (self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, f: (key: K, value: V) => readonly [K, V]) => STM.STM<void>\n>(\n  2,\n  <K, V>(self: TMap.TMap<K, V>, f: (key: K, value: V) => readonly [K, V]) =>\n    core.effect<never, void>((journal) => {\n      const buckets = pipe(self.tBuckets, tRef.unsafeGet(journal))\n      const capacity = buckets.chunk.length\n      const newBuckets = Array.from({ length: capacity }, () => Chunk.empty<readonly [K, V]>())\n      let newSize = 0\n      let index = 0\n      while (index < capacity) {\n        const bucket = buckets.chunk[index]\n        const pairs = tRef.unsafeGet(bucket, journal)\n        const iterator = pairs[Symbol.iterator]()\n        let next: IteratorResult<readonly [K, V], any>\n        while ((next = iterator.next()) && !next.done) {\n          const newPair = f(next.value[0], next.value[1])\n          const index = indexOf(newPair[0], capacity)\n          const newBucket = newBuckets[index]\n          if (!Chunk.some(newBucket, (entry) => Equal.equals(entry[0], newPair[0]))) {\n            newBuckets[index] = Chunk.prepend(newBucket, newPair)\n            newSize = newSize + 1\n          }\n        }\n        index = index + 1\n      }\n      index = 0\n      while (index < capacity) {\n        tRef.unsafeSet(buckets.chunk[index], newBuckets[index], journal)\n        index = index + 1\n      }\n      tRef.unsafeSet(self.tSize, newSize, journal)\n    })\n)\n\n/** @internal */\nexport const transformSTM = dual<\n  <K, V, R, E>(\n    f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<void, E, R>,\n  <K, V, R, E>(self: TMap.TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>) => STM.STM<void, E, R>\n>(\n  2,\n  <K, V, R, E>(self: TMap.TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>) =>\n    pipe(\n      core.flatMap(\n        toReadonlyArray(self),\n        stm.forEach((entry) => f(entry[0], entry[1]))\n      ),\n      core.flatMap((newData) =>\n        core.effect<never, void>((journal) => {\n          const buckets = tRef.unsafeGet(self.tBuckets, journal)\n          const capacity = buckets.chunk.length\n          const newBuckets = Array.from({ length: capacity }, () => Chunk.empty<readonly [K, V]>())\n          const iterator = newData[Symbol.iterator]()\n          let newSize = 0\n          let next: IteratorResult<readonly [K, V], any>\n          while ((next = iterator.next()) && !next.done) {\n            const index = indexOf(next.value[0], capacity)\n            const newBucket = newBuckets[index]\n            if (!Chunk.some(newBucket, (entry) => Equal.equals(entry[0])(next.value[0]))) {\n              newBuckets[index] = Chunk.prepend(newBucket, next.value)\n              newSize = newSize + 1\n            }\n          }\n          let index = 0\n          while (index < capacity) {\n            tRef.unsafeSet(buckets.chunk[index], newBuckets[index], journal)\n            index = index + 1\n          }\n          tRef.unsafeSet(self.tSize, newSize, journal)\n        })\n      )\n    )\n)\n\n/** @internal */\nexport const transformValues = dual<\n  <V>(f: (value: V) => V) => <K>(self: TMap.TMap<K, V>) => STM.STM<void>,\n  <K, V>(self: TMap.TMap<K, V>, f: (value: V) => V) => STM.STM<void>\n>(2, (self, f) => transform(self, (key, value) => [key, f(value)]))\n\n/** @internal */\nexport const transformValuesSTM = dual<\n  <V, R, E>(f: (value: V) => STM.STM<V, E, R>) => <K>(self: TMap.TMap<K, V>) => STM.STM<void, E, R>,\n  <K, V, R, E>(self: TMap.TMap<K, V>, f: (value: V) => STM.STM<V, E, R>) => STM.STM<void, E, R>\n>(2, (self, f) =>\n  transformSTM(\n    self,\n    (key, value) => core.map(f(value), (value) => [key, value])\n  ))\n\n/** @internal */\nexport const updateWith = dual<\n  <K, V>(\n    key: K,\n    f: (value: Option.Option<V>) => Option.Option<V>\n  ) => (self: TMap.TMap<K, V>) => STM.STM<Option.Option<V>>,\n  <K, V>(\n    self: TMap.TMap<K, V>,\n    key: K,\n    f: (value: Option.Option<V>) => Option.Option<V>\n  ) => STM.STM<Option.Option<V>>\n>(3, (self, key, f) =>\n  core.flatMap(get(self, key), (option) =>\n    Option.match(\n      f(option),\n      {\n        onNone: () => stm.as(remove(self, key), Option.none()),\n        onSome: (value) => stm.as(set(self, key, value), Option.some(value))\n      }\n    )))\n\n/** @internal */\nexport const values = <K, V>(self: TMap.TMap<K, V>): STM.STM<Array<V>> =>\n  core.map(toReadonlyArray(self), RA.map((entry) => entry[1]))\n", "/**\n * @since 2.0.0\n */\nimport type * as Chunk from \"./Chunk.js\"\nimport * as internal from \"./internal/stm/tPriorityQueue.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Order from \"./Order.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport type * as SortedMap from \"./SortedMap.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TPriorityQueueTypeId: unique symbol = internal.TPriorityQueueTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TPriorityQueueTypeId = typeof TPriorityQueueTypeId\n\n/**\n * A `TPriorityQueue` contains values of type `A` that an `Order` is defined\n * on. Unlike a `TQueue`, `take` returns the highest priority value (the value\n * that is first in the specified ordering) as opposed to the first value\n * offered to the queue. The ordering that elements with the same priority will\n * be taken from the queue is not guaranteed.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TPriorityQueue<in out A> {\n  /** @internal */\n  readonly ref: TRef.TRef<SortedMap.SortedMap<A, [A, ...Array<A>]>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TPriorityQueue {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [TPriorityQueueTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * Constructs a new empty `TPriorityQueue` with the specified `Order`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>> = internal.empty\n\n/**\n * Creates a new `TPriorityQueue` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <A>(\n  order: Order.Order<A>\n) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>> = internal.fromIterable\n\n/**\n * Checks whether the queue is empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean> = internal.isEmpty\n\n/**\n * Checks whether the queue is not empty.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean> = internal.isNonEmpty\n\n/**\n * Makes a new `TPriorityQueue` that is initialized with specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>> = internal.make\n\n/**\n * Offers the specified value to the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const offer: {\n  /**\n   * Offers the specified value to the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>\n  /**\n   * Offers the specified value to the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>\n} = internal.offer\n\n/**\n * Offers all of the elements in the specified collection to the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const offerAll: {\n  /**\n   * Offers all of the elements in the specified collection to the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>\n  /**\n   * Offers all of the elements in the specified collection to the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>\n} = internal.offerAll\n\n/**\n * Peeks at the first value in the queue without removing it, retrying until a\n * value is in the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A> = internal.peek\n\n/**\n * Peeks at the first value in the queue without removing it, returning `None`\n * if there is not a value in the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>> = internal.peekOption\n\n/**\n * Removes all elements from the queue matching the specified predicate.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const removeIf: {\n  /**\n   * Removes all elements from the queue matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>\n  /**\n   * Removes all elements from the queue matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>\n} = internal.removeIf\n\n/**\n * Retains only elements from the queue matching the specified predicate.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const retainIf: {\n  /**\n   * Retains only elements from the queue matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>\n  /**\n   * Retains only elements from the queue matching the specified predicate.\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>\n} = internal.retainIf\n\n/**\n * Returns the size of the queue.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <A>(self: TPriorityQueue<A>) => STM.STM<number> = internal.size\n\n/**\n * Takes a value from the queue, retrying until a value is in the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const take: <A>(self: TPriorityQueue<A>) => STM.STM<A> = internal.take\n\n/**\n * Takes all values from the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>> = internal.takeAll\n\n/**\n * Takes a value from the queue, returning `None` if there is not a value in\n * the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>> = internal.takeOption\n\n/**\n * Takes up to the specified maximum number of elements from the queue.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeUpTo: {\n  /**\n   * Takes up to the specified maximum number of elements from the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (n: number): <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>\n  /**\n   * Takes up to the specified maximum number of elements from the queue.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TPriorityQueue<A>, n: number): STM.STM<Array<A>>\n} = internal.takeUpTo\n\n/**\n * Collects all values into a `Chunk`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>> = internal.toChunk\n\n/**\n * Collects all values into an array.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>> = internal.toArray\n", "import * as Arr from \"../../Array.js\"\nimport * as Chunk from \"../../Chunk.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport type * as Order from \"../../Order.js\"\nimport type { Predicate } from \"../../Predicate.js\"\nimport * as SortedMap from \"../../SortedMap.js\"\nimport type * as STM from \"../../STM.js\"\nimport type * as TPriorityQueue from \"../../TPriorityQueue.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as core from \"./core.js\"\nimport * as tRef from \"./tRef.js\"\n\n/** @internal */\nconst TPriorityQueueSymbolKey = \"effect/TPriorityQueue\"\n\n/** @internal */\nexport const TPriorityQueueTypeId: TPriorityQueue.TPriorityQueueTypeId = Symbol.for(\n  TPriorityQueueSymbolKey\n) as TPriorityQueue.TPriorityQueueTypeId\n\nconst tPriorityQueueVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nexport class TPriorityQueueImpl<in out A> implements TPriorityQueue.TPriorityQueue<A> {\n  readonly [TPriorityQueueTypeId] = tPriorityQueueVariance\n  constructor(readonly ref: TRef.TRef<SortedMap.SortedMap<A, [A, ...Array<A>]>>) {}\n}\n\n/** @internal */\nexport const empty = <A>(order: Order.Order<A>): STM.STM<TPriorityQueue.TPriorityQueue<A>> =>\n  pipe(\n    tRef.make(SortedMap.empty<A, [A, ...Array<A>]>(order)),\n    core.map((ref) => new TPriorityQueueImpl(ref))\n  )\n\n/** @internal */\nexport const fromIterable =\n  <A>(order: Order.Order<A>) => (iterable: Iterable<A>): STM.STM<TPriorityQueue.TPriorityQueue<A>> =>\n    pipe(\n      tRef.make(\n        Arr.fromIterable(iterable).reduce(\n          (map, value) =>\n            pipe(\n              map,\n              SortedMap.set(\n                value,\n                pipe(\n                  map,\n                  SortedMap.get(value),\n                  Option.match({\n                    onNone: () => Arr.of(value),\n                    onSome: Arr.prepend(value)\n                  })\n                )\n              )\n            ),\n          SortedMap.empty<A, [A, ...Array<A>]>(order)\n        )\n      ),\n      core.map((ref) => new TPriorityQueueImpl(ref))\n    )\n\n/** @internal */\nexport const isEmpty = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<boolean> =>\n  core.map(tRef.get(self.ref), SortedMap.isEmpty)\n\n/** @internal */\nexport const isNonEmpty = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<boolean> =>\n  core.map(tRef.get(self.ref), SortedMap.isNonEmpty)\n\n/** @internal */\nexport const make = <A>(order: Order.Order<A>) => (...elements: Array<A>): STM.STM<TPriorityQueue.TPriorityQueue<A>> =>\n  fromIterable(order)(elements)\n\n/** @internal */\nexport const offer = dual<\n  <A>(value: A) => (self: TPriorityQueue.TPriorityQueue<A>) => STM.STM<void>,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, value: A) => STM.STM<void>\n>(2, (self, value) =>\n  tRef.update(self.ref, (map) =>\n    SortedMap.set(\n      map,\n      value,\n      Option.match(SortedMap.get(map, value), {\n        onNone: () => Arr.of(value),\n        onSome: Arr.prepend(value)\n      })\n    )))\n\n/** @internal */\nexport const offerAll = dual<\n  <A>(values: Iterable<A>) => (self: TPriorityQueue.TPriorityQueue<A>) => STM.STM<void>,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, values: Iterable<A>) => STM.STM<void>\n>(2, (self, values) =>\n  tRef.update(self.ref, (map) =>\n    Arr.fromIterable(values).reduce(\n      (map, value) =>\n        SortedMap.set(\n          map,\n          value,\n          Option.match(SortedMap.get(map, value), {\n            onNone: () => Arr.of(value),\n            onSome: Arr.prepend(value)\n          })\n        ),\n      map\n    )))\n\n/** @internal */\nexport const peek = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<A> =>\n  core.withSTMRuntime((runtime) => {\n    const map = tRef.unsafeGet(self.ref, runtime.journal)\n    return Option.match(\n      SortedMap.headOption(map),\n      {\n        onNone: () => core.retry,\n        onSome: (elements) => core.succeed(elements[0])\n      }\n    )\n  })\n\n/** @internal */\nexport const peekOption = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<Option.Option<A>> =>\n  tRef.modify(self.ref, (map) => [\n    Option.map(SortedMap.headOption(map), (elements) => elements[0]),\n    map\n  ])\n\n/** @internal */\nexport const removeIf = dual<\n  <A>(predicate: Predicate<A>) => (self: TPriorityQueue.TPriorityQueue<A>) => STM.STM<void>,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, predicate: Predicate<A>) => STM.STM<void>\n>(2, (self, predicate) => retainIf(self, (a) => !predicate(a)))\n\n/** @internal */\nexport const retainIf = dual<\n  <A>(predicate: Predicate<A>) => (self: TPriorityQueue.TPriorityQueue<A>) => STM.STM<void>,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, predicate: Predicate<A>) => STM.STM<void>\n>(\n  2,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, predicate: Predicate<A>) =>\n    tRef.update(\n      self.ref,\n      (map) =>\n        SortedMap.reduce(map, SortedMap.empty(SortedMap.getOrder(map)), (map, value, key) => {\n          const filtered: ReadonlyArray<A> = Arr.filter(value, predicate)\n          return filtered.length > 0 ?\n            SortedMap.set(map, key, filtered as [A, ...Array<A>]) :\n            SortedMap.remove(map, key)\n        })\n    )\n)\n\n/** @internal */\nexport const size = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<number> =>\n  tRef.modify(\n    self.ref,\n    (map) => [SortedMap.reduce(map, 0, (n, as) => n + as.length), map]\n  )\n\n/** @internal */\nexport const take = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<A> =>\n  core.withSTMRuntime((runtime) => {\n    const map = tRef.unsafeGet(self.ref, runtime.journal)\n    return Option.match(SortedMap.headOption(map), {\n      onNone: () => core.retry,\n      onSome: (values) => {\n        const head = values[1][0]\n        const tail = values[1].slice(1)\n        tRef.unsafeSet(\n          self.ref,\n          tail.length > 0 ?\n            SortedMap.set(map, head, tail as [A, ...Array<A>]) :\n            SortedMap.remove(map, head),\n          runtime.journal\n        )\n        return core.succeed(head)\n      }\n    })\n  })\n\n/** @internal */\nexport const takeAll = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<Array<A>> =>\n  tRef.modify(self.ref, (map) => {\n    const builder: Array<A> = []\n    for (const entry of map) {\n      for (const value of entry[1]) {\n        builder.push(value)\n      }\n    }\n    return [builder, SortedMap.empty(SortedMap.getOrder(map))]\n  })\n\n/** @internal */\nexport const takeOption = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<Option.Option<A>> =>\n  core.effect<never, Option.Option<A>>((journal) => {\n    const map = pipe(self.ref, tRef.unsafeGet(journal))\n    return Option.match(SortedMap.headOption(map), {\n      onNone: (): Option.Option<A> => Option.none(),\n      onSome: ([key, value]) => {\n        const tail = value.slice(1)\n        tRef.unsafeSet(\n          self.ref,\n          tail.length > 0 ?\n            SortedMap.set(map, key, tail as [A, ...Array<A>]) :\n            SortedMap.remove(map, key),\n          journal\n        )\n        return Option.some(value[0])\n      }\n    })\n  })\n\n/** @internal */\nexport const takeUpTo = dual<\n  (n: number) => <A>(self: TPriorityQueue.TPriorityQueue<A>) => STM.STM<Array<A>>,\n  <A>(self: TPriorityQueue.TPriorityQueue<A>, n: number) => STM.STM<Array<A>>\n>(2, <A>(self: TPriorityQueue.TPriorityQueue<A>, n: number) =>\n  tRef.modify(self.ref, (map) => {\n    const builder: Array<A> = []\n    const iterator = map[Symbol.iterator]()\n    let updated = map\n    let index = 0\n    let next: IteratorResult<readonly [A, [A, ...Array<A>]], any>\n    while ((next = iterator.next()) && !next.done && index < n) {\n      const [key, value] = next.value\n      const [left, right] = pipe(value, Arr.splitAt(n - index))\n      for (const value of left) {\n        builder.push(value)\n      }\n      if (right.length > 0) {\n        updated = SortedMap.set(updated, key, right as [A, ...Array<A>])\n      } else {\n        updated = SortedMap.remove(updated, key)\n      }\n      index = index + left.length\n    }\n    return [builder, updated]\n  }))\n\n/** @internal */\nexport const toChunk = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<Chunk.Chunk<A>> =>\n  tRef.modify(self.ref, (map) => {\n    const builder: Array<A> = []\n    for (const entry of map) {\n      for (const value of entry[1]) {\n        builder.push(value)\n      }\n    }\n    return [Chunk.unsafeFromArray(builder), map]\n  })\n\n/** @internal */\nexport const toArray = <A>(self: TPriorityQueue.TPriorityQueue<A>): STM.STM<Array<A>> =>\n  tRef.modify(self.ref, (map) => {\n    const builder: Array<A> = []\n    for (const entry of map) {\n      for (const value of entry[1]) {\n        builder.push(value)\n      }\n    }\n    return [builder, map]\n  })\n", "/**\n * @since 2.0.0\n */\nimport type * as Context from \"./Context.js\"\nimport * as internal from \"./internal/stm/tRandom.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Random from \"./Utils.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TRandomTypeId: unique symbol = internal.TRandomTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TRandomTypeId = typeof TRandomTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TRandom {\n  readonly [TRandomTypeId]: TRandomTypeId\n  /**\n   * Returns the next numeric value from the pseudo-random number generator.\n   */\n  readonly next: STM.STM<number>\n  /**\n   * Returns the next boolean value from the pseudo-random number generator.\n   */\n  readonly nextBoolean: STM.STM<boolean>\n  /**\n   * Returns the next integer value from the pseudo-random number generator.\n   */\n  readonly nextInt: STM.STM<number>\n  /**\n   * Returns the next numeric value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextRange(min: number, max: number): STM.STM<number>\n  /**\n   * Returns the next integer value in the specified range from the\n   * pseudo-random number generator.\n   */\n  nextIntBetween(min: number, max: number): STM.STM<number>\n  /**\n   * Uses the pseudo-random number generator to shuffle the specified iterable.\n   */\n  shuffle<A>(elements: Iterable<A>): STM.STM<Array<A>>\n}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TRandom {\n  /** @internal */\n  readonly state: TRef.TRef<Random.PCGRandomState>\n}\n\n/**\n * The service tag used to access `TRandom` in the environment of an effect.\n *\n * @since 2.0.0\n * @category context\n */\nexport const Tag: Context.Tag<TRandom, TRandom> = internal.Tag\n\n/**\n * The \"live\" `TRandom` service wrapped into a `Layer`.\n *\n * @since 2.0.0\n * @category context\n */\nexport const live: Layer.Layer<TRandom> = internal.live\n\n/**\n * Returns the next number from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category random\n */\nexport const next: STM.STM<number, never, TRandom> = internal.next\n\n/**\n * Returns the next boolean value from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category random\n */\nexport const nextBoolean: STM.STM<boolean, never, TRandom> = internal.nextBoolean\n\n/**\n * Returns the next integer from the pseudo-random number generator.\n *\n * @since 2.0.0\n * @category random\n */\nexport const nextInt: STM.STM<number, never, TRandom> = internal.nextInt\n\n/**\n * Returns the next integer in the specified range from the pseudo-random number\n * generator.\n *\n * @since 2.0.0\n * @category random\n */\nexport const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom> = internal.nextIntBetween\n\n/**\n * Returns the next number in the specified range from the pseudo-random number\n * generator.\n *\n * @since 2.0.0\n * @category random\n */\nexport const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom> = internal.nextRange\n\n/**\n * Uses the pseudo-random number generator to shuffle the specified iterable.\n *\n * @since 2.0.0\n * @category random\n */\nexport const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom> = internal.shuffle\n", "import * as Context from \"../../Context.js\"\nimport { pipe } from \"../../Function.js\"\nimport * as Layer from \"../../Layer.js\"\nimport type * as STM from \"../../STM.js\"\nimport type * as TArray from \"../../TArray.js\"\nimport type * as TRandom from \"../../TRandom.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as Random from \"../../Utils.js\"\nimport * as core from \"./core.js\"\nimport * as stm from \"./stm.js\"\nimport * as tArray from \"./tArray.js\"\nimport * as tRef from \"./tRef.js\"\n\nconst TRandomSymbolKey = \"effect/TRandom\"\n\n/** @internal */\nexport const TRandomTypeId: TRandom.TRandomTypeId = Symbol.for(\n  TRandomSymbolKey\n) as TRandom.TRandomTypeId\n\nconst randomInteger = (state: Random.PCGRandomState): [number, Random.PCGRandomState] => {\n  const prng = new Random.PCGRandom()\n  prng.setState(state)\n  return [prng.integer(0), prng.getState()]\n}\n\nconst randomIntegerBetween = (low: number, high: number) => {\n  return (state: Random.PCGRandomState): [number, Random.PCGRandomState] => {\n    const prng = new Random.PCGRandom()\n    prng.setState(state)\n    return [prng.integer(high - low) + low, prng.getState()]\n  }\n}\n\nconst randomNumber = (state: Random.PCGRandomState): [number, Random.PCGRandomState] => {\n  const prng = new Random.PCGRandom()\n  prng.setState(state)\n  return [prng.number(), prng.getState()]\n}\n\nconst withState = <A>(\n  state: TRef.TRef<Random.PCGRandomState>,\n  f: (state: Random.PCGRandomState) => [A, Random.PCGRandomState]\n): STM.STM<A> => {\n  return pipe(state, tRef.modify(f))\n}\n\nconst shuffleWith = <A>(\n  iterable: Iterable<A>,\n  nextIntBounded: (n: number) => STM.STM<number>\n): STM.STM<Array<A>> => {\n  const swap = (buffer: TArray.TArray<A>, index1: number, index2: number): STM.STM<void> =>\n    pipe(\n      buffer,\n      tArray.get(index1),\n      core.flatMap((tmp) =>\n        pipe(\n          buffer,\n          tArray.updateSTM(index1, () => pipe(buffer, tArray.get(index2))),\n          core.zipRight(\n            pipe(\n              buffer,\n              tArray.update(index2, () => tmp)\n            )\n          )\n        )\n      )\n    )\n  return pipe(\n    tArray.fromIterable(iterable),\n    core.flatMap((buffer) => {\n      const array: Array<number> = []\n      for (let i = array.length; i >= 2; i = i - 1) {\n        array.push(i)\n      }\n      return pipe(\n        array,\n        stm.forEach((n) => pipe(nextIntBounded(n), core.flatMap((k) => swap(buffer, n - 1, k))), { discard: true }),\n        core.zipRight(tArray.toArray(buffer))\n      )\n    })\n  )\n}\n\n/** @internal */\nexport const Tag = Context.GenericTag<TRandom.TRandom>(\"effect/TRandom\")\n\nclass TRandomImpl implements TRandom.TRandom {\n  readonly [TRandomTypeId]: TRandom.TRandomTypeId = TRandomTypeId\n  constructor(readonly state: TRef.TRef<Random.PCGRandomState>) {\n    this.next = withState(this.state, randomNumber)\n    this.nextBoolean = core.flatMap(this.next, (n) => core.succeed(n > 0.5))\n    this.nextInt = withState(this.state, randomInteger)\n  }\n\n  next: STM.STM<number>\n  nextBoolean: STM.STM<boolean>\n  nextInt: STM.STM<number>\n\n  nextRange(min: number, max: number): STM.STM<number> {\n    return core.flatMap(this.next, (n) => core.succeed((max - min) * n + min))\n  }\n  nextIntBetween(low: number, high: number): STM.STM<number> {\n    return withState(this.state, randomIntegerBetween(low, high))\n  }\n  shuffle<A>(elements: Iterable<A>): STM.STM<Array<A>> {\n    return shuffleWith(elements, (n) => this.nextIntBetween(0, n))\n  }\n}\n\n/** @internal */\nexport const live: Layer.Layer<TRandom.TRandom> = Layer.effect(\n  Tag,\n  pipe(\n    tRef.make(new Random.PCGRandom((Math.random() * 4294967296) >>> 0).getState()),\n    core.map((seed) => new TRandomImpl(seed)),\n    core.commit\n  )\n)\n\n/** @internal */\nexport const next: STM.STM<number, never, TRandom.TRandom> = core.flatMap(Tag, (random) => random.next)\n\n/** @internal */\nexport const nextBoolean: STM.STM<boolean, never, TRandom.TRandom> = core.flatMap(Tag, (random) => random.nextBoolean)\n\n/** @internal */\nexport const nextInt: STM.STM<number, never, TRandom.TRandom> = core.flatMap(Tag, (random) => random.nextInt)\n\n/** @internal */\nexport const nextIntBetween = (low: number, high: number): STM.STM<number, never, TRandom.TRandom> =>\n  core.flatMap(Tag, (random) => random.nextIntBetween(low, high))\n\n/** @internal */\nexport const nextRange = (min: number, max: number): STM.STM<number, never, TRandom.TRandom> =>\n  core.flatMap(Tag, (random) => random.nextRange(min, max))\n\n/** @internal */\nexport const shuffle = <A>(elements: Iterable<A>): STM.STM<Array<A>, never, TRandom.TRandom> =>\n  core.flatMap(Tag, (random) => random.shuffle(elements))\n", "/**\n * @since 2.0.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/stm/tReentrantLock.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TReentrantLockTypeId: unique symbol = internal.TReentrantLockTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TReentrantLockTypeId = typeof TReentrantLockTypeId\n\n/**\n * A `TReentrantLock` is a reentrant read/write lock. Multiple readers may all\n * concurrently acquire read locks. Only one writer is allowed to acquire a\n * write lock at any given time. Read locks may be upgraded into write locks. A\n * fiber that has a write lock may acquire other write locks or read locks.\n *\n * The two primary methods of this structure are `readLock`, which acquires a\n * read lock in a scoped context, and `writeLock`, which acquires a write lock\n * in a scoped context.\n *\n * Although located in the STM package, there is no need for locks within STM\n * transactions. However, this lock can be quite useful in effectful code, to\n * provide consistent read/write access to mutable state; and being in STM\n * allows this structure to be composed into more complicated concurrent\n * structures that are consumed from effectful code.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface TReentrantLock extends TReentrantLock.Proto {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TReentrantLock {\n  /** @internal */\n  readonly state: TRef.TRef<internal.LockState>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TReentrantLock {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [TReentrantLockTypeId]: TReentrantLockTypeId\n  }\n}\n\n/**\n * Acquires a read lock. The transaction will suspend until no other fiber is\n * holding a write lock. Succeeds with the number of read locks held by this\n * fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const acquireRead: (self: TReentrantLock) => STM.STM<number> = internal.acquireRead\n\n/**\n * Acquires a write lock. The transaction will suspend until no other fibers\n * are holding read or write locks. Succeeds with the number of write locks\n * held by this fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const acquireWrite: (self: TReentrantLock) => STM.STM<number> = internal.acquireWrite\n\n/**\n * Retrieves the number of acquired read locks for this fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const fiberReadLocks: (self: TReentrantLock) => STM.STM<number> = internal.fiberReadLocks\n\n/**\n * Retrieves the number of acquired write locks for this fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number> = internal.fiberWriteLocks\n\n/**\n * Just a convenience method for applications that only need reentrant locks,\n * without needing a distinction between readers / writers.\n *\n * See `TReentrantLock.writeLock`.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope> = internal.lock\n\n/**\n * Determines if any fiber has a read or write lock.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const locked: (self: TReentrantLock) => STM.STM<boolean> = internal.locked\n\n/**\n * Makes a new reentrant read/write lock.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: STM.STM<TReentrantLock> = internal.make\n\n/**\n * Obtains a read lock in a scoped context.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope> = internal.readLock\n\n/**\n * Retrieves the total number of acquired read locks.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const readLocks: (self: TReentrantLock) => STM.STM<number> = internal.readLocks\n\n/**\n * Determines if any fiber has a read lock.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const readLocked: (self: TReentrantLock) => STM.STM<boolean> = internal.readLocked\n\n/**\n * Releases a read lock held by this fiber. Succeeds with the outstanding\n * number of read locks held by this fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const releaseRead: (self: TReentrantLock) => STM.STM<number> = internal.releaseRead\n\n/**\n * Releases a write lock held by this fiber. Succeeds with the outstanding\n * number of write locks held by this fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const releaseWrite: (self: TReentrantLock) => STM.STM<number> = internal.releaseWrite\n\n/**\n * Runs the specified workflow with a lock.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const withLock: {\n  /**\n   * Runs the specified workflow with a lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Runs the specified workflow with a lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>\n} = internal.withLock\n\n/**\n * Runs the specified workflow with a read lock.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const withReadLock: {\n  /**\n   * Runs the specified workflow with a read lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Runs the specified workflow with a read lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>\n} = internal.withReadLock\n\n/**\n * Runs the specified workflow with a write lock.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const withWriteLock: {\n  /**\n   * Runs the specified workflow with a write lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * Runs the specified workflow with a write lock.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>\n} = internal.withWriteLock\n\n/**\n * Obtains a write lock in a scoped context.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope> = internal.writeLock\n\n/**\n * Determines if a write lock is held by some fiber.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const writeLocked: (self: TReentrantLock) => STM.STM<boolean> = internal.writeLocked\n\n/**\n * Computes the number of write locks held by fibers.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const writeLocks: (self: TReentrantLock) => STM.STM<number> = internal.writeLocks\n", "import * as Effect from \"../../Effect.js\"\nimport * as Equal from \"../../Equal.js\"\nimport * as FiberId from \"../../FiberId.js\"\nimport { dual } from \"../../Function.js\"\nimport * as HashMap from \"../../HashMap.js\"\nimport * as Option from \"../../Option.js\"\nimport type * as Scope from \"../../Scope.js\"\nimport type * as STM from \"../../STM.js\"\nimport type * as TReentrantLock from \"../../TReentrantLock.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport * as core from \"./core.js\"\nimport * as tRef from \"./tRef.js\"\n\nconst TReentrantLockSymbolKey = \"effect/TReentrantLock\"\n\n/** @internal */\nexport const TReentrantLockTypeId: TReentrantLock.TReentrantLockTypeId = Symbol.for(\n  TReentrantLockSymbolKey\n) as TReentrantLock.TReentrantLockTypeId\n\nconst WriteLockTypeId = Symbol.for(\"effect/TReentrantLock/WriteLock\")\n\ntype WriteLockTypeId = typeof WriteLockTypeId\n\nconst ReadLockTypeId = Symbol.for(\"effect/TReentrantLock/ReadLock\")\n\ntype ReadLockTypeId = typeof ReadLockTypeId\n\nclass TReentranLockImpl implements TReentrantLock.TReentrantLock {\n  readonly [TReentrantLockTypeId]: TReentrantLock.TReentrantLockTypeId = TReentrantLockTypeId\n  constructor(readonly state: TRef.TRef<LockState>) {}\n}\n\n/** @internal */\nexport interface LockState {\n  /**\n   * Computes the total number of read locks acquired.\n   */\n  readonly readLocks: number\n  /**\n   * Computes the total number of write locks acquired.\n   */\n  readonly writeLocks: number\n  /**\n   * Computes the number of read locks held by the specified fiber id.\n   */\n  readLocksHeld(fiberId: FiberId.FiberId): number\n  /**\n   * Computes the number of write locks held by the specified fiber id.\n   */\n  writeLocksHeld(fiberId: FiberId.FiberId): number\n}\n\n/**\n * This data structure describes the state of the lock when multiple fibers\n * have acquired read locks. The state is tracked as a map from fiber identity\n * to number of read locks acquired by the fiber. This level of detail permits\n * upgrading a read lock to a write lock.\n *\n * @internal\n */\nexport class ReadLock implements LockState {\n  readonly [ReadLockTypeId]: ReadLockTypeId = ReadLockTypeId\n  constructor(readonly readers: HashMap.HashMap<FiberId.FiberId, number>) {}\n  get readLocks(): number {\n    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0)\n  }\n  get writeLocks(): number {\n    return 0\n  }\n  readLocksHeld(fiberId: FiberId.FiberId): number {\n    return Option.getOrElse(\n      HashMap.get(this.readers, fiberId),\n      () => 0\n    )\n  }\n  writeLocksHeld(_fiberId: FiberId.FiberId): number {\n    return 0\n  }\n}\n\n/**\n * This data structure describes the state of the lock when a single fiber has\n * a write lock. The fiber has an identity, and may also have acquired a\n * certain number of read locks.\n *\n * @internal\n */\nexport class WriteLock implements LockState {\n  readonly [WriteLockTypeId]: WriteLockTypeId = WriteLockTypeId\n  constructor(\n    readonly readLocks: number,\n    readonly writeLocks: number,\n    readonly fiberId: FiberId.FiberId\n  ) {}\n  readLocksHeld(fiberId: FiberId.FiberId): number {\n    return Equal.equals(fiberId)(this.fiberId) ? this.readLocks : 0\n  }\n  writeLocksHeld(fiberId: FiberId.FiberId): number {\n    return Equal.equals(fiberId)(this.fiberId) ? this.writeLocks : 0\n  }\n}\n\nconst isReadLock = (lock: LockState): lock is ReadLock => {\n  return ReadLockTypeId in lock\n}\n\nconst isWriteLock = (lock: LockState): lock is WriteLock => {\n  return WriteLockTypeId in lock\n}\n\n/**\n * An empty read lock state, in which no fiber holds any read locks.\n */\nconst emptyReadLock = new ReadLock(HashMap.empty())\n\n/**\n * Creates a new read lock where the specified fiber holds the specified\n * number of read locks.\n */\nconst makeReadLock = (fiberId: FiberId.FiberId, count: number): ReadLock => {\n  if (count <= 0) {\n    return emptyReadLock\n  }\n  return new ReadLock(HashMap.make([fiberId, count]))\n}\n\n/**\n * Determines if there is no other holder of read locks aside from the\n * specified fiber id. If there are no other holders of read locks aside\n * from the specified fiber id, then it is safe to upgrade the read lock\n * into a write lock.\n */\nconst noOtherHolder = (readLock: ReadLock, fiberId: FiberId.FiberId): boolean => {\n  return HashMap.isEmpty(readLock.readers) ||\n    (HashMap.size(readLock.readers) === 1 && HashMap.has(readLock.readers, fiberId))\n}\n\n/**\n * Adjusts the number of read locks held by the specified fiber id.\n */\nconst adjustReadLock = (readLock: ReadLock, fiberId: FiberId.FiberId, adjustment: number): ReadLock => {\n  const total = readLock.readLocksHeld(fiberId)\n  const newTotal = total + adjustment\n  if (newTotal < 0) {\n    throw new Error(\n      \"BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues\"\n    )\n  }\n  if (newTotal === 0) {\n    return new ReadLock(HashMap.remove(readLock.readers, fiberId))\n  }\n  return new ReadLock(HashMap.set(readLock.readers, fiberId, newTotal))\n}\n\nconst adjustRead = (self: TReentrantLock.TReentrantLock, delta: number): STM.STM<number> =>\n  core.withSTMRuntime((runtime) => {\n    const lock = tRef.unsafeGet(self.state, runtime.journal)\n    if (isReadLock(lock)) {\n      const result = adjustReadLock(lock, runtime.fiberId, delta)\n      tRef.unsafeSet(self.state, result, runtime.journal)\n      return core.succeed(result.readLocksHeld(runtime.fiberId))\n    }\n    if (isWriteLock(lock) && Equal.equals(runtime.fiberId)(lock.fiberId)) {\n      const newTotal = lock.readLocks + delta\n      if (newTotal < 0) {\n        throw new Error(\n          `Defect: Fiber ${\n            FiberId.threadName(runtime.fiberId)\n          } releasing read locks it does not hold, newTotal: ${newTotal}`\n        )\n      }\n      tRef.unsafeSet(\n        self.state,\n        new WriteLock(newTotal, lock.writeLocks, runtime.fiberId),\n        runtime.journal\n      )\n      return core.succeed(newTotal)\n    }\n    return core.retry\n  })\n\n/** @internal */\nexport const acquireRead = (self: TReentrantLock.TReentrantLock): STM.STM<number> => adjustRead(self, 1)\n\n/** @internal */\nexport const acquireWrite = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.withSTMRuntime((runtime) => {\n    const lock = tRef.unsafeGet(self.state, runtime.journal)\n    if (isReadLock(lock) && noOtherHolder(lock, runtime.fiberId)) {\n      tRef.unsafeSet(\n        self.state,\n        new WriteLock(lock.readLocksHeld(runtime.fiberId), 1, runtime.fiberId),\n        runtime.journal\n      )\n      return core.succeed(1)\n    }\n    if (isWriteLock(lock) && Equal.equals(runtime.fiberId)(lock.fiberId)) {\n      tRef.unsafeSet(\n        self.state,\n        new WriteLock(lock.readLocks, lock.writeLocks + 1, runtime.fiberId),\n        runtime.journal\n      )\n      return core.succeed(lock.writeLocks + 1)\n    }\n    return core.retry\n  })\n\n/** @internal */\nexport const fiberReadLocks = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.effect<never, number>((journal, fiberId) =>\n    tRef.unsafeGet(\n      self.state,\n      journal\n    ).readLocksHeld(fiberId)\n  )\n\n/** @internal */\nexport const fiberWriteLocks = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.effect<never, number>((journal, fiberId) =>\n    tRef.unsafeGet(\n      self.state,\n      journal\n    ).writeLocksHeld(fiberId)\n  )\n\n/** @internal */\nexport const lock = (self: TReentrantLock.TReentrantLock): Effect.Effect<number, never, Scope.Scope> => writeLock(self)\n\n/** @internal */\nexport const locked = (self: TReentrantLock.TReentrantLock): STM.STM<boolean> =>\n  core.zipWith(\n    readLocked(self),\n    writeLocked(self),\n    (x, y) => x || y\n  )\n\n/** @internal */\nexport const make: STM.STM<TReentrantLock.TReentrantLock> = core.map(\n  tRef.make<LockState>(emptyReadLock),\n  (readLock) => new TReentranLockImpl(readLock)\n)\n\n/** @internal */\nexport const readLock = (self: TReentrantLock.TReentrantLock): Effect.Effect<number, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    core.commit(acquireRead(self)),\n    () => core.commit(releaseRead(self))\n  )\n\n/** @internal */\nexport const readLocks = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.map(\n    tRef.get(self.state),\n    (state) => state.readLocks\n  )\n\n/** @internal */\nexport const readLocked = (self: TReentrantLock.TReentrantLock): STM.STM<boolean> =>\n  core.map(\n    tRef.get(self.state),\n    (state) => state.readLocks > 0\n  )\n\n/** @internal */\nexport const releaseRead = (self: TReentrantLock.TReentrantLock): STM.STM<number> => adjustRead(self, -1)\n\n/** @internal */\nexport const releaseWrite = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.withSTMRuntime((runtime) => {\n    const lock = tRef.unsafeGet(self.state, runtime.journal)\n    if (isWriteLock(lock) && lock.writeLocks === 1 && Equal.equals(runtime.fiberId)(lock.fiberId)) {\n      const result = makeReadLock(lock.fiberId, lock.readLocks)\n      tRef.unsafeSet(self.state, result, runtime.journal)\n      return core.succeed(result.writeLocksHeld(runtime.fiberId))\n    }\n    if (isWriteLock(lock) && Equal.equals(runtime.fiberId)(lock.fiberId)) {\n      const result = new WriteLock(lock.readLocks, lock.writeLocks - 1, runtime.fiberId)\n      tRef.unsafeSet(self.state, result, runtime.journal)\n      return core.succeed(result.writeLocksHeld(runtime.fiberId))\n    }\n    throw new Error(\n      `Defect: Fiber ${FiberId.threadName(runtime.fiberId)} releasing write lock it does not hold`\n    )\n  })\n\n/** @internal */\nexport const withLock = dual<\n  (\n    self: TReentrantLock.TReentrantLock\n  ) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    self: TReentrantLock.TReentrantLock\n  ) => Effect.Effect<A, E, R>\n>(2, (effect, self) => withWriteLock(effect, self))\n\n/** @internal */\nexport const withReadLock = dual<\n  (self: TReentrantLock.TReentrantLock) => <A, E, R>(\n    effect: Effect.Effect<A, E, R>\n  ) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    effect: Effect.Effect<A, E, R>,\n    self: TReentrantLock.TReentrantLock\n  ) => Effect.Effect<A, E, R>\n>(2, (effect, self) =>\n  Effect.uninterruptibleMask((restore) =>\n    Effect.zipRight(\n      restore(core.commit(acquireRead(self))),\n      Effect.ensuring(\n        effect,\n        core.commit(releaseRead(self))\n      )\n    )\n  ))\n\n/** @internal */\nexport const withWriteLock = dual<\n  (self: TReentrantLock.TReentrantLock) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock.TReentrantLock) => Effect.Effect<A, E, R>\n>(2, (effect, self) =>\n  Effect.uninterruptibleMask((restore) =>\n    Effect.zipRight(\n      restore(core.commit(acquireWrite(self))),\n      Effect.ensuring(\n        effect,\n        core.commit(releaseWrite(self))\n      )\n    )\n  ))\n\n/** @internal */\nexport const writeLock = (self: TReentrantLock.TReentrantLock): Effect.Effect<number, never, Scope.Scope> =>\n  Effect.acquireRelease(\n    core.commit(acquireWrite(self)),\n    () => core.commit(releaseWrite(self))\n  )\n\n/** @internal */\nexport const writeLocked = (self: TReentrantLock.TReentrantLock): STM.STM<boolean> =>\n  core.map(\n    tRef.get(self.state),\n    (state) => state.writeLocks > 0\n  )\n\n/** @internal */\nexport const writeLocks = (self: TReentrantLock.TReentrantLock): STM.STM<number> =>\n  core.map(\n    tRef.get(self.state),\n    (state) => state.writeLocks\n  )\n", "/**\n * @since 2.0.0\n */\n\nimport type * as Journal from \"./internal/stm/journal.js\"\nimport * as internal from \"./internal/stm/tRef.js\"\nimport type * as TxnId from \"./internal/stm/txnId.js\"\nimport type * as Versioned from \"./internal/stm/versioned.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TRefTypeId: unique symbol = internal.TRefTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TRefTypeId = typeof TRefTypeId\n\n/**\n * A `TRef<A>` is a purely functional description of a mutable reference that can\n * be modified as part of a transactional effect. The fundamental operations of\n * a `TRef` are `set` and `get`. `set` transactionally sets the reference to a\n * new value. `get` gets the current value of the reference.\n *\n * NOTE: While `TRef<A>` provides the transactional equivalent of a mutable\n * reference, the value inside the `TRef` should be immutable.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface TRef<in out A> extends TRef.Variance<A>, Pipeable {\n  /**\n   * Note: the method is unbound, exposed only for potential extensions.\n   */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TRef<in out A> {\n  /** @internal */\n  todos: Map<TxnId.TxnId, Journal.Todo>\n  /** @internal */\n  versioned: Versioned.Versioned<A>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TRef {\n  /**\n   * @since 2.0.0\n   */\n  export interface Variance<in out A> {\n    readonly [TRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const get: <A>(self: TRef<A>) => STM.STM<A> = internal.get\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const getAndSet: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, value: A): STM.STM<A>\n} = internal.getAndSet\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const getAndUpdate: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>\n} = internal.getAndUpdate\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>\n} = internal.getAndUpdateSome\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A>(value: A) => STM.STM<TRef<A>> = internal.make\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const modify: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: TRef<A>) => STM.STM<B>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(self: TRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>\n} = internal.modify\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const modifySome: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TRef<A>) => STM.STM<B>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(self: TRef<A>, fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): STM.STM<B>\n} = internal.modifySome\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const set: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TRef<A>) => STM.STM<void>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, value: A): STM.STM<void>\n} = internal.set\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const setAndGet: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, value: A): STM.STM<A>\n} = internal.setAndGet\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const update: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<void>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => A): STM.STM<void>\n} = internal.update\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const updateAndGet: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => A): STM.STM<A>\n} = internal.updateAndGet\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const updateSome: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<void>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>\n} = internal.updateSome\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TRef<A>) => STM.STM<A>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>\n} = internal.updateSomeAndGet\n", "/**\n * @since 2.0.0\n */\n\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/stm/tSemaphore.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TRef from \"./TRef.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TSemaphoreTypeId: unique symbol = internal.TSemaphoreTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TSemaphoreTypeId = typeof TSemaphoreTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface TSemaphore extends TSemaphore.Proto {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TSemaphore {\n  /** @internal */\n  readonly permits: TRef.TRef<number>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TSemaphore {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Proto {\n    readonly [TSemaphoreTypeId]: TSemaphoreTypeId\n  }\n}\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const acquire: (self: TSemaphore) => STM.STM<void> = internal.acquire\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const acquireN: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (n: number): (self: TSemaphore) => STM.STM<void>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TSemaphore, n: number): STM.STM<void>\n} = internal.acquireN\n\n/**\n * @since 2.0.0\n * @category getters\n */\nexport const available: (self: TSemaphore) => STM.STM<number> = internal.available\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const make: (permits: number) => STM.STM<TSemaphore> = internal.make\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const release: (self: TSemaphore) => STM.STM<void> = internal.release\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const releaseN: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (n: number): (self: TSemaphore) => STM.STM<void>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TSemaphore, n: number): STM.STM<void>\n} = internal.releaseN\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const withPermit: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (semaphore: TSemaphore): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore): Effect.Effect<A, E, R>\n} = internal.withPermit\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const withPermits: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (semaphore: TSemaphore, permits: number): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore, permits: number): Effect.Effect<A, E, R>\n} = internal.withPermits\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const withPermitScoped: (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope> = internal.withPermitScoped\n\n/**\n * @since 2.0.0\n * @category mutations\n */\nexport const withPermitsScoped: {\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (permits: number): (self: TSemaphore) => Effect.Effect<void, never, Scope.Scope>\n  /**\n   * @since 2.0.0\n   * @category mutations\n   */\n  (self: TSemaphore, permits: number): Effect.Effect<void, never, Scope.Scope>\n} = internal.withPermitsScoped\n\n/**\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeMake: (permits: number) => TSemaphore = internal.unsafeMakeSemaphore\n", "import * as Cause from \"../../Cause.js\"\nimport * as Effect from \"../../Effect.js\"\nimport { dual } from \"../../Function.js\"\nimport type * as Scope from \"../../Scope.js\"\nimport * as STM from \"../../STM.js\"\nimport type * as TRef from \"../../TRef.js\"\nimport type * as TSemaphore from \"../../TSemaphore.js\"\nimport * as core from \"./core.js\"\nimport * as tRef from \"./tRef.js\"\n\n/** @internal */\nconst TSemaphoreSymbolKey = \"effect/TSemaphore\"\n\n/** @internal */\nexport const TSemaphoreTypeId: TSemaphore.TSemaphoreTypeId = Symbol.for(\n  TSemaphoreSymbolKey\n) as TSemaphore.TSemaphoreTypeId\n\n/** @internal */\nclass TSemaphoreImpl implements TSemaphore.TSemaphore {\n  readonly [TSemaphoreTypeId]: TSemaphore.TSemaphoreTypeId = TSemaphoreTypeId\n  constructor(readonly permits: TRef.TRef<number>) {}\n}\n\n/** @internal */\nexport const make = (permits: number): STM.STM<TSemaphore.TSemaphore> =>\n  STM.map(tRef.make(permits), (permits) => new TSemaphoreImpl(permits))\n\n/** @internal */\nexport const acquire = (self: TSemaphore.TSemaphore): STM.STM<void> => acquireN(self, 1)\n\n/** @internal */\nexport const acquireN = dual<\n  (n: number) => (self: TSemaphore.TSemaphore) => STM.STM<void>,\n  (self: TSemaphore.TSemaphore, n: number) => STM.STM<void>\n>(2, (self, n) =>\n  core.withSTMRuntime((driver) => {\n    if (n < 0) {\n      throw new Cause.IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.acquireN`)\n    }\n    const value = tRef.unsafeGet(self.permits, driver.journal)\n    if (value < n) {\n      return STM.retry\n    } else {\n      return STM.succeed(tRef.unsafeSet(self.permits, value - n, driver.journal))\n    }\n  }))\n\n/** @internal */\nexport const available = (self: TSemaphore.TSemaphore) => tRef.get(self.permits)\n\n/** @internal */\nexport const release = (self: TSemaphore.TSemaphore): STM.STM<void> => releaseN(self, 1)\n\n/** @internal */\nexport const releaseN = dual<\n  (n: number) => (self: TSemaphore.TSemaphore) => STM.STM<void>,\n  (self: TSemaphore.TSemaphore, n: number) => STM.STM<void>\n>(2, (self, n) =>\n  core.withSTMRuntime((driver) => {\n    if (n < 0) {\n      throw new Cause.IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.releaseN`)\n    }\n    const current = tRef.unsafeGet(self.permits, driver.journal)\n    return STM.succeed(tRef.unsafeSet(self.permits, current + n, driver.journal))\n  }))\n\n/** @internal */\nexport const withPermit = dual<\n  (semaphore: TSemaphore.TSemaphore) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(self: Effect.Effect<A, E, R>, semaphore: TSemaphore.TSemaphore) => Effect.Effect<A, E, R>\n>(2, (self, semaphore) => withPermits(self, semaphore, 1))\n\n/** @internal */\nexport const withPermits = dual<\n  (\n    semaphore: TSemaphore.TSemaphore,\n    permits: number\n  ) => <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  <A, E, R>(\n    self: Effect.Effect<A, E, R>,\n    semaphore: TSemaphore.TSemaphore,\n    permits: number\n  ) => Effect.Effect<A, E, R>\n>(3, (self, semaphore, permits) =>\n  Effect.uninterruptibleMask((restore) =>\n    Effect.zipRight(\n      restore(core.commit(acquireN(permits)(semaphore))),\n      Effect.ensuring(\n        self,\n        core.commit(releaseN(permits)(semaphore))\n      )\n    )\n  ))\n\n/** @internal */\nexport const withPermitScoped = (self: TSemaphore.TSemaphore): Effect.Effect<void, never, Scope.Scope> =>\n  withPermitsScoped(self, 1)\n\n/** @internal */\nexport const withPermitsScoped = dual<\n  (permits: number) => (self: TSemaphore.TSemaphore) => Effect.Effect<void, never, Scope.Scope>,\n  (self: TSemaphore.TSemaphore, permits: number) => Effect.Effect<void, never, Scope.Scope>\n>(2, (self, permits) =>\n  Effect.acquireReleaseInterruptible(\n    core.commit(acquireN(self, permits)),\n    () => core.commit(releaseN(self, permits))\n  ))\n\n/** @internal */\nexport const unsafeMakeSemaphore = (permits: number): TSemaphore.TSemaphore => {\n  return new TSemaphoreImpl(new tRef.TRefImpl(permits))\n}\n", "/**\n * @since 2.0.0\n */\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as HashSet from \"./HashSet.js\"\nimport * as internal from \"./internal/stm/tSet.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Predicate } from \"./Predicate.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as TMap from \"./TMap.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TSetTypeId: unique symbol = internal.TSetTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TSetTypeId = typeof TSetTypeId\n\n/**\n * Transactional set implemented on top of `TMap`.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface TSet<in out A> extends TSet.Variance<A> {}\n/**\n * @internal\n * @since 2.0.0\n */\nexport interface TSet<in out A> {\n  /** @internal */\n  readonly tMap: TMap.TMap<A, void>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace TSet {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [TSetTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * Stores new element in the set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const add: {\n  /**\n   * Stores new element in the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Stores new element in the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, value: A): STM.STM<void>\n} = internal.add\n\n/**\n * Atomically transforms the set into the difference of itself and the\n * provided set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const difference: {\n  /**\n   * Atomically transforms the set into the difference of itself and the\n   * provided set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Atomically transforms the set into the difference of itself and the\n   * provided set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>\n} = internal.difference\n\n/**\n * Makes an empty `TSet`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <A>() => STM.STM<TSet<A>> = internal.empty\n\n/**\n * Atomically performs transactional-effect for each element in set.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const forEach: {\n  /**\n   * Atomically performs transactional-effect for each element in set.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>\n  /**\n   * Atomically performs transactional-effect for each element in set.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>\n} = internal.forEach\n\n/**\n * Creates a new `TSet` from an iterable collection of values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>> = internal.fromIterable\n\n/**\n * Tests whether or not set contains an element.\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * Tests whether or not set contains an element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(value: A): (self: TSet<A>) => STM.STM<boolean>\n  /**\n   * Tests whether or not set contains an element.\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <A>(self: TSet<A>, value: A): STM.STM<boolean>\n} = internal.has\n\n/**\n * Atomically transforms the set into the intersection of itself and the\n * provided set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const intersection: {\n  /**\n   * Atomically transforms the set into the intersection of itself and the\n   * provided set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Atomically transforms the set into the intersection of itself and the\n   * provided set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>\n} = internal.intersection\n\n/**\n * Tests if the set is empty or not\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean> = internal.isEmpty\n\n/**\n * Makes a new `TSet` that is initialized with specified values.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Elements extends Array<any>>(\n  ...elements: Elements\n) => STM.STM<TSet<Elements[number]>> = internal.make\n\n/**\n * Atomically folds using a pure function.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>\n  /**\n   * Atomically folds using a pure function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>\n} = internal.reduce\n\n/**\n * Atomically folds using a transactional function.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduceSTM: {\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>\n  /**\n   * Atomically folds using a transactional function.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>\n} = internal.reduceSTM\n\n/**\n * Removes a single element from the set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const remove: {\n  /**\n   * Removes a single element from the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Removes a single element from the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, value: A): STM.STM<void>\n} = internal.remove\n\n/**\n * Removes elements from the set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const removeAll: {\n  /**\n   * Removes elements from the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Removes elements from the set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>\n} = internal.removeAll\n\n/**\n * Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n * (or `void` if `discard = true`).\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const removeIf: {\n  /**\n   * Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    predicate: Predicate<A>,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TSet<A>) => STM.STM<Array<A>>\n  /**\n   * Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    self: TSet<A>,\n    predicate: Predicate<A>,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  /**\n   * Removes entries from a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    self: TSet<A>,\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<A>>\n} = internal.removeIf\n\n/**\n * Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n * (or `void` if `discard = true`).\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const retainIf: {\n  /**\n   * Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    predicate: Predicate<A>,\n    options: {\n      readonly discard: true\n    }\n  ): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TSet<A>) => STM.STM<Array<A>>\n  /**\n   * Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    self: TSet<A>,\n    predicate: Predicate<A>,\n    options: {\n      readonly discard: true\n    }\n  ): STM.STM<void>\n  /**\n   * Retains entries in a `TSet` that satisfy the specified predicate and returns the removed entries\n   * (or `void` if `discard = true`).\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(\n    self: TSet<A>,\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<A>>\n} = internal.retainIf\n\n/**\n * Returns the set's cardinality.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <A>(self: TSet<A>) => STM.STM<number> = internal.size\n\n/**\n * Takes the first matching value, or retries until there is one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeFirst: {\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>\n} = internal.takeFirst\n\n/**\n * Takes the first matching value, or retries until there is one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeFirstSTM: {\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>\n  /**\n   * Takes the first matching value, or retries until there is one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>\n} = internal.takeFirstSTM\n\n/**\n * Takes all matching values, or retries until there is at least one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeSome: {\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>\n} = internal.takeSome\n\n/**\n * Takes all matching values, or retries until there is at least one.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const takeSomeSTM: {\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>\n  /**\n   * Takes all matching values, or retries until there is at least one.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>\n} = internal.takeSomeSTM\n\n/**\n * Collects all elements into a `Chunk`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>> = internal.toChunk\n\n/**\n * Collects all elements into a `HashSet`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>> = internal.toHashSet\n\n/**\n * Collects all elements into a `Array`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>> = internal.toArray\n\n/**\n * Collects all elements into a `ReadonlySet`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>> = internal.toReadonlySet\n\n/**\n * Atomically updates all elements using a pure function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transform: {\n  /**\n   * Atomically updates all elements using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Atomically updates all elements using a pure function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>\n} = internal.transform\n\n/**\n * Atomically updates all elements using a transactional function.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const transformSTM: {\n  /**\n   * Atomically updates all elements using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>\n  /**\n   * Atomically updates all elements using a transactional function.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>\n} = internal.transformSTM\n\n/**\n * Atomically transforms the set into the union of itself and the provided\n * set.\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const union: {\n  /**\n   * Atomically transforms the set into the union of itself and the provided\n   * set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>\n  /**\n   * Atomically transforms the set into the union of itself and the provided\n   * set.\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>\n} = internal.union\n", "import * as RA from \"../../Array.js\"\nimport * as Chunk from \"../../Chunk.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as HashSet from \"../../HashSet.js\"\nimport type * as Option from \"../../Option.js\"\nimport { hasProperty, type Predicate } from \"../../Predicate.js\"\nimport * as STM from \"../../STM.js\"\nimport type * as TMap from \"../../TMap.js\"\nimport type * as TSet from \"../../TSet.js\"\nimport * as core from \"./core.js\"\nimport * as tMap from \"./tMap.js\"\n\n/** @internal */\nconst TSetSymbolKey = \"effect/TSet\"\n\n/** @internal */\nexport const TSetTypeId: TSet.TSetTypeId = Symbol.for(\n  TSetSymbolKey\n) as TSet.TSetTypeId\n\nconst tSetVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\n/** @internal */\nclass TSetImpl<in out A> implements TSet.TSet<A> {\n  readonly [TSetTypeId] = tSetVariance\n  constructor(readonly tMap: TMap.TMap<A, void>) {}\n}\n\nconst isTSet = (u: unknown) => hasProperty(u, TSetTypeId)\n\n/** @internal */\nexport const add = dual<\n  <A>(value: A) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, value: A) => STM.STM<void>\n>(2, (self, value) => tMap.set(self.tMap, value, void 0 as void))\n\n/** @internal */\nexport const difference = dual<\n  <A>(other: TSet.TSet<A>) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, other: TSet.TSet<A>) => STM.STM<void>\n>(2, (self, other) =>\n  core.flatMap(\n    toHashSet(other),\n    (values) => removeIf(self, (value) => HashSet.has(values, value), { discard: true })\n  ))\n\n/** @internal */\nexport const empty = <A>(): STM.STM<TSet.TSet<A>> => fromIterable<A>([])\n\n/** @internal */\nexport const forEach = dual<\n  <A, R, E>(f: (value: A) => STM.STM<void, E, R>) => (self: TSet.TSet<A>) => STM.STM<void, E, R>,\n  <A, R, E>(self: TSet.TSet<A>, f: (value: A) => STM.STM<void, E, R>) => STM.STM<void, E, R>\n>(2, (self, f) => reduceSTM(self, void 0 as void, (_, value) => f(value)))\n\n/** @internal */\nexport const fromIterable = <A>(iterable: Iterable<A>): STM.STM<TSet.TSet<A>> =>\n  core.map(\n    tMap.fromIterable(Array.from(iterable).map((a): [A, void] => [a, void 0])),\n    (tMap) => new TSetImpl(tMap)\n  )\n\n/** @internal */\nexport const has = dual<\n  <A>(value: A) => (self: TSet.TSet<A>) => STM.STM<boolean>,\n  <A>(self: TSet.TSet<A>, value: A) => STM.STM<boolean>\n>(2, (self, value) => tMap.has(self.tMap, value))\n\n/** @internal */\nexport const intersection = dual<\n  <A>(other: TSet.TSet<A>) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, other: TSet.TSet<A>) => STM.STM<void>\n>(2, (self, other) =>\n  core.flatMap(\n    toHashSet(other),\n    (values) => pipe(self, retainIf((value) => pipe(values, HashSet.has(value)), { discard: true }))\n  ))\n\n/** @internal */\nexport const isEmpty = <A>(self: TSet.TSet<A>): STM.STM<boolean> => tMap.isEmpty(self.tMap)\n\n/** @internal */\nexport const make = <Elements extends Array<any>>(\n  ...elements: Elements\n): STM.STM<TSet.TSet<Elements[number]>> => fromIterable(elements)\n\n/** @internal */\nexport const reduce = dual<\n  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z) => (self: TSet.TSet<A>) => STM.STM<Z>,\n  <Z, A>(self: TSet.TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z) => STM.STM<Z>\n>(3, (self, zero, f) =>\n  tMap.reduce(\n    self.tMap,\n    zero,\n    (acc, _, key) => f(acc, key)\n  ))\n\n/** @internal */\nexport const reduceSTM = dual<\n  <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>) => (self: TSet.TSet<A>) => STM.STM<Z, E, R>,\n  <Z, A, R, E>(self: TSet.TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>) => STM.STM<Z, E, R>\n>(3, (self, zero, f) =>\n  tMap.reduceSTM(\n    self.tMap,\n    zero,\n    (acc, _, key) => f(acc, key)\n  ))\n\n/** @internal */\nexport const remove = dual<\n  <A>(value: A) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, value: A) => STM.STM<void>\n>(2, (self, value) => tMap.remove(self.tMap, value))\n\n/** @internal */\nexport const removeAll = dual<\n  <A>(iterable: Iterable<A>) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, iterable: Iterable<A>) => STM.STM<void>\n>(2, (self, iterable) => tMap.removeAll(self.tMap, iterable))\n\n/** @internal */\nexport const removeIf: {\n  <A>(predicate: Predicate<A>, options: {\n    readonly discard: true\n  }): (self: TSet.TSet<A>) => STM.STM<void>\n  <A>(\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TSet.TSet<A>) => STM.STM<Array<A>>\n  <A>(self: TSet.TSet<A>, predicate: Predicate<A>, options: {\n    readonly discard: true\n  }): STM.STM<void>\n  <A>(\n    self: TSet.TSet<A>,\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<A>>\n} = dual(\n  (args) => isTSet(args[0]),\n  (self, predicate, options) =>\n    options?.discard === true ? tMap.removeIf(self.tMap, (key) => predicate(key), { discard: true }) : pipe(\n      tMap.removeIf(self.tMap, (key) => predicate(key)),\n      core.map(RA.map((entry) => entry[0]))\n    )\n)\n\n/** @internal */\nexport const retainIf: {\n  <A>(predicate: Predicate<A>, options: {\n    readonly discard: true\n  }): (self: TSet.TSet<A>) => STM.STM<void>\n  <A>(\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): (self: TSet.TSet<A>) => STM.STM<Array<A>>\n  <A>(self: TSet.TSet<A>, predicate: Predicate<A>, options: {\n    readonly discard: true\n  }): STM.STM<void>\n  <A>(\n    self: TSet.TSet<A>,\n    predicate: Predicate<A>,\n    options?: {\n      readonly discard: false\n    }\n  ): STM.STM<Array<A>>\n} = dual((args) => isTSet(args[0]), (self, predicate, options) =>\n  options?.discard === true ?\n    tMap.retainIf(self.tMap, (key) => predicate(key), { discard: true }) :\n    pipe(\n      tMap.retainIf(self.tMap, (key) => predicate(key)),\n      core.map(RA.map((entry) => entry[0]))\n    ))\n\n/** @internal */\nexport const size = <A>(self: TSet.TSet<A>): STM.STM<number> => core.map(toChunk(self), (chunk) => chunk.length)\n\n/** @internal */\nexport const takeFirst = dual<\n  <A, B>(pf: (a: A) => Option.Option<B>) => (self: TSet.TSet<A>) => STM.STM<B>,\n  <A, B>(self: TSet.TSet<A>, pf: (a: A) => Option.Option<B>) => STM.STM<B>\n>(2, (self, pf) => tMap.takeFirst(self.tMap, (key) => pf(key)))\n\n/** @internal */\nexport const takeFirstSTM = dual<\n  <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>) => (self: TSet.TSet<A>) => STM.STM<B, E, R>,\n  <A, B, E, R>(self: TSet.TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>) => STM.STM<B, E, R>\n>(2, (self, pf) => tMap.takeFirstSTM(self.tMap, (key) => pf(key)))\n\n/** @internal */\nexport const takeSome = dual<\n  <A, B>(pf: (a: A) => Option.Option<B>) => (self: TSet.TSet<A>) => STM.STM<RA.NonEmptyArray<B>>,\n  <A, B>(self: TSet.TSet<A>, pf: (a: A) => Option.Option<B>) => STM.STM<RA.NonEmptyArray<B>>\n>(2, (self, pf) => tMap.takeSome(self.tMap, (key) => pf(key)))\n\n/** @internal */\nexport const takeSomeSTM = dual<\n  <A, B, E, R>(\n    pf: (a: A) => STM.STM<B, Option.Option<E>, R>\n  ) => (self: TSet.TSet<A>) => STM.STM<RA.NonEmptyArray<B>, E, R>,\n  <A, B, E, R>(\n    self: TSet.TSet<A>,\n    pf: (a: A) => STM.STM<B, Option.Option<E>, R>\n  ) => STM.STM<RA.NonEmptyArray<B>, E, R>\n>(2, (self, pf) => tMap.takeSomeSTM(self.tMap, (key) => pf(key)))\n\n/** @internal */\nexport const toChunk = <A>(self: TSet.TSet<A>): STM.STM<Chunk.Chunk<A>> =>\n  tMap.keys(self.tMap).pipe(STM.map(Chunk.unsafeFromArray))\n\n/** @internal */\nexport const toHashSet = <A>(self: TSet.TSet<A>): STM.STM<HashSet.HashSet<A>> =>\n  reduce(\n    self,\n    HashSet.empty<A>(),\n    (acc, value) => pipe(acc, HashSet.add(value))\n  )\n\n/** @internal */\nexport const toArray = <A>(self: TSet.TSet<A>): STM.STM<Array<A>> =>\n  reduce<Array<A>, A>(\n    self,\n    [],\n    (acc, value) => [...acc, value]\n  )\n\n/** @internal */\nexport const toReadonlySet = <A>(self: TSet.TSet<A>): STM.STM<ReadonlySet<A>> =>\n  core.map(toArray(self), (values) => new Set(values))\n\n/** @internal */\nexport const transform = dual<\n  <A>(f: (a: A) => A) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, f: (a: A) => A) => STM.STM<void>\n>(2, (self, f) => tMap.transform(self.tMap, (key, value) => [f(key), value]))\n\n/** @internal */\nexport const transformSTM = dual<\n  <A, R, E>(f: (a: A) => STM.STM<A, E, R>) => (self: TSet.TSet<A>) => STM.STM<void, E, R>,\n  <A, R, E>(self: TSet.TSet<A>, f: (a: A) => STM.STM<A, E, R>) => STM.STM<void, E, R>\n>(2, (self, f) =>\n  tMap.transformSTM(\n    self.tMap,\n    (key, value) => core.map(f(key), (a) => [a, value])\n  ))\n\n/** @internal */\nexport const union = dual<\n  <A>(other: TSet.TSet<A>) => (self: TSet.TSet<A>) => STM.STM<void>,\n  <A>(self: TSet.TSet<A>, other: TSet.TSet<A>) => STM.STM<void>\n>(2, (self, other) => forEach(other, (value) => add(self, value)))\n", "/**\n * @since 3.10.0\n */\nimport type * as Effect from \"./Effect.js\"\nimport * as internal from \"./internal/stm/tSubscriptionRef.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as STM from \"./STM.js\"\nimport type * as Stream from \"./Stream.js\"\nimport type * as TPubSub from \"./TPubSub.js\"\nimport type * as TQueue from \"./TQueue.js\"\nimport type * as TRef from \"./TRef.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 3.10.0\n * @category symbols\n */\nexport const TSubscriptionRefTypeId: unique symbol = internal.TSubscriptionRefTypeId\n\n/**\n * @since 3.10.0\n * @category symbols\n */\nexport type TSubscriptionRefTypeId = typeof TSubscriptionRefTypeId\n\n/**\n * A `TSubscriptionRef<A>` is a `TRef` that can be subscribed to in order to\n * receive a `TDequeue<A>` of the current value and all committed changes to the value.\n *\n * @since 3.10.0\n * @category models\n */\nexport interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {\n  /** @internal */\n  readonly ref: TRef.TRef<A>\n  /** @internal */\n  readonly pubsub: TPubSub.TPubSub<A>\n  /** @internal */\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>\n\n  /**\n   * A TDequeue containing the current value of the `Ref` as well as all changes\n   * to that value.\n   */\n  readonly changes: STM.STM<TQueue.TDequeue<A>>\n}\n\n/**\n * @since 3.10.0\n */\nexport declare namespace TSubscriptionRef {\n  /**\n   * @since 3.10.0\n   * @category models\n   */\n  export interface Variance<in out A> {\n    readonly [TSubscriptionRefTypeId]: {\n      readonly _A: Types.Invariant<A>\n    }\n  }\n}\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const get: <A>(self: TSubscriptionRef<A>) => STM.STM<A> = internal.get\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const getAndSet: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>\n} = internal.getAndSet\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const getAndUpdate: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>\n} = internal.getAndUpdate\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const getAndUpdateSome: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>\n} = internal.getAndUpdateSome\n\n/**\n * @since 3.10.0\n * @category constructors\n */\nexport const make: <A>(value: A) => STM.STM<TSubscriptionRef<A>> = internal.make\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const modify: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A, B>(f: (a: A) => readonly [B, A]): (self: TSubscriptionRef<A>) => STM.STM<B>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A, B>(self: TSubscriptionRef<A>, f: (a: A) => readonly [B, A]): STM.STM<B>\n} = internal.modify\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const modifySome: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A, B>(fallback: B, f: (a: A) => Option.Option<readonly [B, A]>): (self: TSubscriptionRef<A>) => STM.STM<B>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A, B>(\n   self: TSubscriptionRef<A>,\n   fallback: B,\n   f: (a: A) => Option.Option<readonly [B, A]>\n  ): STM.STM<B>\n} = internal.modifySome\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const set: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<void>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, value: A): STM.STM<void>\n} = internal.set\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const setAndGet: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(value: A): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, value: A): STM.STM<A>\n} = internal.setAndGet\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const update: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<void>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<void>\n} = internal.update\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const updateAndGet: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => A): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => A): STM.STM<A>\n} = internal.updateAndGet\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const updateSome: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<void>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<void>\n} = internal.updateSome\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const updateSomeAndGet: {\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(f: (a: A) => Option.Option<A>): (self: TSubscriptionRef<A>) => STM.STM<A>\n  /**\n   * @since 3.10.0\n   * @category mutations\n   */\n  <A>(self: TSubscriptionRef<A>, f: (a: A) => Option.Option<A>): STM.STM<A>\n} = internal.updateSomeAndGet\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const changesScoped: <A>(self: TSubscriptionRef<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope> =\n  internal.changesScoped\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const changesStream: <A>(self: TSubscriptionRef<A>) => Stream.Stream<A> = internal.changesStream\n\n/**\n * @since 3.10.0\n * @category mutations\n */\nexport const changes: <A>(self: TSubscriptionRef<A>) => STM.STM<TQueue.TDequeue<A>> = (self) => self.changes\n", "import * as Effect from \"../../Effect.js\"\nimport { dual, pipe } from \"../../Function.js\"\nimport * as Option from \"../../Option.js\"\nimport { pipeArguments } from \"../../Pipeable.js\"\nimport * as STM from \"../../STM.js\"\nimport * as TPubSub from \"../../TPubSub.js\"\nimport * as TQueue from \"../../TQueue.js\"\nimport * as TRef from \"../../TRef.js\"\nimport type * as TSubscriptionRef from \"../../TSubscriptionRef.js\"\nimport * as stream from \"../stream.js\"\nimport { tDequeueVariance } from \"./tQueue.js\"\nimport { tRefVariance } from \"./tRef.js\"\n\n/** @internal */\nconst TSubscriptionRefSymbolKey = \"effect/TSubscriptionRef\"\n\n/** @internal */\nexport const TSubscriptionRefTypeId: TSubscriptionRef.TSubscriptionRefTypeId = Symbol.for(\n  TSubscriptionRefSymbolKey\n) as TSubscriptionRef.TSubscriptionRefTypeId\n\nconst TSubscriptionRefVariance = {\n  /* c8 ignore next */\n  _A: (_: any) => _\n}\n\nclass TDequeueMerge<A> implements TQueue.TDequeue<A> {\n  [TQueue.TDequeueTypeId] = tDequeueVariance\n\n  constructor(\n    readonly first: TQueue.TDequeue<A>,\n    readonly second: TQueue.TDequeue<A>\n  ) {}\n\n  peek: STM.STM<A> = STM.gen(this, function*() {\n    const first = yield* this.peekOption\n    if (first._tag === \"Some\") {\n      return first.value\n    }\n    return yield* STM.retry\n  })\n\n  peekOption: STM.STM<Option.Option<A>> = STM.gen(this, function*() {\n    const first = yield* this.first.peekOption\n    if (first._tag === \"Some\") {\n      return first\n    }\n    const second = yield* this.second.peekOption\n    if (second._tag === \"Some\") {\n      return second\n    }\n    return Option.none()\n  })\n\n  take: STM.STM<A> = STM.gen(this, function*() {\n    if (!(yield* this.first.isEmpty)) {\n      return yield* this.first.take\n    }\n    if (!(yield* this.second.isEmpty)) {\n      return yield* this.second.take\n    }\n    return yield* STM.retry\n  })\n\n  takeAll: STM.STM<Array<A>> = STM.gen(this, function*() {\n    return [...yield* this.first.takeAll, ...yield* this.second.takeAll]\n  })\n\n  takeUpTo(max: number): STM.STM<Array<A>> {\n    return STM.gen(this, function*() {\n      const first = yield* this.first.takeUpTo(max)\n      if (first.length >= max) {\n        return first\n      }\n      return [...first, ...yield* this.second.takeUpTo(max - first.length)]\n    })\n  }\n\n  capacity(): number {\n    return this.first.capacity() + this.second.capacity()\n  }\n\n  size: STM.STM<number> = STM.gen(this, function*() {\n    return (yield* this.first.size) + (yield* this.second.size)\n  })\n\n  isFull: STM.STM<boolean> = STM.gen(this, function*() {\n    return (yield* this.first.isFull) && (yield* this.second.isFull)\n  })\n\n  isEmpty: STM.STM<boolean> = STM.gen(this, function*() {\n    return (yield* this.first.isEmpty) && (yield* this.second.isEmpty)\n  })\n\n  shutdown: STM.STM<void> = STM.gen(this, function*() {\n    yield* this.first.shutdown\n    yield* this.second.shutdown\n  })\n\n  isShutdown: STM.STM<boolean> = STM.gen(this, function*() {\n    return (yield* this.first.isShutdown) && (yield* this.second.isShutdown)\n  })\n\n  awaitShutdown: STM.STM<void> = STM.gen(this, function*() {\n    yield* this.first.awaitShutdown\n    yield* this.second.awaitShutdown\n  })\n}\n\n/** @internal */\nclass TSubscriptionRefImpl<in out A> implements TSubscriptionRef.TSubscriptionRef<A> {\n  readonly [TSubscriptionRefTypeId] = TSubscriptionRefVariance\n  readonly [TRef.TRefTypeId] = tRefVariance\n\n  constructor(\n    readonly ref: TRef.TRef<A>,\n    readonly pubsub: TPubSub.TPubSub<A>\n  ) {}\n\n  get todos() {\n    return this.ref.todos\n  }\n\n  get versioned() {\n    return this.ref.versioned\n  }\n\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n\n  get changes(): STM.STM<TQueue.TDequeue<A>> {\n    return STM.gen(this, function*() {\n      const first = yield* TQueue.unbounded<A>()\n      yield* TQueue.offer(first, yield* TRef.get(this.ref))\n      return new TDequeueMerge(first, yield* TPubSub.subscribe(this.pubsub))\n    })\n  }\n\n  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B> {\n    return pipe(\n      TRef.get(this.ref),\n      STM.map(f),\n      STM.flatMap(([b, a]) =>\n        pipe(\n          TRef.set(this.ref, a),\n          STM.as(b),\n          STM.zipLeft(TPubSub.publish(this.pubsub, a))\n        )\n      )\n    )\n  }\n}\n\n/** @internal */\nexport const make = <A>(value: A): STM.STM<TSubscriptionRef.TSubscriptionRef<A>> =>\n  pipe(\n    STM.all([\n      TPubSub.unbounded<A>(),\n      TRef.make(value)\n    ]),\n    STM.map(([pubsub, ref]) => new TSubscriptionRefImpl(ref, pubsub))\n  )\n\n/** @internal */\nexport const get = <A>(self: TSubscriptionRef.TSubscriptionRef<A>) => TRef.get(self.ref)\n\n/** @internal */\nexport const set = dual<\n  <A>(value: A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<void>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, value: A) => STM.STM<void>\n>(\n  2,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, value: A): STM.STM<void> =>\n    self.modify((): [void, A] => [void 0, value])\n)\n\n/** @internal */\nexport const getAndSet = dual<\n  <A>(value: A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, value: A) => STM.STM<A>\n>(2, (self, value) => self.modify((a) => [a, value]))\n\n/** @internal */\nexport const getAndUpdate = dual<\n  <A>(f: (a: A) => A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => A) => STM.STM<A>\n>(2, (self, f) => self.modify((a) => [a, f(a)]))\n\n/** @internal */\nexport const getAndUpdateSome = dual<\n  <A>(f: (a: A) => Option.Option<A>) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => Option.Option<A>) => STM.STM<A>\n>(2, (self, f) =>\n  self.modify((a) =>\n    Option.match(f(a), {\n      onNone: () => [a, a],\n      onSome: (b) => [a, b]\n    })\n  ))\n\n/** @internal */\nexport const setAndGet = dual<\n  <A>(value: A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, value: A) => STM.STM<A>\n>(2, (self, value) => self.modify(() => [value, value]))\n\n/** @internal */\nexport const modify = dual<\n  <A, B>(f: (a: A) => readonly [B, A]) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<B>,\n  <A, B>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => readonly [B, A]) => STM.STM<B>\n>(2, (self, f) => self.modify(f))\n\n/** @internal */\nexport const modifySome = dual<\n  <A, B>(\n    fallback: B,\n    f: (a: A) => Option.Option<readonly [B, A]>\n  ) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<B>,\n  <A, B>(\n    self: TSubscriptionRef.TSubscriptionRef<A>,\n    fallback: B,\n    f: (a: A) => Option.Option<readonly [B, A]>\n  ) => STM.STM<B>\n>(3, (self, fallback, f) =>\n  self.modify((a) =>\n    Option.match(f(a), {\n      onNone: () => [fallback, a],\n      onSome: (b) => b\n    })\n  ))\n\n/** @internal */\nexport const update = dual<\n  <A>(f: (a: A) => A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<void>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => A) => STM.STM<void>\n>(2, (self, f) => self.modify((a) => [void 0, f(a)]))\n\n/** @internal */\nexport const updateAndGet = dual<\n  <A>(f: (a: A) => A) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => A) => STM.STM<A>\n>(2, (self, f) =>\n  self.modify((a) => {\n    const b = f(a)\n    return [b, b]\n  }))\n\n/** @internal */\nexport const updateSome = dual<\n  <A>(f: (a: A) => Option.Option<A>) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<void>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => Option.Option<A>) => STM.STM<void>\n>(\n  2,\n  (self, f) =>\n    self.modify((a) => [\n      void 0,\n      Option.match(f(a), {\n        onNone: () => a,\n        onSome: (b) => b\n      })\n    ])\n)\n\n/** @internal */\nexport const updateSomeAndGet = dual<\n  <A>(f: (a: A) => Option.Option<A>) => (self: TSubscriptionRef.TSubscriptionRef<A>) => STM.STM<A>,\n  <A>(self: TSubscriptionRef.TSubscriptionRef<A>, f: (a: A) => Option.Option<A>) => STM.STM<A>\n>(\n  2,\n  (self, f) =>\n    self.modify((a) =>\n      Option.match(f(a), {\n        onNone: () => [a, a],\n        onSome: (b) => [b, b]\n      })\n    )\n)\n\n/** @internal */\nexport const changesScoped = <A>(self: TSubscriptionRef.TSubscriptionRef<A>) =>\n  Effect.acquireRelease(self.changes, TQueue.shutdown)\n\n/** @internal */\nexport const changesStream = <A>(self: TSubscriptionRef.TSubscriptionRef<A>) =>\n  stream.unwrap(Effect.map(self.changes, stream.fromTQueue))\n", "/**\n * @since 2.0.0\n */\nimport type * as Cause from \"./Cause.js\"\nimport type * as Chunk from \"./Chunk.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as Exit from \"./Exit.js\"\nimport * as internal from \"./internal/take.js\"\nimport type * as Option from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const TakeTypeId: unique symbol = internal.TakeTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type TakeTypeId = typeof TakeTypeId\n\n/**\n * A `Take<A, E>` represents a single `take` from a queue modeling a stream of\n * values. A `Take` may be a failure cause `Cause<E>`, a chunk value `Chunk<A>`,\n * or an end-of-stream marker.\n *\n * @since 2.0.0\n * @category models\n */\nexport interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {\n  /** @internal */\n  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>\n}\n\n/**\n * @since 2.0.0\n */\nexport declare namespace Take {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A, out E> {\n    readonly [TakeTypeId]: {\n      readonly _A: Types.Covariant<A>\n      readonly _E: Types.Covariant<E>\n    }\n  }\n}\n\n/**\n * Creates a `Take` with the specified chunk.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A> = internal.chunk\n\n/**\n * Creates a failing `Take` with the specified defect.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const die: (defect: unknown) => Take<never> = internal.die\n\n/**\n * Creates a failing `Take` with the specified error message.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const dieMessage: (message: string) => Take<never> = internal.dieMessage\n\n/**\n * Transforms a `Take<A, E>` to an `Effect<A, E>`.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>> = internal.done\n\n/**\n * Represents the end-of-stream marker.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const end: Take<never> = internal.end\n\n/**\n * Creates a failing `Take` with the specified error.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fail: <E>(error: E) => Take<never, E> = internal.fail\n\n/**\n * Creates a failing `Take` with the specified cause.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E> = internal.failCause\n\n/**\n * Creates an effect from `Effect<A, E, R>` that does not fail, but succeeds with\n * the `Take<A, E>`. Error from stream when pulling is converted to\n * `Take.failCause`. Creates a single value chunk.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R> =\n  internal.fromEffect\n\n/**\n * Creates a `Take` from an `Exit`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E> = internal.fromExit\n\n/**\n * Creates effect from `Effect<Chunk<A>, Option<E>, R>` that does not fail, but\n * succeeds with the `Take<A, E>`. Errors from stream when pulling are converted\n * to `Take.failCause`, and the end-of-stream is converted to `Take.end`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromPull: <A, E, R>(\n  pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>\n) => Effect.Effect<Take<A, E>, never, R> = internal.fromPull\n\n/**\n * Checks if this `take` is done (`Take.end`).\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isDone: <A, E>(self: Take<A, E>) => boolean = internal.isDone\n\n/**\n * Checks if this `take` is a failure.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isFailure: <A, E>(self: Take<A, E>) => boolean = internal.isFailure\n\n/**\n * Checks if this `take` is a success.\n *\n * @since 2.0.0\n * @category getters\n */\nexport const isSuccess: <A, E>(self: Take<A, E>) => boolean = internal.isSuccess\n\n/**\n * Constructs a `Take`.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E> = internal.make\n\n/**\n * Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.\n *\n * @since 2.0.0\n * @category mapping\n */\nexport const map: {\n  /**\n   * Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>\n  /**\n   * Transforms `Take<A, E>` to `Take<B, A>` by applying function `f`.\n   *\n   * @since 2.0.0\n   * @category mapping\n   */\n  <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>\n} = internal.map\n\n/**\n * Folds over the failure cause, success value and end-of-stream marker to\n * yield a value.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const match: {\n  /**\n   * Folds over the failure cause, success value and end-of-stream marker to\n   * yield a value.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <Z, E, Z2, A, Z3>(\n   options: {\n     readonly onEnd: () => Z\n     readonly onFailure: (cause: Cause.Cause<E>) => Z2\n     readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3\n   }\n  ): (self: Take<A, E>) => Z | Z2 | Z3\n  /**\n   * Folds over the failure cause, success value and end-of-stream marker to\n   * yield a value.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <A, E, Z, Z2, Z3>(\n   self: Take<A, E>,\n   options: {\n     readonly onEnd: () => Z\n     readonly onFailure: (cause: Cause.Cause<E>) => Z2\n     readonly onSuccess: (chunk: Chunk.Chunk<A>) => Z3\n   }\n  ): Z | Z2 | Z3\n} = internal.match\n\n/**\n * Effectful version of `Take.fold`.\n *\n * Folds over the failure cause, success value and end-of-stream marker to\n * yield an effect.\n *\n * @since 2.0.0\n * @category destructors\n */\nexport const matchEffect: {\n  /**\n   * Effectful version of `Take.fold`.\n   *\n   * Folds over the failure cause, success value and end-of-stream marker to\n   * yield an effect.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(\n   options: {\n     readonly onEnd: Effect.Effect<Z, E2, R>\n     readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>\n     readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>\n   }\n  ): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>\n  /**\n   * Effectful version of `Take.fold`.\n   *\n   * Folds over the failure cause, success value and end-of-stream marker to\n   * yield an effect.\n   *\n   * @since 2.0.0\n   * @category destructors\n   */\n  <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(\n   self: Take<A, E>,\n   options: {\n     readonly onEnd: Effect.Effect<Z, E2, R>\n     readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>\n     readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>\n   }\n  ): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>\n} = internal.matchEffect\n\n/**\n * Creates a `Take` with a single value chunk.\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const of: <A>(value: A) => Take<A> = internal.of\n\n/**\n * Returns an effect that effectfully \"peeks\" at the success of this take.\n *\n * @since 2.0.0\n * @category sequencing\n */\nexport const tap: {\n  /**\n   * Returns an effect that effectfully \"peeks\" at the success of this take.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>\n  /**\n   * Returns an effect that effectfully \"peeks\" at the success of this take.\n   *\n   * @since 2.0.0\n   * @category sequencing\n   */\n  <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>\n} = internal.tap\n", "/**\n * @since 2.0.0\n */\nimport * as Chunk from \"./Chunk.js\"\nimport * as Either from \"./Either.js\"\nimport * as Equal from \"./Equal.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport { pipe } from \"./Function.js\"\nimport * as Hash from \"./Hash.js\"\nimport * as HashSet from \"./HashSet.js\"\nimport { getBugErrorMessage } from \"./internal/errors.js\"\nimport type * as MutableRef from \"./MutableRef.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport type * as SortedSet from \"./SortedSet.js\"\nimport type * as Types from \"./Types.js\"\n\n/** @internal */\nconst TestAnnotationSymbolKey = \"effect/TestAnnotation\"\n\n/**\n * @since 2.0.0\n */\nexport const TestAnnotationTypeId: unique symbol = Symbol.for(TestAnnotationSymbolKey)\n\n/**\n * @since 2.0.0\n */\nexport type TestAnnotationTypeId = typeof TestAnnotationTypeId\n\n/**\n * @since 2.0.0\n */\nexport interface TestAnnotation<in out A> extends Equal.Equal {\n  readonly [TestAnnotationTypeId]: {\n    readonly _A: Types.Invariant<A>\n  }\n  readonly identifier: string\n  readonly initial: A\n  combine(a: A, b: A): A\n}\n\n/** @internal */\nclass TestAnnotationImpl<A> implements Equal.Equal {\n  readonly [TestAnnotationTypeId] = {\n    _A: (_: any) => _\n  }\n  constructor(\n    readonly identifier: string,\n    readonly initial: A,\n    readonly combine: (a: A, b: A) => A\n  ) {}\n  [Hash.symbol](): number {\n    return pipe(\n      Hash.hash(TestAnnotationSymbolKey),\n      Hash.combine(Hash.hash(this.identifier)),\n      Hash.cached(this)\n    )\n  }\n  [Equal.symbol](that: unknown): boolean {\n    return isTestAnnotation(that) &&\n      this.identifier === that.identifier\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const isTestAnnotation = (u: unknown): u is TestAnnotation<unknown> => hasProperty(u, TestAnnotationTypeId)\n\n/**\n * @since 2.0.0\n */\nexport const make = <A>(\n  identifier: string,\n  initial: A,\n  combine: (a: A, b: A) => A\n): TestAnnotation<A> => {\n  return new TestAnnotationImpl<A>(identifier, initial, combine)\n}\n\n/**\n * @since 2.0.0\n */\nexport const compose = <A>(\n  left: Either.Either<Chunk.Chunk<A>, number>,\n  right: Either.Either<Chunk.Chunk<A>, number>\n): Either.Either<Chunk.Chunk<A>, number> => {\n  if (Either.isLeft(left) && Either.isLeft(right)) {\n    return Either.left(left.left + right.left)\n  }\n  if (Either.isRight(left) && Either.isRight(right)) {\n    return Either.right(pipe(left.right, Chunk.appendAll(right.right)))\n  }\n  if (Either.isRight(left) && Either.isLeft(right)) {\n    return right\n  }\n  if (Either.isLeft(left) && Either.isRight(right)) {\n    return right\n  }\n  throw new Error(getBugErrorMessage(\"TestAnnotation.compose\"))\n}\n\n/**\n * @since 2.0.0\n */\nexport const fibers: TestAnnotation<\n  Either.Either<Chunk.Chunk<MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>>, number>\n> = make<\n  Either.Either<Chunk.Chunk<MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>>, number>\n>(\n  \"fibers\",\n  Either.left(0),\n  compose\n)\n\n/**\n * An annotation which counts ignored tests.\n *\n * @since 2.0.0\n */\nexport const ignored: TestAnnotation<number> = make(\n  \"ignored\",\n  0,\n  (a, b) => a + b\n)\n\n/**\n * An annotation which counts repeated tests.\n *\n * @since 2.0.0\n */\nexport const repeated: TestAnnotation<number> = make(\n  \"repeated\",\n  0,\n  (a, b) => a + b\n)\n\n/**\n * An annotation which counts retried tests.\n *\n * @since 2.0.0\n */\nexport const retried: TestAnnotation<number> = make(\n  \"retried\",\n  0,\n  (a, b) => a + b\n)\n\n/**\n * An annotation which tags tests with strings.\n *\n * @since 2.0.0\n */\nexport const tagged: TestAnnotation<HashSet.HashSet<string>> = make(\n  \"tagged\",\n  HashSet.empty(),\n  (a, b) => pipe(a, HashSet.union(b))\n)\n", "/**\n * @since 2.0.0\n */\nimport { dual } from \"./Function.js\"\nimport * as HashMap from \"./HashMap.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport type * as TestAnnotation from \"./TestAnnotation.js\"\n\n/**\n * @since 2.0.0\n */\nexport const TestAnnotationMapTypeId: unique symbol = Symbol.for(\"effect/TestAnnotationMap\")\n\n/**\n * @since 2.0.0\n */\nexport type TestAnnotationMapTypeId = typeof TestAnnotationMapTypeId\n\n/**\n * An annotation map keeps track of annotations of different types.\n *\n * @since 2.0.0\n */\nexport interface TestAnnotationMap {\n  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId\n  /** @internal */\n  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>\n}\n\n/** @internal */\nclass TestAnnotationMapImpl implements TestAnnotationMap {\n  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId = TestAnnotationMapTypeId\n  constructor(readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>) {\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const isTestAnnotationMap = (u: unknown): u is TestAnnotationMap => hasProperty(u, TestAnnotationMapTypeId)\n\n/**\n * @since 2.0.0\n */\nexport const empty: (_: void) => TestAnnotationMap = () => new TestAnnotationMapImpl(HashMap.empty())\n\n/**\n * @since 2.0.0\n */\nexport const make = (map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>): TestAnnotationMap => {\n  return new TestAnnotationMapImpl(map)\n}\n\n/**\n * @since 2.0.0\n */\nexport const overwrite = dual<\n  /**\n   * @since 2.0.0\n   */\n  <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap,\n  /**\n   * @since 2.0.0\n   */\n  <A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap\n>(3, (self, key, value) => make(HashMap.set(self.map, key, value)))\n\n/**\n * @since 2.0.0\n */\nexport const update = dual<\n  /**\n   * @since 2.0.0\n   */\n  <A>(key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => (self: TestAnnotationMap) => TestAnnotationMap,\n  /**\n   * @since 2.0.0\n   */\n  <A>(\n    self: TestAnnotationMap,\n    key: TestAnnotation.TestAnnotation<A>,\n    f: (value: A) => A\n  ) => TestAnnotationMap\n>(3, <A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, f: (value: A) => A) => {\n  let value = key.initial\n  if (HashMap.has(self.map, key)) {\n    value = HashMap.unsafeGet(self.map, key) as A\n  }\n  return overwrite(self, key, f(value))\n})\n\n/**\n * Retrieves the annotation of the specified type, or its default value if\n * there is none.\n *\n * @since 2.0.0\n */\nexport const get = dual<\n  /**\n   * Retrieves the annotation of the specified type, or its default value if\n   * there is none.\n   *\n   * @since 2.0.0\n   */\n  <A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A,\n  /**\n   * Retrieves the annotation of the specified type, or its default value if\n   * there is none.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A\n>(2, <A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => {\n  if (HashMap.has(self.map, key)) {\n    return HashMap.unsafeGet(self.map, key) as A\n  }\n  return key.initial\n})\n\n/**\n * Appends the specified annotation to the annotation map.\n *\n * @since 2.0.0\n */\nexport const annotate = dual<\n  /**\n   * Appends the specified annotation to the annotation map.\n   *\n   * @since 2.0.0\n   */\n  <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap,\n  /**\n   * Appends the specified annotation to the annotation map.\n   *\n   * @since 2.0.0\n   */\n  <A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap\n>(3, (self, key, value) => update(self, key, (_) => key.combine(_, value)))\n\n/**\n * @since 2.0.0\n */\nexport const combine = dual<\n  /**\n   * @since 2.0.0\n   */\n  (that: TestAnnotationMap) => (self: TestAnnotationMap) => TestAnnotationMap,\n  /**\n   * @since 2.0.0\n   */\n  (self: TestAnnotationMap, that: TestAnnotationMap) => TestAnnotationMap\n>(2, (self, that) => {\n  let result = self.map\n  for (const entry of that.map) {\n    if (HashMap.has(result, entry[0])) {\n      const value = HashMap.get(result, entry[0])!\n      result = HashMap.set(result, entry[0], entry[0].combine(value, entry[1]))\n    } else {\n      result = HashMap.set(result, entry[0], entry[1])\n    }\n  }\n  return make(result)\n})\n", "/**\n * @since 2.0.0\n */\nimport * as RA from \"./Array.js\"\nimport * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as Equal from \"./Equal.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport { pipe } from \"./Function.js\"\nimport * as effect from \"./internal/core-effect.js\"\nimport * as core from \"./internal/core.js\"\nimport * as fiber from \"./internal/fiber.js\"\nimport * as MutableRef from \"./MutableRef.js\"\nimport { hasProperty } from \"./Predicate.js\"\nimport * as Ref from \"./Ref.js\"\nimport * as SortedSet from \"./SortedSet.js\"\nimport * as TestAnnotation from \"./TestAnnotation.js\"\nimport * as TestAnnotationMap from \"./TestAnnotationMap.js\"\n\n/**\n * @since 2.0.0\n */\nexport const TestAnnotationsTypeId: unique symbol = Symbol.for(\"effect/TestAnnotations\")\n\n/**\n * @since 2.0.0\n */\nexport type TestAnnotationsTypeId = typeof TestAnnotationsTypeId\n\n/**\n * The `Annotations` trait provides access to an annotation map that tests can\n * add arbitrary annotations to. Each annotation consists of a string\n * identifier, an initial value, and a function for combining two values.\n * Annotations form monoids and you can think of `Annotations` as a more\n * structured logging service or as a super polymorphic version of the writer\n * monad effect.\n *\n * @since 2.0.0\n */\nexport interface TestAnnotations {\n  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId\n\n  /**\n   * A ref containing the bacnking map for all annotations\n   */\n  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>\n\n  /**\n   * Accesses an `Annotations` instance in the context and retrieves the\n   * annotation of the specified type, or its default value if there is none.\n   */\n  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>\n\n  /**\n   * Accesses an `Annotations` instance in the context and appends the\n   * specified annotation to the annotation map.\n   */\n  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>\n\n  /**\n   * Returns the set of all fibers in this test.\n   */\n  readonly supervisedFibers: Effect.Effect<\n    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>\n  >\n}\n\n/** @internal */\nclass AnnotationsImpl implements TestAnnotations {\n  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId = TestAnnotationsTypeId\n  constructor(readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>) {\n  }\n  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A> {\n    return core.map(Ref.get(this.ref), TestAnnotationMap.get(key))\n  }\n  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void> {\n    return Ref.update(this.ref, TestAnnotationMap.annotate(key, value))\n  }\n  get supervisedFibers(): Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>> {\n    return effect.descriptorWith((descriptor) =>\n      core.flatMap(this.get(TestAnnotation.fibers), (either) => {\n        switch (either._tag) {\n          case \"Left\": {\n            return core.succeed(SortedSet.empty(fiber.Order))\n          }\n          case \"Right\": {\n            return pipe(\n              either.right,\n              core.forEachSequential((ref) => core.sync(() => MutableRef.get(ref))),\n              core.map(RA.reduce(SortedSet.empty(fiber.Order), (a, b) => SortedSet.union(a, b))),\n              core.map(SortedSet.filter((fiber) => !Equal.equals(fiber.id(), descriptor.id)))\n            )\n          }\n        }\n      })\n    )\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const TestAnnotations: Context.Tag<TestAnnotations, TestAnnotations> = Context.GenericTag<TestAnnotations>(\n  \"effect/Annotations\"\n)\n\n/**\n * @since 2.0.0\n */\nexport const isTestAnnotations = (u: unknown): u is TestAnnotations => hasProperty(u, TestAnnotationsTypeId)\n\n/**\n * @since 2.0.0\n */\nexport const make = (\n  ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>\n): TestAnnotations => new AnnotationsImpl(ref)\n", "/**\n * @since 2.0.0\n */\nimport * as Chunk from \"./Chunk.js\"\nimport type * as Clock from \"./Clock.js\"\nimport * as Context from \"./Context.js\"\nimport * as DateTime from \"./DateTime.js\"\nimport type * as Deferred from \"./Deferred.js\"\nimport * as Duration from \"./Duration.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as Equal from \"./Equal.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport type * as FiberId from \"./FiberId.js\"\nimport * as FiberStatus from \"./FiberStatus.js\"\nimport { constVoid, dual, identity, pipe } from \"./Function.js\"\nimport * as HashMap from \"./HashMap.js\"\nimport * as clock from \"./internal/clock.js\"\nimport * as effect from \"./internal/core-effect.js\"\nimport * as core from \"./internal/core.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as circular from \"./internal/effect/circular.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as layer from \"./internal/layer.js\"\nimport * as ref from \"./internal/ref.js\"\nimport * as synchronized from \"./internal/synchronizedRef.js\"\nimport * as SuspendedWarningData from \"./internal/testing/suspendedWarningData.js\"\nimport * as WarningData from \"./internal/testing/warningData.js\"\nimport type * as Layer from \"./Layer.js\"\nimport * as number from \"./Number.js\"\nimport * as Option from \"./Option.js\"\nimport * as Order from \"./Order.js\"\nimport type * as Ref from \"./Ref.js\"\nimport type * as SortedSet from \"./SortedSet.js\"\nimport type * as Synchronized from \"./SynchronizedRef.js\"\nimport * as Annotations from \"./TestAnnotations.js\"\nimport * as Live from \"./TestLive.js\"\n\n/**\n * A `TestClock` makes it easy to deterministically and efficiently test effects\n * involving the passage of time.\n *\n * Instead of waiting for actual time to pass, `sleep` and methods implemented\n * in terms of it schedule effects to take place at a given clock time. Users\n * can adjust the clock time using the `adjust` and `setTime` methods, and all\n * effects scheduled to take place on or before that time will automatically be\n * run in order.\n *\n * For example, here is how we can test `Effect.timeout` using `TestClock`:\n *\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Duration, Effect, Fiber, TestClock, Option, pipe } from \"effect\"\n *\n * Effect.gen(function*() {\n *   const fiber = yield* pipe(\n *     Effect.sleep(Duration.minutes(5)),\n *     Effect.timeout(Duration.minutes(1)),\n *     Effect.fork\n *   )\n *   yield* TestClock.adjust(Duration.minutes(1))\n *   const result = yield* Fiber.join(fiber)\n *   assert.deepStrictEqual(result, Option.none())\n * })\n * ```\n *\n * Note how we forked the fiber that `sleep` was invoked on. Calls to `sleep`\n * and methods derived from it will semantically block until the time is set to\n * on or after the time they are scheduled to run. If we didn't fork the fiber\n * on which we called sleep we would never get to set the time on the line\n * below. Thus, a useful pattern when using `TestClock` is to fork the effect\n * being tested, then adjust the clock time, and finally verify that the\n * expected effects have been performed.\n *\n * @since 2.0.0\n */\nexport interface TestClock extends Clock.Clock {\n  adjust(duration: Duration.DurationInput): Effect.Effect<void>\n  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  readonly save: Effect.Effect<Effect.Effect<void>>\n  setTime(time: number): Effect.Effect<void>\n  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>\n}\n\n/**\n * `Data` represents the state of the `TestClock`, including the clock time.\n *\n * @since 2.0.1\n */\nexport interface Data {\n  readonly instant: number\n  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>\n}\n\n/**\n * @since 2.0.0\n */\nexport const makeData = (\n  instant: number,\n  sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>\n): Data => ({\n  instant,\n  sleeps\n})\n\n/**\n * @since 2.0.0\n */\nexport const TestClock: Context.Tag<TestClock, TestClock> = Context.GenericTag<TestClock>(\"effect/TestClock\")\n\n/**\n * The warning message that will be displayed if a test is using time but is\n * not advancing the `TestClock`.\n *\n * @internal\n */\nconst warning = \"Warning: A test is using time, but is not advancing \" +\n  \"the test clock, which may result in the test hanging. Use TestClock.adjust to \" +\n  \"manually advance the time.\"\n\n/**\n * The warning message that will be displayed if a test is advancing the clock\n * but a fiber is still running.\n *\n * @internal\n */\nconst suspendedWarning = \"Warning: A test is advancing the test clock, \" +\n  \"but a fiber is not suspending, which may result in the test hanging. Use \" +\n  \"TestAspect.diagnose to identity the fiber that is not suspending.\"\n\n/** @internal */\nexport class TestClockImpl implements TestClock {\n  [clock.ClockTypeId]: Clock.ClockTypeId = clock.ClockTypeId\n  constructor(\n    readonly clockState: Ref.Ref<Data>,\n    readonly live: Live.TestLive,\n    readonly annotations: Annotations.TestAnnotations,\n    readonly warningState: Synchronized.SynchronizedRef<WarningData.WarningData>,\n    readonly suspendedWarningState: Synchronized.SynchronizedRef<SuspendedWarningData.SuspendedWarningData>\n  ) {\n    this.currentTimeMillis = core.map(\n      ref.get(this.clockState),\n      (data) => data.instant\n    )\n    this.currentTimeNanos = core.map(\n      ref.get(this.clockState),\n      (data) => BigInt(data.instant * 1000000)\n    )\n  }\n\n  /**\n   * Unsafely returns the current time in milliseconds.\n   */\n  unsafeCurrentTimeMillis(): number {\n    return ref.unsafeGet(this.clockState).instant\n  }\n\n  /**\n   * Unsafely returns the current time in nanoseconds.\n   */\n  unsafeCurrentTimeNanos(): bigint {\n    return BigInt(ref.unsafeGet(this.clockState).instant * 1000000)\n  }\n\n  /**\n   * Returns the current clock time in milliseconds.\n   */\n  currentTimeMillis: Effect.Effect<number>\n\n  /**\n   * Returns the current clock time in nanoseconds.\n   */\n  currentTimeNanos: Effect.Effect<bigint>\n\n  /**\n   * Saves the `TestClock`'s current state in an effect which, when run, will\n   * restore the `TestClock` state to the saved state.\n   */\n  get save(): Effect.Effect<Effect.Effect<void>> {\n    return core.map(ref.get(this.clockState), (data) => ref.set(this.clockState, data))\n  }\n  /**\n   * Sets the current clock time to the specified instant. Any effects that\n   * were scheduled to occur on or before the new time will be run in order.\n   */\n  setTime(instant: number): Effect.Effect<void> {\n    return core.zipRight(this.warningDone(), this.run(() => instant))\n  }\n  /**\n   * Semantically blocks the current fiber until the clock time is equal to or\n   * greater than the specified duration. Once the clock time is adjusted to\n   * on or after the duration, the fiber will automatically be resumed.\n   */\n  sleep(durationInput: Duration.DurationInput): Effect.Effect<void> {\n    const duration = Duration.decode(durationInput)\n    return core.flatMap(core.deferredMake<void>(), (deferred) =>\n      pipe(\n        ref.modify(this.clockState, (data) => {\n          const end = data.instant + Duration.toMillis(duration)\n          if (end > data.instant) {\n            return [\n              true,\n              makeData(data.instant, pipe(data.sleeps, Chunk.prepend([end, deferred] as const)))\n            ] as const\n          }\n          return [false, data] as const\n        }),\n        core.flatMap((shouldAwait) =>\n          shouldAwait ?\n            pipe(this.warningStart(), core.zipRight(core.deferredAwait(deferred))) :\n            pipe(core.deferredSucceed(deferred, void 0), core.asVoid)\n        )\n      ))\n  }\n  /**\n   * Returns a list of the times at which all queued effects are scheduled to\n   * resume.\n   */\n  get sleeps(): Effect.Effect<Chunk.Chunk<number>> {\n    return core.map(\n      ref.get(this.clockState),\n      (data) => Chunk.map(data.sleeps, (_) => _[0])\n    )\n  }\n  /**\n   * Increments the current clock time by the specified duration. Any effects\n   * that were scheduled to occur on or before the new time will be run in\n   * order.\n   */\n  adjust(durationInput: Duration.DurationInput): Effect.Effect<void> {\n    const duration = Duration.decode(durationInput)\n    return core.zipRight(this.warningDone(), this.run((n) => n + Duration.toMillis(duration)))\n  }\n  /**\n   * Increments the current clock time by the specified duration. Any effects\n   * that were scheduled to occur on or before the new time will be run in\n   * order.\n   */\n  adjustWith(durationInput: Duration.DurationInput) {\n    const duration = Duration.decode(durationInput)\n    return <A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n      fiberRuntime.zipLeftOptions(effect, this.adjust(duration), { concurrent: true })\n  }\n  /**\n   * Returns a set of all fibers in this test.\n   */\n  supervisedFibers(): Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>> {\n    return this.annotations.supervisedFibers\n  }\n  /**\n   * Captures a \"snapshot\" of the identifier and status of all fibers in this\n   * test other than the current fiber. Fails with the `void` value if any of\n   * these fibers are not done or suspended. Note that because we cannot\n   * synchronize on the status of multiple fibers at the same time this\n   * snapshot may not be fully consistent.\n   */\n  freeze(): Effect.Effect<HashMap.HashMap<FiberId.FiberId, FiberStatus.FiberStatus>, void> {\n    return core.flatMap(this.supervisedFibers(), (fibers) =>\n      pipe(\n        fibers,\n        effect.reduce(HashMap.empty<FiberId.FiberId, FiberStatus.FiberStatus>(), (map, fiber) =>\n          pipe(\n            fiber.status,\n            core.flatMap((status) => {\n              if (FiberStatus.isDone(status)) {\n                return core.succeed(HashMap.set(map, fiber.id() as FiberId.FiberId, status as FiberStatus.FiberStatus))\n              }\n              if (FiberStatus.isSuspended(status)) {\n                return core.succeed(HashMap.set(map, fiber.id() as FiberId.FiberId, status as FiberStatus.FiberStatus))\n              }\n              return core.fail(void 0)\n            })\n          ))\n      ))\n  }\n  /**\n   * Forks a fiber that will display a warning message if a test is using time\n   * but is not advancing the `TestClock`.\n   */\n  warningStart(): Effect.Effect<void> {\n    return synchronized.updateSomeEffect(this.warningState, (data) =>\n      WarningData.isStart(data) ?\n        Option.some(\n          pipe(\n            this.live.provide(\n              pipe(effect.logWarning(warning), effect.delay(Duration.seconds(5)))\n            ),\n            core.interruptible,\n            fiberRuntime.fork,\n            core.map((fiber) => WarningData.pending(fiber))\n          )\n        ) :\n        Option.none())\n  }\n  /**\n   * Cancels the warning message that is displayed if a test is using time but\n   * is not advancing the `TestClock`.\n   */\n  warningDone(): Effect.Effect<void> {\n    return synchronized.updateSomeEffect(this.warningState, (warningData) => {\n      if (WarningData.isStart(warningData)) {\n        return Option.some(core.succeed(WarningData.done))\n      }\n      if (WarningData.isPending(warningData)) {\n        return Option.some(pipe(core.interruptFiber(warningData.fiber), core.as(WarningData.done)))\n      }\n      return Option.none()\n    })\n  }\n\n  private yieldTimer = core.async<void>((resume) => {\n    const timer = setTimeout(() => {\n      resume(core.void)\n    }, 0)\n    return core.sync(() => clearTimeout(timer))\n  })\n\n  /**\n   * Returns whether all descendants of this fiber are done or suspended.\n   */\n  suspended(): Effect.Effect<HashMap.HashMap<FiberId.FiberId, FiberStatus.FiberStatus>, void> {\n    return pipe(\n      this.freeze(),\n      core.zip(pipe(this.yieldTimer, core.zipRight(this.freeze()))),\n      core.flatMap(([first, last]) =>\n        Equal.equals(first, last) ?\n          core.succeed(first) :\n          core.fail(void 0)\n      )\n    )\n  }\n  /**\n   * Polls until all descendants of this fiber are done or suspended.\n   */\n  awaitSuspended(): Effect.Effect<void> {\n    return pipe(\n      this.suspendedWarningStart(),\n      core.zipRight(\n        pipe(\n          this.suspended(),\n          core.zipWith(\n            pipe(this.yieldTimer, core.zipRight(this.suspended())),\n            Equal.equals\n          ),\n          effect.filterOrFail(identity, constVoid),\n          effect.eventually\n        )\n      ),\n      core.zipRight(this.suspendedWarningDone())\n    )\n  }\n  /**\n   * Forks a fiber that will display a warning message if a test is advancing\n   * the `TestClock` but a fiber is not suspending.\n   */\n  suspendedWarningStart(): Effect.Effect<void> {\n    return synchronized.updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {\n      if (SuspendedWarningData.isStart(suspendedWarningData)) {\n        return Option.some(\n          pipe(\n            this.live.provide(\n              pipe(\n                effect.logWarning(suspendedWarning),\n                core.zipRight(ref.set(this.suspendedWarningState, SuspendedWarningData.done)),\n                effect.delay(Duration.seconds(5))\n              )\n            ),\n            core.interruptible,\n            fiberRuntime.fork,\n            core.map((fiber) => SuspendedWarningData.pending(fiber))\n          )\n        )\n      }\n      return Option.none()\n    })\n  }\n  /**\n   * Cancels the warning message that is displayed if a test is advancing the\n   * `TestClock` but a fiber is not suspending.\n   */\n  suspendedWarningDone(): Effect.Effect<void> {\n    return synchronized.updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {\n      if (SuspendedWarningData.isPending(suspendedWarningData)) {\n        return Option.some(pipe(core.interruptFiber(suspendedWarningData.fiber), core.as(SuspendedWarningData.start)))\n      }\n      return Option.none()\n    })\n  }\n  /**\n   * Runs all effects scheduled to occur on or before the specified instant,\n   * which may depend on the current time, in order.\n   */\n  run(f: (instant: number) => number): Effect.Effect<void> {\n    return pipe(\n      this.awaitSuspended(),\n      core.zipRight(pipe(\n        ref.modify(this.clockState, (data) => {\n          const end = f(data.instant)\n          const sorted = pipe(\n            data.sleeps,\n            Chunk.sort<readonly [number, Deferred.Deferred<void>]>(\n              pipe(number.Order, Order.mapInput((_) => _[0]))\n            )\n          )\n          if (Chunk.isNonEmpty(sorted)) {\n            const [instant, deferred] = Chunk.headNonEmpty(sorted)\n            if (instant <= end) {\n              return [\n                Option.some([end, deferred] as const),\n                makeData(instant, Chunk.tailNonEmpty(sorted))\n              ] as const\n            }\n          }\n          return [Option.none(), makeData(end, data.sleeps)] as const\n        }),\n        core.flatMap((option) => {\n          switch (option._tag) {\n            case \"None\": {\n              return core.void\n            }\n            case \"Some\": {\n              const [end, deferred] = option.value\n              return pipe(\n                core.deferredSucceed(deferred, void 0),\n                core.zipRight(core.yieldNow()),\n                core.zipRight(this.run(() => end))\n              )\n            }\n          }\n        })\n      ))\n    )\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const live = (data: Data): Layer.Layer<TestClock, never, Annotations.TestAnnotations | Live.TestLive> =>\n  layer.scoped(\n    TestClock,\n    core.gen(function*($) {\n      const live = yield* $(Live.TestLive)\n      const annotations = yield* $(Annotations.TestAnnotations)\n      const clockState = yield* $(core.sync(() => ref.unsafeMake(data)))\n      const warningState = yield* $(circular.makeSynchronized(WarningData.start))\n      const suspendedWarningState = yield* $(circular.makeSynchronized(SuspendedWarningData.start))\n      const testClock = new TestClockImpl(clockState, live, annotations, warningState, suspendedWarningState)\n      yield* $(fiberRuntime.withClockScoped(testClock))\n      yield* $(fiberRuntime.addFinalizer(\n        () => core.zipRight(testClock.warningDone(), testClock.suspendedWarningDone())\n      ))\n      return testClock\n    })\n  )\n\n/**\n * @since 2.0.0\n */\nexport const defaultTestClock: Layer.Layer<TestClock, never, Annotations.TestAnnotations | Live.TestLive> = live(\n  makeData(new Date(0).getTime(), Chunk.empty())\n)\n\n/**\n * Accesses a `TestClock` instance in the context and increments the time\n * by the specified duration, running any actions scheduled for on or before\n * the new time in order.\n *\n * @since 2.0.0\n */\nexport const adjust = (durationInput: Duration.DurationInput): Effect.Effect<void> => {\n  const duration = Duration.decode(durationInput)\n  return testClockWith((testClock) => testClock.adjust(duration))\n}\n\n/**\n * @since 2.0.0\n */\nexport const adjustWith = dual<\n  /**\n   * @since 2.0.0\n   */\n  (duration: Duration.DurationInput) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, duration: Duration.DurationInput) => Effect.Effect<A, E, R>\n>(2, (effect, durationInput) => {\n  const duration = Duration.decode(durationInput)\n  return testClockWith((testClock) => testClock.adjustWith(duration)(effect))\n})\n\n/**\n * Accesses a `TestClock` instance in the context and saves the clock\n * state in an effect which, when run, will restore the `TestClock` to the\n * saved state.\n *\n * @since 2.0.0\n */\nexport const save = (): Effect.Effect<Effect.Effect<void>> => testClockWith((testClock) => testClock.save)\n\n/**\n * Accesses a `TestClock` instance in the context and sets the clock time\n * to the specified `Instant` or `Date`, running any actions scheduled for on or before\n * the new time in order.\n *\n * @since 2.0.0\n */\nexport const setTime = (input: DateTime.DateTime.Input): Effect.Effect<void> =>\n  testClockWith((testClock) =>\n    testClock.setTime(\n      typeof input === \"number\"\n        ? input\n        : DateTime.unsafeMake(input).epochMillis\n    )\n  )\n\n/**\n * Semantically blocks the current fiber until the clock time is equal to or\n * greater than the specified duration. Once the clock time is adjusted to\n * on or after the duration, the fiber will automatically be resumed.\n *\n * @since 2.0.0\n */\nexport const sleep = (durationInput: Duration.DurationInput): Effect.Effect<void> => {\n  const duration = Duration.decode(durationInput)\n  return testClockWith((testClock) => testClock.sleep(duration))\n}\n\n/**\n * Accesses a `TestClock` instance in the context and returns a list of\n * times that effects are scheduled to run.\n *\n * @since 2.0.0\n */\nexport const sleeps = (): Effect.Effect<Chunk.Chunk<number>> => testClockWith((testClock) => testClock.sleeps)\n\n/**\n * Retrieves the `TestClock` service for this test.\n *\n * @since 2.0.0\n */\nexport const testClock = (): Effect.Effect<TestClock> => testClockWith(core.succeed)\n\n/**\n * Retrieves the `TestClock` service for this test and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n */\nexport const testClockWith = <A, E, R>(f: (testClock: TestClock) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.fiberRefGetWith(\n    defaultServices.currentServices,\n    (services) => f(pipe(services, Context.get(clock.clockTag)) as TestClock)\n  )\n\n/**\n * Accesses the current time of a `TestClock` instance in the context in\n * milliseconds.\n *\n * @since 2.0.0\n */\nexport const currentTimeMillis: Effect.Effect<number> = testClockWith((testClock) => testClock.currentTimeMillis)\n", "import type * as Fiber from \"../../Fiber.js\"\n\n/** @internal */\nexport type SuspendedWarningData = Start | Pending | Done\n\n/** @internal */\nexport const OP_SUSPENDED_WARNING_DATA_START = \"Start\" as const\n\n/** @internal */\nexport type OP_SUSPENDED_WARNING_DATA_START = typeof OP_SUSPENDED_WARNING_DATA_START\n\n/** @internal */\nexport const OP_SUSPENDED_WARNING_DATA_PENDING = \"Pending\" as const\n\n/** @internal */\nexport type OP_SUSPENDED_WARNING_DATA_PENDING = typeof OP_SUSPENDED_WARNING_DATA_PENDING\n\n/** @internal */\nexport const OP_SUSPENDED_WARNING_DATA_DONE = \"Done\" as const\n\n/** @internal */\nexport type OP_SUSPENDED_WARNING_DATA_DONE = typeof OP_SUSPENDED_WARNING_DATA_DONE\n\n/** @internal */\nexport interface Start {\n  readonly _tag: OP_SUSPENDED_WARNING_DATA_START\n}\n\n/** @internal */\nexport interface Pending {\n  readonly _tag: OP_SUSPENDED_WARNING_DATA_PENDING\n  readonly fiber: Fiber.Fiber<void, Error>\n}\n\n/** @internal */\nexport interface Done {\n  readonly _tag: OP_SUSPENDED_WARNING_DATA_DONE\n}\n\n/**\n * State indicating that a test has not adjusted the clock.\n *\n * @internal\n */\nexport const start: SuspendedWarningData = {\n  _tag: OP_SUSPENDED_WARNING_DATA_START\n}\n\n/**\n * State indicating that a test has adjusted the clock but a fiber is still\n * running with a reference to the fiber that will display the warning\n * message.\n *\n * @internal\n */\nexport const pending = (fiber: Fiber.Fiber<void, Error>): SuspendedWarningData => {\n  return {\n    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,\n    fiber\n  }\n}\n\n/**\n * State indicating that the warning message has already been displayed.\n *\n * @internal\n */\nexport const done: SuspendedWarningData = {\n  _tag: OP_SUSPENDED_WARNING_DATA_DONE\n}\n\n/** @internal */\nexport const isStart = (self: SuspendedWarningData): self is Start => {\n  return self._tag === OP_SUSPENDED_WARNING_DATA_START\n}\n\n/** @internal */\nexport const isPending = (self: SuspendedWarningData): self is Pending => {\n  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING\n}\n\n/** @internal */\nexport const isDone = (self: SuspendedWarningData): self is Done => {\n  return self._tag === OP_SUSPENDED_WARNING_DATA_DONE\n}\n", "import type * as Fiber from \"../../Fiber.js\"\n\n/**\n * `WarningData` describes the state of the warning message that is displayed\n * if a test is using time by is not advancing the `TestClock`. The possible\n * states are `Start` if a test has not used time, `Pending` if a test has\n * used time but has not adjusted the `TestClock`, and `Done` if a test has\n * adjusted the `TestClock` or the warning message has already been displayed.\n *\n * @internal\n */\nexport type WarningData = Start | Pending | Done\n\n/** @internal */\nexport const OP_WARNING_DATA_START = \"Start\" as const\n\n/** @internal */\nexport type OP_WARNING_DATA_START = typeof OP_WARNING_DATA_START\n\n/** @internal */\nexport const OP_WARNING_DATA_PENDING = \"Pending\" as const\n\n/** @internal */\nexport type OP_WARNING_DATA_PENDING = typeof OP_WARNING_DATA_PENDING\n\n/** @internal */\nexport const OP_WARNING_DATA_DONE = \"Done\" as const\n\n/** @internal */\nexport type OP_WARNING_DATA_DONE = typeof OP_WARNING_DATA_DONE\n\n/** @internal */\nexport interface Start {\n  readonly _tag: OP_WARNING_DATA_START\n}\n\n/** @internal */\nexport interface Pending {\n  readonly _tag: OP_WARNING_DATA_PENDING\n  readonly fiber: Fiber.Fiber<void, Error>\n}\n\n/** @internal */\nexport interface Done {\n  readonly _tag: OP_WARNING_DATA_DONE\n}\n\n/**\n * State indicating that a test has not used time.\n *\n * @internal\n */\nexport const start: WarningData = {\n  _tag: OP_WARNING_DATA_START\n}\n\n/**\n * State indicating that a test has used time but has not adjusted the\n * `TestClock` with a reference to the fiber that will display the warning\n * message.\n *\n * @internal\n */\nexport const pending = (fiber: Fiber.Fiber<void, Error>): WarningData => {\n  return {\n    _tag: OP_WARNING_DATA_PENDING,\n    fiber\n  }\n}\n\n/**\n * State indicating that a test has used time or the warning message has\n * already been displayed.\n *\n * @internal\n */\nexport const done: WarningData = {\n  _tag: OP_WARNING_DATA_DONE\n}\n\n/** @internal */\nexport const isStart = (self: WarningData): self is Start => {\n  return self._tag === OP_WARNING_DATA_START\n}\n\n/** @internal */\nexport const isPending = (self: WarningData): self is Pending => {\n  return self._tag === OP_WARNING_DATA_PENDING\n}\n\n/** @internal */\nexport const isDone = (self: WarningData): self is Done => {\n  return self._tag === OP_WARNING_DATA_DONE\n}\n", "/**\n * @since 2.0.0\n */\nimport * as Context from \"./Context.js\"\nimport type * as DefaultServices from \"./DefaultServices.js\"\nimport type * as Effect from \"./Effect.js\"\nimport * as core from \"./internal/core.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\n\n/**\n * @since 2.0.0\n */\nexport const TestLiveTypeId: unique symbol = Symbol.for(\"effect/TestLive\")\n\n/**\n * @since 2.0.0\n */\nexport type TestLiveTypeId = typeof TestLiveTypeId\n\n/**\n * The `Live` trait provides access to the \"live\" default Effect services from\n * within tests for workflows such as printing test results to the console or\n * timing out tests where it is necessary to access the real implementations of\n * these services.\n *\n * @since 2.0.0\n */\nexport interface TestLive {\n  readonly [TestLiveTypeId]: TestLiveTypeId\n  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport const TestLive: Context.Tag<TestLive, TestLive> = Context.GenericTag<TestLive>(\"effect/TestLive\")\n\n/** @internal */\nclass LiveImpl implements TestLive {\n  readonly [TestLiveTypeId]: TestLiveTypeId = TestLiveTypeId\n  constructor(readonly services: Context.Context<DefaultServices.DefaultServices>) {}\n  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> {\n    return core.fiberRefLocallyWith(\n      defaultServices.currentServices,\n      Context.merge(this.services)\n    )(effect)\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const make = (services: Context.Context<DefaultServices.DefaultServices>): TestLive => new LiveImpl(services)\n", "/**\n * @since 2.0.0\n */\nimport * as Context from \"./Context.js\"\n\n/**\n * The `TestConfig` service provides access to default configuration settings\n * used by tests, including the number of times to repeat tests to ensure\n * they are stable, the number of times to retry flaky tests, the sufficient\n * number of samples to check from a random variable, and the maximum number of\n * shrinkings to minimize large failures.\n *\n * @since 2.0.0\n */\nexport interface TestConfig {\n  /**\n   * The number of times to repeat tests to ensure they are stable.\n   */\n  readonly repeats: number\n  /**\n   * The number of times to retry flaky tests.\n   */\n  readonly retries: number\n  /**\n   * The number of sufficient samples to check for a random variable.\n   */\n  readonly samples: number\n  /**\n   * The maximum number of shrinkings to minimize large failures\n   */\n  readonly shrinks: number\n}\n\n/**\n * @since 2.0.0\n */\nexport const TestConfig: Context.Tag<TestConfig, TestConfig> = Context.GenericTag<TestConfig>(\"effect/TestConfig\")\n\n/**\n * @since 2.0.0\n */\nexport const make = (params: {\n  readonly repeats: number\n  readonly retries: number\n  readonly samples: number\n  readonly shrinks: number\n}): TestConfig => params\n", "/**\n * @since 2.0.0\n */\nimport type * as DefaultServices from \"./DefaultServices.js\"\nimport { pipe } from \"./Function.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as layer from \"./internal/layer.js\"\nimport type * as Layer from \"./Layer.js\"\nimport * as TestClock from \"./TestClock.js\"\nimport * as TestServices from \"./TestServices.js\"\n\n/** @internal */\nexport const live: Layer.Layer<TestServices.TestServices, never, DefaultServices.DefaultServices> = pipe(\n  TestServices.annotationsLayer(),\n  layer.merge(TestServices.liveLayer()),\n  layer.merge(TestServices.sizedLayer(100)),\n  layer.merge(pipe(\n    TestClock.defaultTestClock,\n    layer.provideMerge(\n      layer.merge(TestServices.liveLayer(), TestServices.annotationsLayer())\n    )\n  )),\n  layer.merge(TestServices.testConfigLayer({ repeats: 100, retries: 100, samples: 200, shrinks: 1000 }))\n)\n\n/**\n * @since 2.0.0\n */\nexport const LiveContext: Layer.Layer<DefaultServices.DefaultServices> = layer.syncContext(() =>\n  defaultServices.liveServices\n)\n\n/**\n * @since 2.0.0\n */\nexport const TestContext: Layer.Layer<TestServices.TestServices> = layer.provideMerge(live, LiveContext)\n", "/**\n * @since 2.0.0\n */\nimport * as Context from \"./Context.js\"\nimport type * as DefaultServices from \"./DefaultServices.js\"\nimport * as Effect from \"./Effect.js\"\nimport type * as Fiber from \"./Fiber.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport { dual, pipe } from \"./Function.js\"\nimport * as core from \"./internal/core.js\"\nimport * as defaultServices from \"./internal/defaultServices.js\"\nimport * as fiberRuntime from \"./internal/fiberRuntime.js\"\nimport * as layer from \"./internal/layer.js\"\nimport * as ref from \"./internal/ref.js\"\nimport type * as Layer from \"./Layer.js\"\nimport type * as Scope from \"./Scope.js\"\nimport type * as SortedSet from \"./SortedSet.js\"\nimport type * as TestAnnotation from \"./TestAnnotation.js\"\nimport * as TestAnnotationMap from \"./TestAnnotationMap.js\"\nimport * as Annotations from \"./TestAnnotations.js\"\nimport * as TestConfig from \"./TestConfig.js\"\nimport * as Live from \"./TestLive.js\"\nimport * as Sized from \"./TestSized.js\"\n\n/**\n * @since 2.0.0\n */\nexport type TestServices =\n  | Annotations.TestAnnotations\n  | Live.TestLive\n  | Sized.TestSized\n  | TestConfig.TestConfig\n\n/**\n * The default Effect test services.\n *\n * @since 2.0.0\n */\nexport const liveServices: Context.Context<TestServices> = pipe(\n  Context.make(Annotations.TestAnnotations, Annotations.make(ref.unsafeMake(TestAnnotationMap.empty()))),\n  Context.add(Live.TestLive, Live.make(defaultServices.liveServices)),\n  Context.add(Sized.TestSized, Sized.make(100)),\n  Context.add(TestConfig.TestConfig, TestConfig.make({ repeats: 100, retries: 100, samples: 200, shrinks: 1000 }))\n)\n\n/**\n * @since 2.0.0\n */\nexport const currentServices: FiberRef.FiberRef<Context.Context<TestServices>> = core.fiberRefUnsafeMakeContext(\n  liveServices\n)\n\n/**\n * Retrieves the `Annotations` service for this test.\n *\n * @since 2.0.0\n */\nexport const annotations = (): Effect.Effect<Annotations.TestAnnotations> => annotationsWith(core.succeed)\n\n/**\n * Retrieves the `Annotations` service for this test and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n */\nexport const annotationsWith = <A, E, R>(\n  f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  core.fiberRefGetWith(\n    currentServices,\n    (services) => f(Context.get(services, Annotations.TestAnnotations))\n  )\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * annotations service.\n *\n * @since 2.0.0\n */\nexport const withAnnotations = dual<\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * annotations service.\n   *\n   * @since 2.0.0\n   */\n  (annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * annotations service.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>\n>(2, (effect, annotations) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(Annotations.TestAnnotations, annotations)\n  )(effect))\n\n/**\n * Sets the implementation of the annotations service to the specified value\n * and restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n */\nexport const withAnnotationsScoped = (\n  annotations: Annotations.TestAnnotations\n): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRuntime.fiberRefLocallyScopedWith(\n    currentServices,\n    Context.add(Annotations.TestAnnotations, annotations)\n  )\n\n/**\n * Constructs a new `Annotations` service wrapped in a layer.\n *\n * @since 2.0.0\n */\nexport const annotationsLayer = (): Layer.Layer<Annotations.TestAnnotations> =>\n  layer.scoped(\n    Annotations.TestAnnotations,\n    pipe(\n      core.sync(() => ref.unsafeMake(TestAnnotationMap.empty())),\n      core.map(Annotations.make),\n      core.tap(withAnnotationsScoped)\n    )\n  )\n\n/**\n * Accesses an `Annotations` instance in the context and retrieves the\n * annotation of the specified type, or its default value if there is none.\n *\n * @since 2.0.0\n */\nexport const get = <A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A> =>\n  annotationsWith((annotations) => annotations.get(key))\n\n/**\n * Accesses an `Annotations` instance in the context and appends the\n * specified annotation to the annotation map.\n *\n * @since 2.0.0\n */\nexport const annotate = <A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void> =>\n  annotationsWith((annotations) => annotations.annotate(key, value))\n\n/**\n * Returns the set of all fibers in this test.\n *\n * @since 2.0.0\n */\nexport const supervisedFibers = (): Effect.Effect<\n  SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>\n> => annotationsWith((annotations) => annotations.supervisedFibers)\n\n/**\n * Retrieves the `Live` service for this test and uses it to run the specified\n * workflow.\n *\n * @since 2.0.0\n */\nexport const liveWith = <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.fiberRefGetWith(currentServices, (services) => f(Context.get(services, Live.TestLive)))\n\n/**\n * Retrieves the `Live` service for this test.\n *\n * @since 2.0.0\n */\nexport const live: Effect.Effect<Live.TestLive> = liveWith(core.succeed)\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * live service.\n *\n * @since 2.0.0\n */\nexport const withLive = dual<\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * live service.\n   *\n   * @since 2.0.0\n   */\n  (live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * live service.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>\n>(2, (effect, live) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(Live.TestLive, live)\n  )(effect))\n\n/**\n * Sets the implementation of the live service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n */\nexport const withLiveScoped = (live: Live.TestLive): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Live.TestLive, live))\n\n/**\n * Constructs a new `Live` service wrapped in a layer.\n *\n * @since 2.0.0\n */\nexport const liveLayer = (): Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices> =>\n  layer.scoped(\n    Live.TestLive,\n    pipe(\n      core.context<DefaultServices.DefaultServices>(),\n      core.map(Live.make),\n      core.tap(withLiveScoped)\n    )\n  )\n\n/**\n * Provides a workflow with the \"live\" default Effect services.\n *\n * @since 2.0.0\n */\nexport const provideLive = <A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  liveWith((live) => live.provide(effect))\n\n/**\n * Runs a transformation function with the live default Effect services while\n * ensuring that the workflow itself is run with the test services.\n *\n * @since 2.0.0\n */\nexport const provideWithLive = dual<\n  /**\n   * Runs a transformation function with the live default Effect services while\n   * ensuring that the workflow itself is run with the test services.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>,\n  /**\n   * Runs a transformation function with the live default Effect services while\n   * ensuring that the workflow itself is run with the test services.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R, A2, E2, R2>(\n    self: Effect.Effect<A, E, R>,\n    f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>\n  ) => Effect.Effect<A2, E | E2, R | R2>\n>(2, (self, f) =>\n  core.fiberRefGetWith(\n    defaultServices.currentServices,\n    (services) => provideLive(f(core.fiberRefLocally(defaultServices.currentServices, services)(self)))\n  ))\n\n/**\n * Retrieves the `Sized` service for this test and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n */\nexport const sizedWith = <A, E, R>(f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n  core.fiberRefGetWith(\n    currentServices,\n    (services) => f(Context.get(services, Sized.TestSized))\n  )\n\n/**\n * Retrieves the `Sized` service for this test.\n *\n * @since 2.0.0\n */\nexport const sized: Effect.Effect<Sized.TestSized> = sizedWith(core.succeed)\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * sized service.\n *\n * @since 2.0.0\n */\nexport const withSized = dual<\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * sized service.\n   *\n   * @since 2.0.0\n   */\n  (sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * sized service.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>\n>(2, (effect, sized) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(Sized.TestSized, sized)\n  )(effect))\n\n/**\n * Sets the implementation of the sized service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n */\nexport const withSizedScoped = (sized: Sized.TestSized): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(Sized.TestSized, sized))\n\n/**\n * @since 2.0.0\n */\nexport const sizedLayer = (size: number): Layer.Layer<Sized.TestSized> =>\n  layer.scoped(\n    Sized.TestSized,\n    pipe(\n      fiberRuntime.fiberRefMake(size),\n      core.map(Sized.fromFiberRef),\n      core.tap(withSizedScoped)\n    )\n  )\n\n/**\n * @since 2.0.0\n */\nexport const size: Effect.Effect<number> = sizedWith((sized) => sized.size)\n\n/**\n * @since 2.0.0\n */\nexport const withSize = dual<\n  /**\n   * @since 2.0.0\n   */\n  (size: number) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, size: number) => Effect.Effect<A, E, R>\n>(2, (effect, size) => sizedWith((sized) => sized.withSize(size)(effect)))\n\n/**\n * Retrieves the `TestConfig` service for this test and uses it to run the\n * specified workflow.\n *\n * @since 2.0.0\n */\nexport const testConfigWith = <A, E, R>(\n  f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>\n): Effect.Effect<A, E, R> =>\n  core.fiberRefGetWith(\n    currentServices,\n    (services) => f(Context.get(services, TestConfig.TestConfig))\n  )\n\n/**\n * Retrieves the `TestConfig` service for this test.\n *\n * @since 2.0.0\n */\nexport const testConfig: Effect.Effect<TestConfig.TestConfig> = testConfigWith(core.succeed)\n\n/**\n * Executes the specified workflow with the specified implementation of the\n * config service.\n *\n * @since 2.0.0\n */\nexport const withTestConfig = dual<\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * config service.\n   *\n   * @since 2.0.0\n   */\n  (config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>,\n  /**\n   * Executes the specified workflow with the specified implementation of the\n   * config service.\n   *\n   * @since 2.0.0\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>\n>(2, (effect, config) =>\n  core.fiberRefLocallyWith(\n    currentServices,\n    Context.add(TestConfig.TestConfig, config)\n  )(effect))\n\n/**\n * Sets the implementation of the config service to the specified value and\n * restores it to its original value when the scope is closed.\n *\n * @since 2.0.0\n */\nexport const withTestConfigScoped = (config: TestConfig.TestConfig): Effect.Effect<void, never, Scope.Scope> =>\n  fiberRuntime.fiberRefLocallyScopedWith(currentServices, Context.add(TestConfig.TestConfig, config))\n\n/**\n * Constructs a new `TestConfig` service with the specified settings.\n *\n * @since 2.0.0\n */\nexport const testConfigLayer = (params: {\n  readonly repeats: number\n  readonly retries: number\n  readonly samples: number\n  readonly shrinks: number\n}): Layer.Layer<TestConfig.TestConfig> =>\n  layer.scoped(\n    TestConfig.TestConfig,\n    Effect.suspend(() => {\n      const testConfig = TestConfig.make(params)\n      return pipe(\n        withTestConfigScoped(testConfig),\n        core.as(testConfig)\n      )\n    })\n  )\n\n/**\n * The number of times to repeat tests to ensure they are stable.\n *\n * @since 2.0.0\n */\nexport const repeats: Effect.Effect<number> = testConfigWith((config) => core.succeed(config.repeats))\n\n/**\n * The number of times to retry flaky tests.\n *\n * @since 2.0.0\n */\nexport const retries: Effect.Effect<number> = testConfigWith((config) => core.succeed(config.retries))\n\n/**\n * The number of sufficient samples to check for a random variable.\n *\n * @since 2.0.0\n */\nexport const samples: Effect.Effect<number> = testConfigWith((config) => core.succeed(config.samples))\n\n/**\n * The maximum number of shrinkings to minimize large failures.\n *\n * @since 2.0.0\n */\nexport const shrinks: Effect.Effect<number> = testConfigWith((config) => core.succeed(config.shrinks))\n", "/**\n * @since 2.0.0\n */\nimport * as Context from \"./Context.js\"\nimport type * as Effect from \"./Effect.js\"\nimport type * as FiberRef from \"./FiberRef.js\"\nimport * as core from \"./internal/core.js\"\n\n/**\n * @since 2.0.0\n */\nexport const TestSizedTypeId: unique symbol = Symbol.for(\"effect/TestSized\")\n\n/**\n * @since 2.0.0\n */\nexport type TestSizedTypeId = typeof TestSizedTypeId\n\n/**\n * @since 2.0.0\n */\nexport interface TestSized {\n  readonly [TestSizedTypeId]: TestSizedTypeId\n  readonly fiberRef: FiberRef.FiberRef<number>\n  readonly size: Effect.Effect<number>\n  withSize(size: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n}\n\n/**\n * @since 2.0.0\n */\nexport const TestSized: Context.Tag<TestSized, TestSized> = Context.GenericTag(\"effect/TestSized\")\n\n/** @internal */\nclass SizedImpl implements TestSized {\n  readonly [TestSizedTypeId]: TestSizedTypeId = TestSizedTypeId\n  constructor(readonly fiberRef: FiberRef.FiberRef<number>) {}\n  get size(): Effect.Effect<number> {\n    return core.fiberRefGet(this.fiberRef)\n  }\n  withSize(size: number) {\n    return <A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R> =>\n      core.fiberRefLocally(this.fiberRef, size)(effect)\n  }\n}\n\n/**\n * @since 2.0.0\n */\nexport const make = (size: number): TestSized => new SizedImpl(core.fiberRefUnsafeMake(size))\n\n/**\n * @since 2.0.0\n */\nexport const fromFiberRef = (fiberRef: FiberRef.FiberRef<number>): TestSized => new SizedImpl(fiberRef)\n", "/**\n * A `Trie` is used for locating specific `string` keys from within a set.\n *\n * It works similar to `HashMap`, but with keys required to be `string`.\n * This constraint unlocks some performance optimizations and new methods to get string prefixes (e.g. `keysWithPrefix`, `longestPrefixOf`).\n *\n * Prefix search is also the main feature that makes a `Trie` more suited than `HashMap` for certain usecases.\n *\n * A `Trie` is often used to store a dictionary (list of words) that can be searched\n * in a manner that allows for efficient generation of completion lists\n * (e.g. predict the rest of a word a user is typing).\n *\n * A `Trie` has O(n) lookup time where `n` is the size of the key,\n * or even less than `n` on search misses.\n *\n * @since 2.0.0\n */\nimport type { Equal } from \"./Equal.js\"\nimport type { Inspectable } from \"./Inspectable.js\"\nimport * as TR from \"./internal/trie.js\"\nimport type { Option } from \"./Option.js\"\nimport type { Pipeable } from \"./Pipeable.js\"\nimport type { Covariant, NoInfer } from \"./Types.js\"\n\nconst TypeId: unique symbol = TR.TrieTypeId as TypeId\n\n/**\n * @since 2.0.0\n * @category symbol\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Trie<out Value> extends Iterable<[string, Value]>, Equal, Pipeable, Inspectable {\n  readonly [TypeId]: {\n    readonly _Value: Covariant<Value>\n  }\n}\n\n/**\n * Creates an empty `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.empty<string>()\n *\n * assert.equal(Trie.size(trie), 0)\n * assert.deepStrictEqual(Array.from(trie), [])\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const empty: <V = never>() => Trie<V> = TR.empty\n\n/**\n * Creates a new `Trie` from an iterable collection of key/value pairs (e.g. `Array<[string, V]>`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const iterable: Array<readonly [string, number]> = [[\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]]\n * const trie = Trie.fromIterable(iterable)\n *\n * // The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order\n * assert.deepStrictEqual(Array.from(trie), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n * assert.equal(Equal.equals(Trie.make([\"call\", 0], [\"me\", 1], [\"mind\", 2], [\"mid\", 3]), trie), true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V> = TR.fromIterable\n\n/**\n * Constructs a new `Trie` from the specified entries (`[string, V]`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.make([\"ca\", 0], [\"me\", 1])\n *\n * assert.deepStrictEqual(Array.from(trie), [[\"ca\", 0], [\"me\", 1]])\n * assert.equal(Equal.equals(Trie.fromIterable([[\"ca\", 0], [\"me\", 1]]), trie), true)\n * ```\n *\n * @since 2.0.0\n * @category constructors\n */\nexport const make: <Entries extends Array<readonly [string, any]>>(\n  ...entries: Entries\n) => Trie<Entries[number] extends readonly [any, infer V] ? V : never> = TR.make\n\n/**\n * Insert a new entry in the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie1 = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0)\n * )\n * const trie2 = trie1.pipe(Trie.insert(\"me\", 1))\n * const trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\n * const trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n *\n * assert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\n * assert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\n * assert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\n * assert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n * ```\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const insert: {\n  /**\n   * Insert a new entry in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie1 = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0)\n   * )\n   * const trie2 = trie1.pipe(Trie.insert(\"me\", 1))\n   * const trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\n   * const trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n   *\n   * assert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\n   * assert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\n   * assert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\n   * assert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>\n  /**\n   * Insert a new entry in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie1 = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0)\n   * )\n   * const trie2 = trie1.pipe(Trie.insert(\"me\", 1))\n   * const trie3 = trie2.pipe(Trie.insert(\"mind\", 2))\n   * const trie4 = trie3.pipe(Trie.insert(\"mid\", 3))\n   *\n   * assert.deepStrictEqual(Array.from(trie1), [[\"call\", 0]])\n   * assert.deepStrictEqual(Array.from(trie2), [[\"call\", 0], [\"me\", 1]])\n   * assert.deepStrictEqual(Array.from(trie3), [[\"call\", 0], [\"me\", 1], [\"mind\", 2]])\n   * assert.deepStrictEqual(Array.from(trie4), [[\"call\", 0], [\"me\", 1], [\"mid\", 3], [\"mind\", 2]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>\n} = TR.insert\n\n/**\n * Returns an `IterableIterator` of the keys within the `Trie`.\n *\n * The keys are returned in alphabetical order, regardless of insertion order.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"cab\", 0),\n *   Trie.insert(\"abc\", 1),\n *   Trie.insert(\"bca\", 2)\n * )\n *\n * const result = Array.from(Trie.keys(trie))\n * assert.deepStrictEqual(result, [\"abc\", \"bca\", \"cab\"])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keys: <V>(self: Trie<V>) => IterableIterator<string> = TR.keys\n\n/**\n * Returns an `IterableIterator` of the values within the `Trie`.\n *\n * Values are ordered based on their key in alphabetical order, regardless of insertion order.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1),\n *   Trie.insert(\"and\", 2)\n * )\n *\n * const result = Array.from(Trie.values(trie))\n * assert.deepStrictEqual(result, [2, 0, 1])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const values: <V>(self: Trie<V>) => IterableIterator<V> = TR.values\n\n/**\n * Returns an `IterableIterator` of the entries within the `Trie`.\n *\n * The entries are returned by keys in alphabetical order, regardless of insertion order.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1)\n * )\n *\n * const result = Array.from(Trie.entries(trie))\n * assert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]> = TR.entries\n\n/**\n * Returns an `Array<[K, V]>` of the entries within the `Trie`.\n *\n * Equivalent to `Array.from(Trie.entries(trie))`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1)\n * )\n * const result = Trie.toEntries(trie)\n *\n * assert.deepStrictEqual(result, [[\"call\", 0], [\"me\", 1]])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toEntries = <V>(self: Trie<V>): Array<[string, V]> => Array.from(entries(self))\n\n/**\n * Returns an `IterableIterator` of the keys within the `Trie`\n * that have `prefix` as prefix (`prefix` included if it exists).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"she\", 0),\n *   Trie.insert(\"shells\", 1),\n *   Trie.insert(\"sea\", 2),\n *   Trie.insert(\"shore\", 3)\n * )\n *\n * const result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\n * assert.deepStrictEqual(result, [\"she\", \"shells\"])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const keysWithPrefix: {\n  /**\n   * Returns an `IterableIterator` of the keys within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\n   * assert.deepStrictEqual(result, [\"she\", \"shells\"])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>\n  /**\n   * Returns an `IterableIterator` of the keys within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.keysWithPrefix(trie, \"she\"))\n   * assert.deepStrictEqual(result, [\"she\", \"shells\"])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <V>(self: Trie<V>, prefix: string): IterableIterator<string>\n} = TR.keysWithPrefix\n\n/**\n * Returns an `IterableIterator` of the values within the `Trie`\n * that have `prefix` as prefix (`prefix` included if it exists).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"she\", 0),\n *   Trie.insert(\"shells\", 1),\n *   Trie.insert(\"sea\", 2),\n *   Trie.insert(\"shore\", 3)\n * )\n *\n * const result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n *\n * // 0: \"she\", 1: \"shells\"\n * assert.deepStrictEqual(result, [0, 1])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const valuesWithPrefix: {\n  /**\n   * Returns an `IterableIterator` of the values within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n   *\n   * // 0: \"she\", 1: \"shells\"\n   * assert.deepStrictEqual(result, [0, 1])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>\n  /**\n   * Returns an `IterableIterator` of the values within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.valuesWithPrefix(trie, \"she\"))\n   *\n   * // 0: \"she\", 1: \"shells\"\n   * assert.deepStrictEqual(result, [0, 1])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <V>(self: Trie<V>, prefix: string): IterableIterator<V>\n} = TR.valuesWithPrefix\n\n/**\n * Returns an `IterableIterator` of the entries within the `Trie`\n * that have `prefix` as prefix (`prefix` included if it exists).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"she\", 0),\n *   Trie.insert(\"shells\", 1),\n *   Trie.insert(\"sea\", 2),\n *   Trie.insert(\"shore\", 3)\n * )\n *\n * const result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\n * assert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const entriesWithPrefix: {\n  /**\n   * Returns an `IterableIterator` of the entries within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\n   * assert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>\n  /**\n   * Returns an `IterableIterator` of the entries within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 0),\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"shore\", 3)\n   * )\n   *\n   * const result = Array.from(Trie.entriesWithPrefix(trie, \"she\"))\n   * assert.deepStrictEqual(result, [[\"she\", 0], [\"shells\", 1]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>\n} = TR.entriesWithPrefix\n\n/**\n * Returns `Array<[K, V]>` of the entries within the `Trie`\n * that have `prefix` as prefix (`prefix` included if it exists).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"sea\", 2),\n *   Trie.insert(\"she\", 3)\n * )\n *\n * const result = Trie.toEntriesWithPrefix(trie, \"she\")\n * assert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const toEntriesWithPrefix: {\n  /**\n   * Returns `Array<[K, V]>` of the entries within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * const result = Trie.toEntriesWithPrefix(trie, \"she\")\n   * assert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>\n  /**\n   * Returns `Array<[K, V]>` of the entries within the `Trie`\n   * that have `prefix` as prefix (`prefix` included if it exists).\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"sea\", 2),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * const result = Trie.toEntriesWithPrefix(trie, \"she\")\n   * assert.deepStrictEqual(result, [[\"she\", 3], [\"shells\", 0]])\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <V>(self: Trie<V>, prefix: string): Array<[string, V]>\n} = TR.toEntriesWithPrefix\n\n/**\n * Returns the longest key/value in the `Trie`\n * that is a prefix of that `key` if it exists, `None` otherwise.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Option } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\n * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\n * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\n * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const longestPrefixOf: {\n  /**\n   * Returns the longest key/value in the `Trie`\n   * that is a prefix of that `key` if it exists, `None` otherwise.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  (key: string): <V>(self: Trie<V>) => Option<[string, V]>\n  /**\n   * Returns the longest key/value in the `Trie`\n   * that is a prefix of that `key` if it exists, `None` otherwise.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sell\"), Option.none())\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"sells\"), Option.some([\"sells\", 1]))\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shell\"), Option.some([\"she\", 2]))\n   * assert.deepStrictEqual(Trie.longestPrefixOf(trie, \"shellsort\"), Option.some([\"shells\", 0]))\n   * ```\n   *\n   * @since 2.0.0\n   * @category getters\n   */\n  <V>(self: Trie<V>, key: string): Option<[string, V]>\n} = TR.longestPrefixOf\n\n/**\n * Returns the size of the `Trie` (number of entries in the `Trie`).\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"a\", 0),\n *   Trie.insert(\"b\", 1)\n * )\n *\n * assert.equal(Trie.size(trie), 2)\n * ```\n *\n * @since 2.0.0\n * @category getters\n */\nexport const size: <V>(self: Trie<V>) => number = TR.size\n\n/**\n * Safely lookup the value for the specified key in the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Option } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1),\n *   Trie.insert(\"mind\", 2),\n *   Trie.insert(\"mid\", 3)\n * )\n *\n * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n * assert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\n * assert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\n * assert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\n * assert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\n * assert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\n * assert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\n * assert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const get: {\n  /**\n   * Safely lookup the value for the specified key in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n   * assert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\n   * assert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\n   * assert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\n   * assert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (key: string): <V>(self: Trie<V>) => Option<V>\n  /**\n   * Safely lookup the value for the specified key in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n   * assert.deepStrictEqual(Trie.get(trie, \"me\"), Option.some(1))\n   * assert.deepStrictEqual(Trie.get(trie, \"mind\"), Option.some(2))\n   * assert.deepStrictEqual(Trie.get(trie, \"mid\"), Option.some(3))\n   * assert.deepStrictEqual(Trie.get(trie, \"cale\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"ma\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"midn\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie, \"mea\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <V>(self: Trie<V>, key: string): Option<V>\n} = TR.get\n\n/**\n * Check if the given key exists in the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1),\n *   Trie.insert(\"mind\", 2),\n *   Trie.insert(\"mid\", 3)\n * )\n *\n * assert.equal(Trie.has(trie, \"call\"), true)\n * assert.equal(Trie.has(trie, \"me\"), true)\n * assert.equal(Trie.has(trie, \"mind\"), true)\n * assert.equal(Trie.has(trie, \"mid\"), true)\n * assert.equal(Trie.has(trie, \"cale\"), false)\n * assert.equal(Trie.has(trie, \"ma\"), false)\n * assert.equal(Trie.has(trie, \"midn\"), false)\n * assert.equal(Trie.has(trie, \"mea\"), false)\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const has: {\n  /**\n   * Check if the given key exists in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * assert.equal(Trie.has(trie, \"call\"), true)\n   * assert.equal(Trie.has(trie, \"me\"), true)\n   * assert.equal(Trie.has(trie, \"mind\"), true)\n   * assert.equal(Trie.has(trie, \"mid\"), true)\n   * assert.equal(Trie.has(trie, \"cale\"), false)\n   * assert.equal(Trie.has(trie, \"ma\"), false)\n   * assert.equal(Trie.has(trie, \"midn\"), false)\n   * assert.equal(Trie.has(trie, \"mea\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  (key: string): <V>(self: Trie<V>) => boolean\n  /**\n   * Check if the given key exists in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * assert.equal(Trie.has(trie, \"call\"), true)\n   * assert.equal(Trie.has(trie, \"me\"), true)\n   * assert.equal(Trie.has(trie, \"mind\"), true)\n   * assert.equal(Trie.has(trie, \"mid\"), true)\n   * assert.equal(Trie.has(trie, \"cale\"), false)\n   * assert.equal(Trie.has(trie, \"ma\"), false)\n   * assert.equal(Trie.has(trie, \"midn\"), false)\n   * assert.equal(Trie.has(trie, \"mea\"), false)\n   * ```\n   *\n   * @since 2.0.0\n   * @category elements\n   */\n  <V>(self: Trie<V>, key: string): boolean\n} = TR.has\n\n/**\n * Checks if the `Trie` contains any entries.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>()\n * const trie1 = trie.pipe(Trie.insert(\"ma\", 0))\n *\n * assert.equal(Trie.isEmpty(trie), true)\n * assert.equal(Trie.isEmpty(trie1), false)\n * ```\n *\n * @since 2.0.0\n * @category elements\n */\nexport const isEmpty: <V>(self: Trie<V>) => boolean = TR.isEmpty\n\n/**\n * Unsafely lookup the value for the specified key in the `Trie`.\n *\n * `unsafeGet` will throw if the key is not found. Use `get` instead to safely\n * get a value from the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1)\n * )\n *\n * assert.throws(() => Trie.unsafeGet(trie, \"mae\"))\n * ```\n *\n * @since 2.0.0\n * @category unsafe\n */\nexport const unsafeGet: {\n  /**\n   * Unsafely lookup the value for the specified key in the `Trie`.\n   *\n   * `unsafeGet` will throw if the key is not found. Use `get` instead to safely\n   * get a value from the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1)\n   * )\n   *\n   * assert.throws(() => Trie.unsafeGet(trie, \"mae\"))\n   * ```\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  (key: string): <V>(self: Trie<V>) => V\n  /**\n   * Unsafely lookup the value for the specified key in the `Trie`.\n   *\n   * `unsafeGet` will throw if the key is not found. Use `get` instead to safely\n   * get a value from the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1)\n   * )\n   *\n   * assert.throws(() => Trie.unsafeGet(trie, \"mae\"))\n   * ```\n   *\n   * @since 2.0.0\n   * @category unsafe\n   */\n  <V>(self: Trie<V>, key: string): V\n} = TR.unsafeGet\n\n/**\n * Remove the entry for the specified key in the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Option } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"call\", 0),\n *   Trie.insert(\"me\", 1),\n *   Trie.insert(\"mind\", 2),\n *   Trie.insert(\"mid\", 3)\n * )\n *\n * const trie1 = trie.pipe(Trie.remove(\"call\"))\n * const trie2 = trie1.pipe(Trie.remove(\"mea\"))\n *\n * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n * assert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\n * assert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())\n * ```\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const remove: {\n  /**\n   * Remove the entry for the specified key in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * const trie1 = trie.pipe(Trie.remove(\"call\"))\n   * const trie2 = trie1.pipe(Trie.remove(\"mea\"))\n   *\n   * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n   * assert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (key: string): <V>(self: Trie<V>) => Trie<V>\n  /**\n   * Remove the entry for the specified key in the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"call\", 0),\n   *   Trie.insert(\"me\", 1),\n   *   Trie.insert(\"mind\", 2),\n   *   Trie.insert(\"mid\", 3)\n   * )\n   *\n   * const trie1 = trie.pipe(Trie.remove(\"call\"))\n   * const trie2 = trie1.pipe(Trie.remove(\"mea\"))\n   *\n   * assert.deepStrictEqual(Trie.get(trie, \"call\"), Option.some(0))\n   * assert.deepStrictEqual(Trie.get(trie1, \"call\"), Option.none())\n   * assert.deepStrictEqual(Trie.get(trie2, \"call\"), Option.none())\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V>(self: Trie<V>, key: string): Trie<V>\n} = TR.remove\n\n/**\n * Reduce a state over the entries of the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * assert.equal(\n *   trie.pipe(\n *     Trie.reduce(0, (acc, n) => acc + n)\n *   ),\n *   3\n * )\n * assert.equal(\n *   trie.pipe(\n *     Trie.reduce(10, (acc, n) => acc + n)\n *   ),\n *   13\n * )\n * assert.equal(\n *   trie.pipe(\n *     Trie.reduce(\"\", (acc, _, key) => acc + key)\n *   ),\n *   \"sellssheshells\"\n * )\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const reduce: {\n  /**\n   * Reduce a state over the entries of the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(0, (acc, n) => acc + n)\n   *   ),\n   *   3\n   * )\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(10, (acc, n) => acc + n)\n   *   ),\n   *   13\n   * )\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(\"\", (acc, _, key) => acc + key)\n   *   ),\n   *   \"sellssheshells\"\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z\n  /**\n   * Reduce a state over the entries of the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(0, (acc, n) => acc + n)\n   *   ),\n   *   3\n   * )\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(10, (acc, n) => acc + n)\n   *   ),\n   *   13\n   * )\n   * assert.equal(\n   *   trie.pipe(\n   *     Trie.reduce(\"\", (acc, _, key) => acc + key)\n   *   ),\n   *   \"sellssheshells\"\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z\n} = TR.reduce\n\n/**\n * Maps over the entries of the `Trie` using the specified function.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieMapV = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 1),\n *   Trie.insert(\"sells\", 2),\n *   Trie.insert(\"she\", 3)\n * )\n *\n * const trieMapK = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 6),\n *   Trie.insert(\"sells\", 5),\n *   Trie.insert(\"she\", 3)\n * )\n *\n * assert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\n * assert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)\n * ```\n *\n * @since 2.0.0\n * @category folding\n */\nexport const map: {\n  /**\n   * Maps over the entries of the `Trie` using the specified function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sells\", 2),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 6),\n   *   Trie.insert(\"sells\", 5),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>\n  /**\n   * Maps over the entries of the `Trie` using the specified function.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 1),\n   *   Trie.insert(\"sells\", 2),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 6),\n   *   Trie.insert(\"sells\", 5),\n   *   Trie.insert(\"she\", 3)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>\n} = TR.map\n\n/**\n * Filters entries out of a `Trie` using the specified predicate.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieMapV = Trie.empty<number>().pipe(\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieMapK = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1)\n * )\n *\n * assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\n * assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n * ```\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filter: {\n  /**\n   * Filters entries out of a `Trie` using the specified predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>\n  /**\n   * Filters entries out of a `Trie` using the specified predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>\n  /**\n   * Filters entries out of a `Trie` using the specified predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>\n  /**\n   * Filters entries out of a `Trie` using the specified predicate.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)\n   * assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>\n} = TR.filter\n\n/**\n * Maps over the entries of the `Trie` using the specified partial function\n * and filters out `None` values.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal, Option } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieMapV = Trie.empty<number>().pipe(\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieMapK = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1)\n * )\n *\n * assert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\n * assert.equal(\n *   Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n *   true\n * )\n * ```\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const filterMap: {\n  /**\n   * Maps over the entries of the `Trie` using the specified partial function\n   * and filters out `None` values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\n   * assert.equal(\n   *   Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>\n  /**\n   * Maps over the entries of the `Trie` using the specified partial function\n   * and filters out `None` values.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapV = Trie.empty<number>().pipe(\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieMapK = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1)\n   * )\n   *\n   * assert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)\n   * assert.equal(\n   *   Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category filtering\n   */\n  <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>\n} = TR.filterMap\n\n/**\n * Filters out `None` values from a `Trie` of `Options`s.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal, Option } from \"effect\"\n *\n * const trie = Trie.empty<Option.Option<number>>().pipe(\n *   Trie.insert(\"shells\", Option.some(0)),\n *   Trie.insert(\"sells\", Option.none()),\n *   Trie.insert(\"she\", Option.some(2))\n * )\n *\n * const trieMapV = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * assert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)\n * ```\n *\n * @since 2.0.0\n * @category filtering\n */\nexport const compact: <A>(self: Trie<Option<A>>) => Trie<A> = TR.compact\n\n/**\n * Applies the specified function to the entries of the `Trie`.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie } from \"effect\"\n *\n * let value = 0\n *\n * Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2),\n *   Trie.forEach((n, key) => {\n *     value += n + key.length\n *   })\n * )\n *\n * assert.equal(value, 17)\n * ```\n *\n * @since 2.0.0\n * @category traversing\n */\nexport const forEach: {\n  /**\n   * Applies the specified function to the entries of the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * let value = 0\n   *\n   * Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2),\n   *   Trie.forEach((n, key) => {\n   *     value += n + key.length\n   *   })\n   * )\n   *\n   * assert.equal(value, 17)\n   * ```\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void\n  /**\n   * Applies the specified function to the entries of the `Trie`.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie } from \"effect\"\n   *\n   * let value = 0\n   *\n   * Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2),\n   *   Trie.forEach((n, key) => {\n   *     value += n + key.length\n   *   })\n   * )\n   *\n   * assert.equal(value, 17)\n   * ```\n   *\n   * @since 2.0.0\n   * @category traversing\n   */\n  <V>(self: Trie<V>, f: (value: V, key: string) => void): void\n} = TR.forEach\n\n/**\n * Updates the value of the specified key within the `Trie` if it exists.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal, Option } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * assert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n *\n * assert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)\n * ```\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const modify: {\n  /**\n   * Updates the value of the specified key within the `Trie` if it exists.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n   *\n   * assert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>\n  /**\n   * Updates the value of the specified key within the `Trie` if it exists.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal, Option } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.deepStrictEqual(trie.pipe(Trie.modify(\"she\", (v) => v + 10), Trie.get(\"she\")), Option.some(12))\n   *\n   * assert.equal(Equal.equals(trie.pipe(Trie.modify(\"me\", (v) => v)), trie), true)\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>\n} = TR.modify\n\n/**\n * Removes all entries in the `Trie` which have the specified keys.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * assert.equal(\n *   Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n *   true\n * )\n * ```\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const removeMany: {\n  /**\n   * Removes all entries in the `Trie` which have the specified keys.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.equal(\n   *   Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>\n  /**\n   * Removes all entries in the `Trie` which have the specified keys.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * assert.equal(\n   *   Equal.equals(trie.pipe(Trie.removeMany([\"she\", \"sells\"])), Trie.empty<number>().pipe(Trie.insert(\"shells\", 0))),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>\n} = TR.removeMany\n\n/**\n * Insert multiple entries in the `Trie` at once.\n *\n * @example\n * ```ts\n * import * as assert from \"node:assert\"\n * import { Trie, Equal } from \"effect\"\n *\n * const trie = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insert(\"sells\", 1),\n *   Trie.insert(\"she\", 2)\n * )\n *\n * const trieInsert = Trie.empty<number>().pipe(\n *   Trie.insert(\"shells\", 0),\n *   Trie.insertMany(\n *     [[\"sells\", 1], [\"she\", 2]]\n *   )\n * )\n *\n * assert.equal(\n *   Equal.equals(trie, trieInsert),\n *   true\n * )\n * ```\n *\n * @since 2.0.0\n * @category mutations\n */\nexport const insertMany: {\n  /**\n   * Insert multiple entries in the `Trie` at once.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieInsert = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insertMany(\n   *     [[\"sells\", 1], [\"she\", 2]]\n   *   )\n   * )\n   *\n   * assert.equal(\n   *   Equal.equals(trie, trieInsert),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>\n  /**\n   * Insert multiple entries in the `Trie` at once.\n   *\n   * @example\n   * ```ts\n   * import * as assert from \"node:assert\"\n   * import { Trie, Equal } from \"effect\"\n   *\n   * const trie = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insert(\"sells\", 1),\n   *   Trie.insert(\"she\", 2)\n   * )\n   *\n   * const trieInsert = Trie.empty<number>().pipe(\n   *   Trie.insert(\"shells\", 0),\n   *   Trie.insertMany(\n   *     [[\"sells\", 1], [\"she\", 2]]\n   *   )\n   * )\n   *\n   * assert.equal(\n   *   Equal.equals(trie, trieInsert),\n   *   true\n   * )\n   * ```\n   *\n   * @since 2.0.0\n   * @category mutations\n   */\n  <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>\n} = TR.insertMany\n", "import * as Equal from \"../Equal.js\"\nimport { dual, identity, pipe } from \"../Function.js\"\nimport * as Hash from \"../Hash.js\"\nimport { format, NodeInspectSymbol, toJSON } from \"../Inspectable.js\"\nimport * as Option from \"../Option.js\"\nimport type * as Ordering from \"../Ordering.js\"\nimport { pipeArguments } from \"../Pipeable.js\"\nimport { hasProperty } from \"../Predicate.js\"\nimport type * as TR from \"../Trie.js\"\nimport type { NoInfer } from \"../Types.js\"\n\nconst TrieSymbolKey = \"effect/Trie\"\n\n/** @internal */\nexport const TrieTypeId: TR.TypeId = Symbol.for(TrieSymbolKey) as TR.TypeId\n\ntype TraversalMap<K, V, A> = (k: K, v: V) => A\n\ntype TraversalFilter<K, V> = (k: K, v: V) => boolean\n\n/** @internal */\nexport interface TrieImpl<in out V> extends TR.Trie<V> {\n  readonly _root: Node<V> | undefined\n  readonly _count: number\n}\n\nconst trieVariance = {\n  /* c8 ignore next */\n  _Value: (_: never) => _\n}\n\nconst TrieProto: TR.Trie<unknown> = {\n  [TrieTypeId]: trieVariance,\n  [Symbol.iterator]<V>(this: TrieImpl<V>): Iterator<[string, V]> {\n    return new TrieIterator(this, (k, v) => [k, v], () => true)\n  },\n  [Hash.symbol](this: TR.Trie<unknown>): number {\n    let hash = Hash.hash(TrieSymbolKey)\n    for (const item of this) {\n      hash ^= pipe(Hash.hash(item[0]), Hash.combine(Hash.hash(item[1])))\n    }\n    return Hash.cached(this, hash)\n  },\n  [Equal.symbol]<V>(this: TrieImpl<V>, that: unknown): boolean {\n    if (isTrie(that)) {\n      const entries = Array.from(that)\n      return Array.from(this).every((itemSelf, i) => {\n        const itemThat = entries[i]\n        return Equal.equals(itemSelf[0], itemThat[0]) && Equal.equals(itemSelf[1], itemThat[1])\n      })\n    }\n    return false\n  },\n  toString() {\n    return format(this.toJSON())\n  },\n  toJSON() {\n    return {\n      _id: \"Trie\",\n      values: Array.from(this).map(toJSON)\n    }\n  },\n  [NodeInspectSymbol]() {\n    return this.toJSON()\n  },\n  pipe() {\n    return pipeArguments(this, arguments)\n  }\n}\n\nconst makeImpl = <V>(root: Node<V> | undefined): TrieImpl<V> => {\n  const trie = Object.create(TrieProto)\n  trie._root = root\n  trie._count = root?.count ?? 0\n  return trie\n}\n\nclass TrieIterator<in out V, out T> implements IterableIterator<T> {\n  stack: Array<[Node<V>, string, boolean]> = []\n\n  constructor(\n    readonly trie: TrieImpl<V>,\n    readonly f: TraversalMap<string, V, T>,\n    readonly filter: TraversalFilter<string, V>\n  ) {\n    const root = trie._root !== undefined ? trie._root : undefined\n    if (root !== undefined) {\n      this.stack.push([root, \"\", false])\n    }\n  }\n\n  next(): IteratorResult<T> {\n    while (this.stack.length > 0) {\n      const [node, keyString, isAdded] = this.stack.pop()!\n\n      if (isAdded) {\n        const value = node.value\n        if (value !== undefined) {\n          const key = keyString + node.key\n          if (this.filter(key, value)) {\n            return { done: false, value: this.f(key, value) }\n          }\n        }\n      } else {\n        this.addToStack(node, keyString)\n      }\n    }\n\n    return { done: true, value: undefined }\n  }\n\n  addToStack(node: Node<V>, keyString: string) {\n    if (node.right !== undefined) {\n      this.stack.push([node.right, keyString, false])\n    }\n    if (node.mid !== undefined) {\n      this.stack.push([node.mid, keyString + node.key, false])\n    }\n    this.stack.push([node, keyString, true])\n    if (node.left !== undefined) {\n      this.stack.push([node.left, keyString, false])\n    }\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return new TrieIterator(this.trie, this.f, this.filter)\n  }\n}\n\n/** @internal */\nexport const isTrie: {\n  <V>(u: Iterable<readonly [string, V]>): u is TR.Trie<V>\n  (u: unknown): u is TR.Trie<unknown>\n} = (u: unknown): u is TR.Trie<unknown> => hasProperty(u, TrieTypeId)\n\n/** @internal */\nexport const empty = <V = never>(): TR.Trie<V> => makeImpl<V>(undefined)\n\n/** @internal */\nexport const fromIterable = <V>(entries: Iterable<readonly [string, V]>) => {\n  let trie = empty<V>()\n  for (const [key, value] of entries) {\n    trie = insert(trie, key, value)\n  }\n  return trie\n}\n\n/** @internal */\nexport const make = <Entries extends Array<readonly [string, any]>>(...entries: Entries): TR.Trie<\n  Entries[number] extends readonly [any, infer V] ? V : never\n> => {\n  return fromIterable(entries)\n}\n\n/** @internal */\nexport const insert = dual<\n  <V>(key: string, value: V) => (self: TR.Trie<V>) => TR.Trie<V>,\n  <V>(self: TR.Trie<V>, key: string, value: V) => TR.Trie<V>\n>(3, <V>(self: TR.Trie<V>, key: string, value: V) => {\n  if (key.length === 0) return self\n\n  // -1:left | 0:mid | 1:right\n  const dStack: Array<Ordering.Ordering> = []\n  const nStack: Array<Node<V>> = []\n  let n: Node<V> = (self as TrieImpl<V>)._root ?? {\n    key: key[0],\n    count: 0\n  }\n  const count = n.count + 1\n  let cIndex = 0\n\n  while (cIndex < key.length) {\n    const c = key[cIndex]\n    nStack.push(n)\n    if (c > n.key) {\n      dStack.push(1)\n      if (n.right === undefined) {\n        n = { key: c, count }\n      } else {\n        n = n.right\n      }\n    } else if (c < n.key) {\n      dStack.push(-1)\n      if (n.left === undefined) {\n        n = { key: c, count }\n      } else {\n        n = n.left\n      }\n    } else {\n      if (cIndex === key.length - 1) {\n        n.value = value\n      } else if (n.mid === undefined) {\n        dStack.push(0)\n        n = { key: key[cIndex + 1], count }\n      } else {\n        dStack.push(0)\n        n = n.mid\n      }\n\n      cIndex += 1\n    }\n  }\n\n  // Rebuild path to leaf node (Path-copying immutability)\n  for (let s = nStack.length - 2; s >= 0; --s) {\n    const n2 = nStack[s]\n    const d = dStack[s]\n    if (d === -1) {\n      // left\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: nStack[s + 1],\n        mid: n2.mid,\n        right: n2.right\n      }\n    } else if (d === 1) {\n      // right\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: n2.mid,\n        right: nStack[s + 1]\n      }\n    } else {\n      // mid\n      nStack[s] = {\n        key: n2.key,\n        count,\n        value: n2.value,\n        left: n2.left,\n        mid: nStack[s + 1],\n        right: n2.right\n      }\n    }\n  }\n\n  nStack[0].count = count\n  return makeImpl(nStack[0])\n})\n\n/** @internal */\nexport const size = <V>(self: TR.Trie<V>): number => (self as TrieImpl<V>)._root?.count ?? 0\n\n/** @internal */\nexport const isEmpty = <V>(self: TR.Trie<V>): boolean => size(self) === 0\n\n/** @internal */\nexport const keys = <V>(self: TR.Trie<V>): IterableIterator<string> =>\n  new TrieIterator(self as TrieImpl<V>, (key) => key, () => true)\n\n/** @internal */\nexport const values = <V>(self: TR.Trie<V>): IterableIterator<V> =>\n  new TrieIterator(self as TrieImpl<V>, (_, value) => value, () => true)\n\n/** @internal */\nexport const entries = <V>(self: TR.Trie<V>): IterableIterator<[string, V]> =>\n  new TrieIterator(self as TrieImpl<V>, (key, value) => [key, value], () => true)\n\n/** @internal */\nexport const reduce = dual<\n  <Z, V>(\n    zero: Z,\n    f: (accumulator: Z, value: V, key: string) => Z\n  ) => (self: TR.Trie<V>) => Z,\n  <Z, V>(self: TR.Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z) => Z\n>(3, (self, zero, f) => {\n  let accumulator = zero\n  for (const entry of self) {\n    accumulator = f(accumulator, entry[1], entry[0])\n  }\n  return accumulator\n})\n\n/** @internal */\nexport const map = dual<\n  <A, V>(f: (value: V, key: string) => A) => (self: TR.Trie<V>) => TR.Trie<A>,\n  <V, A>(self: TR.Trie<V>, f: (value: V, key: string) => A) => TR.Trie<A>\n>(2, (self, f) =>\n  reduce(\n    self,\n    empty(),\n    (trie, value, key) => insert(trie, key, f(value, key))\n  ))\n\n/** @internal */\nexport const filter: {\n  <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: TR.Trie<A>) => TR.Trie<B>\n  <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: TR.Trie<A>) => TR.Trie<A>\n  <A, B extends A>(self: TR.Trie<A>, f: (a: A, k: string) => a is B): TR.Trie<B>\n  <A>(self: TR.Trie<A>, f: (a: A, k: string) => boolean): TR.Trie<A>\n} = dual(\n  2,\n  <A>(self: TR.Trie<A>, f: (a: A, k: string) => boolean): TR.Trie<A> =>\n    reduce(\n      self,\n      empty(),\n      (trie, value, key) => f(value, key) ? insert(trie, key, value) : trie\n    )\n)\n\n/** @internal */\nexport const filterMap = dual<\n  <A, B>(\n    f: (value: A, key: string) => Option.Option<B>\n  ) => (self: TR.Trie<A>) => TR.Trie<B>,\n  <A, B>(self: TR.Trie<A>, f: (value: A, key: string) => Option.Option<B>) => TR.Trie<B>\n>(2, (self, f) =>\n  reduce(\n    self,\n    empty(),\n    (trie, value, key) => {\n      const option = f(value, key)\n      return Option.isSome(option) ? insert(trie, key, option.value) : trie\n    }\n  ))\n\n/** @internal */\nexport const compact = <A>(self: TR.Trie<Option.Option<A>>) => filterMap(self, identity)\n\n/** @internal */\nexport const forEach = dual<\n  <V>(f: (value: V, key: string) => void) => (self: TR.Trie<V>) => void,\n  <V>(self: TR.Trie<V>, f: (value: V, key: string) => void) => void\n>(2, (self, f) => reduce(self, void 0 as void, (_, value, key) => f(value, key)))\n\n/** @internal */\nexport const keysWithPrefix = dual<\n  (prefix: string) => <V>(self: TR.Trie<V>) => IterableIterator<string>,\n  <V>(self: TR.Trie<V>, prefix: string) => IterableIterator<string>\n>(\n  2,\n  <V>(self: TR.Trie<V>, prefix: string): IterableIterator<string> =>\n    new TrieIterator(self as TrieImpl<V>, (key) => key, (key) => key.startsWith(prefix))\n)\n\n/** @internal */\nexport const valuesWithPrefix = dual<\n  (prefix: string) => <V>(self: TR.Trie<V>) => IterableIterator<V>,\n  <V>(self: TR.Trie<V>, prefix: string) => IterableIterator<V>\n>(\n  2,\n  <V>(self: TR.Trie<V>, prefix: string): IterableIterator<V> =>\n    new TrieIterator(self as TrieImpl<V>, (_, value) => value, (key) => key.startsWith(prefix))\n)\n\n/** @internal */\nexport const entriesWithPrefix = dual<\n  (prefix: string) => <V>(self: TR.Trie<V>) => IterableIterator<[string, V]>,\n  <V>(self: TR.Trie<V>, prefix: string) => IterableIterator<[string, V]>\n>(\n  2,\n  <V>(self: TR.Trie<V>, prefix: string): IterableIterator<[string, V]> =>\n    new TrieIterator(self as TrieImpl<V>, (key, value) => [key, value], (key) => key.startsWith(prefix))\n)\n\n/** @internal */\nexport const toEntriesWithPrefix = dual<\n  (prefix: string) => <V>(self: TR.Trie<V>) => Array<[string, V]>,\n  <V>(self: TR.Trie<V>, prefix: string) => Array<[string, V]>\n>(\n  2,\n  <V>(self: TR.Trie<V>, prefix: string): Array<[string, V]> => Array.from(entriesWithPrefix(self, prefix))\n)\n\n/** @internal */\nexport const get = dual<\n  (key: string) => <V>(self: TR.Trie<V>) => Option.Option<V>,\n  <V>(self: TR.Trie<V>, key: string) => Option.Option<V>\n>(\n  2,\n  <V>(self: TR.Trie<V>, key: string) => {\n    let n: Node<V> | undefined = (self as TrieImpl<V>)._root\n    if (n === undefined || key.length === 0) return Option.none()\n    let cIndex = 0\n    while (cIndex < key.length) {\n      const c = key[cIndex]\n      if (c > n.key) {\n        if (n.right === undefined) {\n          return Option.none()\n        } else {\n          n = n.right\n        }\n      } else if (c < n.key) {\n        if (n.left === undefined) {\n          return Option.none()\n        } else {\n          n = n.left\n        }\n      } else {\n        if (cIndex === key.length - 1) {\n          return Option.fromNullable(n.value)\n        } else {\n          if (n.mid === undefined) {\n            return Option.none()\n          } else {\n            n = n.mid\n            cIndex += 1\n          }\n        }\n      }\n    }\n    return Option.none()\n  }\n)\n\n/** @internal */\nexport const has = dual<\n  (key: string) => <V>(self: TR.Trie<V>) => boolean,\n  <V>(self: TR.Trie<V>, key: string) => boolean\n>(2, (self, key) => Option.isSome(get(self, key)))\n\n/** @internal */\nexport const unsafeGet = dual<\n  (key: string) => <V>(self: TR.Trie<V>) => V,\n  <V>(self: TR.Trie<V>, key: string) => V\n>(2, (self, key) => {\n  const element = get(self, key)\n  if (Option.isNone(element)) {\n    throw new Error(\"Expected trie to contain key\")\n  }\n  return element.value\n})\n\n/** @internal */\nexport const remove = dual<\n  (key: string) => <V>(self: TR.Trie<V>) => TR.Trie<V>,\n  <V>(self: TR.Trie<V>, key: string) => TR.Trie<V>\n>(\n  2,\n  <V>(self: TR.Trie<V>, key: string) => {\n    let n: Node<V> | undefined = (self as TrieImpl<V>)._root\n    if (n === undefined || key.length === 0) return self\n\n    const count = n.count - 1\n    // -1:left | 0:mid | 1:right\n    const dStack: Array<Ordering.Ordering> = []\n    const nStack: Array<Node<V>> = []\n\n    let cIndex = 0\n    while (cIndex < key.length) {\n      const c = key[cIndex]\n      if (c > n.key) {\n        if (n.right === undefined) {\n          return self\n        } else {\n          nStack.push(n)\n          dStack.push(1)\n          n = n.right\n        }\n      } else if (c < n.key) {\n        if (n.left === undefined) {\n          return self\n        } else {\n          nStack.push(n)\n          dStack.push(-1)\n          n = n.left\n        }\n      } else {\n        if (cIndex === key.length - 1) {\n          if (n.value !== undefined) {\n            nStack.push(n)\n            dStack.push(0)\n            cIndex += 1\n          } else {\n            return self\n          }\n        } else {\n          if (n.mid === undefined) {\n            return self\n          } else {\n            nStack.push(n)\n            dStack.push(0)\n            n = n.mid\n            cIndex += 1\n          }\n        }\n      }\n    }\n\n    const removeNode = nStack[nStack.length - 1]\n    nStack[nStack.length - 1] = {\n      key: removeNode.key,\n      count,\n      left: removeNode.left,\n      mid: removeNode.mid,\n      right: removeNode.right\n    }\n\n    // Rebuild path to leaf node (Path-copying immutability)\n    for (let s = nStack.length - 2; s >= 0; --s) {\n      const n2 = nStack[s]\n      const d = dStack[s]\n      const child = nStack[s + 1]\n      const nc = child.left === undefined && child.mid === undefined && child.right === undefined ? undefined : child\n      if (d === -1) {\n        // left\n        nStack[s] = {\n          key: n2.key,\n          count,\n          value: n2.value,\n          left: nc,\n          mid: n2.mid,\n          right: n2.right\n        }\n      } else if (d === 1) {\n        // right\n        nStack[s] = {\n          key: n2.key,\n          count,\n          value: n2.value,\n          left: n2.left,\n          mid: n2.mid,\n          right: nc\n        }\n      } else {\n        // mid\n        nStack[s] = {\n          key: n2.key,\n          count,\n          value: n2.value,\n          left: n2.left,\n          mid: nc,\n          right: n2.right\n        }\n      }\n    }\n\n    nStack[0].count = count\n    return makeImpl(nStack[0])\n  }\n)\n\n/** @internal */\nexport const removeMany = dual<\n  (keys: Iterable<string>) => <V>(self: TR.Trie<V>) => TR.Trie<V>,\n  <V>(self: TR.Trie<V>, keys: Iterable<string>) => TR.Trie<V>\n>(2, (self, keys) => {\n  let trie = self\n  for (const key of keys) {\n    trie = remove(key)(trie)\n  }\n  return trie\n})\n\n/** @internal */\nexport const insertMany = dual<\n  <V>(iter: Iterable<[string, V]>) => (self: TR.Trie<V>) => TR.Trie<V>,\n  <V>(self: TR.Trie<V>, iter: Iterable<[string, V]>) => TR.Trie<V>\n>(2, (self, iter) => {\n  let trie = self\n  for (const [key, value] of iter) {\n    trie = insert(key, value)(trie)\n  }\n  return trie\n})\n\n/** @internal */\nexport const modify = dual<\n  <V>(key: string, f: (v: V) => V) => (self: TR.Trie<V>) => TR.Trie<V>,\n  <V>(self: TR.Trie<V>, key: string, f: (v: V) => V) => TR.Trie<V>\n>(\n  3,\n  <V>(self: TR.Trie<V>, key: string, f: (v: V) => V): TR.Trie<V> => {\n    let n: Node<V> | undefined = (self as TrieImpl<V>)._root\n    if (n === undefined || key.length === 0) return self\n\n    // -1:left | 0:mid | 1:right\n    const dStack: Array<Ordering.Ordering> = []\n    const nStack: Array<Node<V>> = []\n\n    let cIndex = 0\n    while (cIndex < key.length) {\n      const c = key[cIndex]\n      if (c > n.key) {\n        if (n.right === undefined) {\n          return self\n        } else {\n          nStack.push(n)\n          dStack.push(1)\n          n = n.right\n        }\n      } else if (c < n.key) {\n        if (n.left === undefined) {\n          return self\n        } else {\n          nStack.push(n)\n          dStack.push(-1)\n          n = n.left\n        }\n      } else {\n        if (cIndex === key.length - 1) {\n          if (n.value !== undefined) {\n            nStack.push(n)\n            dStack.push(0)\n            cIndex += 1\n          } else {\n            return self\n          }\n        } else {\n          if (n.mid === undefined) {\n            return self\n          } else {\n            nStack.push(n)\n            dStack.push(0)\n            n = n.mid\n            cIndex += 1\n          }\n        }\n      }\n    }\n\n    const updateNode = nStack[nStack.length - 1]\n    if (updateNode.value === undefined) {\n      return self\n    }\n\n    nStack[nStack.length - 1] = {\n      key: updateNode.key,\n      count: updateNode.count,\n      value: f(updateNode.value), // Update\n      left: updateNode.left,\n      mid: updateNode.mid,\n      right: updateNode.right\n    }\n\n    // Rebuild path to leaf node (Path-copying immutability)\n    for (let s = nStack.length - 2; s >= 0; --s) {\n      const n2 = nStack[s]\n      const d = dStack[s]\n      const child = nStack[s + 1]\n      if (d === -1) {\n        // left\n        nStack[s] = {\n          key: n2.key,\n          count: n2.count,\n          value: n2.value,\n          left: child,\n          mid: n2.mid,\n          right: n2.right\n        }\n      } else if (d === 1) {\n        // right\n        nStack[s] = {\n          key: n2.key,\n          count: n2.count,\n          value: n2.value,\n          left: n2.left,\n          mid: n2.mid,\n          right: child\n        }\n      } else {\n        // mid\n        nStack[s] = {\n          key: n2.key,\n          count: n2.count,\n          value: n2.value,\n          left: n2.left,\n          mid: child,\n          right: n2.right\n        }\n      }\n    }\n\n    return makeImpl(nStack[0])\n  }\n)\n\n/** @internal */\nexport const longestPrefixOf = dual<\n  (key: string) => <V>(self: TR.Trie<V>) => Option.Option<[string, V]>,\n  <V>(self: TR.Trie<V>, key: string) => Option.Option<[string, V]>\n>(\n  2,\n  <V>(self: TR.Trie<V>, key: string) => {\n    let n: Node<V> | undefined = (self as TrieImpl<V>)._root\n    if (n === undefined || key.length === 0) return Option.none()\n    let longestPrefixNode: [string, V] | undefined = undefined\n    let cIndex = 0\n    while (cIndex < key.length) {\n      const c = key[cIndex]\n      if (n.value !== undefined) {\n        longestPrefixNode = [key.slice(0, cIndex + 1), n.value]\n      }\n\n      if (c > n.key) {\n        if (n.right === undefined) {\n          break\n        } else {\n          n = n.right\n        }\n      } else if (c < n.key) {\n        if (n.left === undefined) {\n          break\n        } else {\n          n = n.left\n        }\n      } else {\n        if (n.mid === undefined) {\n          break\n        } else {\n          n = n.mid\n          cIndex += 1\n        }\n      }\n    }\n\n    return Option.fromNullable(longestPrefixNode)\n  }\n)\n\ninterface Node<V> {\n  key: string\n  count: number\n  value?: V | undefined\n  left?: Node<V> | undefined\n  mid?: Node<V> | undefined\n  right?: Node<V> | undefined\n}\n", "/**\n * A collection of types that are commonly used types.\n *\n * @since 2.0.0\n */\n\ntype _TupleOf<T, N extends number, R extends Array<unknown>> = R[\"length\"] extends N ? R : _TupleOf<T, N, [T, ...R]>\n\n/**\n * Represents a tuple with a fixed number of elements of type `T`.\n *\n * This type constructs a tuple that has exactly `N` elements of type `T`.\n *\n * @typeParam N - The number of elements in the tuple.\n * @typeParam T - The type of elements in the tuple.\n *\n * @example\n * ```ts\n * import { TupleOf } from \"effect/Types\"\n *\n * // A tuple with exactly 3 numbers\n * const example1: TupleOf<3, number> = [1, 2, 3]; // valid\n * // @ts-expect-error\n * const example2: TupleOf<3, number> = [1, 2]; // invalid\n * // @ts-expect-error\n * const example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid\n * ```\n *\n * @category tuples\n * @since 3.3.0\n */\nexport type TupleOf<N extends number, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never\n\n/**\n * Represents a tuple with at least `N` elements of type `T`.\n *\n * This type constructs a tuple that has a fixed number of elements `N` of type `T` at the start,\n * followed by any number (including zero) of additional elements of the same type `T`.\n *\n * @typeParam N - The minimum number of elements in the tuple.\n * @typeParam T - The type of elements in the tuple.\n *\n * @example\n * ```ts\n * import { TupleOfAtLeast } from \"effect/Types\"\n *\n * // A tuple with at least 3 numbers\n * const example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid\n * const example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid\n * // @ts-expect-error\n * const example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid\n * ```\n *\n * @category tuples\n * @since 3.3.0\n */\nexport type TupleOfAtLeast<N extends number, T> = [...TupleOf<N, T>, ...Array<T>]\n\n/**\n * Returns the tags in a type.\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res = Types.Tags<string | { _tag: \"a\" } | { _tag: \"b\" } > // \"a\" | \"b\"\n * ```\n *\n * @category types\n * @since 2.0.0\n */\nexport type Tags<E> = E extends { _tag: string } ? E[\"_tag\"] : never\n\n/**\n * Excludes the tagged object from the type.\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res = Types.ExcludeTag<string | { _tag: \"a\" } | { _tag: \"b\" }, \"a\"> // string | { _tag: \"b\" }\n * ```\n *\n * @category types\n * @since 2.0.0\n */\nexport type ExcludeTag<E, K extends Tags<E>> = Exclude<E, { _tag: K }>\n\n/**\n * Extracts the type of the given tag.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res = Types.ExtractTag<{ _tag: \"a\", a: number } | { _tag: \"b\", b: number }, \"b\"> // { _tag: \"b\", b: number }\n * ```\n *\n * @category types\n * @since 2.0.0\n */\nexport type ExtractTag<E, K extends Tags<E>> = Extract<E, { _tag: K }>\n\n/**\n * A utility type that transforms a union type `T` into an intersection type.\n *\n * @since 2.0.0\n * @category types\n */\nexport type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R\n  : never\n\n/**\n * Simplifies the type signature of a type.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }\n * ```\n *\n * @since 2.0.0\n * @category types\n */\nexport type Simplify<A> = {\n  [K in keyof A]: A[K]\n} extends infer B ? B : never\n\n/**\n * Determines if two types are equal.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res1 = Types.Equals<{ a: number }, { a: number }> // true\n * type Res2 = Types.Equals<{ a: number }, { b: number }> // false\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <\n  T\n>() => T extends Y ? 1 : 2 ? true\n  : false\n\n/**\n * Determines if two types are equal, allowing to specify the return types.\n *\n * @since 3.15.0\n * @category models\n */\nexport type EqualsWith<A, B, Y, N> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? Y : N\n\n/**\n * Determines if a record contains any of the given keys.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type Res1 = Types.Has<{ a: number }, \"a\" | \"b\"> // true\n * type Res2 = Types.Has<{ c: number }, \"a\" | \"b\"> // false\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type Has<A, Key extends string> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never\n  ? false\n  : true\n\n/**\n * Merges two object where the keys of the left object take precedence in the case of a conflict.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n * type MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type MergeLeft<Source, Target> = MergeRight<Target, Source>\n\n/**\n * Merges two object where the keys of the right object take precedence in the case of a conflict.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n * type MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }\n * ```\n *\n * @since 2.0.0\n * @category models\n */\nexport type MergeRight<Target, Source> = Simplify<\n  & Source\n  & {\n    [Key in keyof Target as Key extends keyof Source ? never : Key]: Target[Key]\n  }\n>\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type MergeRecord<Source, Target> = MergeLeft<Source, Target>\n\n/**\n * Describes the concurrency to use when executing multiple Effect's.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Concurrency = number | \"unbounded\" | \"inherit\"\n\n/**\n * Make all properties in `T` mutable. Supports arrays, tuples, and records as well.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }\n *\n * type MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]\n *\n * type MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]\n *\n * type MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }\n * ```\n *\n * @since 2.0.0\n * @category types\n */\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P]\n}\n\n/**\n * Like `Types.Mutable`, but works recursively.\n *\n * @example\n * ```ts\n * import type { Types } from \"effect\"\n *\n * type DeepMutableStruct = Types.DeepMutable<{\n *   readonly a: string;\n *   readonly b: readonly string[]\n * }>\n * // { a: string; b: string[] }\n * ```\n *\n * @since 3.1.0\n * @category types\n */\nexport type DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>\n  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>\n  : T extends string | number | boolean | bigint | symbol ? T\n  : { -readonly [K in keyof T]: DeepMutable<T[K]> }\n\n/**\n * Avoid inference on a specific parameter\n *\n * @since 2.0.0\n * @category models\n */\nexport type NoInfer<A> = [A][A extends any ? 0 : never]\n\n/**\n * Invariant helper.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Invariant<A> = (_: A) => A\n\n/**\n * @since 3.9.0\n * @category models\n */\nexport declare namespace Invariant {\n  /**\n   * @since 3.9.0\n   * @category models\n   */\n  export type Type<A> = A extends Invariant<infer U> ? U : never\n}\n\n/**\n * Covariant helper.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Covariant<A> = (_: never) => A\n\n/**\n * @since 3.9.0\n * @category models\n */\nexport declare namespace Covariant {\n  /**\n   * @since 3.9.0\n   * @category models\n   */\n  export type Type<A> = A extends Covariant<infer U> ? U : never\n}\n\n/**\n * Contravariant helper.\n *\n * @since 2.0.0\n * @category models\n */\nexport type Contravariant<A> = (_: A) => void\n\n/**\n * @since 3.9.0\n * @category models\n */\nexport declare namespace Contravariant {\n  /**\n   * @since 3.9.0\n   * @category models\n   */\n  export type Type<A> = A extends Contravariant<infer U> ? U : never\n}\n\n/**\n * @since 2.0.0\n */\nexport type MatchRecord<S, onTrue, onFalse> = {} extends S ? onTrue : onFalse\n\n/**\n * @since 2.0.0\n */\nexport type NotFunction<T> = T extends Function ? never : T\n\n/**\n * @since 3.9.0\n */\nexport type NoExcessProperties<T, U> = T & { readonly [K in Exclude<keyof U, keyof T>]: never }\n\n/**\n * @since 3.15.0\n */\nexport type Ctor<T = {}> = new(...args: Array<any>) => T\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/channel/upstreamPullRequest.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const UpstreamPullRequestTypeId: unique symbol = internal.UpstreamPullRequestTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type UpstreamPullRequestTypeId = typeof UpstreamPullRequestTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type UpstreamPullRequest<A> = Pulled<A> | NoUpstream\n\n/**\n * @since 2.0.0\n */\nexport declare namespace UpstreamPullRequest {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A> {\n    readonly [UpstreamPullRequestTypeId]: {\n      readonly _A: Types.Covariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface Pulled<out A> extends UpstreamPullRequest.Variance<A> {\n  readonly _tag: \"Pulled\"\n  readonly value: A\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface NoUpstream extends UpstreamPullRequest.Variance<never> {\n  readonly _tag: \"NoUpstream\"\n  readonly activeDownstreamCount: number\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const Pulled: <A>(value: A) => UpstreamPullRequest<A> = internal.Pulled\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const NoUpstream: (activeDownstreamCount: number) => UpstreamPullRequest<never> = internal.NoUpstream\n\n/**\n * Returns `true` if the specified value is an `UpstreamPullRequest`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown> = internal.isUpstreamPullRequest\n\n/**\n * Returns `true` if the specified `UpstreamPullRequest` is a `Pulled`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A> = internal.isPulled\n\n/**\n * Returns `true` if the specified `UpstreamPullRequest` is a `NoUpstream`,\n * `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream = internal.isNoUpstream\n\n/**\n * Folds an `UpstreamPullRequest<A>` into a value of type `Z`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds an `UpstreamPullRequest<A>` into a value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, Z>(\n   options: {\n     readonly onPulled: (value: A) => Z\n     readonly onNoUpstream: (activeDownstreamCount: number) => Z\n   }\n  ): (self: UpstreamPullRequest<A>) => Z\n  /**\n   * Folds an `UpstreamPullRequest<A>` into a value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, Z>(\n   self: UpstreamPullRequest<A>,\n   options: {\n     readonly onPulled: (value: A) => Z\n     readonly onNoUpstream: (activeDownstreamCount: number) => Z\n   }\n  ): Z\n} = internal.match\n", "/**\n * @since 2.0.0\n */\nimport * as internal from \"./internal/channel/upstreamPullStrategy.js\"\nimport type * as Option from \"./Option.js\"\nimport type * as Types from \"./Types.js\"\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport const UpstreamPullStrategyTypeId: unique symbol = internal.UpstreamPullStrategyTypeId\n\n/**\n * @since 2.0.0\n * @category symbols\n */\nexport type UpstreamPullStrategyTypeId = typeof UpstreamPullStrategyTypeId\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport type UpstreamPullStrategy<A> = PullAfterNext<A> | PullAfterAllEnqueued<A>\n\n/**\n * @since 2.0.0\n */\nexport declare namespace UpstreamPullStrategy {\n  /**\n   * @since 2.0.0\n   * @category models\n   */\n  export interface Variance<out A> {\n    readonly [UpstreamPullStrategyTypeId]: {\n      readonly _A: Types.Covariant<A>\n    }\n  }\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface PullAfterNext<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterNext\"\n  readonly emitSeparator: Option.Option<A>\n}\n\n/**\n * @since 2.0.0\n * @category models\n */\nexport interface PullAfterAllEnqueued<out A> extends UpstreamPullStrategy.Variance<A> {\n  readonly _tag: \"PullAfterAllEnqueued\"\n  readonly emitSeparator: Option.Option<A>\n}\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const PullAfterNext: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A> = internal.PullAfterNext\n\n/**\n * @since 2.0.0\n * @category constructors\n */\nexport const PullAfterAllEnqueued: <A>(emitSeparator: Option.Option<A>) => UpstreamPullStrategy<A> =\n  internal.PullAfterAllEnqueued\n\n/**\n * Returns `true` if the specified value is an `UpstreamPullStrategy`, `false`\n * otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown> =\n  internal.isUpstreamPullStrategy\n\n/**\n * Returns `true` if the specified `UpstreamPullStrategy` is a `PullAfterNext`,\n * `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A> = internal.isPullAfterNext\n\n/**\n * Returns `true` if the specified `UpstreamPullStrategy` is a\n * `PullAfterAllEnqueued`, `false` otherwise.\n *\n * @since 2.0.0\n * @category refinements\n */\nexport const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A> =\n  internal.isPullAfterAllEnqueued\n\n/**\n * Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.\n *\n * @since 2.0.0\n * @category folding\n */\nexport const match: {\n  /**\n   * Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, Z>(\n   options: {\n     readonly onNext: (emitSeparator: Option.Option<A>) => Z\n     readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z\n   }\n  ): (self: UpstreamPullStrategy<A>) => Z\n  /**\n   * Folds an `UpstreamPullStrategy<A>` into a value of type `Z`.\n   *\n   * @since 2.0.0\n   * @category folding\n   */\n  <A, Z>(\n   self: UpstreamPullStrategy<A>,\n   options: {\n     readonly onNext: (emitSeparator: Option.Option<A>) => Z\n     readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z\n   }\n  ): Z\n} = internal.match\n"],
  "mappings": "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",
  "names": ["make", "makeLazy", "schema", "description", "getDescription", "ast", "go", "maxDepth", "make", "FastCheck", "makeStringConstraints", "options", "out", "_tag", "constraints", "isNumber", "minLength", "maxLength", "isString", "pattern", "makeNumberConstraints", "isInteger", "min", "Math", "fround", "isBoolean", "minExcluded", "max", "maxExcluded", "noNaN", "noDefaultInfinity", "makeBigIntConstraints", "isBigInt", "makeArrayConstraints", "makeDateConstraints", "isDate", "noInvalidDate", "getArbitraryAnnotation", "getAnnotation", "ArbitraryAnnotationId", "getASTConstraints", "TypeAnnotationId", "annotations", "SchemaIdAnnotationId", "isPropertyKey", "isReadonlyRecord", "idMemoMap", "globalValue", "Symbol", "for", "Map", "counter", "wrapGetDescription", "f", "g", "path", "parseMeta", "jsonSchema", "getJSONSchemaAnnotation", "pipe", "filter", "getOrUndefined", "schemaId", "getOrElse", "getSchemaIdAnnotation", "undefined", "schemaParams", "fromNullable", "map", "id", "annotation", "isSome", "value", "meta", "from", "refinements", "c", "NonNaNSchemaId", "type", "exclusiveMinimum", "minimum", "exclusiveMaximum", "maximum", "minItems", "maxItems", "DateFromSelfSchemaId", "typeParameters", "literal", "symbol", "enums", "head", "spans", "span", "elements", "element", "i", "isOptional", "rest", "propertySignatures", "ps", "name", "indexSignatures", "is", "parameter", "members", "types", "member", "memoId", "get", "set", "to", "getMax", "n1", "n2", "getMin", "getOr", "a", "b", "mergePattern", "pattern1", "pattern2", "mergeStringConstraints", "c1", "c2", "buildStringConstraints", "length", "reduce", "mergeNumberConstraints", "buildNumberConstraints", "mergeBigIntConstraints", "buildBigIntConstraints", "mergeDateConstraints", "buildDateConstraints", "constArrayConstraints", "mergeArrayConstraints", "buildArrayConstraints", "arbitraryMemoMap", "WeakMap", "applyFilters", "filters", "arb", "fc", "absurd", "message", "Error", "getContextConstraints", "wrapGo", "ctx", "lazyArb", "getArbitraryMissingAnnotationErrorMessage", "getArbitraryEmptyEnumErrorMessage", "isNone", "defaultParseOption", "p", "date", "constant", "anything", "boolean", "string", "s", "oneof", "object", "array", "_", "number", "float", "getTemplateLiteralArb", "components", "getTemplateLiteralSpanTypeArb", "String", "forEach", "push", "tuple", "join", "stringMatching", "RegExp", "integer", "bigInt", "hasOptionals", "d", "output", "indexes", "chain", "booleans", "reverse", "entries", "splice", "isNonEmptyReadonlyArray", "tail", "item", "as", "len", "restArrayConstraints", "subtractElementsLength", "arr", "depthIdentifier", "getSuspendedArray", "j", "requiredKeys", "pps", "record", "key", "o", "tuples", "Object", "fromEntries", "memo", "memoizeThunk", "JSON", "stringify", "maxLengthLimit", "CacheTypeId", "ConsumerCacheTypeId", "make", "makeCacheStats", "makeEntryStats", "makeWith", "CacheTypeId", "ConsumerCacheTypeId", "make", "makeWith", "makeCacheStats", "makeEntryStats", "ChildExecutorDecisionTypeId", "Close", "Continue", "Yield", "isChildExecutorDecision", "isClose", "isContinue", "isYield", "match", "ChildExecutorDecisionTypeId", "Continue", "Close", "Yield", "isChildExecutorDecision", "isContinue", "isClose", "isYield", "match", "TypeId", "assert", "clear", "consoleWith", "count", "countReset", "debug", "dir", "dirxml", "error", "group", "info", "log", "setConsole", "table", "time", "timeLog", "trace", "warn", "withConsole", "withGroup", "withTime", "TypeId", "Console", "consoleTag", "withConsole", "setConsole", "consoleWith", "assert", "clear", "count", "countReset", "debug", "dir", "dirxml", "error", "group", "info", "log", "table", "time", "timeLog", "trace", "warn", "withGroup", "withTime", "TypeId", "isExecutionPlan", "make", "merge", "TypeId", "isExecutionPlan", "make", "steps", "makeProto", "map", "options", "i", "attempts", "Error", "schedule", "while", "input", "suspend", "result", "succeed", "undefined", "provide", "Proto", "withRequirements", "self", "contextWith", "context", "step", "isLayer", "succeedContext", "pipe", "pipeArguments", "arguments", "Object", "create", "merge", "plans", "flatMap", "plan", "TypeId", "clear", "get", "make", "runtime", "set", "unsafeGet", "unsafeSet", "TypeId", "Symbol", "for", "isFiberHandle", "u", "hasProperty", "Proto", "toString", "format", "toJSON", "_id", "state", "NodeInspectSymbol", "pipe", "pipeArguments", "arguments", "unsafeMake", "deferred", "self", "Object", "create", "_tag", "fiber", "undefined", "make", "acquireRelease", "map", "handle", "withFiberRuntime", "parent", "void", "intoDeferred", "asVoid", "interruptAs", "combine", "id", "internalFiberId", "done", "makeRuntime", "flatMap", "runtime", "makeRuntimePromise", "runtimePromise", "internalFiberIdId", "isInternalInterruption", "reduceWithContext", "emptyCase", "constFalse", "failCase", "dieCase", "interruptCase", "_", "fiberId", "has", "ids", "sequentialCase", "left", "right", "parallelCase", "unsafeSet", "dual", "args", "options", "unsafeInterruptAsFork", "none", "onlyIfMissing", "addObserver", "exit", "isFailure", "propagateInterruption", "cause", "isInterruptedOnly", "Deferred", "unsafeDone", "set", "fiberIdWith", "sync", "unsafeGet", "fromNullable", "get", "suspend", "clear", "uninterruptibleMask", "restore", "zipRight", "constInterruptedFiber", "runFork", "interrupt", "run", "isEffect", "runImpl", "effect", "tap", "forkDaemon", "Promise", "resolve", "reject", "isSuccess", "value", "squash", "join", "await", "awaitEmpty", "TypeId", "awaitEmpty", "clear", "get", "has", "join", "make", "makeRuntime", "makeRuntimePromise", "remove", "run", "runtime", "runtimePromise", "set", "size", "unsafeGet", "unsafeSet", "TypeId", "Symbol", "for", "isFiberMap", "u", "hasProperty", "Proto", "iterator", "state", "_tag", "empty", "backing", "toString", "format", "toJSON", "_id", "NodeInspectSymbol", "pipe", "pipeArguments", "arguments", "unsafeMake", "deferred", "self", "Object", "create", "make", "acquireRelease", "map", "withFiberRuntime", "parent", "void", "interruptAllAs", "fiber", "combine", "id", "internalFiberId", "intoDeferred", "makeRuntime", "flatMap", "runtime", "makeRuntimePromise", "runtimePromise", "internalFiberIdId", "isInternalInterruption", "reduceWithContext", "undefined", "emptyCase", "constFalse", "failCase", "dieCase", "interruptCase", "_", "fiberId", "has", "ids", "sequentialCase", "left", "right", "parallelCase", "unsafeSet", "dual", "args", "key", "options", "unsafeInterruptAsFork", "interruptAs", "none", "previous", "get", "onlyIfMissing", "value", "MutableHashMap", "set", "addObserver", "exit", "current", "isSome", "remove", "isFailure", "propagateInterruption", "cause", "isInterruptedOnly", "Deferred", "unsafeDone", "fiberIdWith", "sync", "unsafeGet", "suspend", "unsafeHas", "removeFiber", "clear", "clearFiber", "forEach", "constInterruptedFiber", "runFork", "interrupt", "run", "isEffect", "runImpl", "effect", "tap", "forkDaemon", "Promise", "resolve", "reject", "isSuccess", "squash", "size", "join", "await", "awaitEmpty", "whileLoop", "while", "body", "unsafeHead", "step", "constVoid", "GroupByTypeId", "evaluate", "filter", "first", "make", "GroupByTypeId", "evaluate", "filter", "first", "make", "KeyedPoolTypeId", "get", "invalidate", "make", "makeWith", "makeWithTTL", "makeWithTTLBy", "KeyedPoolSymbolKey", "KeyedPoolTypeId", "Symbol", "for", "KeyedPoolMapValueSymbol", "keyedPoolVariance", "_K", "_", "_E", "_A", "KeyedPoolImpl", "getOrCreatePool", "activePools", "constructor", "get", "key", "flatMap", "invalidate", "item", "forEachSequentialDiscard", "pool", "pipe", "pipeArguments", "arguments", "Complete", "_tag", "symbol", "string", "combine", "hash", "cached", "u", "isComplete", "equals", "isTagged", "Pending", "deferred", "isPending", "makeImpl", "min", "max", "timeToLive", "all", "context", "fiberId", "sync", "make", "empty", "scopeMake", "map", "scope", "suspend", "value", "getOrUndefined", "undefined", "uninterruptibleMask", "restore", "deferredUnsafeMake", "previous", "has", "MutableRef", "update", "set", "scopeExtend", "makeWithTTL", "acquire", "provideContext", "getOrElse", "infinity", "matchCauseEffect", "onFailure", "cause", "current", "remove", "zipRight", "deferredFailCause", "failCause", "onSuccess", "as", "deferredSucceed", "succeed", "deferredAwait", "forEachSequential", "toValues", "options", "size", "none", "makeWith", "decode", "some", "makeWithTTLBy", "dual", "self", "KeyedPoolTypeId", "make", "makeWith", "makeWithTTL", "makeWithTTLBy", "get", "invalidate", "TypeId", "make", "TypeId", "get", "invalidate", "keys", "make", "touch", "TypeId", "Symbol", "for", "variance", "_K", "identity", "_A", "_E", "RcMapImpl", "lookup", "context", "scope", "idleTimeToLive", "capacity", "state", "_tag", "map", "empty", "semaphore", "unsafeMakeSemaphore", "constructor", "pipe", "pipeArguments", "arguments", "make", "options", "withFiberRuntime", "fiber", "getFiberRef", "currentContext", "get", "scopeTag", "self", "decode", "undefined", "Math", "max", "Number", "POSITIVE_INFINITY", "as", "addFinalizer", "suspend", "void", "forEachSequentialDiscard", "entry", "scopeClose", "exitVoid", "tap", "MutableHashMap", "clear", "withPermits", "dual", "self_", "key", "uninterruptibleMask", "restore", "getImpl", "fnUntraced", "interrupt", "o", "value", "refCount", "isFinite", "size", "fail", "ExceededCapacityException", "acquire", "finalizer", "deferredAwait", "deferred", "scopeMake", "deferredMake", "contextMap", "Map", "unsafeMap", "mapInputContext", "inputContext", "forEach", "set", "unsafeMake", "exit", "flatMap", "deferredDone", "forkIn", "expiresAt", "release", "clockWith", "clock", "has", "remove", "unsafeCurrentTimeMillis", "toMillis", "interruptibleMask", "loop", "now", "remaining", "sleep", "millis", "ensuring", "sync", "keys", "impl", "succeed", "invalidate", "interruptFiber", "touch", "TypeId", "make", "get", "keys", "invalidate", "touch", "TypeId", "Symbol", "for", "make", "fnUntraced", "lookup", "options", "context", "memoMap", "unsafeMap", "has", "CurrentMemoMap", "key", "get", "makeMemoMap", "rcMap", "scopeWith", "scope", "diffFiberRefs", "buildWithMemoMap", "pipe", "map", "patch", "layer", "scopedContext", "withFiberRuntime", "fiber", "unsafeGet", "currentContext", "Scope", "oldRefs", "getFiberRefs", "newRefs", "id", "revert", "diff", "setFiberRefs", "as", "addFinalizerExit", "void", "runtimeEffect", "fiberRefs", "succeed", "runtimeFlags", "defaultRuntime", "idleTimeToLive", "identity", "unwrapScoped", "runtime", "flatMap", "invalidate", "fromRecord", "layers", "Service", "Err", "globalThis", "Error", "limit", "stackTraceLimit", "creationError", "TagClass", "TagClass_", "Object", "setPrototypeOf", "getPrototypeOf", "GenericTag", "defineProperty", "stack", "DefaultWithoutDependencies", "scoped", "Default", "dependencies", "length", "provide", "layerMap", "any", "defined", "discriminator", "discriminatorStartsWith", "discriminators", "discriminatorsExhaustive", "either", "exhaustive", "instanceOf", "is", "nonEmptyString", "not", "option", "orElse", "orElseAbsurd", "string", "symbol", "tag", "tagStartsWith", "tags", "tagsExhaustive", "type", "typeTags", "value", "valueTags", "when", "whenAnd", "whenOr", "withReturnType", "TypeId", "Symbol", "for", "TypeMatcherProto", "_input", "identity", "_filters", "_remaining", "_result", "_return", "_tag", "add", "_case", "makeTypeMatcher", "cases", "pipe", "pipeArguments", "arguments", "matcher", "Object", "create", "ValueMatcherProto", "_provided", "value", "guard", "provided", "makeValueMatcher", "right", "evaluate", "makeWhen", "makeNot", "makePredicate", "pattern", "Array", "isArray", "predicates", "map", "len", "length", "u", "i", "keysAndPredicates", "entries", "k", "p", "key", "predicate", "makeOrPredicate", "patterns", "makeAndPredicate", "type", "left", "valueTags", "dual", "input", "fields", "match", "tagsExhaustive", "typeTags", "withReturnType", "self", "when", "f", "whenOr", "args", "onMatch", "slice", "whenAnd", "discriminator", "field", "values", "pred", "_", "includes", "discriminatorStartsWith", "startsWith", "discriminators", "arg", "data", "discriminatorsExhaustive", "addCases", "exhaustive", "tag", "tagStartsWith", "tags", "not", "nonEmptyString", "is", "literals", "any", "defined", "undefined", "instanceOf", "constructor", "orElse", "f", "self", "result", "either", "isEither", "_tag", "right", "left", "input", "a", "orElseAbsurd", "Error", "value", "len", "cases", "length", "_case", "guard", "evaluate", "i", "option", "toEither", "match", "onLeft", "none", "onRight", "some", "getExhaustiveAbsurdErrorMessage", "exhaustive", "u", "MatcherTypeId", "TypeId", "type", "value", "valueTags", "typeTags", "withReturnType", "when", "whenOr", "whenAnd", "discriminator", "discriminatorStartsWith", "discriminators", "discriminatorsExhaustive", "tag", "tagStartsWith", "tags", "tagsExhaustive", "not", "nonEmptyString", "is", "string", "isString", "number", "isNumber", "any", "defined", "boolean", "isBoolean", "_undefined", "isUndefined", "_null", "isNull", "bigint", "isBigInt", "symbol", "isSymbol", "date", "isDate", "record", "isRecord", "instanceOf", "instanceOfUnsafe", "orElse", "orElseAbsurd", "either", "option", "exhaustive", "SafeRefinementId", "Symbol", "for", "Fail", "BothRunning", "LeftDone", "MergeStateTypeId", "RightDone", "isBothRunning", "isLeftDone", "isMergeState", "isRightDone", "match", "MergeStateTypeId", "BothRunning", "LeftDone", "RightDone", "isMergeState", "isBothRunning", "isLeftDone", "isRightDone", "match", "BackPressure", "BufferSliding", "MergeStrategyTypeId", "isBackPressure", "isBufferSliding", "isMergeStrategy", "match", "MergeStrategyTypeId", "BackPressure", "BufferSliding", "isMergeStrategy", "isBackPressure", "isBufferSliding", "match", "MetricTypeId", "counter", "fiberActive", "fiberFailures", "fiberLifetimes", "fiberStarted", "fiberSuccesses", "frequency", "fromMetricKey", "gauge", "globalMetricRegistry", "histogram", "increment", "incrementBy", "make", "map", "mapInput", "mapType", "modify", "set", "snapshot", "succeed", "summary", "summaryTimestamp", "sync", "tagged", "taggedWithLabels", "taggedWithLabelsInput", "timer", "timerWithBoundaries", "trackAll", "trackDefect", "trackDefectWith", "trackDuration", "trackDurationWith", "trackError", "trackErrorWith", "trackSuccess", "trackSuccessWith", "unsafeSnapshot", "update", "value", "withConstantInput", "withNow", "zip", "MetricTypeId", "globalMetricRegistry", "make", "mapInput", "counter", "frequency", "withConstantInput", "fromMetricKey", "gauge", "histogram", "increment", "incrementBy", "map", "mapType", "modify", "set", "snapshot", "succeed", "sync", "summary", "summaryTimestamp", "tagged", "taggedWithLabelsInput", "taggedWithLabels", "timer", "timerWithBoundaries", "trackAll", "trackDefect", "trackDefectWith", "trackDuration", "trackDurationWith", "trackError", "trackErrorWith", "trackSuccess", "trackSuccessWith", "update", "value", "withNow", "zip", "unsafeSnapshot", "fiberStarted", "fiberSuccesses", "fiberFailures", "fiberLifetimes", "fiberActive", "MetricBoundariesTypeId", "exponential", "fromIterable", "isMetricBoundaries", "linear", "MetricBoundariesTypeId", "isMetricBoundaries", "fromIterable", "linear", "exponential", "MetricHookTypeId", "counter", "frequency", "gauge", "histogram", "make", "onModify", "onUpdate", "summary", "MetricHookTypeId", "make", "counter", "frequency", "gauge", "histogram", "summary", "onUpdate", "onModify", "MetricKeyTypeId", "counter", "frequency", "gauge", "histogram", "isMetricKey", "summary", "tagged", "taggedWithLabels", "MetricKeyTypeId", "isMetricKey", "counter", "frequency", "gauge", "histogram", "summary", "tagged", "taggedWithLabels", "CounterKeyTypeTypeId", "FrequencyKeyTypeTypeId", "GaugeKeyTypeTypeId", "HistogramKeyTypeTypeId", "MetricKeyTypeTypeId", "SummaryKeyTypeTypeId", "counter", "frequency", "gauge", "histogram", "isCounterKey", "isFrequencyKey", "isGaugeKey", "isHistogramKey", "isMetricKeyType", "isSummaryKey", "summary", "MetricKeyTypeTypeId", "CounterKeyTypeTypeId", "FrequencyKeyTypeTypeId", "GaugeKeyTypeTypeId", "HistogramKeyTypeTypeId", "SummaryKeyTypeTypeId", "counter", "frequency", "gauge", "histogram", "summary", "isMetricKeyType", "isCounterKey", "isFrequencyKey", "isGaugeKey", "isHistogramKey", "isSummaryKey", "MetricLabelTypeId", "isMetricLabel", "make", "MetricLabelTypeId", "make", "isMetricLabel", "MetricPairTypeId", "make", "unsafeMake", "MetricPairTypeId", "make", "unsafeMake", "MetricPollingTypeId", "collectAll", "launch", "make", "poll", "pollAndUpdate", "retry", "zip", "MetricPollingSymbolKey", "MetricPollingTypeId", "Symbol", "for", "make", "metric", "poll", "pipe", "pipeArguments", "arguments", "collectAll", "iterable", "metrics", "Array", "from", "of", "inputs", "extraTags", "i", "length", "pollingMetric", "input", "x", "unsafeUpdate", "map", "unsafeValue", "unsafeModify", "forEachSequential", "launch", "dual", "self", "schedule", "pollAndUpdate", "zipRight", "value", "scheduleForked", "flatMap", "update", "retry", "policy", "retry_Effect", "zip", "that", "MetricPollingTypeId", "make", "collectAll", "launch", "poll", "pollAndUpdate", "retry", "zip", "MetricRegistryTypeId", "make", "MetricRegistryTypeId", "make", "CounterStateTypeId", "FrequencyStateTypeId", "GaugeStateTypeId", "HistogramStateTypeId", "MetricStateTypeId", "SummaryStateTypeId", "counter", "frequency", "gauge", "histogram", "isCounterState", "isFrequencyState", "isGaugeState", "isHistogramState", "isMetricState", "isSummaryState", "summary", "MetricStateTypeId", "CounterStateTypeId", "FrequencyStateTypeId", "GaugeStateTypeId", "HistogramStateTypeId", "SummaryStateTypeId", "counter", "frequency", "gauge", "histogram", "summary", "isMetricState", "isCounterState", "isFrequencyState", "isGaugeState", "isHistogramState", "isSummaryState", "getCurrentVersion", "setCurrentVersion", "getCurrentVersion", "setCurrentVersion", "add", "clear", "empty", "fromIterable", "has", "make", "remove", "size", "TypeId", "Symbol", "for", "MutableHashSetProto", "iterator", "Array", "from", "keyMap", "map", "_", "toString", "format", "toJSON", "_id", "values", "NodeInspectSymbol", "pipe", "pipeArguments", "arguments", "fromHashMap", "set", "Object", "create", "empty", "fromIterable", "keys", "k", "make", "add", "dual", "self", "key", "has", "remove", "size", "clear", "unprepend", "self", "iterator", "Symbol", "next", "done", "Error", "value", "combine", "match", "reverse", "o", "match", "dual", "self", "onEqual", "onGreaterThan", "onLessThan", "combine", "that", "combineMany", "collection", "ordering", "combineAll", "make", "match", "make", "schema", "compile", "ast", "getPrettyAnnotation", "getAnnotation", "PrettyAnnotationId", "getMatcher", "defaultPretty", "match", "onNone", "onSome", "handler", "toString", "a", "String", "stringify", "JSON", "formatUnknown", "Declaration", "go", "path", "annotation", "isSome", "value", "typeParameters", "map", "tp", "Error", "getPrettyMissingAnnotationErrorMessage", "getPrettyNeverErrorMessage", "literal", "TupleType", "hook", "elements", "e", "i", "type", "concat", "rest", "annotatedAST", "input", "output", "length", "isOptional", "push", "isNonEmptyReadonlyArray", "head", "tail", "j", "join", "TypeLiteral", "propertySignaturesTypes", "propertySignatures", "ps", "name", "indexSignatureTypes", "indexSignatures", "is", "expectedKeys", "Object", "prototype", "hasOwnProperty", "call", "formatPropertyKey", "keys", "getKeysForIndexSignature", "parameter", "key", "Union", "types", "index", "findIndex", "getPrettyNoMatchingSchemaErrorMessage", "Suspend", "get", "memoizeThunk", "f", "Refinement", "from", "Transformation", "to", "getCompiler", "make", "withCost", "make", "algorithm", "interval", "limit", "fixedWindow", "tokenBucket", "window", "gen", "millisPerToken", "Math", "ceil", "toMillis", "semaphore", "makeSemaphore", "latch", "refill", "sleep", "pipe", "zipRight", "releaseAll", "release", "flatMap", "free", "void", "take", "forever", "forkScoped", "interruptible", "uninterruptibleMask", "restore", "get", "currentCost", "cost", "effect", "globalValue", "Symbol", "for", "unsafeMake", "withCost", "locally", "make", "withCost", "ReloadableTypeId", "auto", "autoFromConfig", "get", "manual", "reload", "reloadFork", "tag", "ScopedRefSymbolKey", "ScopedRefTypeId", "Symbol", "for", "scopedRefVariance", "_A", "_", "proto", "CommitPrototype", "commit", "get", "close", "self", "flatMap", "ref", "tuple", "exitVoid", "fromAcquire", "acquire", "uninterruptible", "scopeMake", "pipe", "newScope", "mapInputContext", "add", "scopeTag", "onError", "cause", "exitFail", "value", "makeSynchronized", "scopedRef", "Object", "create", "addFinalizer", "as", "map", "make", "evaluate", "sync", "set", "dual", "flatten", "modifyEffect", "oldScope", "scopeClose", "zipRight", "exit", "scopeExtend", "exitMatch", "onFailure", "failCause", "onSuccess", "succeed", "void", "ReloadableSymbolKey", "ReloadableTypeId", "Symbol", "for", "reloadableVariance", "_A", "_", "auto", "tag", "options", "scoped", "reloadableTag", "pipe", "build", "manual", "layer", "map", "unsafeGet", "tap", "reloadable", "acquireRelease", "reload", "ignoreLogged", "schedule_Effect", "schedule", "forkDaemon", "interruptFiber", "autoFromConfig", "context", "flatMap", "env", "scheduleFromConfig", "get", "scopedRef", "fromAcquire", "ref", "set", "provideContext", "GenericTag", "key", "reloadFork", "asVoid", "ReloadableTypeId", "auto", "autoFromConfig", "get", "manual", "reload", "tag", "reloadableTag", "reloadFork", "empty", "mapRequestResolvers", "reduce", "single", "single", "empty", "mapRequestResolvers", "parallel", "par", "reduce", "sequential", "seq", "RequestResolverTypeId", "around", "aroundRequests", "batchN", "eitherWith", "fromEffect", "fromEffectTagged", "fromFunction", "fromFunctionBatched", "isRequestResolver", "locally", "make", "makeBatched", "makeWithEntry", "mapInputContext", "never", "provideContext", "race", "make", "runAll", "RequestResolverImpl", "requests", "map", "_", "request", "makeWithEntry", "makeBatched", "run", "length", "forEachSequentialDiscard", "block", "filtered", "filter", "state", "completed", "isNonEmptyArray", "void", "invokeWithInterrupt", "around", "dual", "self", "before", "after", "acquireUseRelease", "aroundRequests", "flatRequests", "flatMap", "chunk", "entry", "a2", "batchN", "n", "die", "IllegalArgumentException", "Array", "from", "reduce", "empty", "acc", "appendAll", "chunksOf", "unsafeFromArray", "mapInputContext", "f", "context", "eitherWith", "that", "batch", "pipe", "forEachSequential", "as", "bs", "partitionMap", "zipWithOptions", "of", "concurrent", "fromFunction", "complete", "exitSucceed", "identified", "fromFunctionBatched", "forEach", "res", "i", "discard", "fromEffect", "a", "exit", "e", "concurrency", "fromEffectTagged", "fns", "grouped", "tags", "len", "includes", "_tag", "push", "tag", "matchCauseEffect", "onFailure", "cause", "req", "exitFail", "onSuccess", "never", "provideContext", "race", "RequestResolverTypeId", "contextFromEffect", "self", "contextWith", "_", "provideContext", "contextFromServices", "services", "pick", "isRequestResolver", "make", "makeWithEntry", "makeBatched", "around", "aroundRequests", "batchN", "mapInputContext", "eitherWith", "fromFunction", "fromFunctionBatched", "fromEffect", "fromEffectTagged", "never", "race", "locally", "resolverLocally", "ResourceTypeId", "auto", "get", "manual", "refresh", "ResourceSymbolKey", "ResourceTypeId", "Symbol", "for", "resourceVariance", "_E", "_", "_A", "proto", "CommitPrototype", "commit", "get", "auto", "acquire", "policy", "tap", "manual", "acquireRelease", "pipe", "refresh", "schedule_Effect", "interruptible", "forkDaemon", "interruptFiber", "flatMap", "context", "env", "fromAcquire", "exit", "map", "ref", "resource", "Object", "create", "scopedRef", "provideContext", "self", "identity", "set", "exitSucceed", "ResourceTypeId", "auto", "get", "manual", "refresh", "CooperativeYielding", "Interruption", "None", "OpSupervision", "RuntimeMetrics", "WindDown", "cooperativeYielding", "diff", "differ", "disable", "disableAll", "disableCooperativeYielding", "disableInterruption", "disableOpSupervision", "disableRuntimeMetrics", "disableWindDown", "enable", "enableAll", "enableCooperativeYielding", "enableInterruption", "enableOpSupervision", "enableRuntimeMetrics", "enableWindDown", "interruptible", "interruption", "isDisabled", "isEnabled", "make", "none", "opSupervision", "patch", "render", "runtimeMetrics", "toSet", "windDown", "None", "Interruption", "OpSupervision", "RuntimeMetrics", "WindDown", "CooperativeYielding", "cooperativeYielding", "diff", "differ", "disable", "disableAll", "disableCooperativeYielding", "disableInterruption", "disableOpSupervision", "disableRuntimeMetrics", "disableWindDown", "enable", "enableAll", "enableCooperativeYielding", "enableInterruption", "enableOpSupervision", "enableRuntimeMetrics", "enableWindDown", "interruptible", "interruption", "isEnabled", "isDisabled", "make", "none", "opSupervision", "patch", "render", "runtimeMetrics", "toSet", "windDown", "STMTypeId", "acquireUseRelease", "all", "as", "asSome", "asSomeError", "asVoid", "attempt", "bind", "bindTo", "catchAll", "catchSome", "catchTag", "catchTags", "check", "collect", "collectSTM", "commit", "commitEither", "cond", "context", "contextWith", "contextWithSTM", "die", "dieMessage", "dieSync", "either", "ensuring", "eventually", "every", "exists", "fail", "failSync", "fiberId", "filter", "filterNot", "filterOrDie", "filterOrDieMessage", "filterOrElse", "filterOrFail", "flatMap", "flatten", "flip", "flipWith", "forEach", "fromEither", "fromOption", "gen", "head", "if_", "ignore", "interrupt", "interruptAs", "isFailure", "isSTM", "isSuccess", "iterate", "let_", "loop", "map", "mapAttempt", "mapBoth", "mapError", "mapInputContext", "match", "matchSTM", "merge", "mergeAll", "negate", "none", "option", "orDie", "orDieWith", "orElse", "orElseEither", "orElseFail", "orElseOptional", "orElseSucceed", "orTry", "partition", "provideContext", "provideService", "provideServiceSTM", "provideSomeContext", "reduce", "reduceAll", "reduceRight", "refineOrDie", "refineOrDieWith", "reject", "rejectSTM", "repeatUntil", "repeatWhile", "replicate", "replicateSTM", "replicateSTMDiscard", "retry", "retryUntil", "retryWhile", "some", "succeed", "succeedNone", "succeedSome", "summarized", "suspend", "sync", "tap", "tapBoth", "tapError", "try_", "unless", "unlessSTM", "unsome", "validateAll", "validateFirst", "void_", "when", "whenSTM", "zip", "zipLeft", "zipRight", "zipWith", "STMTypeId", "isSTM", "acquireUseRelease", "all", "as", "asSome", "asSomeError", "asVoid", "attempt", "catchAll", "catchSome", "catchTag", "catchTags", "check", "collect", "collectSTM", "commit", "commitEither", "cond", "context", "contextWith", "contextWithSTM", "mapInputContext", "die", "dieMessage", "dieSync", "either", "ensuring", "eventually", "every", "exists", "fail", "failSync", "fiberId", "filter", "filterNot", "filterOrDie", "filterOrDieMessage", "filterOrElse", "filterOrFail", "flatMap", "flatten", "flip", "flipWith", "match", "matchSTM", "forEach", "fromEither", "fromOption", "gen", "head", "if_", "ignore", "interrupt", "interruptAs", "isFailure", "isSuccess", "iterate", "loop", "map", "mapAttempt", "mapBoth", "mapError", "merge", "mergeAll", "negate", "none", "option", "orDie", "orDieWith", "orElse", "orElseEither", "orElseFail", "orElseOptional", "orElseSucceed", "orTry", "partition", "provideContext", "provideSomeContext", "provideService", "provideServiceSTM", "reduce", "reduceAll", "reduceRight", "refineOrDie", "refineOrDieWith", "reject", "rejectSTM", "repeatUntil", "repeatWhile", "replicate", "replicateSTM", "replicateSTMDiscard", "retry", "retryUntil", "retryWhile", "some", "succeed", "succeedNone", "succeedSome", "summarized", "suspend", "sync", "tap", "tapBoth", "tapError", "try_", "unless", "unlessSTM", "unsome", "void_", "void", "validateAll", "validateFirst", "when", "whenSTM", "zip", "zipLeft", "zipRight", "zipWith", "firstSuccessOf", "effects", "suspend", "list", "fromIterable", "isNonEmpty", "dieSync", "IllegalArgumentException", "reduce", "tailNonEmpty", "headNonEmpty", "left", "right", "orElse", "Do", "succeed", "bind", "let_", "bindTo", "ScopedCacheTypeId", "make", "makeWith", "makeCacheState", "map", "keys", "accesses", "updating", "hits", "misses", "initialCacheState", "empty", "makeKeySet", "unbounded", "make", "complete", "key", "exit", "ownerCount", "entryStats", "timeToLive", "struct", "_tag", "pending", "scoped", "refreshing", "toScoped", "self", "matchEffect", "onFailure", "cause", "failCause", "onSuccess", "value", "acquireRelease", "as", "sync", "incrementAndGet", "releaseOwner", "void", "finalizer", "flatMap", "decrementAndGet", "numOwner", "when", "ScopedCacheSymbolKey", "ScopedCacheTypeId", "Symbol", "for", "scopedCacheVariance", "_Key", "_", "_Error", "_Value", "ScopedCacheImpl", "capacity", "scopedLookup", "clock", "context", "cacheState", "constructor", "pipe", "pipeArguments", "arguments", "cacheStats", "makeCacheStats", "size", "getOption", "suspend", "match", "get", "onNone", "succeedNone", "onSome", "flatten", "resolveMapValue", "getOptionComplete", "contains", "has", "getOrUndefined", "undefined", "none", "some", "makeEntryStats", "loadedMillis", "lookupValueOf", "memoize", "lookupValue", "k", "makeMapKey", "MutableHashMap", "set", "trackMiss", "zipRight", "ensureMapSizeNotExceeded", "val", "current", "equals", "remove", "succeed", "invalidate", "mapValue", "invalidateAll", "forEachConcurrentDiscard", "fromIterable", "Array", "from", "refresh", "newKey", "finalScoped", "hasExpired", "s", "scopedEffect", "asVoid", "ignorePending", "trackHit", "asSome", "onInterrupt", "scope", "provideContext", "add", "Scope", "close", "release", "now", "unsafeCurrentTimeMillis", "expiredAt", "toMillis", "exitWithFinalizer", "completedResult", "previousValue", "cleanMapValue", "trackAccess", "cleanedKeys", "MutableQueue", "offer", "compareAndSet", "loop", "poll", "EmptyMutableQueue", "removed", "push", "MutableRef", "cleanedMapValue", "options", "decode", "makeWith", "lookup", "buildWith", "cache", "ScopedCacheTypeId", "make", "makeWith", "ScopedRefTypeId", "fromAcquire", "get", "make", "set", "ScopedRefTypeId", "fromAcquire", "get", "make", "set", "SecretTypeId", "fromIterable", "fromString", "isSecret", "make", "unsafeWipe", "value", "SecretTypeId", "isSecret", "make", "fromIterable", "fromString", "value", "unsafeWipe", "make", "make", "empty", "fromIterable", "get", "getOrder", "has", "isEmpty", "isNonEmpty", "keys", "make", "map", "partition", "reduce", "remove", "set", "size", "values", "TypeId", "Symbol", "for", "SortedMapProto", "_K", "_", "_V", "symbol", "pipe", "hash", "tree", "combine", "cached", "that", "isSortedMap", "equals", "iterator", "toString", "format", "toJSON", "_id", "values", "Array", "from", "map", "NodeInspectSymbol", "pipeArguments", "arguments", "makeImpl", "self", "Object", "create", "u", "hasProperty", "empty", "ord", "fromIterable", "dual", "iterable", "make", "entries", "isEmpty", "size", "isNonEmpty", "get", "key", "findFirst", "getOrder", "has", "isSome", "headOption", "first", "f", "reduce", "acc", "v", "k", "set", "zero", "remove", "removeFirst", "value", "insert", "keys", "lastOption", "last", "partition", "predicate", "right", "left", "Class", "streamVariance", "_R", "_", "_E", "_A", "Class", "StreamTypeId", "pipe", "pipeArguments", "arguments", "channel", "toChannel", "toStream", "TypeId", "make", "map", "mapEffect", "unwrap", "TypeId", "Symbol", "for", "isSubscribable", "u", "hasProperty", "Proto", "pipe", "pipeArguments", "arguments", "make", "options", "Object", "assign", "create", "map", "dual", "self", "f", "get", "changes", "mapEffect", "flatMap", "unwrap", "effect", "s", "SubscriptionRefTypeId", "get", "getAndSet", "getAndUpdate", "getAndUpdateEffect", "getAndUpdateSome", "getAndUpdateSomeEffect", "make", "modify", "modifyEffect", "modifySome", "modifySomeEffect", "set", "setAndGet", "update", "updateAndGet", "updateAndGetEffect", "updateEffect", "updateSome", "updateSomeAndGet", "updateSomeAndGetEffect", "updateSomeEffect", "get", "getAndSet", "getAndUpdate", "getAndUpdateEffect", "getAndUpdateSome", "getAndUpdateSomeEffect", "make", "modify", "modifyEffect", "modifySome", "modifySomeEffect", "set", "setAndGet", "unsafeMake", "update", "updateAndGet", "updateAndGetEffect", "updateEffect", "updateSome", "updateSomeAndGet", "updateSomeEffect", "SynchronizedRefTypeId", "SynchronizedTypeId", "make", "makeSynchronized", "get", "getAndSet", "getAndUpdate", "getAndUpdateEffect", "getAndUpdateSome", "getAndUpdateSomeEffect", "modify", "modifyEffect", "modifySome", "modifySomeEffect", "set", "setAndGet", "update", "updateEffect", "updateAndGet", "updateAndGetEffect", "updateSome", "updateSomeEffect", "updateSomeAndGet", "updateSomeAndGetEffect", "updateSomeAndGetEffectSynchronized", "unsafeMake", "unsafeMakeSynchronized", "SubscriptionRefSymbolKey", "SubscriptionRefTypeId", "Symbol", "for", "subscriptionRefVariance", "_A", "_", "SubscriptionRefImpl", "Class", "ref", "pubsub", "semaphore", "TypeId", "RefTypeId", "refVariance", "SynchronizedRefTypeId", "synchronizedVariance", "constructor", "get", "commit", "changes", "pipe", "flatMap", "a", "map", "fromPubSub", "scoped", "s", "concat", "make", "withPermits", "unwrapScoped", "modify", "f", "modifyEffect", "succeed", "b", "set", "as", "zipLeft", "publish", "self", "value", "all", "unbounded", "makeSemaphore", "dual", "SubscriptionRefTypeId", "get", "getAndSet", "getAndUpdate", "getAndUpdateEffect", "getAndUpdateSome", "getAndUpdateSomeEffect", "make", "modify", "modifyEffect", "modifySome", "modifySomeEffect", "set", "setAndGet", "update", "updateEffect", "updateAndGet", "updateAndGetEffect", "updateSome", "updateSomeEffect", "updateSomeAndGet", "updateSomeAndGetEffect", "SupervisorTypeId", "addSupervisor", "fibersIn", "fromEffect", "none", "track", "unsafeTrack", "SupervisorTypeId", "addSupervisor", "fibersIn", "fromEffect", "none", "track", "unsafeTrack", "AbstractSupervisor", "onStart", "_context", "_effect", "_parent", "_fiber", "onEnd", "_value", "onEffect", "onSuspend", "onResume", "map", "f", "ProxySupervisor", "value", "zip", "right", "Zip", "onRun", "execution", "supervisorVariance", "isSymbol", "isSymbol", "Equivalence", "symbol", "TArrayTypeId", "collectFirst", "collectFirstSTM", "contains", "count", "countSTM", "empty", "every", "everySTM", "findFirst", "findFirstIndex", "findFirstIndexFrom", "findFirstIndexWhere", "findFirstIndexWhereFrom", "findFirstIndexWhereFromSTM", "findFirstIndexWhereSTM", "findFirstSTM", "findLast", "findLastIndex", "findLastIndexFrom", "findLastSTM", "forEach", "fromIterable", "get", "headOption", "lastOption", "make", "maxOption", "minOption", "reduce", "reduceOption", "reduceOptionSTM", "reduceSTM", "size", "some", "someSTM", "toArray", "transform", "transformSTM", "update", "updateSTM", "TArraySymbolKey", "TArrayTypeId", "Symbol", "for", "tArrayVariance", "_A", "_", "TArrayImpl", "chunk", "constructor", "collectFirst", "dual", "self", "pf", "collectFirstSTM", "a", "pipe", "map", "succeed", "withSTMRuntime", "runtime", "index", "result", "none", "isNone", "length", "element", "unsafeGet", "journal", "option", "isSome", "match", "onNone", "succeedNone", "onSome", "some", "contains", "value", "equals", "count", "predicate", "reduce", "n", "countSTM", "reduceSTM", "bool", "empty", "fromIterable", "every", "negate", "everySTM", "findFirst", "findFirstIndex", "findFirstIndexFrom", "from", "findFirstIndexWhereFrom", "findFirstIndexWhere", "effect", "found", "findFirstIndexWhereSTM", "findFirstIndexWhereFromSTM", "forIndex", "get", "flatMap", "findFirstSTM", "init", "cont", "state", "iterate", "while", "body", "findLast", "findLastIndex", "findLastIndexFrom", "end", "findLastSTM", "forEach", "f", "iterable", "make", "dieMessage", "headOption", "lastOption", "elements", "maxOption", "order", "greaterThan", "reduceOption", "acc", "curr", "minOption", "lessThan", "zero", "undefined", "fromNullable", "reduceOptionSTM", "succeedSome", "toArray", "size", "someSTM", "transform", "ref", "tRef", "unsafeSet", "transformSTM", "iterator", "next", "done", "update", "updateSTM", "updated", "set", "TArrayTypeId", "collectFirst", "collectFirstSTM", "contains", "count", "countSTM", "empty", "every", "everySTM", "findFirst", "findFirstIndex", "findFirstIndexFrom", "findFirstIndexWhere", "findFirstIndexWhereFrom", "findFirstIndexWhereSTM", "findFirstIndexWhereFromSTM", "findFirstSTM", "findLast", "findLastIndex", "findLastIndexFrom", "findLastSTM", "forEach", "fromIterable", "get", "headOption", "lastOption", "make", "maxOption", "minOption", "reduce", "reduceOption", "reduceOptionSTM", "reduceSTM", "size", "some", "someSTM", "toArray", "transform", "transformSTM", "update", "updateSTM", "TDeferredTypeId", "_await", "done", "fail", "make", "poll", "succeed", "TDeferredSymbolKey", "TDeferredTypeId", "Symbol", "for", "tDeferredVariance", "_A", "_", "_E", "TDeferredImpl", "ref", "constructor", "_await", "self", "flatten", "collect", "get", "option", "isSome", "some", "fromEither", "value", "none", "done", "dual", "either", "flatMap", "match", "onNone", "zipRight", "set", "succeed", "onSome", "fail", "error", "left", "make", "map", "poll", "right", "TDeferredTypeId", "_await", "done", "fail", "make", "poll", "succeed", "TMapTypeId", "empty", "find", "findAll", "findAllSTM", "findSTM", "forEach", "fromIterable", "get", "getOrElse", "has", "isEmpty", "keys", "make", "merge", "reduce", "reduceSTM", "remove", "removeAll", "removeIf", "retainIf", "set", "setIfAbsent", "size", "takeFirst", "takeFirstSTM", "takeSome", "takeSomeSTM", "toArray", "toChunk", "toHashMap", "toMap", "transform", "transformSTM", "transformValues", "transformValuesSTM", "updateWith", "values", "TMapSymbolKey", "TMapTypeId", "Symbol", "for", "tMapVariance", "_K", "_", "_V", "TMapImpl", "tBuckets", "tSize", "constructor", "isTMap", "u", "hasProperty", "InitialCapacity", "LoadFactor", "nextPowerOfTwo", "size", "n", "Math", "clz32", "hash", "key", "h", "indexOf", "k", "capacity", "allocate", "data", "buckets", "Array", "from", "length", "empty", "distinct", "Map", "entry", "index", "pipe", "prepend", "fromIterable", "flatMap", "make", "map", "find", "dual", "self", "pf", "findSTM", "value", "option", "isSome", "succeed", "fail", "none", "f", "reduceSTM", "acc", "isNone", "matchSTM", "onFailure", "match", "onNone", "succeedNone", "onSome", "onSuccess", "succeedSome", "findAll", "findAllSTM", "a", "append", "forEach", "asVoid", "iterable", "suspend", "get", "effect", "journal", "unsafeGet", "chunk", "bucket", "findFirst", "equals", "getOrElse", "fallback", "has", "isEmpty", "keys", "toReadonlyArray", "entries", "merge", "as", "set", "v0", "v1", "reduce", "zero", "result", "items", "remove", "toRemove", "toRetain", "partition", "isNonEmpty", "currentSize", "tRef", "unsafeSet", "removeAll", "iterator", "next", "done", "removeIf", "args", "predicate", "options", "discard", "removed", "newSize", "newBucket", "v", "push", "retainIf", "resize", "newCapacity", "newBuckets", "pairs", "newIndex", "newArray", "TRefImpl", "newTArray", "TArrayImpl", "shouldUpdate", "some", "setIfAbsent", "void", "takeFirst", "recreate", "collect", "takeFirstSTM", "takeSome", "builder", "takeSomeSTM", "isNonEmptyArray", "toChunk", "toHashMap", "toArray", "unshift", "toMap", "transform", "newPair", "transformSTM", "newData", "transformValues", "transformValuesSTM", "updateWith", "values", "TMapTypeId", "empty", "find", "findSTM", "findAll", "findAllSTM", "forEach", "fromIterable", "get", "getOrElse", "has", "isEmpty", "keys", "make", "merge", "reduce", "reduceSTM", "remove", "removeAll", "removeIf", "retainIf", "set", "setIfAbsent", "size", "takeFirst", "takeFirstSTM", "takeSome", "takeSomeSTM", "toChunk", "toHashMap", "toArray", "toMap", "transform", "transformSTM", "transformValues", "transformValuesSTM", "updateWith", "values", "TPriorityQueueTypeId", "empty", "fromIterable", "isEmpty", "isNonEmpty", "make", "offer", "offerAll", "peek", "peekOption", "removeIf", "retainIf", "size", "take", "takeAll", "takeOption", "takeUpTo", "toArray", "toChunk", "TPriorityQueueSymbolKey", "TPriorityQueueTypeId", "Symbol", "for", "tPriorityQueueVariance", "_A", "_", "TPriorityQueueImpl", "ref", "constructor", "empty", "order", "pipe", "make", "map", "fromIterable", "iterable", "reduce", "value", "set", "get", "match", "onNone", "of", "onSome", "prepend", "isEmpty", "self", "isNonEmpty", "elements", "offer", "dual", "update", "offerAll", "values", "peek", "withSTMRuntime", "runtime", "unsafeGet", "journal", "headOption", "retry", "succeed", "peekOption", "modify", "removeIf", "predicate", "retainIf", "a", "getOrder", "key", "filtered", "filter", "length", "remove", "size", "n", "as", "take", "head", "tail", "slice", "tRef", "unsafeSet", "takeAll", "builder", "entry", "push", "takeOption", "effect", "none", "some", "takeUpTo", "iterator", "updated", "index", "next", "done", "left", "right", "splitAt", "toChunk", "unsafeFromArray", "toArray", "TPriorityQueueTypeId", "empty", "fromIterable", "isEmpty", "isNonEmpty", "make", "offer", "offerAll", "peek", "peekOption", "removeIf", "retainIf", "size", "take", "takeAll", "takeOption", "takeUpTo", "toChunk", "toArray", "TRandomTypeId", "Tag", "live", "next", "nextBoolean", "nextInt", "nextIntBetween", "nextRange", "shuffle", "TRandomSymbolKey", "TRandomTypeId", "Symbol", "for", "randomInteger", "state", "prng", "PCGRandom", "setState", "integer", "getState", "randomIntegerBetween", "low", "high", "randomNumber", "number", "withState", "f", "pipe", "modify", "shuffleWith", "iterable", "nextIntBounded", "swap", "buffer", "index1", "index2", "get", "flatMap", "tmp", "updateSTM", "zipRight", "update", "fromIterable", "array", "i", "length", "push", "forEach", "n", "k", "discard", "toArray", "Tag", "GenericTag", "TRandomImpl", "constructor", "next", "nextBoolean", "succeed", "nextInt", "nextRange", "min", "max", "nextIntBetween", "shuffle", "elements", "live", "effect", "make", "Math", "random", "map", "seed", "commit", "TRandomTypeId", "Tag", "live", "next", "nextBoolean", "nextInt", "nextIntBetween", "nextRange", "shuffle", "TReentrantLockTypeId", "acquireRead", "acquireWrite", "fiberReadLocks", "fiberWriteLocks", "lock", "locked", "make", "readLock", "readLocked", "readLocks", "releaseRead", "releaseWrite", "withLock", "withReadLock", "withWriteLock", "writeLock", "writeLocked", "writeLocks", "TReentrantLockSymbolKey", "TReentrantLockTypeId", "Symbol", "for", "WriteLockTypeId", "ReadLockTypeId", "TReentranLockImpl", "state", "constructor", "ReadLock", "readers", "readLocks", "Array", "from", "reduce", "acc", "curr", "writeLocks", "readLocksHeld", "fiberId", "getOrElse", "get", "writeLocksHeld", "_fiberId", "WriteLock", "equals", "isReadLock", "lock", "isWriteLock", "emptyReadLock", "empty", "makeReadLock", "count", "make", "noOtherHolder", "readLock", "isEmpty", "size", "has", "adjustReadLock", "adjustment", "total", "newTotal", "Error", "remove", "set", "adjustRead", "self", "delta", "withSTMRuntime", "runtime", "unsafeGet", "journal", "result", "tRef", "unsafeSet", "succeed", "threadName", "retry", "acquireRead", "acquireWrite", "fiberReadLocks", "effect", "fiberWriteLocks", "writeLock", "locked", "zipWith", "readLocked", "writeLocked", "x", "y", "map", "acquireRelease", "commit", "releaseRead", "releaseWrite", "withLock", "dual", "withWriteLock", "withReadLock", "uninterruptibleMask", "restore", "zipRight", "ensuring", "TReentrantLockTypeId", "acquireRead", "acquireWrite", "fiberReadLocks", "fiberWriteLocks", "lock", "locked", "make", "readLock", "readLocks", "readLocked", "releaseRead", "releaseWrite", "withLock", "withReadLock", "withWriteLock", "writeLock", "writeLocked", "writeLocks", "TRefTypeId", "get", "getAndSet", "getAndUpdate", "getAndUpdateSome", "make", "modify", "modifySome", "set", "setAndGet", "update", "updateAndGet", "updateSome", "updateSomeAndGet", "TRefTypeId", "get", "getAndSet", "getAndUpdate", "getAndUpdateSome", "make", "modify", "modifySome", "set", "setAndGet", "update", "updateAndGet", "updateSome", "updateSomeAndGet", "TSemaphoreTypeId", "acquire", "acquireN", "available", "make", "release", "releaseN", "unsafeMake", "withPermit", "withPermitScoped", "withPermits", "withPermitsScoped", "TSemaphoreSymbolKey", "TSemaphoreTypeId", "Symbol", "for", "TSemaphoreImpl", "permits", "constructor", "make", "map", "acquire", "self", "acquireN", "dual", "n", "withSTMRuntime", "driver", "IllegalArgumentException", "value", "unsafeGet", "journal", "retry", "succeed", "unsafeSet", "available", "get", "release", "releaseN", "current", "withPermit", "semaphore", "withPermits", "uninterruptibleMask", "restore", "zipRight", "commit", "ensuring", "withPermitScoped", "withPermitsScoped", "acquireReleaseInterruptible", "unsafeMakeSemaphore", "TRefImpl", "TSemaphoreTypeId", "acquire", "acquireN", "available", "make", "release", "releaseN", "withPermit", "withPermits", "withPermitScoped", "withPermitsScoped", "unsafeMake", "unsafeMakeSemaphore", "TSetTypeId", "add", "difference", "empty", "forEach", "fromIterable", "has", "intersection", "isEmpty", "make", "reduce", "reduceSTM", "remove", "removeAll", "removeIf", "retainIf", "size", "takeFirst", "takeFirstSTM", "takeSome", "takeSomeSTM", "toArray", "toChunk", "toHashSet", "toReadonlySet", "transform", "transformSTM", "union", "TSetSymbolKey", "TSetTypeId", "Symbol", "for", "tSetVariance", "_A", "_", "TSetImpl", "tMap", "constructor", "isTSet", "u", "hasProperty", "add", "dual", "self", "value", "set", "difference", "other", "flatMap", "toHashSet", "values", "removeIf", "has", "discard", "empty", "fromIterable", "forEach", "f", "reduceSTM", "iterable", "map", "Array", "from", "a", "intersection", "pipe", "retainIf", "isEmpty", "make", "elements", "reduce", "zero", "acc", "key", "remove", "removeAll", "args", "predicate", "options", "entry", "size", "toChunk", "chunk", "length", "takeFirst", "pf", "takeFirstSTM", "takeSome", "takeSomeSTM", "keys", "unsafeFromArray", "toArray", "toReadonlySet", "Set", "transform", "transformSTM", "union", "TSetTypeId", "add", "difference", "empty", "forEach", "fromIterable", "has", "intersection", "isEmpty", "make", "reduce", "reduceSTM", "remove", "removeAll", "removeIf", "retainIf", "size", "takeFirst", "takeFirstSTM", "takeSome", "takeSomeSTM", "toChunk", "toHashSet", "toArray", "toReadonlySet", "transform", "transformSTM", "union", "TSubscriptionRefTypeId", "changesScoped", "changesStream", "get", "getAndSet", "getAndUpdate", "getAndUpdateSome", "make", "modify", "modifySome", "set", "setAndGet", "update", "updateAndGet", "updateSome", "updateSomeAndGet", "TSubscriptionRefSymbolKey", "TSubscriptionRefTypeId", "Symbol", "for", "TSubscriptionRefVariance", "_A", "_", "TDequeueMerge", "first", "second", "TDequeueTypeId", "tDequeueVariance", "constructor", "peek", "gen", "peekOption", "_tag", "value", "retry", "none", "take", "isEmpty", "takeAll", "takeUpTo", "max", "length", "capacity", "size", "isFull", "shutdown", "isShutdown", "awaitShutdown", "TSubscriptionRefImpl", "ref", "pubsub", "TRefTypeId", "tRefVariance", "todos", "versioned", "pipe", "pipeArguments", "arguments", "changes", "unbounded", "offer", "get", "subscribe", "modify", "f", "map", "flatMap", "b", "a", "set", "as", "zipLeft", "publish", "make", "all", "self", "dual", "getAndSet", "getAndUpdate", "getAndUpdateSome", "match", "onNone", "onSome", "setAndGet", "modifySome", "fallback", "update", "updateAndGet", "updateSome", "updateSomeAndGet", "changesScoped", "acquireRelease", "changesStream", "unwrap", "fromTQueue", "TSubscriptionRefTypeId", "get", "getAndSet", "getAndUpdate", "getAndUpdateSome", "make", "modify", "modifySome", "set", "setAndGet", "update", "updateAndGet", "updateSome", "updateSomeAndGet", "changesScoped", "changesStream", "changes", "self", "TakeTypeId", "chunk", "die", "dieMessage", "done", "end", "fail", "failCause", "fromEffect", "fromExit", "fromPull", "isDone", "isFailure", "isSuccess", "make", "map", "match", "matchEffect", "of", "tap", "TakeTypeId", "chunk", "die", "dieMessage", "done", "end", "fail", "failCause", "fromEffect", "fromExit", "fromPull", "isDone", "isFailure", "isSuccess", "make", "map", "match", "matchEffect", "of", "tap", "make", "tagged", "TestAnnotationSymbolKey", "TestAnnotationTypeId", "Symbol", "for", "TestAnnotationImpl", "identifier", "initial", "combine", "_A", "_", "constructor", "symbol", "pipe", "hash", "cached", "that", "isTestAnnotation", "u", "hasProperty", "make", "compose", "left", "right", "isLeft", "isRight", "appendAll", "Error", "getBugErrorMessage", "fibers", "ignored", "a", "b", "repeated", "retried", "tagged", "empty", "union", "combine", "empty", "get", "make", "update", "TestAnnotationMapTypeId", "Symbol", "for", "TestAnnotationMapImpl", "map", "constructor", "isTestAnnotationMap", "u", "hasProperty", "empty", "make", "overwrite", "dual", "self", "key", "value", "set", "update", "f", "initial", "has", "unsafeGet", "get", "annotate", "_", "combine", "that", "result", "entry", "make", "TestAnnotationsTypeId", "Symbol", "for", "AnnotationsImpl", "ref", "constructor", "get", "key", "map", "annotate", "value", "update", "supervisedFibers", "descriptorWith", "descriptor", "flatMap", "fibers", "either", "_tag", "succeed", "empty", "Order", "pipe", "right", "forEachSequential", "sync", "reduce", "a", "b", "union", "filter", "fiber", "equals", "id", "TestAnnotations", "GenericTag", "isTestAnnotations", "u", "hasProperty", "make", "live", "sleep", "OP_SUSPENDED_WARNING_DATA_START", "OP_SUSPENDED_WARNING_DATA_PENDING", "OP_SUSPENDED_WARNING_DATA_DONE", "start", "_tag", "pending", "fiber", "done", "isStart", "self", "isPending", "OP_WARNING_DATA_START", "OP_WARNING_DATA_PENDING", "OP_WARNING_DATA_DONE", "start", "_tag", "pending", "fiber", "done", "isStart", "self", "isPending", "make", "TestLiveTypeId", "Symbol", "for", "TestLive", "GenericTag", "LiveImpl", "services", "constructor", "provide", "effect", "fiberRefLocallyWith", "currentServices", "merge", "make", "makeData", "instant", "sleeps", "TestClock", "GenericTag", "warning", "suspendedWarning", "TestClockImpl", "clockState", "live", "annotations", "warningState", "suspendedWarningState", "ClockTypeId", "constructor", "currentTimeMillis", "map", "get", "data", "currentTimeNanos", "BigInt", "unsafeCurrentTimeMillis", "unsafeGet", "unsafeCurrentTimeNanos", "save", "set", "setTime", "zipRight", "warningDone", "run", "sleep", "durationInput", "duration", "decode", "flatMap", "deferredMake", "deferred", "pipe", "modify", "end", "toMillis", "prepend", "shouldAwait", "warningStart", "deferredAwait", "deferredSucceed", "asVoid", "_", "adjust", "n", "adjustWith", "effect", "zipLeftOptions", "concurrent", "supervisedFibers", "freeze", "fibers", "reduce", "empty", "fiber", "status", "isDone", "succeed", "id", "isSuspended", "fail", "updateSomeEffect", "isStart", "some", "provide", "logWarning", "delay", "seconds", "interruptible", "fork", "pending", "none", "warningData", "done", "isPending", "interruptFiber", "as", "yieldTimer", "async", "resume", "timer", "setTimeout", "void", "sync", "clearTimeout", "suspended", "zip", "first", "last", "equals", "awaitSuspended", "suspendedWarningStart", "zipWith", "filterOrFail", "identity", "constVoid", "eventually", "suspendedWarningDone", "suspendedWarningData", "start", "f", "sorted", "sort", "Order", "mapInput", "isNonEmpty", "headNonEmpty", "tailNonEmpty", "option", "_tag", "value", "yieldNow", "scoped", "gen", "$", "TestLive", "TestAnnotations", "unsafeMake", "makeSynchronized", "testClock", "withClockScoped", "addFinalizer", "defaultTestClock", "Date", "getTime", "testClockWith", "dual", "input", "epochMillis", "fiberRefGetWith", "currentServices", "services", "clockTag", "make", "TestConfig", "GenericTag", "make", "params", "live", "annotate", "currentServices", "get", "live", "liveServices", "size", "make", "TestSizedTypeId", "Symbol", "for", "TestSized", "GenericTag", "SizedImpl", "fiberRef", "constructor", "size", "fiberRefGet", "withSize", "effect", "fiberRefLocally", "make", "fiberRefUnsafeMake", "fromFiberRef", "liveServices", "pipe", "make", "TestAnnotations", "unsafeMake", "empty", "add", "TestLive", "TestSized", "TestConfig", "repeats", "retries", "samples", "shrinks", "currentServices", "fiberRefUnsafeMakeContext", "annotations", "annotationsWith", "succeed", "f", "fiberRefGetWith", "services", "get", "withAnnotations", "dual", "effect", "fiberRefLocallyWith", "withAnnotationsScoped", "fiberRefLocallyScopedWith", "annotationsLayer", "scoped", "sync", "map", "tap", "key", "annotate", "value", "supervisedFibers", "liveWith", "live", "withLive", "withLiveScoped", "liveLayer", "context", "provideLive", "provide", "provideWithLive", "self", "fiberRefLocally", "sizedWith", "sized", "withSized", "withSizedScoped", "sizedLayer", "size", "fiberRefMake", "fromFiberRef", "withSize", "testConfigWith", "testConfig", "withTestConfig", "config", "withTestConfigScoped", "testConfigLayer", "params", "suspend", "as", "live", "pipe", "annotationsLayer", "merge", "liveLayer", "sizedLayer", "defaultTestClock", "provideMerge", "testConfigLayer", "repeats", "retries", "samples", "shrinks", "LiveContext", "syncContext", "liveServices", "TestContext", "compact", "empty", "entries", "entriesWithPrefix", "filter", "filterMap", "forEach", "fromIterable", "get", "has", "insert", "insertMany", "isEmpty", "keys", "keysWithPrefix", "longestPrefixOf", "make", "map", "modify", "reduce", "remove", "removeMany", "size", "toEntriesWithPrefix", "unsafeGet", "values", "valuesWithPrefix", "TrieSymbolKey", "TrieTypeId", "Symbol", "for", "trieVariance", "_Value", "_", "TrieProto", "iterator", "TrieIterator", "k", "v", "symbol", "hash", "item", "pipe", "combine", "cached", "that", "isTrie", "entries", "Array", "from", "every", "itemSelf", "i", "itemThat", "equals", "toString", "format", "toJSON", "_id", "values", "map", "NodeInspectSymbol", "pipeArguments", "arguments", "makeImpl", "root", "trie", "Object", "create", "_root", "_count", "count", "f", "filter", "stack", "constructor", "undefined", "push", "next", "length", "node", "keyString", "isAdded", "pop", "value", "key", "done", "addToStack", "right", "mid", "left", "u", "hasProperty", "empty", "fromIterable", "insert", "make", "dual", "self", "dStack", "nStack", "n", "cIndex", "c", "s", "n2", "d", "size", "isEmpty", "keys", "reduce", "zero", "accumulator", "entry", "filterMap", "option", "isSome", "compact", "identity", "forEach", "keysWithPrefix", "prefix", "startsWith", "valuesWithPrefix", "entriesWithPrefix", "toEntriesWithPrefix", "get", "none", "fromNullable", "has", "unsafeGet", "element", "isNone", "Error", "remove", "removeNode", "child", "nc", "removeMany", "insertMany", "iter", "modify", "updateNode", "longestPrefixOf", "longestPrefixNode", "slice", "empty", "fromIterable", "make", "insert", "keys", "values", "entries", "toEntries", "self", "Array", "from", "keysWithPrefix", "valuesWithPrefix", "entriesWithPrefix", "toEntriesWithPrefix", "longestPrefixOf", "size", "get", "has", "isEmpty", "unsafeGet", "remove", "reduce", "map", "filter", "filterMap", "compact", "forEach", "modify", "removeMany", "insertMany", "NoUpstream", "Pulled", "UpstreamPullRequestTypeId", "isNoUpstream", "isPulled", "isUpstreamPullRequest", "match", "UpstreamPullRequestTypeId", "Pulled", "NoUpstream", "isUpstreamPullRequest", "isPulled", "isNoUpstream", "match", "PullAfterAllEnqueued", "PullAfterNext", "UpstreamPullStrategyTypeId", "isPullAfterAllEnqueued", "isPullAfterNext", "isUpstreamPullStrategy", "match", "UpstreamPullStrategyTypeId", "PullAfterNext", "PullAfterAllEnqueued", "isUpstreamPullStrategy", "isPullAfterNext", "isPullAfterAllEnqueued", "match"]
}
