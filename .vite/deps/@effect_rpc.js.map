{
  "version": 3,
  "sources": ["../../node_modules/@effect/rpc/src/Rpc.ts", "../../node_modules/@effect/rpc/src/RpcSchema.ts", "../../node_modules/@effect/rpc/src/RpcClient.ts", "../../node_modules/@effect/rpc/src/internal/utils.ts", "../../node_modules/@effect/rpc/src/RpcMessage.ts", "../../node_modules/@effect/rpc/src/RpcSerialization.ts", "../../node_modules/@effect/rpc/src/RpcWorker.ts", "../../node_modules/@effect/rpc/src/RpcGroup.ts", "../../node_modules/@effect/rpc/src/RpcMiddleware.ts", "../../node_modules/@effect/rpc/src/RpcServer.ts", "../../node_modules/@effect/rpc/src/RpcTest.ts"],
  "sourcesContent": ["/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport * as Context_ from \"effect/Context\"\nimport type { Effect } from \"effect/Effect\"\nimport type { Exit as Exit_ } from \"effect/Exit\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport type { ReadonlyMailbox } from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport { type Pipeable, pipeArguments } from \"effect/Pipeable\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as PrimaryKey from \"effect/PrimaryKey\"\nimport * as Schema from \"effect/Schema\"\nimport type * as AST from \"effect/SchemaAST\"\nimport type { Stream } from \"effect/Stream\"\nimport type { NoInfer } from \"effect/Types\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\nimport * as RpcSchema from \"./RpcSchema.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/Rpc\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category guards\n */\nexport const isRpc = (u: unknown): u is Rpc<any, any, any> => Predicate.hasProperty(u, TypeId)\n\n/**\n * Represents an API endpoint. An API endpoint is mapped to a single route on\n * the underlying `HttpRouter`.\n *\n * @since 1.0.0\n * @category models\n */\nexport interface Rpc<\n  in out Tag extends string,\n  out Payload extends AnySchema = typeof Schema.Void,\n  out Success extends Schema.Schema.Any = typeof Schema.Void,\n  out Error extends Schema.Schema.All = typeof Schema.Never,\n  out Middleware extends RpcMiddleware.TagClassAny = never\n> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly _tag: Tag\n  readonly key: string\n  readonly payloadSchema: Payload\n  readonly successSchema: Success\n  readonly errorSchema: Error\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<Middleware>\n\n  /**\n   * Set the schema for the success response of the rpc.\n   */\n  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<\n    Tag,\n    Payload,\n    S,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the error response of the rpc.\n   */\n  setError<E extends Schema.Schema.Any>(schema: E): Rpc<\n    Tag,\n    Payload,\n    Success,\n    E,\n    Middleware\n  >\n\n  /**\n   * Set the schema for the payload of the rpc.\n   */\n  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(\n    schema: P\n  ): Rpc<\n    Tag,\n    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,\n    Success,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Add an `RpcMiddleware` to this procedure.\n   */\n  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<\n    Tag,\n    Payload,\n    Success,\n    Error,\n    Middleware | M\n  >\n\n  /**\n   * Set the schema for the error response of the rpc.\n   */\n  prefix<const Prefix extends string>(prefix: Prefix): Rpc<\n    `${Prefix}${Tag}`,\n    Payload,\n    Success,\n    Error,\n    Middleware\n  >\n\n  /**\n   * Add an annotation on the rpc.\n   */\n  annotate<I, S>(\n    tag: Context_.Tag<I, S>,\n    value: S\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n\n  /**\n   * Merge the annotations of the rpc with the provided context.\n   */\n  annotateContext<I>(\n    context: Context_.Context<I>\n  ): Rpc<Tag, Payload, Success, Error, Middleware>\n}\n\n/**\n * Represents an implemented rpc.\n *\n * @since 1.0.0\n * @category models\n */\nexport interface Handler<Tag extends string> {\n  readonly _: unique symbol\n  readonly tag: Tag\n  readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>\n  readonly context: Context<never>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Any extends Pipeable {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface AnyWithProps {\n  readonly [TypeId]: TypeId\n  readonly _tag: string\n  readonly key: string\n  readonly payloadSchema: AnySchema\n  readonly successSchema: Schema.Schema.Any\n  readonly errorSchema: Schema.Schema.All\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<RpcMiddleware.TagClassAnyWithProps>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Tag<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Tag\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Success<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Success[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessEncoded<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Success[\"Encoded\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessExit<R> = Success<R> extends infer T ? T extends Stream<infer _A, infer _E, infer _Env> ? void : T\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessExitEncoded<R> = SuccessEncoded<R> extends infer T ?\n  T extends Stream<infer _A, infer _E, infer _Env> ? void : T\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessChunk<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessChunkEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env> ? _A : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorSchema<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Error | _Middleware\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Error<R> = Schema.Schema.Type<ErrorSchema<R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorEncoded<R> = Schema.Schema.Encoded<ErrorSchema<R>>\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorExit<R> = Success<R> extends Stream<infer _A, infer _E, infer _Env> ? _E | Error<R> : Error<R>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ErrorExitEncoded<R> = SuccessEncoded<R> extends Stream<infer _A, infer _E, infer _Env>\n  ? _E | ErrorEncoded<R>\n  : ErrorEncoded<R>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Exit<R> = Exit_<SuccessExit<R>, ErrorExit<R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExitEncoded<R, Defect = unknown> = Schema.ExitEncoded<SuccessExitEncoded<R>, ErrorExitEncoded<R>, Defect>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type PayloadConstructor<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ?\n  _Payload extends { readonly fields: Schema.Struct.Fields } ?\n    Schema.Simplify<Schema.Struct.Constructor<_Payload[\"fields\"]>>\n  : _Payload[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Payload<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Payload[\"Type\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Context<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Middleware<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Context_.Tag.Identifier<_Middleware>\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type MiddlewareClient<R> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ?\n  _Middleware extends { readonly requiredForClient: true }\n    ? RpcMiddleware.ForClient<Context_.Tag.Identifier<_Middleware>>\n  : never\n  : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type AddError<R extends Any, Error extends Schema.Schema.All> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    _Tag,\n    _Payload,\n    _Success,\n    _Error | Error,\n    _Middleware\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type AddMiddleware<R extends Any, Middleware extends RpcMiddleware.TagClassAny> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    _Tag,\n    _Payload,\n    _Success,\n    _Error,\n    _Middleware | Middleware\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ToHandler<R extends Any> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Handler<_Tag> :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ToHandlerFn<Current extends Any, R = any> = (\n  payload: Payload<Current>,\n  headers: Headers\n) => ResultFrom<Current, R> | Fork<ResultFrom<Current, R>>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type IsStream<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, RpcSchema.Stream<infer _A, infer _E>, infer _Error, infer _Middleware> ? true : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExtractTag<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? R : never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExtractProvides<R extends Any, Tag extends string> = R extends\n  Rpc<Tag, infer _Payload, infer _Success, infer _Error, infer _Middleware> ? _Middleware extends {\n    readonly provides: Context_.Tag<infer _I, infer _S>\n  } ? _I :\n  never :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ExcludeProvides<Env, R extends Any, Tag extends string> = Exclude<\n  Env,\n  ExtractProvides<R, Tag>\n>\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface From<S extends AnyTaggedRequestSchema> extends Rpc<S[\"_tag\"], S, S[\"success\"], S[\"failure\"]> {}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type ResultFrom<R extends Any, Context> = R extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? [_Success] extends [RpcSchema.Stream<infer _SA, infer _SE>] ?\n      | Stream<\n        _SA[\"Type\"],\n        _SE[\"Type\"] | _Error[\"Type\"],\n        Context\n      >\n      | Effect<\n        ReadonlyMailbox<_SA[\"Type\"], _SE[\"Type\"] | _Error[\"Type\"]>,\n        _SE[\"Type\"] | Schema.Schema.Type<_Error>,\n        Context\n      > :\n  Effect<\n    _Success[\"Type\"],\n    _Error[\"Type\"],\n    Context\n  > :\n  never\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type Prefixed<Rpcs extends Any, Prefix extends string> = Rpcs extends Rpc<\n  infer _Tag,\n  infer _Payload,\n  infer _Success,\n  infer _Error,\n  infer _Middleware\n> ? Rpc<\n    `${Prefix}${_Tag}`,\n    _Payload,\n    _Success,\n    _Error,\n    _Middleware\n  >\n  : never\n\nconst Proto = {\n  [TypeId]: TypeId,\n  pipe() {\n    return pipeArguments(this, arguments)\n  },\n  setSuccess(\n    this: AnyWithProps,\n    successSchema: Schema.Schema.Any\n  ) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  setError(this: AnyWithProps, errorSchema: Schema.Schema.All) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  setPayload(this: AnyWithProps, payloadSchema: Schema.Struct<any> | Schema.Struct.Fields) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: Schema.isSchema(payloadSchema) ? payloadSchema as any : Schema.Struct(payloadSchema as any),\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  middleware(this: AnyWithProps, middleware: RpcMiddleware.TagClassAny) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: new Set([...this.middlewares, middleware])\n    })\n  },\n  prefix(this: AnyWithProps, prefix: string) {\n    return makeProto({\n      _tag: `${prefix}${this._tag}`,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      annotations: this.annotations,\n      middlewares: this.middlewares\n    })\n  },\n  annotate(this: AnyWithProps, tag: Context_.Tag<any, any>, value: any) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      middlewares: this.middlewares,\n      annotations: Context_.add(this.annotations, tag, value)\n    })\n  },\n  annotateContext(this: AnyWithProps, context: Context_.Context<any>) {\n    return makeProto({\n      _tag: this._tag,\n      payloadSchema: this.payloadSchema,\n      successSchema: this.successSchema,\n      errorSchema: this.errorSchema,\n      middlewares: this.middlewares,\n      annotations: Context_.merge(this.annotations, context)\n    })\n  }\n}\n\nconst makeProto = <\n  const Tag extends string,\n  Payload extends Schema.Schema.Any,\n  Success extends Schema.Schema.Any,\n  Error extends Schema.Schema.All,\n  Middleware extends RpcMiddleware.TagClassAny\n>(options: {\n  readonly _tag: Tag\n  readonly payloadSchema: Payload\n  readonly successSchema: Success\n  readonly errorSchema: Error\n  readonly annotations: Context_.Context<never>\n  readonly middlewares: ReadonlySet<Middleware>\n}): Rpc<Tag, Payload, Success, Error, Middleware> => {\n  function Rpc() {}\n  Object.setPrototypeOf(Rpc, Proto)\n  Object.assign(Rpc, options)\n  Rpc.key = `@effect/rpc/Rpc/${options._tag}`\n  return Rpc as any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const make = <\n  const Tag extends string,\n  Payload extends Schema.Schema.Any | Schema.Struct.Fields = typeof Schema.Void,\n  Success extends Schema.Schema.Any = typeof Schema.Void,\n  Error extends Schema.Schema.All = typeof Schema.Never,\n  const Stream extends boolean = false\n>(tag: Tag, options?: {\n  readonly payload?: Payload\n  readonly success?: Success\n  readonly error?: Error\n  readonly stream?: Stream\n  readonly primaryKey?: [Payload] extends [Schema.Struct.Fields] ?\n    ((payload: Schema.Simplify<Schema.Struct.Type<NoInfer<Payload>>>) => string) :\n    never\n}): Rpc<\n  Tag,\n  Payload extends Schema.Struct.Fields ? Schema.Struct<Payload> : Payload,\n  Stream extends true ? RpcSchema.Stream<Success, Error> : Success,\n  Stream extends true ? typeof Schema.Never : Error\n> => {\n  const successSchema = options?.success ?? Schema.Void\n  const errorSchema = options?.error ?? Schema.Never\n  let payloadSchema: any\n  if (options?.primaryKey) {\n    payloadSchema = class Payload extends Schema.Class<Payload>(`@effect/rpc/Rpc/${tag}`)(options.payload as any) {\n      [PrimaryKey.symbol](): string {\n        return options.primaryKey!(this as any)\n      }\n    }\n  } else {\n    payloadSchema = Schema.isSchema(options?.payload)\n      ? options?.payload as any\n      : options?.payload\n      ? Schema.Struct(options?.payload as any)\n      : Schema.Void\n  }\n  return makeProto({\n    _tag: tag,\n    payloadSchema,\n    successSchema: options?.stream ?\n      RpcSchema.Stream({\n        success: successSchema,\n        failure: errorSchema\n      }) :\n      successSchema,\n    errorSchema: options?.stream ? Schema.Never : errorSchema,\n    annotations: Context_.empty(),\n    middlewares: new Set<never>()\n  }) as any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport interface AnySchema extends Pipeable {\n  readonly [Schema.TypeId]: any\n  readonly Type: any\n  readonly Encoded: any\n  readonly Context: any\n  readonly make?: (params: any, ...rest: ReadonlyArray<any>) => any\n  readonly ast: AST.AST\n  readonly annotations: any\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport interface AnyTaggedRequestSchema extends AnySchema {\n  readonly _tag: string\n  readonly success: Schema.Schema.Any\n  readonly failure: Schema.Schema.All\n}\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const fromTaggedRequest = <S extends AnyTaggedRequestSchema>(\n  schema: S\n): From<S> =>\n  makeProto({\n    _tag: schema._tag,\n    payloadSchema: schema as any,\n    successSchema: schema.success as any,\n    errorSchema: schema.failure,\n    annotations: Context_.empty(),\n    middlewares: new Set()\n  })\n\nconst exitSchemaCache = globalValue(\"@effect/rpc/Rpc/exitSchemaCache\", () => new WeakMap<Any, Schema.Schema.Any>())\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const exitSchema = <R extends Any>(\n  self: R\n): Schema.Schema<Exit<R>, ExitEncoded<R>, Context<R>> => {\n  if (exitSchemaCache.has(self)) {\n    return exitSchemaCache.get(self) as any\n  }\n  const rpc = self as any as AnyWithProps\n  const failures = new Set<Schema.Schema.All>([rpc.errorSchema])\n  const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)\n  if (Option.isSome(streamSchemas)) {\n    failures.add(streamSchemas.value.failure)\n  }\n  for (const middleware of rpc.middlewares) {\n    failures.add(middleware.failure)\n  }\n  const schema = Schema.Exit({\n    success: Option.isSome(streamSchemas) ? Schema.Void : rpc.successSchema,\n    failure: Schema.Union(...failures),\n    defect: Schema.Defect\n  })\n  exitSchemaCache.set(self, schema)\n  return schema as any\n}\n\n/**\n * @since 1.0.0\n * @category Fork\n */\nexport const ForkTypeId: unique symbol = Symbol.for(\"@effect/rpc/Rpc/Fork\")\n\n/**\n * @since 1.0.0\n * @category Fork\n */\nexport type ForkTypeId = typeof ForkTypeId\n\n/**\n * @since 1.0.0\n * @category Fork\n */\nexport interface Fork<A> {\n  readonly [ForkTypeId]: ForkTypeId\n  readonly value: A\n}\n\n/**\n * You can use `fork` to wrap a response Effect or Stream, to ensure that the\n * response is executed concurrently regardless of the RpcServer concurrency\n * setting.\n *\n * @since 1.0.0\n * @category Fork\n */\nexport const fork = <A>(value: A): Fork<A> => ({ [ForkTypeId]: ForkTypeId, value })\n\n/**\n * @since 1.0.0\n * @category Fork\n */\nexport const isFork = (u: object): u is Fork<any> => ForkTypeId in u\n", "/**\n * @since 1.0.0\n */\nimport type * as Chunk from \"effect/Chunk\"\nimport * as Effect from \"effect/Effect\"\nimport * as Option from \"effect/Option\"\nimport * as ParseResult from \"effect/ParseResult\"\nimport { hasProperty } from \"effect/Predicate\"\nimport * as Schema from \"effect/Schema\"\nimport * as AST from \"effect/SchemaAST\"\nimport * as Stream_ from \"effect/Stream\"\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const StreamSchemaId: unique symbol = Symbol.for(\"@effect/rpc/RpcSchema/Stream\")\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const isStreamSchema = (schema: Schema.Schema.All): schema is Stream<any, any> =>\n  schema.ast.annotations[AST.SchemaIdAnnotationId] === StreamSchemaId\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const isStreamSerializable = (schema: Schema.WithResult.Any): boolean =>\n  isStreamSchema(Schema.successSchema(schema))\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const getStreamSchemas = (\n  ast: AST.AST\n): Option.Option<{\n  readonly success: Schema.Schema.Any\n  readonly failure: Schema.Schema.All\n}> => ast.annotations[StreamSchemaId] ? Option.some(ast.annotations[StreamSchemaId] as any) : Option.none()\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport interface Stream<A extends Schema.Schema.Any, E extends Schema.Schema.All> extends\n  Schema.Schema<\n    Stream_.Stream<A[\"Type\"], E[\"Type\"]>,\n    Stream_.Stream<A[\"Encoded\"], E[\"Encoded\"]>,\n    A[\"Context\"] | E[\"Context\"]\n  >\n{\n  readonly success: A\n  readonly failure: E\n}\n\n/**\n * @since 1.0.0\n * @category Stream\n */\nexport const Stream = <A extends Schema.Schema.Any, E extends Schema.Schema.All>(\n  { failure, success }: {\n    readonly failure: E\n    readonly success: A\n  }\n): Stream<A, E> =>\n  Object.assign(\n    Schema.declare(\n      [success, failure],\n      {\n        decode: (success, failure) =>\n          parseStream(\n            ParseResult.decodeUnknown(Schema.ChunkFromSelf(success)),\n            ParseResult.decodeUnknown(failure)\n          ),\n        encode: (success, failure) =>\n          parseStream(\n            ParseResult.encodeUnknown(Schema.ChunkFromSelf(success)),\n            ParseResult.encodeUnknown(failure)\n          )\n      },\n      {\n        schemaId: StreamSchemaId,\n        [StreamSchemaId]: { success, failure }\n      }\n    ),\n    {\n      success,\n      failure\n    }\n  )\n\nconst isStream = (u: unknown): u is Stream_.Stream<unknown, unknown> => hasProperty(u, Stream_.StreamTypeId)\n\nconst parseStream = <A, E, RA, RE>(\n  decodeSuccess: (\n    u: Chunk.Chunk<unknown>,\n    overrideOptions?: AST.ParseOptions\n  ) => Effect.Effect<Chunk.Chunk<A>, ParseResult.ParseIssue, RA>,\n  decodeFailure: (u: unknown, overrideOptions?: AST.ParseOptions) => Effect.Effect<E, ParseResult.ParseIssue, RE>\n) =>\n(u: unknown, options: AST.ParseOptions, ast: AST.AST) =>\n  Effect.flatMap(\n    Effect.context<RA | RE>(),\n    (context) => {\n      if (!isStream(u)) return Effect.fail(new ParseResult.Type(ast, u))\n      return Effect.succeed(u.pipe(\n        Stream_.mapChunksEffect((value) => decodeSuccess(value, options)),\n        Stream_.catchAll((error) => {\n          if (ParseResult.isParseError(error)) return Stream_.die(error)\n          return Effect.matchEffect(decodeFailure(error, options), {\n            onFailure: Effect.die,\n            onSuccess: Effect.fail\n          })\n        }),\n        Stream_.provideContext(context)\n      ))\n    }\n  )\n", "/**\n * @since 1.0.0\n */\nimport * as Headers from \"@effect/platform/Headers\"\nimport * as HttpBody from \"@effect/platform/HttpBody\"\nimport * as HttpClient from \"@effect/platform/HttpClient\"\nimport * as HttpClientRequest from \"@effect/platform/HttpClientRequest\"\nimport * as Socket from \"@effect/platform/Socket\"\nimport * as Transferable from \"@effect/platform/Transferable\"\nimport * as Worker from \"@effect/platform/Worker\"\nimport type { WorkerError } from \"@effect/platform/WorkerError\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport type * as Duration from \"effect/Duration\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as FiberRef from \"effect/FiberRef\"\nimport { constVoid, dual, identity } from \"effect/Function\"\nimport { globalValue } from \"effect/GlobalValue\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as Option from \"effect/Option\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as Pool from \"effect/Pool\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport type { Span } from \"effect/Tracer\"\nimport type { Mutable } from \"effect/Types\"\nimport { withRun } from \"./internal/utils.js\"\nimport * as Rpc from \"./Rpc.js\"\nimport type * as RpcGroup from \"./RpcGroup.js\"\nimport type { FromClient, FromClientEncoded, FromServer, FromServerEncoded, Request } from \"./RpcMessage.js\"\nimport { constPing, RequestId } from \"./RpcMessage.js\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\nimport * as RpcSchema from \"./RpcSchema.js\"\nimport * as RpcSerialization from \"./RpcSerialization.js\"\nimport * as RpcWorker from \"./RpcWorker.js\"\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport type RpcClient<Rpcs extends Rpc.Any, E = never> = Schema.Simplify<\n  & RpcClient.From<RpcClient.NonPrefixed<Rpcs>, E, \"\">\n  & {\n    readonly [CurrentPrefix in RpcClient.Prefixes<Rpcs>]: RpcClient.From<\n      RpcClient.Prefixed<Rpcs, CurrentPrefix>,\n      E,\n      CurrentPrefix\n    >\n  }\n>\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport declare namespace RpcClient {\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Prefixes<Rpcs extends Rpc.Any> = Rpcs[\"_tag\"] extends infer Tag\n    ? Tag extends `${infer Prefix}.${string}` ? Prefix : never\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type NonPrefixed<Rpcs extends Rpc.Any> = Exclude<Rpcs, { readonly _tag: `${string}.${string}` }>\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Prefixed<Rpcs extends Rpc.Any, Prefix extends string> = Extract<\n    Rpcs,\n    { readonly _tag: `${Prefix}.${string}` }\n  >\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type From<Rpcs extends Rpc.Any, E = never, Prefix extends string = \"\"> = {\n    readonly [\n      Current in Rpcs as Current[\"_tag\"] extends `${Prefix}.${infer Method}` ? Method\n        : Current[\"_tag\"]\n    ]: <\n      const AsMailbox extends boolean = false,\n      const Discard = false\n    >(\n      input: Rpc.PayloadConstructor<Current>,\n      options?: Rpc.Success<Current> extends Stream.Stream<infer _A, infer _E, infer _R> ? {\n          readonly asMailbox?: AsMailbox | undefined\n          readonly streamBufferSize?: number | undefined\n          readonly headers?: Headers.Input | undefined\n          readonly context?: Context.Context<never> | undefined\n        } :\n        {\n          readonly headers?: Headers.Input | undefined\n          readonly context?: Context.Context<never> | undefined\n          readonly discard?: Discard | undefined\n        }\n    ) => Current extends Rpc.Rpc<\n      infer _Tag,\n      infer _Payload,\n      infer _Success,\n      infer _Error,\n      infer _Middleware\n    > ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<\n            Mailbox.ReadonlyMailbox<_A[\"Type\"], _E[\"Type\"] | _Error[\"Type\"] | E>,\n            never,\n            Scope.Scope | _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n          >\n        : Stream.Stream<\n          _A[\"Type\"],\n          _E[\"Type\"] | _Error[\"Type\"] | E,\n          _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n        >\n      : Effect.Effect<\n        Discard extends true ? void : _Success[\"Type\"],\n        Discard extends true ? E : _Error[\"Type\"] | E,\n        _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n      > :\n      never\n  }\n\n  /**\n   * @since 1.0.0\n   * @category client\n   */\n  export type Flat<Rpcs extends Rpc.Any, E = never> = <\n    const Tag extends Rpcs[\"_tag\"],\n    const AsMailbox extends boolean = false,\n    const Discard = false\n  >(\n    tag: Tag,\n    payload: Rpc.PayloadConstructor<Rpc.ExtractTag<Rpcs, Tag>>,\n    options?: Rpc.Success<Rpc.ExtractTag<Rpcs, Tag>> extends Stream.Stream<infer _A, infer _E, infer _R> ? {\n        readonly asMailbox?: AsMailbox | undefined\n        readonly streamBufferSize?: number | undefined\n        readonly headers?: Headers.Input | undefined\n        readonly context?: Context.Context<never> | undefined\n      } :\n      {\n        readonly headers?: Headers.Input | undefined\n        readonly context?: Context.Context<never> | undefined\n        readonly discard?: Discard | undefined\n      }\n  ) => Rpc.ExtractTag<Rpcs, Tag> extends Rpc.Rpc<\n    infer _Tag,\n    infer _Payload,\n    infer _Success,\n    infer _Error,\n    infer _Middleware\n  > ? [_Success] extends [RpcSchema.Stream<infer _A, infer _E>] ? AsMailbox extends true ? Effect.Effect<\n          Mailbox.ReadonlyMailbox<_A[\"Type\"], _E[\"Type\"] | _Error[\"Type\"] | E>,\n          never,\n          Scope.Scope | _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n        >\n      : Stream.Stream<\n        _A[\"Type\"],\n        _E[\"Type\"] | _Error[\"Type\"] | E,\n        _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n      >\n    : Effect.Effect<\n      Discard extends true ? void : _Success[\"Type\"],\n      Discard extends true ? E : _Error[\"Type\"] | E,\n      _Payload[\"Context\"] | _Success[\"Context\"] | _Error[\"Context\"]\n    > :\n    never\n}\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport type FromGroup<Group> = RpcClient<RpcGroup.Rpcs<Group>>\n\nlet requestIdCounter = BigInt(0)\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport const makeNoSerialization: <Rpcs extends Rpc.Any, E, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromClient: (\n      options: {\n        readonly message: FromClient<Rpcs>\n        readonly context: Context.Context<never>\n        readonly discard: boolean\n      }\n    ) => Effect.Effect<void, E>\n    readonly supportsAck?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  }\n) => Effect.Effect<\n  {\n    readonly client: Flatten extends true ? RpcClient.Flat<Rpcs, E> : RpcClient<Rpcs, E>\n    readonly write: (message: FromServer<Rpcs>) => Effect.Effect<void>\n  },\n  never,\n  Scope.Scope | Rpc.MiddlewareClient<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any, E, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromClient: (\n      options: {\n        readonly message: FromClient<Rpcs>\n        readonly context: Context.Context<never>\n        readonly discard: boolean\n      }\n    ) => Effect.Effect<void, E>\n    readonly supportsAck?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  }\n) {\n  const spanPrefix = options?.spanPrefix ?? \"RpcClient\"\n  const supportsAck = options?.supportsAck ?? true\n  const disableTracing = options?.disableTracing ?? false\n  const generateRequestId = options?.generateRequestId ?? (() => requestIdCounter++ as RequestId)\n\n  const context = yield* Effect.context<Rpc.MiddlewareClient<Rpcs> | Scope.Scope>()\n  const scope = Context.get(context, Scope.Scope)\n\n  type ClientEntry = {\n    readonly _tag: \"Effect\"\n    readonly rpc: Rpc.AnyWithProps\n    readonly context: Context.Context<never>\n    resume: (_: Exit.Exit<any, any>) => void\n  } | {\n    readonly _tag: \"Mailbox\"\n    readonly rpc: Rpc.AnyWithProps\n    readonly mailbox: Mailbox.Mailbox<any, any>\n    readonly scope: Scope.Scope\n    readonly context: Context.Context<never>\n  }\n  const entries = new Map<RequestId, ClientEntry>()\n\n  let isShutdown = false\n  yield* Scope.addFinalizer(\n    scope,\n    Effect.fiberIdWith((fiberId) => {\n      isShutdown = true\n      return clearEntries(Exit.interrupt(fiberId))\n    })\n  )\n\n  const clearEntries = Effect.fnUntraced(function*(exit: Exit.Exit<never>) {\n    for (const [id, entry] of entries) {\n      entries.delete(id)\n      if (entry._tag === \"Mailbox\") {\n        yield* entry.mailbox.done(exit)\n      } else {\n        entry.resume(exit)\n      }\n    }\n  })\n\n  const onRequest = (rpc: Rpc.AnyWithProps) => {\n    const isStream = RpcSchema.isStreamSchema(rpc.successSchema)\n    const middleware = getRpcClientMiddleware(rpc)\n    return (payload: any, opts?: {\n      readonly asMailbox?: boolean | undefined\n      readonly streamBufferSize?: number | undefined\n      readonly headers?: Headers.Input | undefined\n      readonly context?: Context.Context<never> | undefined\n      readonly discard?: boolean | undefined\n    }) => {\n      const headers = opts?.headers ? Headers.fromInput(opts.headers) : Headers.empty\n      const context = opts?.context ?? Context.empty()\n      if (!isStream) {\n        const onRequest = (span: Span | undefined) =>\n          onEffectRequest(\n            rpc,\n            middleware,\n            span,\n            rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload,\n            headers,\n            context,\n            opts?.discard ?? false\n          )\n        return disableTracing ? onRequest(undefined) : Effect.useSpan(\n          `${spanPrefix}.${rpc._tag}`,\n          { captureStackTrace: false, attributes: options.spanAttributes },\n          onRequest\n        )\n      }\n      const mailbox = onStreamRequest(\n        rpc,\n        middleware,\n        rpc.payloadSchema.make ? rpc.payloadSchema.make(payload) : payload,\n        headers,\n        opts?.streamBufferSize ?? 16,\n        context\n      )\n      if (opts?.asMailbox) return mailbox\n      return Stream.unwrapScoped(Effect.map(mailbox, Mailbox.toStream))\n    }\n  }\n\n  const onEffectRequest = (\n    rpc: Rpc.AnyWithProps,\n    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,\n    span: Span | undefined,\n    payload: any,\n    headers: Headers.Headers,\n    context: Context.Context<never>,\n    discard: boolean\n  ) =>\n    Effect.withFiberRuntime<any, any, any>((parentFiber) => {\n      if (isShutdown) {\n        return Effect.interrupt\n      }\n      const id = generateRequestId()\n      const send = middleware({\n        _tag: \"Request\",\n        id,\n        tag: rpc._tag as Rpc.Tag<Rpcs>,\n        payload,\n        traceId: span?.traceId,\n        spanId: span?.spanId,\n        sampled: span?.sampled,\n        headers: Headers.merge(parentFiber.getFiberRef(currentHeaders), headers)\n      })\n      if (discard) {\n        return Effect.flatMap(send, (message) =>\n          options.onFromClient({\n            message,\n            context,\n            discard\n          }))\n      }\n      const runtime = Runtime.make({\n        context: parentFiber.currentContext,\n        fiberRefs: parentFiber.getFiberRefs(),\n        runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n      })\n      let fiber: Fiber.RuntimeFiber<any, any>\n      return Effect.onInterrupt(\n        Effect.async<any, any>((resume) => {\n          const entry: ClientEntry = {\n            _tag: \"Effect\",\n            rpc,\n            context,\n            resume(exit) {\n              resume(exit)\n              if (fiber && !fiber.unsafePoll()) {\n                parentFiber.currentScheduler.scheduleTask(() => {\n                  fiber.unsafeInterruptAsFork(parentFiber.id())\n                }, 0)\n              }\n            }\n          }\n          entries.set(id, entry)\n          fiber = send.pipe(\n            Effect.flatMap((request) =>\n              options.onFromClient({\n                message: request,\n                context,\n                discard\n              })\n            ),\n            span ? Effect.withParentSpan(span) : identity,\n            Runtime.runFork(runtime)\n          )\n          fiber.addObserver((exit) => {\n            if (exit._tag === \"Failure\") {\n              return resume(exit)\n            }\n          })\n        }),\n        (interruptors) => {\n          entries.delete(id)\n          const ids = Array.from(interruptors).flatMap((id) => Array.from(FiberId.toSet(id)))\n          return Effect.zipRight(\n            Fiber.interrupt(fiber),\n            sendInterrupt(id, ids, context)\n          )\n        }\n      )\n    })\n\n  const onStreamRequest = Effect.fnUntraced(function*(\n    rpc: Rpc.AnyWithProps,\n    middleware: (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>>,\n    payload: any,\n    headers: Headers.Headers,\n    streamBufferSize: number,\n    context: Context.Context<never>\n  ) {\n    if (isShutdown) {\n      return yield* Effect.interrupt\n    }\n\n    const span = disableTracing ? undefined : yield* Effect.makeSpanScoped(`${spanPrefix}.${rpc._tag}`, {\n      captureStackTrace: false,\n      attributes: options.spanAttributes\n    })\n    const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n    const id = generateRequestId()\n\n    const scope = Context.unsafeGet(fiber.currentContext, Scope.Scope)\n    yield* Scope.addFinalizerExit(\n      scope,\n      (exit) => {\n        if (!entries.has(id)) return Effect.void\n        entries.delete(id)\n        return sendInterrupt(\n          id,\n          Exit.isFailure(exit)\n            ? Array.from(Cause.interruptors(exit.cause)).flatMap((id) => Array.from(FiberId.toSet(id)))\n            : [],\n          context\n        )\n      }\n    )\n\n    const mailbox = yield* Mailbox.make<any, any>(streamBufferSize)\n    entries.set(id, {\n      _tag: \"Mailbox\",\n      rpc,\n      mailbox,\n      scope,\n      context\n    })\n\n    yield* middleware({\n      _tag: \"Request\",\n      id,\n      tag: rpc._tag as Rpc.Tag<Rpcs>,\n      traceId: span?.traceId,\n      payload,\n      spanId: span?.spanId,\n      sampled: span?.sampled,\n      headers: Headers.merge(fiber.getFiberRef(currentHeaders), headers)\n    }).pipe(\n      Effect.flatMap(\n        (request) =>\n          options.onFromClient({\n            message: request,\n            context,\n            discard: false\n          })\n      ),\n      span ? Effect.withParentSpan(span) : identity,\n      Effect.catchAllCause((error) => mailbox.failCause(error)),\n      Effect.interruptible,\n      Effect.forkIn(scope)\n    )\n\n    return mailbox\n  })\n\n  const getRpcClientMiddleware = (rpc: Rpc.AnyWithProps): (request: Request<Rpcs>) => Effect.Effect<Request<Rpcs>> => {\n    const middlewares: Array<RpcMiddleware.RpcMiddlewareClient> = []\n    for (const tag of rpc.middlewares.values()) {\n      const middleware = context.unsafeMap.get(`${tag.key}/Client`)\n      if (!middleware) continue\n      middlewares.push(middleware)\n    }\n    return middlewares.length === 0\n      ? Effect.succeed\n      : function(request) {\n        let i = 0\n        return Effect.map(\n          Effect.whileLoop({\n            while: () => i < middlewares.length,\n            body: () =>\n              middlewares[i]({\n                rpc,\n                request\n              }) as Effect.Effect<Request<Rpcs>>,\n            step(nextRequest) {\n              request = nextRequest\n              i++\n            }\n          }),\n          () => request\n        )\n      }\n  }\n\n  const sendInterrupt = (\n    requestId: RequestId,\n    interruptors: ReadonlyArray<FiberId.FiberId>,\n    context: Context.Context<never>\n  ): Effect.Effect<void> =>\n    Effect.async<void>((resume) => {\n      const parentFiber = Option.getOrThrow(Fiber.getCurrentFiber())\n      const runtime = Runtime.make({\n        context: parentFiber.currentContext,\n        fiberRefs: parentFiber.getFiberRefs(),\n        runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n      })\n      const fiber = options.onFromClient({\n        message: { _tag: \"Interrupt\", requestId, interruptors },\n        context,\n        discard: false\n      }).pipe(\n        Effect.timeout(1000),\n        Runtime.runFork(runtime)\n      )\n      fiber.addObserver(() => {\n        resume(Effect.void)\n      })\n    })\n\n  const write = (message: FromServer<Rpcs>): Effect.Effect<void> => {\n    switch (message._tag) {\n      case \"Chunk\": {\n        const requestId = message.requestId\n        const entry = entries.get(requestId)\n        if (!entry || entry._tag !== \"Mailbox\") return Effect.void\n        return entry.mailbox.offerAll(message.values).pipe(\n          supportsAck\n            ? Effect.zipRight(\n              options.onFromClient({\n                message: { _tag: \"Ack\", requestId: message.requestId },\n                context: entry.context,\n                discard: false\n              })\n            )\n            : identity,\n          Effect.catchAllCause((cause) => entry.mailbox.done(Exit.failCause(cause)))\n        )\n      }\n      case \"Exit\": {\n        const requestId = message.requestId\n        const entry = entries.get(requestId)\n        if (!entry) return Effect.void\n        entries.delete(requestId)\n        if (entry._tag === \"Effect\") {\n          entry.resume(message.exit)\n          return Effect.void\n        }\n        return entry.mailbox.done(Exit.asVoid(message.exit))\n      }\n      case \"Defect\": {\n        return clearEntries(Exit.die(message.defect))\n      }\n      case \"ClientEnd\": {\n        return Effect.void\n      }\n    }\n  }\n\n  let client: any\n  if (options.flatten) {\n    const fns = new Map<string, any>()\n    client = function client(tag: string, payload: any, options?: {}) {\n      let fn = fns.get(tag)\n      if (!fn) {\n        fn = onRequest(group.requests.get(tag)! as any)\n        fns.set(tag, fn)\n      }\n      return fn(payload, options)\n    }\n  } else {\n    client = {}\n    for (const rpc of group.requests.values()) {\n      const dot = rpc._tag.indexOf(\".\")\n      const prefix = dot === -1 ? undefined : rpc._tag.slice(0, dot)\n      if (prefix !== undefined && !(prefix in client)) {\n        ;(client as any)[prefix] = {} as Mutable<RpcClient.Prefixed<Rpcs, typeof prefix>>\n      }\n      const target = prefix !== undefined ? (client as any)[prefix] : client\n      const tag = prefix !== undefined ? rpc._tag.slice(dot + 1) : rpc._tag\n      target[tag] = onRequest(rpc as any)\n    }\n  }\n\n  return { client, write } as const\n})\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport const make: <Rpcs extends Rpc.Any, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  } | undefined\n) => Effect.Effect<\n  Flatten extends true ? RpcClient.Flat<Rpcs> : RpcClient<Rpcs>,\n  never,\n  Protocol | Rpc.MiddlewareClient<Rpcs> | Scope.Scope\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any, const Flatten extends boolean = false>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly generateRequestId?: (() => RequestId) | undefined\n    readonly disableTracing?: boolean | undefined\n    readonly flatten?: Flatten | undefined\n  } | undefined\n) {\n  const { run, send, supportsAck, supportsTransferables } = yield* Protocol\n\n  type ClientEntry = {\n    readonly rpc: Rpc.AnyWithProps\n    readonly context: Context.Context<never>\n    readonly decodeChunk:\n      | ((chunk: ReadonlyArray<unknown>) => Effect.Effect<NonEmptyReadonlyArray<any>, ParseError, unknown>)\n      | undefined\n  }\n  const entries = new Map<RequestId, ClientEntry>()\n\n  const { client, write } = yield* makeNoSerialization(group, {\n    ...options,\n    supportsAck,\n    onFromClient({ message }) {\n      switch (message._tag) {\n        case \"Request\": {\n          const rpc = group.requests.get(message.tag)! as any as Rpc.AnyWithProps\n          const schemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)\n          const collector = supportsTransferables ? Transferable.unsafeMakeCollector() : undefined\n\n          const fiber = Option.getOrThrow(Fiber.getCurrentFiber())\n\n          const entry: ClientEntry = {\n            rpc,\n            context: collector\n              ? Context.add(fiber.currentContext, Transferable.Collector, collector)\n              : fiber.currentContext,\n            decodeChunk: Option.isSome(schemas)\n              ? Schema.decodeUnknown(Schema.NonEmptyArray(schemas.value.success))\n              : undefined\n          }\n          entries.set(message.id, entry)\n\n          return Schema.encode(rpc.payloadSchema)(message.payload).pipe(\n            Effect.locally(FiberRef.currentContext, entry.context),\n            Effect.orDie,\n            Effect.flatMap((payload) =>\n              send({\n                ...message,\n                id: String(message.id),\n                payload,\n                headers: Object.entries(message.headers)\n              }, collector && collector.unsafeClear())\n            )\n          ) as Effect.Effect<void>\n        }\n        case \"Ack\": {\n          const entry = entries.get(message.requestId)\n          if (!entry) return Effect.void\n          return send({\n            _tag: \"Ack\",\n            requestId: String(message.requestId)\n          }) as Effect.Effect<void>\n        }\n        case \"Interrupt\": {\n          const entry = entries.get(message.requestId)\n          if (!entry) return Effect.void\n          entries.delete(message.requestId)\n          return send({\n            _tag: \"Interrupt\",\n            requestId: String(message.requestId)\n          }) as Effect.Effect<void>\n        }\n        case \"Eof\": {\n          return Effect.void\n        }\n      }\n    }\n  })\n\n  yield* run((message) => {\n    switch (message._tag) {\n      case \"Chunk\": {\n        const requestId = RequestId(message.requestId)\n        const entry = entries.get(requestId)\n        if (!entry || !entry.decodeChunk) return Effect.void\n        return entry.decodeChunk(message.values).pipe(\n          Effect.locally(FiberRef.currentContext, entry.context),\n          Effect.orDie,\n          Effect.flatMap((chunk) =>\n            write({ _tag: \"Chunk\", clientId: 0, requestId: RequestId(message.requestId), values: chunk })\n          ),\n          Effect.onError((cause) =>\n            write({\n              _tag: \"Exit\",\n              clientId: 0,\n              requestId: RequestId(message.requestId),\n              exit: Exit.failCause(cause)\n            })\n          )\n        ) as Effect.Effect<void>\n      }\n      case \"Exit\": {\n        const requestId = RequestId(message.requestId)\n        const entry = entries.get(requestId)\n        if (!entry) return Effect.void\n        entries.delete(requestId)\n        return Schema.decode(Rpc.exitSchema(entry.rpc as any))(message.exit).pipe(\n          Effect.locally(FiberRef.currentContext, entry.context),\n          Effect.orDie,\n          Effect.matchCauseEffect({\n            onSuccess: (exit) => write({ _tag: \"Exit\", clientId: 0, requestId, exit }),\n            onFailure: (cause) => write({ _tag: \"Exit\", clientId: 0, requestId, exit: Exit.failCause(cause) })\n          })\n        ) as Effect.Effect<void>\n      }\n      case \"Defect\": {\n        return write({ _tag: \"Defect\", clientId: 0, defect: decodeDefect(message.defect) })\n      }\n      default: {\n        return Effect.void\n      }\n    }\n  }).pipe(\n    Effect.catchAllCause(Effect.logError),\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n\n  return client\n})\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const currentHeaders: FiberRef.FiberRef<Headers.Headers> = globalValue(\n  \"@effect/rpc/RpcClient/currentHeaders\",\n  () => FiberRef.unsafeMake(Headers.empty)\n)\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const withHeaders: {\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  (headers: Headers.Input): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R>\n} = dual(\n  2,\n  <A, E, R>(effect: Effect.Effect<A, E, R>, headers: Headers.Input): Effect.Effect<A, E, R> =>\n    Effect.locallyWith(effect, currentHeaders, Headers.merge(Headers.fromInput(headers)))\n)\n\n/**\n * @since 1.0.0\n * @category headers\n */\nexport const withHeadersEffect: {\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <E2, R2>(headers: Effect.Effect<Headers.Input, E2, R2>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | E2, R | R2>\n  /**\n   * @since 1.0.0\n   * @category headers\n   */\n  <A, E, R, E2, R2>(\n    effect: Effect.Effect<A, E, R>,\n    headers: Effect.Effect<Headers.Input, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2>\n} = dual(\n  2,\n  <A, E, R, E2, R2>(\n    effect: Effect.Effect<A, E, R>,\n    headers: Effect.Effect<Headers.Input, E2, R2>\n  ): Effect.Effect<A, E | E2, R | R2> => Effect.flatMap(headers, (headers) => withHeaders(effect, headers))\n)\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport class Protocol extends Context.Tag(\"@effect/rpc/RpcClient/Protocol\")<Protocol, {\n  readonly run: (\n    f: (data: FromServerEncoded) => Effect.Effect<void>\n  ) => Effect.Effect<never>\n  readonly send: (\n    request: FromClientEncoded,\n    transferables?: ReadonlyArray<globalThis.Transferable>\n  ) => Effect.Effect<void>\n  readonly supportsAck: boolean\n  readonly supportsTransferables: boolean\n}>() {\n  /**\n   * @since 1.0.0\n   */\n  static make = withRun<Protocol[\"Type\"]>()\n}\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolHttp = (client: HttpClient.HttpClient): Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  RpcSerialization.RpcSerialization\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const serialization = yield* RpcSerialization.RpcSerialization\n    const isJson = serialization.contentType === \"application/json\"\n\n    const send = (request: FromClientEncoded): Effect.Effect<void> => {\n      if (request._tag !== \"Request\") {\n        return Effect.void\n      }\n\n      const parser = serialization.unsafeMake()\n\n      const encoded = parser.encode(request)!\n      const body = typeof encoded === \"string\" ?\n        HttpBody.text(encoded, serialization.contentType) :\n        HttpBody.uint8Array(encoded, serialization.contentType)\n\n      if (isJson) {\n        return client.post(\"\", { body }).pipe(\n          Effect.flatMap((r) => r.json),\n          Effect.scoped,\n          Effect.flatMap((u) => {\n            if (!Array.isArray(u)) {\n              return Effect.dieMessage(`Expected an array of responses, but got: ${u}`)\n            }\n            let i = 0\n            return Effect.whileLoop({\n              while: () => i < u.length,\n              body: () => writeResponse(u[i++]),\n              step: constVoid\n            })\n          }),\n          Effect.orDie\n        )\n      }\n\n      return client.post(\"\", { body }).pipe(\n        Effect.flatMap((r) =>\n          Stream.runForEachChunk(r.stream, (chunk) => {\n            const responses = Chunk.toReadonlyArray(chunk).flatMap(parser.decode) as Array<FromServerEncoded>\n            if (responses.length === 0) return Effect.void\n            let i = 0\n            return Effect.whileLoop({\n              while: () => i < responses.length,\n              body: () => writeResponse(responses[i++]),\n              step: constVoid\n            })\n          })\n        ),\n        Effect.orDie\n      )\n    }\n\n    return {\n      send,\n      supportsAck: false,\n      supportsTransferables: false\n    }\n  }))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolHttp = (options: {\n  readonly url: string\n  readonly transformClient?: <E, R>(client: HttpClient.HttpClient.With<E, R>) => HttpClient.HttpClient.With<E, R>\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpClient.HttpClient> =>\n  Layer.scoped(\n    Protocol,\n    Effect.flatMap(\n      HttpClient.HttpClient,\n      (client) => {\n        client = HttpClient.mapRequest(client, HttpClientRequest.prependUrl(options.url))\n        return makeProtocolHttp(options.transformClient ? options.transformClient(client) : client)\n      }\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolSocket = (options?: {\n  readonly retryTransientErrors?: boolean | undefined\n}): Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  Scope.Scope | RpcSerialization.RpcSerialization | Socket.Socket\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const socket = yield* Socket.Socket\n    const serialization = yield* RpcSerialization.RpcSerialization\n\n    const write = yield* socket.writer\n\n    let parser = serialization.unsafeMake()\n\n    const pinger = yield* makePinger(write(parser.encode(constPing)!))\n\n    yield* Effect.suspend(() => {\n      parser = serialization.unsafeMake()\n      pinger.reset()\n      return socket.runRaw((message) => {\n        try {\n          const responses = parser.decode(message) as Array<FromServerEncoded>\n          if (responses.length === 0) return\n          let i = 0\n          return Effect.whileLoop({\n            while: () => i < responses.length,\n            body: () => {\n              const response = responses[i++]\n              if (response._tag === \"Pong\") {\n                pinger.onPong()\n              }\n              return writeResponse(response)\n            },\n            step: constVoid\n          })\n        } catch (defect) {\n          return writeResponse({ _tag: \"Defect\", defect })\n        }\n      }).pipe(\n        Effect.raceFirst(Effect.zipRight(\n          pinger.timeout,\n          Effect.fail(\n            new Socket.SocketGenericError({\n              reason: \"OpenTimeout\",\n              cause: new Error(\"ping timeout\")\n            })\n          )\n        ))\n      )\n    }).pipe(\n      Effect.zipRight(Effect.fail(\n        new Socket.SocketCloseError({\n          reason: \"Close\",\n          code: 1000\n        })\n      )),\n      Effect.tapErrorCause((cause) => {\n        const error = Cause.failureOption(cause)\n        if (\n          options?.retryTransientErrors && Option.isSome(error) &&\n          (error.value.reason === \"Open\" || error.value.reason === \"OpenTimeout\")\n        ) {\n          return Effect.void\n        }\n        return writeResponse({ _tag: \"Defect\", defect: Cause.squash(cause) })\n      }),\n      Effect.retry(Schedule.spaced(1000)),\n      Effect.annotateLogs({\n        module: \"RpcClient\",\n        method: \"makeProtocolSocket\"\n      }),\n      Effect.interruptible,\n      Effect.forkScoped\n    )\n\n    return {\n      send(request) {\n        const encoded = parser.encode(request)\n        if (encoded === undefined) return Effect.void\n        return Effect.orDie(write(encoded))\n      },\n      supportsAck: true,\n      supportsTransferables: false\n    }\n  }))\n\nconst makePinger = Effect.fnUntraced(function*<A, E, R>(writePing: Effect.Effect<A, E, R>) {\n  let recievedPong = true\n  const latch = Effect.unsafeMakeLatch()\n  const reset = () => {\n    recievedPong = true\n    latch.unsafeClose()\n  }\n  const onPong = () => {\n    recievedPong = true\n  }\n  yield* Effect.suspend(() => {\n    if (!recievedPong) return latch.open\n    recievedPong = false\n    return writePing\n  }).pipe(\n    Effect.delay(\"10 seconds\"),\n    Effect.ignore,\n    Effect.forever,\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n  return { timeout: latch.await, reset, onPong } as const\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWorker = (\n  options: {\n    readonly size: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n  } | {\n    readonly minSize: number\n    readonly maxSize: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n    readonly timeToLive: Duration.DurationInput\n  }\n): Effect.Effect<\n  Protocol[\"Type\"],\n  WorkerError,\n  Scope.Scope | Worker.PlatformWorker | Worker.Spawner\n> =>\n  Protocol.make(Effect.fnUntraced(function*(writeResponse) {\n    const worker = yield* Worker.PlatformWorker\n    const scope = yield* Effect.scope\n    let workerId = 0\n    const initialMessage = yield* Effect.serviceOption(RpcWorker.InitialMessage)\n\n    const entries = new Map<string, {\n      readonly worker: Worker.BackingWorker<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>\n      readonly latch: Effect.Latch\n    }>()\n\n    const acquire = Effect.gen(function*() {\n      const id = workerId++\n      const backing = yield* worker.spawn<FromClientEncoded | RpcWorker.InitialMessage.Encoded, FromServerEncoded>(id)\n      const readyLatch = yield* Effect.makeLatch()\n\n      yield* backing.run((message) => {\n        if (message[0] === 0) {\n          return readyLatch.open\n        }\n        const response = message[1]\n        if (response._tag === \"Exit\") {\n          const entry = entries.get(response.requestId)\n          if (entry) {\n            entries.delete(response.requestId)\n            entry.latch.unsafeOpen()\n            return writeResponse(response)\n          }\n        } else if (response._tag === \"Defect\") {\n          for (const [requestId, entry] of entries) {\n            entries.delete(requestId)\n            entry.latch.unsafeOpen()\n          }\n          return writeResponse(response)\n        }\n        return writeResponse(response)\n      }).pipe(\n        Effect.tapErrorCause((cause) => writeResponse({ _tag: \"Defect\", defect: Cause.squash(cause) })),\n        Effect.retry(Schedule.spaced(1000)),\n        Effect.annotateLogs({\n          module: \"RpcClient\",\n          method: \"makeProtocolWorker\"\n        }),\n        Effect.interruptible,\n        Effect.forkScoped\n      )\n\n      yield* readyLatch.await\n\n      if (Option.isSome(initialMessage)) {\n        const [value, transfers] = yield* initialMessage.value\n        yield* backing.send({ _tag: \"InitialMessage\", value }, transfers)\n      }\n\n      return backing\n    })\n\n    const pool = \"minSize\" in options ?\n      yield* Pool.makeWithTTL({\n        acquire,\n        min: options.minSize,\n        max: options.maxSize,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization,\n        timeToLive: options.timeToLive\n      }) :\n      yield* Pool.make({\n        acquire,\n        size: options.size,\n        concurrency: options.concurrency,\n        targetUtilization: options.targetUtilization\n      })\n\n    yield* Scope.addFinalizer(\n      scope,\n      Effect.sync(() => {\n        for (const entry of entries.values()) {\n          entry.latch.unsafeOpen()\n        }\n        entries.clear()\n      })\n    )\n\n    const send = (request: FromClientEncoded, transferables?: ReadonlyArray<globalThis.Transferable>) => {\n      switch (request._tag) {\n        case \"Request\": {\n          return pool.get.pipe(\n            Effect.flatMap((worker) => {\n              const latch = Effect.unsafeMakeLatch(false)\n              entries.set(request.id, { worker, latch })\n              return Effect.zipRight(worker.send(request, transferables), latch.await)\n            }),\n            Effect.scoped,\n            Effect.orDie\n          )\n        }\n        case \"Interrupt\": {\n          const entry = entries.get(request.requestId)\n          if (!entry) return Effect.void\n          entries.delete(request.requestId)\n          entry.latch.unsafeOpen()\n          return Effect.orDie(entry.worker.send(request))\n        }\n        case \"Ack\": {\n          const entry = entries.get(request.requestId)\n          if (!entry) return Effect.void\n          return Effect.orDie(entry.worker.send(request))\n        }\n      }\n      return Effect.void\n    }\n\n    yield* Effect.scoped(pool.get)\n\n    return {\n      send,\n      supportsAck: true,\n      supportsTransferables: true\n    }\n  }))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolWorker = (\n  options: {\n    readonly size: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n  } | {\n    readonly minSize: number\n    readonly maxSize: number\n    readonly concurrency?: number | undefined\n    readonly targetUtilization?: number | undefined\n    readonly timeToLive: Duration.DurationInput\n  }\n): Layer.Layer<Protocol, WorkerError, Worker.PlatformWorker | Worker.Spawner> =>\n  Layer.scoped(Protocol, makeProtocolWorker(options))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolSocket = (options?: {\n  readonly retryTransientErrors?: boolean | undefined\n}): Layer.Layer<\n  Protocol,\n  never,\n  Socket.Socket | RpcSerialization.RpcSerialization\n> => Layer.scoped(Protocol, makeProtocolSocket(options))\n\n// internal\n\nconst decodeDefect = Schema.decodeSync(Schema.Defect)\n", "import type * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\n\n/** @internal */\nexport const withRun = <\n  A extends {\n    readonly run: (f: (...args: Array<any>) => Effect.Effect<void>) => Effect.Effect<never>\n  }\n>() =>\n<EX, RX>(f: (write: Parameters<A[\"run\"]>[0]) => Effect.Effect<Omit<A, \"run\">, EX, RX>): Effect.Effect<A, EX, RX> =>\n  Effect.suspend(() => {\n    const semaphore = Effect.unsafeMakeSemaphore(1)\n    let buffer: Array<[Array<any>, Context.Context<never>]> = []\n    let write = (...args: Array<any>): Effect.Effect<void> =>\n      Effect.contextWith((context) => {\n        buffer.push([args, context])\n      })\n    return Effect.map(f((...args) => write(...args)), (a) => ({\n      ...a,\n      run(f) {\n        return semaphore.withPermits(1)(Effect.gen(function*() {\n          const prev = write\n          write = f\n\n          for (const [args, context] of buffer) {\n            yield* Effect.provide(write(...args), context)\n          }\n          buffer = []\n\n          return yield* Effect.onExit(Effect.never, () => {\n            write = prev\n            return Effect.void\n          })\n        }))\n      }\n    } as A))\n  })\n", "/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport type { Branded } from \"effect/Brand\"\nimport type * as FiberId from \"effect/FiberId\"\nimport * as Schema from \"effect/Schema\"\nimport type * as Rpc from \"./Rpc.js\"\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type FromClient<A extends Rpc.Any> = Request<A> | Ack | Interrupt | Eof\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type FromClientEncoded = RequestEncoded | AckEncoded | InterruptEncoded | Ping | Eof\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const RequestIdTypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcServer/RequestId\")\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type RequestIdTypeId = typeof RequestIdTypeId\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport type RequestId = Branded<bigint, RequestIdTypeId>\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const RequestId = (id: bigint | string): RequestId =>\n  typeof id === \"bigint\" ? id as RequestId : BigInt(id) as RequestId\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface RequestEncoded {\n  readonly _tag: \"Request\"\n  readonly id: string\n  readonly tag: string\n  readonly payload: unknown\n  readonly headers: ReadonlyArray<[string, string]>\n  readonly traceId?: string | undefined\n  readonly spanId?: string | undefined\n  readonly sampled?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Request<A extends Rpc.Any> {\n  readonly _tag: \"Request\"\n  readonly id: RequestId\n  readonly tag: Rpc.Tag<A>\n  readonly payload: Rpc.Payload<A>\n  readonly headers: Headers\n  readonly traceId?: string | undefined\n  readonly spanId?: string | undefined\n  readonly sampled?: boolean | undefined\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Ack {\n  readonly _tag: \"Ack\"\n  readonly requestId: RequestId\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Interrupt {\n  readonly _tag: \"Interrupt\"\n  readonly requestId: RequestId\n  readonly interruptors: ReadonlyArray<FiberId.FiberId>\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface AckEncoded {\n  readonly _tag: \"Ack\"\n  readonly requestId: string\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface InterruptEncoded {\n  readonly _tag: \"Interrupt\"\n  readonly requestId: string\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Eof {\n  readonly _tag: \"Eof\"\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport interface Ping {\n  readonly _tag: \"Ping\"\n}\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const constEof: Eof = { _tag: \"Eof\" }\n\n/**\n * @since 1.0.0\n * @category request\n */\nexport const constPing: Ping = { _tag: \"Ping\" }\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type FromServer<A extends Rpc.Any> =\n  | ResponseChunk<A>\n  | ResponseExit<A>\n  | ResponseDefect\n  | ClientEnd\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type FromServerEncoded = ResponseChunkEncoded | ResponseExitEncoded | ResponseDefectEncoded | Pong\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const ResponseIdTypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcServer/ResponseId\")\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type ResponseIdTypeId = typeof ResponseIdTypeId\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport type ResponseId = Branded<number, ResponseIdTypeId>\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseChunkEncoded {\n  readonly _tag: \"Chunk\"\n  readonly requestId: string\n  readonly values: NonEmptyReadonlyArray<unknown>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseChunk<A extends Rpc.Any> {\n  readonly _tag: \"Chunk\"\n  readonly clientId: number\n  readonly requestId: RequestId\n  readonly values: NonEmptyReadonlyArray<Rpc.SuccessChunk<A>>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseExitEncoded {\n  readonly _tag: \"Exit\"\n  readonly requestId: string\n  readonly exit: Schema.ExitEncoded<unknown, unknown, unknown>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseExit<A extends Rpc.Any> {\n  readonly _tag: \"Exit\"\n  readonly clientId: number\n  readonly requestId: RequestId\n  readonly exit: Rpc.Exit<A>\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseDefectEncoded {\n  readonly _tag: \"Defect\"\n  readonly defect: unknown\n}\n\nconst encodeDefect = Schema.encodeSync(Schema.Defect)\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const ResponseDefectEncoded = (input: unknown): ResponseDefectEncoded => ({\n  _tag: \"Defect\",\n  defect: encodeDefect(input)\n})\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ResponseDefect {\n  readonly _tag: \"Defect\"\n  readonly clientId: number\n  readonly defect: unknown\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface ClientEnd {\n  readonly _tag: \"ClientEnd\"\n  readonly clientId: number\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport interface Pong {\n  readonly _tag: \"Pong\"\n}\n\n/**\n * @since 1.0.0\n * @category response\n */\nexport const constPong: Pong = { _tag: \"Pong\" }\n", "/**\n * @since 1.0.0\n */\nimport { Msgpackr } from \"@effect/platform/MsgPack\"\nimport * as Context from \"effect/Context\"\nimport * as Layer from \"effect/Layer\"\nimport { hasProperty } from \"effect/Predicate\"\nimport type * as RpcMessage from \"./RpcMessage.js\"\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport class RpcSerialization extends Context.Tag(\"@effect/rpc/RpcSerialization\")<RpcSerialization, {\n  unsafeMake(): Parser\n  readonly contentType: string\n  readonly includesFraming: boolean\n}>() {}\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport interface Parser {\n  readonly decode: (data: Uint8Array | string) => ReadonlyArray<unknown>\n  readonly encode: (response: unknown) => Uint8Array | string | undefined\n}\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const json: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/json\",\n  includesFraming: false,\n  unsafeMake: () => {\n    const decoder = new TextDecoder()\n    return {\n      decode: (bytes) => [JSON.parse(typeof bytes === \"string\" ? bytes : decoder.decode(bytes))],\n      encode: (response) => JSON.stringify(response)\n    }\n  }\n})\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const ndjson: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/ndjson\",\n  includesFraming: true,\n  unsafeMake: () => {\n    const decoder = new TextDecoder()\n    let buffer = \"\"\n    return ({\n      decode: (bytes) => {\n        buffer += typeof bytes === \"string\" ? bytes : decoder.decode(bytes)\n        let position = 0\n        let nlIndex = buffer.indexOf(\"\\n\", position)\n        const items: Array<unknown> = []\n        while (nlIndex !== -1) {\n          const item = JSON.parse(buffer.slice(position, nlIndex))\n          items.push(item)\n          position = nlIndex + 1\n          nlIndex = buffer.indexOf(\"\\n\", position)\n        }\n        buffer = buffer.slice(position)\n        return items\n      },\n      encode: (response) => {\n        if (Array.isArray(response)) {\n          if (response.length === 0) return undefined\n          let data = \"\"\n          for (let i = 0; i < response.length; i++) {\n            data += JSON.stringify(response[i]) + \"\\n\"\n          }\n          return data\n        }\n        return JSON.stringify(response) + \"\\n\"\n      }\n    })\n  }\n})\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const jsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): RpcSerialization[\"Type\"] =>\n  RpcSerialization.of({\n    contentType: options?.contentType ?? \"application/json\",\n    includesFraming: false,\n    unsafeMake: () => {\n      const decoder = new TextDecoder()\n      const batches = new Map<string, {\n        readonly size: number\n        readonly responses: Map<string, RpcMessage.FromServerEncoded>\n      }>()\n      return {\n        decode: (bytes) => {\n          const decoded: JsonRpcMessage | Array<JsonRpcMessage> = JSON.parse(\n            typeof bytes === \"string\" ? bytes : decoder.decode(bytes)\n          )\n          return decodeJsonRpcRaw(decoded, batches)\n        },\n        encode: (response) => {\n          if (Array.isArray(response)) {\n            if (response.length === 0) return undefined\n            return JSON.stringify(response.map(encodeJsonRpcMessage))\n          }\n          const encoded = encodeJsonRpcRaw(response as any, batches)\n          return encoded && JSON.stringify(encoded)\n        }\n      }\n    }\n  })\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const ndJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): RpcSerialization[\"Type\"] =>\n  RpcSerialization.of({\n    contentType: options?.contentType ?? \"application/json-rpc\",\n    includesFraming: true,\n    unsafeMake: () => {\n      const parser = ndjson.unsafeMake()\n      const batches = new Map<string, {\n        readonly size: number\n        readonly responses: Map<string, RpcMessage.FromServerEncoded>\n      }>()\n      return ({\n        decode: (bytes) => {\n          const frames = parser.decode(bytes)\n          if (frames.length === 0) return []\n          const messages: Array<RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded> = []\n          for (let i = 0; i < frames.length; i++) {\n            const frame = frames[i]\n            // eslint-disable-next-line no-restricted-syntax\n            messages.push(...decodeJsonRpcRaw(frame as any, batches) as any)\n          }\n          return messages\n        },\n        encode: (response) => {\n          if (Array.isArray(response)) {\n            return parser.encode(response.map(encodeJsonRpcMessage))\n          }\n          const encoded = encodeJsonRpcRaw(response as any, batches)\n          return encoded && parser.encode(encoded)\n        }\n      })\n    }\n  })\n\nfunction decodeJsonRpcRaw(\n  decoded: JsonRpcMessage | Array<JsonRpcMessage>,\n  batches: Map<string, {\n    readonly size: number\n    readonly responses: Map<string, RpcMessage.FromServerEncoded>\n  }>\n) {\n  if (Array.isArray(decoded)) {\n    const batch = {\n      size: 0,\n      responses: new Map<string, RpcMessage.FromServerEncoded>()\n    }\n    const messages: Array<RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded> = []\n    for (let i = 0; i < decoded.length; i++) {\n      const message = decodeJsonRpcMessage(decoded[i])\n      if (message._tag === \"Request\") {\n        batch.size++\n        batches.set(message.id, batch)\n      }\n    }\n    return messages\n  }\n  return Array.isArray(decoded) ? decoded.map(decodeJsonRpcMessage) : [decodeJsonRpcMessage(decoded)]\n}\n\nfunction decodeJsonRpcMessage(decoded: JsonRpcMessage): RpcMessage.FromClientEncoded | RpcMessage.FromServerEncoded {\n  if (\"method\" in decoded) {\n    if (!decoded.id && decoded.method.startsWith(\"@effect/rpc/\")) {\n      const tag = decoded.method.slice(\"@effect/rpc/\".length) as\n        | RpcMessage.FromServerEncoded[\"_tag\"]\n        | Exclude<RpcMessage.FromClientEncoded[\"_tag\"], \"Request\">\n      const requestId = (decoded as any).params?.requestId\n      return requestId ?\n        {\n          _tag: tag,\n          requestId: String(requestId)\n        } as any :\n        { _tag: tag } as any\n    }\n    return {\n      _tag: \"Request\",\n      id: decoded.id ? String(decoded.id) : \"\",\n      tag: decoded.method,\n      payload: decoded.params,\n      headers: decoded.headers ?? [],\n      traceId: decoded.traceId,\n      spanId: decoded.spanId,\n      sampled: decoded.sampled\n    }\n  } else if (decoded.error && decoded.error._tag === \"Defect\") {\n    return {\n      _tag: \"Defect\",\n      defect: decoded.error.data\n    }\n  } else if (decoded.chunk === true) {\n    return {\n      _tag: \"Chunk\",\n      requestId: String(decoded.id),\n      values: decoded.result as any\n    }\n  }\n  return {\n    _tag: \"Exit\",\n    requestId: String(decoded.id),\n    exit: decoded.error != null ?\n      {\n        _tag: \"Failure\",\n        cause: decoded.error._tag === \"Cause\" ?\n          decoded.error.data as any :\n          {\n            _tag: \"Die\",\n            defect: decoded.error\n          }\n      } :\n      {\n        _tag: \"Success\",\n        value: decoded.result\n      }\n  }\n}\n\nfunction encodeJsonRpcRaw(\n  response: RpcMessage.FromServerEncoded | RpcMessage.FromClientEncoded,\n  batches: Map<string, {\n    readonly size: number\n    readonly responses: Map<string, RpcMessage.FromServerEncoded>\n  }>\n) {\n  if (!(\"requestId\" in response)) {\n    return encodeJsonRpcMessage(response)\n  }\n  const batch = batches.get(response.requestId)\n  if (batch) {\n    batches.delete(response.requestId)\n    batch.responses.set(response.requestId, response as any)\n    if (batch.size === batch.responses.size) {\n      return Array.from(batch.responses.values(), encodeJsonRpcMessage)\n    }\n    return undefined\n  }\n  return encodeJsonRpcMessage(response)\n}\n\nfunction encodeJsonRpcMessage(response: RpcMessage.FromServerEncoded | RpcMessage.FromClientEncoded): JsonRpcMessage {\n  switch (response._tag) {\n    case \"Request\":\n      return {\n        jsonrpc: \"2.0\",\n        method: response.tag,\n        params: response.payload,\n        id: response.id && Number(response.id),\n        headers: response.headers,\n        traceId: response.traceId,\n        spanId: response.spanId,\n        sampled: response.sampled\n      }\n    case \"Ping\":\n    case \"Pong\":\n    case \"Interrupt\":\n    case \"Ack\":\n    case \"Eof\":\n      return {\n        jsonrpc: \"2.0\",\n        method: `@effect/rpc/${response._tag}`,\n        params: \"requestId\" in response ? { requestId: response.requestId } : undefined\n      }\n    case \"Chunk\":\n      return {\n        jsonrpc: \"2.0\",\n        chunk: true,\n        id: Number(response.requestId),\n        result: response.values\n      }\n    case \"Exit\":\n      return {\n        jsonrpc: \"2.0\",\n        id: response.requestId ? Number(response.requestId) : undefined,\n        result: response.exit._tag === \"Success\" ? response.exit.value : undefined,\n        error: response.exit._tag === \"Failure\" ?\n          {\n            _tag: \"Cause\",\n            code: response.exit.cause._tag === \"Fail\" && hasProperty(response.exit.cause.error, \"code\")\n              ? Number(response.exit.cause.error.code)\n              : 0,\n            message: response.exit.cause._tag === \"Fail\" && hasProperty(response.exit.cause.error, \"message\")\n              ? response.exit.cause.error.message\n              : JSON.stringify(response.exit.cause),\n            data: response.exit.cause\n          } :\n          undefined\n      } as any\n    case \"Defect\":\n      return {\n        jsonrpc: \"2.0\",\n        id: jsonRpcInternalError,\n        error: {\n          _tag: \"Defect\",\n          code: 1,\n          message: \"A defect occurred\",\n          data: response.defect\n        }\n      }\n  }\n}\n\nconst jsonRpcInternalError = -32603\n\ninterface JsonRpcRequest {\n  readonly jsonrpc: \"2.0\"\n  readonly id?: number | string | null\n  readonly method: string\n  readonly params?: unknown\n  readonly headers?: ReadonlyArray<[string, string]>\n  readonly traceId?: string\n  readonly spanId?: string\n  readonly sampled?: boolean\n}\n\ninterface JsonRpcResponse {\n  readonly jsonrpc: \"2.0\"\n  readonly id?: number | string | null\n  readonly result?: unknown\n  readonly chunk?: boolean\n  readonly error?: {\n    readonly code: number\n    readonly message: string\n    readonly data?: unknown\n    readonly _tag?: \"Cause\" | \"Defect\"\n  }\n}\n\ntype JsonRpcMessage = JsonRpcRequest | JsonRpcResponse\n\n/**\n * @since 1.0.0\n * @category serialization\n */\nexport const msgPack: RpcSerialization[\"Type\"] = RpcSerialization.of({\n  contentType: \"application/msgpack\",\n  includesFraming: true,\n  unsafeMake: () => {\n    const unpackr = new Msgpackr.Unpackr()\n    const packr = new Msgpackr.Packr()\n    const encoder = new TextEncoder()\n    return {\n      decode: (bytes) => unpackr.unpackMultiple(typeof bytes === \"string\" ? encoder.encode(bytes) : bytes),\n      encode: (response) => packr.pack(response)\n    }\n  }\n})\n\n/**\n * A rpc serialization layer that uses JSON for serialization.\n *\n * Use this if your protocol supports framing for messages, otherwise use\n * {@link layerNdjson}.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerJson: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, json)\n\n/**\n * A rpc serialization layer that uses NDJSON for serialization.\n *\n * Use this if your protocol does not support framing for messages, otherwise\n * use {@link layerJson}.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerNdjson: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, ndjson)\n\n/**\n * A rpc serialization layer that uses JSON-RPC for serialization.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): Layer.Layer<RpcSerialization> => Layer.succeed(RpcSerialization, jsonRpc(options))\n\n/**\n * A rpc serialization layer that uses JSON-RPC for serialization seperated by\n * new lines.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerNdJsonRpc = (options?: {\n  readonly contentType?: string | undefined\n}): Layer.Layer<RpcSerialization> => Layer.succeed(RpcSerialization, ndJsonRpc(options))\n\n/**\n * A rpc serialization layer that uses MessagePack for serialization.\n *\n * MessagePack has a more compact binary format compared to JSON and NDJSON. It\n * also has better support for binary data.\n *\n * @since 1.0.0\n * @category serialization\n */\nexport const layerMsgPack: Layer.Layer<RpcSerialization> = Layer.succeed(RpcSerialization, msgPack)\n", "/**\n * @since 1.0.0\n */\nimport * as Transferable from \"@effect/platform/Transferable\"\nimport type { NoSuchElementException } from \"effect/Cause\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Layer from \"effect/Layer\"\nimport type { ParseError } from \"effect/ParseResult\"\nimport * as Schema from \"effect/Schema\"\nimport type { Protocol } from \"./RpcServer.js\"\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport class InitialMessage extends Context.Tag(\"@effect/rpc/RpcWorker/InitialMessage\")<\n  InitialMessage,\n  Effect.Effect<\n    readonly [\n      data: unknown,\n      transfers: ReadonlyArray<Transferable>\n    ]\n  >\n>() {}\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport declare namespace InitialMessage {\n  /**\n   * @since 1.0.0\n   * @category initial message\n   */\n  export interface Encoded {\n    readonly _tag: \"InitialMessage\"\n    readonly value: unknown\n  }\n}\n\nconst ProtocolTag: typeof Protocol = Context.GenericTag(\"@effect/rpc/RpcServer/Protocol\") as any\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const makeInitialMessage = <A, I, R, E, R2>(\n  schema: Schema.Schema<A, I, R>,\n  effect: Effect.Effect<A, E, R2>\n): Effect.Effect<\n  readonly [data: unknown, transferables: ReadonlyArray<globalThis.Transferable>],\n  E | ParseError,\n  R | R2\n> =>\n  Effect.flatMap(effect, (value) => {\n    const collector = Transferable.unsafeMakeCollector()\n    return Schema.encode(schema)(value).pipe(\n      Effect.provideService(Transferable.Collector, collector),\n      Effect.map((encoded) => [encoded, collector.unsafeClear()] as const)\n    )\n  })\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const layerInitialMessage = <A, I, R, R2>(\n  schema: Schema.Schema<A, I, R>,\n  build: Effect.Effect<A, never, R2>\n): Layer.Layer<InitialMessage, never, R | R2> =>\n  Layer.effect(\n    InitialMessage,\n    Effect.contextWith((context: Context.Context<R | R2>) =>\n      Effect.provide(Effect.orDie(makeInitialMessage(schema, build)), context)\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category initial message\n */\nexport const initialMessage = <A, I, R>(\n  schema: Schema.Schema<A, I, R>\n): Effect.Effect<A, NoSuchElementException | ParseError, Protocol | R> =>\n  ProtocolTag.pipe(\n    Effect.flatMap((protocol) => protocol.initialMessage),\n    Effect.flatten,\n    Effect.flatMap(Schema.decodeUnknown(schema))\n  )\n", "/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport { identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport type { ReadonlyMailbox } from \"effect/Mailbox\"\nimport { type Pipeable } from \"effect/Pipeable\"\nimport type * as Record from \"effect/Record\"\nimport * as Schema from \"effect/Schema\"\nimport type { Scope } from \"effect/Scope\"\nimport * as Stream from \"effect/Stream\"\nimport * as Rpc from \"./Rpc.js\"\nimport type * as RpcMiddleware from \"./RpcMiddleware.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcGroup\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport interface RpcGroup<in out R extends Rpc.Any> extends Pipeable {\n  new(_: never): {}\n\n  readonly [TypeId]: TypeId\n  readonly requests: ReadonlyMap<string, R>\n  readonly annotations: Context.Context<never>\n\n  /**\n   * Add one or more procedures to the group.\n   */\n  add<const Rpcs2 extends ReadonlyArray<Rpc.Any>>(\n    ...rpcs: Rpcs2\n  ): RpcGroup<R | Rpcs2[number]>\n\n  /**\n   * Merge this group with one or more other groups.\n   */\n  merge<const Groups extends ReadonlyArray<Any>>(\n    ...groups: Groups\n  ): RpcGroup<R | Rpcs<Groups[number]>>\n\n  /**\n   * Add middleware to all the procedures added to the group until this point.\n   */\n  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): RpcGroup<Rpc.AddMiddleware<R, M>>\n\n  /**\n   * Add a prefix to the procedures in this group, returning a new group\n   */\n  prefix<const Prefix extends string>(prefix: Prefix): RpcGroup<Rpc.Prefixed<R, Prefix>>\n\n  /**\n   * Implement the handlers for the procedures in this group, returning a\n   * context object.\n   */\n  toHandlersContext<\n    Handlers extends HandlersFrom<R>,\n    EX = never,\n    RX = never\n  >(\n    build:\n      | Handlers\n      | Effect.Effect<Handlers, EX, RX>\n  ): Effect.Effect<\n    Context.Context<Rpc.ToHandler<R>>,\n    EX,\n    | RX\n    | HandlersContext<R, Handlers>\n  >\n\n  /**\n   * Implement the handlers for the procedures in this group.\n   */\n  toLayer<\n    Handlers extends HandlersFrom<R>,\n    EX = never,\n    RX = never\n  >(\n    build:\n      | Handlers\n      | Effect.Effect<Handlers, EX, RX>\n  ): Layer.Layer<\n    Rpc.ToHandler<R>,\n    EX,\n    | Exclude<RX, Scope>\n    | HandlersContext<R, Handlers>\n  >\n\n  of<const Handlers extends HandlersFrom<R>>(handlers: Handlers): Handlers\n\n  /**\n   * Implement a single handler from the group.\n   */\n  toLayerHandler<\n    const Tag extends R[\"_tag\"],\n    Handler extends HandlerFrom<R, Tag>,\n    EX = never,\n    RX = never\n  >(\n    tag: Tag,\n    build:\n      | Handler\n      | Effect.Effect<Handler, EX, RX>\n  ): Layer.Layer<\n    Rpc.Handler<Tag>,\n    EX,\n    | Exclude<RX, Scope>\n    | HandlerContext<R, Tag, Handler>\n  >\n\n  /**\n   * Retrieve a handler for a specific procedure in the group.\n   */\n  accessHandler<const Tag extends R[\"_tag\"]>(tag: Tag): Effect.Effect<\n    (\n      payload: Rpc.Payload<Extract<R, { readonly _tag: Tag }>>,\n      headers: Headers\n    ) => Rpc.ResultFrom<Extract<R, { readonly _tag: Tag }>, never>,\n    never,\n    Rpc.Handler<Tag>\n  >\n\n  /**\n   * Annotate the group with a value.\n   */\n  annotate<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>\n\n  /**\n   * Annotate the Rpc's above this point with a value.\n   */\n  annotateRpcs<I, S>(tag: Context.Tag<I, S>, value: S): RpcGroup<R>\n\n  /**\n   * Annotate the group with a context object.\n   */\n  annotateContext<S>(context: Context.Context<S>): RpcGroup<R>\n\n  /**\n   * Annotate the Rpc's above this point with a context object.\n   */\n  annotateRpcsContext<S>(context: Context.Context<S>): RpcGroup<R>\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport interface Any {\n  readonly [TypeId]: TypeId\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlersFrom<Rpc extends Rpc.Any> = {\n  readonly [Current in Rpc as Current[\"_tag\"]]: Rpc.ToHandlerFn<Current>\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlerFrom<Rpc extends Rpc.Any, Tag extends Rpc[\"_tag\"]> = Extract<Rpc, { readonly _tag: Tag }> extends\n  infer Current ? Current extends Rpc.Any ? Rpc.ToHandlerFn<Current> : never : never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlersContext<Rpcs extends Rpc.Any, Handlers> = keyof Handlers extends infer K ?\n  K extends keyof Handlers & string ? HandlerContext<Rpcs, K, Handlers[K]> : never :\n  never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type HandlerContext<Rpcs extends Rpc.Any, K extends Rpcs[\"_tag\"], Handler> = [Rpc.IsStream<Rpcs, K>] extends\n  [true] ? Handler extends (...args: any) =>\n    | Stream.Stream<infer _A, infer _E, infer _R>\n    | Rpc.Fork<Stream.Stream<infer _A, infer _E, infer _R>>\n    | Effect.Effect<\n      ReadonlyMailbox<infer _A, infer _E>,\n      infer _EX,\n      infer _R\n    >\n    | Rpc.Fork<\n      Effect.Effect<\n        ReadonlyMailbox<infer _A, infer _E>,\n        infer _EX,\n        infer _R\n      >\n    > ? Exclude<Rpc.ExcludeProvides<_R, Rpcs, K>, Scope> :\n  never :\n  Handler extends (\n    ...args: any\n  ) => Effect.Effect<infer _A, infer _E, infer _R> | Rpc.Fork<Effect.Effect<infer _A, infer _E, infer _R>> ?\n    Rpc.ExcludeProvides<_R, Rpcs, K>\n  : never\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport type Rpcs<Group> = Group extends RpcGroup<infer R> ? string extends R[\"_tag\"] ? never : R : never\n\nconst RpcGroupProto = {\n  add(this: RpcGroup<any>, ...rpcs: Array<any>) {\n    return makeProto({\n      requests: resolveInput(\n        ...this.requests.values(),\n        ...rpcs\n      ),\n      annotations: this.annotations\n    })\n  },\n  merge(this: RpcGroup<any>, ...groups: ReadonlyArray<RpcGroup<any>>) {\n    const requests = new Map(this.requests)\n    const annotations = new Map(this.annotations.unsafeMap)\n\n    for (const group of groups) {\n      for (const [tag, rpc] of group.requests) {\n        requests.set(tag, rpc)\n      }\n      for (const [key, value] of group.annotations.unsafeMap) {\n        annotations.set(key, value)\n      }\n    }\n\n    return makeProto({\n      requests,\n      annotations: Context.unsafeMake(annotations)\n    })\n  },\n  middleware(this: RpcGroup<any>, middleware: RpcMiddleware.TagClassAny) {\n    const requests = new Map<string, any>()\n    for (const [tag, rpc] of this.requests) {\n      requests.set(tag, rpc.middleware(middleware))\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  },\n  toHandlersContext(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Effect.gen(this, function*() {\n      const context = yield* Effect.context<never>()\n      const handlers = Effect.isEffect(build) ? yield* build : build\n      const contextMap = new Map<string, unknown>()\n      for (const [tag, handler] of Object.entries(handlers)) {\n        const rpc = this.requests.get(tag)!\n        contextMap.set(rpc.key, {\n          handler,\n          context\n        })\n      }\n      return Context.unsafeMake(contextMap)\n    })\n  },\n  prefix<const Prefix extends string>(this: RpcGroup<any>, prefix: Prefix) {\n    const requests = new Map<string, any>()\n    for (const [rpc] of this.requests.values()) {\n      const newRpc = rpc.prefix(prefix)\n      requests.set(newRpc._tag, newRpc)\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  },\n  toLayer(this: RpcGroup<any>, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Layer.scopedContext(this.toHandlersContext(build))\n  },\n  of: identity,\n  toLayerHandler(this: RpcGroup<any>, tag: string, build: Effect.Effect<Record<string, (request: any) => any>>) {\n    return Layer.scopedContext(Effect.gen(this, function*() {\n      const context = yield* Effect.context<never>()\n      const handler = Effect.isEffect(build) ? yield* build : build\n      const contextMap = new Map<string, unknown>()\n      const rpc = this.requests.get(tag)!\n      contextMap.set(rpc.key, {\n        handler,\n        context\n      })\n      return Context.unsafeMake(contextMap)\n    }))\n  },\n  accessHandler(this: RpcGroup<any>, tag: string) {\n    return Effect.contextWith((parentContext: Context.Context<any>) => {\n      const rpc = this.requests.get(tag)!\n      const { context, handler } = parentContext.unsafeMap.get(rpc.key) as Rpc.Handler<any>\n      return (payload: Rpc.Payload<any>, headers: Headers) => {\n        const result = handler(payload, headers)\n        const effectOrStream = Rpc.isFork(result) ? result.value : result\n        return Effect.isEffect(effectOrStream)\n          ? Effect.provide(effectOrStream, context)\n          : Stream.provideContext(effectOrStream, context)\n      }\n    })\n  },\n  annotate(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {\n    return makeProto({\n      requests: this.requests,\n      annotations: Context.add(this.annotations, tag, value)\n    })\n  },\n  annotateRpcs(this: RpcGroup<any>, tag: Context.Tag<any, any>, value: any) {\n    return this.annotateRpcsContext(Context.make(tag, value))\n  },\n  annotateContext(this: RpcGroup<any>, context: Context.Context<any>) {\n    return makeProto({\n      requests: this.requests,\n      annotations: Context.merge(this.annotations, context)\n    })\n  },\n  annotateRpcsContext(this: RpcGroup<any>, context: Context.Context<any>) {\n    const requests = new Map<string, any>()\n    for (const [tag, rpc] of this.requests) {\n      requests.set(tag, rpc.annotateContext(Context.merge(context, rpc.annotations)))\n    }\n    return makeProto({\n      requests,\n      annotations: this.annotations\n    })\n  }\n}\n\nconst makeProto = <Rpcs extends Rpc.Any>(options: {\n  readonly requests: ReadonlyMap<string, Rpcs>\n  readonly annotations: Context.Context<never>\n}): RpcGroup<Rpcs> =>\n  Object.assign(function() {}, RpcGroupProto, {\n    requests: options.requests,\n    annotations: options.annotations\n  }) as any\n\nconst resolveInput = <Rpcs extends ReadonlyArray<Rpc.Any>>(\n  ...rpcs: Rpcs\n): ReadonlyMap<string, Rpcs[number]> => {\n  const requests = new Map<string, Rpcs[number]>()\n  for (const rpc of rpcs) {\n    requests.set(rpc._tag, Schema.isSchema(rpc) ? Rpc.fromTaggedRequest(rpc as any) : rpc as any)\n  }\n  return requests\n}\n\n/**\n * @since 1.0.0\n * @category groups\n */\nexport const make = <const Rpcs extends ReadonlyArray<Rpc.Any>>(\n  ...rpcs: Rpcs\n): RpcGroup<Rpcs[number]> =>\n  makeProto({\n    requests: resolveInput(...rpcs),\n    annotations: Context.empty()\n  })\n", "/**\n * @since 1.0.0\n */\nimport type { Headers } from \"@effect/platform/Headers\"\nimport * as Context from \"effect/Context\"\nimport * as Effect from \"effect/Effect\"\nimport * as Layer from \"effect/Layer\"\nimport * as Schema from \"effect/Schema\"\nimport { Scope } from \"effect/Scope\"\nimport type { Mutable } from \"effect/Types\"\nimport type * as Rpc from \"./Rpc.js\"\nimport type { Request } from \"./RpcMessage.js\"\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport const TypeId: unique symbol = Symbol.for(\"@effect/rpc/RpcMiddleware\")\n\n/**\n * @since 1.0.0\n * @category type ids\n */\nexport type TypeId = typeof TypeId\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RpcMiddleware<Provides, E> {\n  (options: {\n    readonly clientId: number\n    readonly rpc: Rpc.AnyWithProps\n    readonly payload: unknown\n    readonly headers: Headers\n  }): Effect.Effect<Provides, E>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RpcMiddlewareWrap<Provides, E> {\n  (options: {\n    readonly clientId: number\n    readonly rpc: Rpc.AnyWithProps\n    readonly payload: unknown\n    readonly headers: Headers\n    readonly next: Effect.Effect<SuccessValue, E, Provides>\n  }): Effect.Effect<SuccessValue, E>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport const SuccessValue: unique symbol = Symbol.for(\"@effect/rpc/RpcMiddleware/SuccessValue\")\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport type SuccessValue = typeof SuccessValue\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface RpcMiddlewareClient<R = never> {\n  (options: {\n    readonly rpc: Rpc.AnyWithProps\n    readonly request: Request<Rpc.Any>\n  }): Effect.Effect<Request<Rpc.Any>, never, R>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface ForClient<Id> {\n  readonly _: unique symbol\n  readonly id: Id\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface Any {\n  (options: {\n    readonly rpc: Rpc.AnyWithProps\n    readonly payload: unknown\n    readonly headers: Headers\n    readonly next?: Effect.Effect<any, any, any>\n  }): Effect.Effect<any, any>\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TagClass<\n  Self,\n  Name extends string,\n  Options\n> extends\n  TagClass.Base<\n    Self,\n    Name,\n    Options,\n    TagClass.Wrap<Options> extends true ? RpcMiddlewareWrap<\n        TagClass.Provides<Options>,\n        TagClass.Failure<Options>\n      > :\n      RpcMiddleware<\n        TagClass.Service<Options>,\n        TagClass.FailureService<Options>\n      >\n  >\n{}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport declare namespace TagClass {\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Provides<Options> = Options extends {\n    readonly provides: Context.Tag<any, any>\n    readonly optional?: false\n  } ? Context.Tag.Identifier<Options[\"provides\"]>\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Service<Options> = Options extends { readonly provides: Context.Tag<any, any> }\n    ? Context.Tag.Service<Options[\"provides\"]>\n    : void\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureSchema<Options> = Options extends\n    { readonly failure: Schema.Schema.All; readonly optional?: false } ? Options[\"failure\"]\n    : typeof Schema.Never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Failure<Options> = Options extends\n    { readonly failure: Schema.Schema<infer _A, infer _I, infer _R>; readonly optional?: false } ? _A\n    : never\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureContext<Options> = Schema.Schema.Context<FailureSchema<Options>>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type FailureService<Options> = Optional<Options> extends true ? unknown : Failure<Options>\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Optional<Options> = Options extends { readonly optional: true } ? true : false\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type RequiredForClient<Options> = Options extends { readonly requiredForClient: true } ? true : false\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export type Wrap<Options> = Options extends { readonly wrap: true } ? true : false\n\n  /**\n   * @since 1.0.0\n   * @category models\n   */\n  export interface Base<Self, Name extends string, Options, Service> extends Context.Tag<Self, Service> {\n    new(_: never): Context.TagClassShape<Name, Service>\n    readonly [TypeId]: TypeId\n    readonly optional: Optional<Options>\n    readonly failure: FailureSchema<Options>\n    readonly provides: Options extends { readonly provides: Context.Tag<any, any> } ? Options[\"provides\"]\n      : undefined\n    readonly requiredForClient: RequiredForClient<Options>\n    readonly wrap: Wrap<Options>\n  }\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TagClassAny extends Context.Tag<any, any> {\n  readonly [TypeId]: TypeId\n  readonly optional: boolean\n  readonly provides?: Context.Tag<any, any> | undefined\n  readonly failure: Schema.Schema.All\n  readonly requiredForClient: boolean\n  readonly wrap: boolean\n}\n\n/**\n * @since 1.0.0\n * @category models\n */\nexport interface TagClassAnyWithProps extends Context.Tag<any, RpcMiddleware<any, any> | RpcMiddlewareWrap<any, any>> {\n  readonly [TypeId]: TypeId\n  readonly optional: boolean\n  readonly provides?: Context.Tag<any, any>\n  readonly failure: Schema.Schema.All\n  readonly requiredForClient: boolean\n  readonly wrap: boolean\n}\n\n/**\n * @since 1.0.0\n * @category tags\n */\nexport const Tag = <Self>(): <\n  const Name extends string,\n  const Options extends {\n    readonly wrap?: boolean\n    readonly optional?: boolean\n    readonly failure?: Schema.Schema.All\n    readonly provides?: Context.Tag<any, any>\n    readonly requiredForClient?: boolean\n  }\n>(\n  id: Name,\n  options?: Options | undefined\n) => TagClass<Self, Name, Options> =>\n(\n  id: string,\n  options?: {\n    readonly optional?: boolean\n    readonly failure?: Schema.Schema.All\n    readonly provides?: Context.Tag<any, any>\n    readonly requiredForClient?: boolean\n    readonly wrap?: boolean\n  }\n) => {\n  const Err = globalThis.Error as any\n  const limit = Err.stackTraceLimit\n  Err.stackTraceLimit = 2\n  const creationError = new Err()\n  Err.stackTraceLimit = limit\n\n  function TagClass() {}\n  const TagClass_ = TagClass as any as Mutable<TagClassAny>\n  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(Context.GenericTag<Self, any>(id)))\n  TagClass.key = id\n  Object.defineProperty(TagClass, \"stack\", {\n    get() {\n      return creationError.stack\n    }\n  })\n  TagClass_[TypeId] = TypeId\n  TagClass_.failure = options?.optional === true || options?.failure === undefined ? Schema.Never : options.failure\n  if (options?.provides) {\n    TagClass_.provides = options.provides\n  }\n  TagClass_.optional = options?.optional ?? false\n  TagClass_.requiredForClient = options?.requiredForClient ?? false\n  TagClass_.wrap = options?.wrap ?? false\n  return TagClass as any\n}\n\n/**\n * @since 1.0.0\n * @category client\n */\nexport const layerClient = <Id, S, R, EX = never, RX = never>(\n  tag: Context.Tag<Id, S>,\n  service: RpcMiddlewareClient<R> | Effect.Effect<RpcMiddlewareClient<R>, EX, RX>\n): Layer.Layer<ForClient<Id>, EX, R | Exclude<RX, Scope>> =>\n  Layer.scopedContext(Effect.gen(function*() {\n    const context = (yield* Effect.context<R | Scope>()).pipe(\n      Context.omit(Scope)\n    ) as Context.Context<R>\n    const middleware = Effect.isEffect(service) ? yield* service : service\n    return Context.unsafeMake(\n      new Map([[\n        `${tag.key}/Client`,\n        (options: any) =>\n          Effect.mapInputContext(\n            middleware(options),\n            (requestContext) => Context.merge(context, requestContext)\n          )\n      ]])\n    )\n  }))\n", "/**\n * @since 1.0.0\n */\nimport * as Headers from \"@effect/platform/Headers\"\nimport * as HttpApp from \"@effect/platform/HttpApp\"\nimport * as HttpLayerRouter from \"@effect/platform/HttpLayerRouter\"\nimport * as HttpRouter from \"@effect/platform/HttpRouter\"\nimport * as HttpServerRequest from \"@effect/platform/HttpServerRequest\"\nimport * as HttpServerResponse from \"@effect/platform/HttpServerResponse\"\nimport type * as Socket from \"@effect/platform/Socket\"\nimport * as SocketServer from \"@effect/platform/SocketServer\"\nimport * as Transferable from \"@effect/platform/Transferable\"\nimport type { WorkerError } from \"@effect/platform/WorkerError\"\nimport * as WorkerRunner from \"@effect/platform/WorkerRunner\"\nimport type { NonEmptyReadonlyArray } from \"effect/Array\"\nimport * as Arr from \"effect/Array\"\nimport * as Cause from \"effect/Cause\"\nimport * as Chunk from \"effect/Chunk\"\nimport * as Context from \"effect/Context\"\nimport * as Deferred from \"effect/Deferred\"\nimport * as Effect from \"effect/Effect\"\nimport * as Exit from \"effect/Exit\"\nimport * as Fiber from \"effect/Fiber\"\nimport * as FiberId from \"effect/FiberId\"\nimport * as FiberSet from \"effect/FiberSet\"\nimport { constant, constTrue, constVoid, identity } from \"effect/Function\"\nimport * as Layer from \"effect/Layer\"\nimport * as Mailbox from \"effect/Mailbox\"\nimport * as ManagedRuntime from \"effect/ManagedRuntime\"\nimport * as Option from \"effect/Option\"\nimport { type ParseError, TreeFormatter } from \"effect/ParseResult\"\nimport * as Predicate from \"effect/Predicate\"\nimport * as Runtime from \"effect/Runtime\"\nimport * as Schedule from \"effect/Schedule\"\nimport * as Schema from \"effect/Schema\"\nimport * as Scope from \"effect/Scope\"\nimport type * as Sink from \"effect/Sink\"\nimport * as Stream from \"effect/Stream\"\nimport * as Tracer from \"effect/Tracer\"\nimport { withRun } from \"./internal/utils.js\"\nimport * as Rpc from \"./Rpc.js\"\nimport type * as RpcGroup from \"./RpcGroup.js\"\nimport {\n  constEof,\n  constPong,\n  type FromClient,\n  type FromClientEncoded,\n  type FromServer,\n  type FromServerEncoded,\n  type Request,\n  RequestId,\n  ResponseDefectEncoded\n} from \"./RpcMessage.js\"\nimport type { RpcMiddleware } from \"./RpcMiddleware.js\"\nimport * as RpcSchema from \"./RpcSchema.js\"\nimport * as RpcSerialization from \"./RpcSerialization.js\"\nimport type { InitialMessage } from \"./RpcWorker.js\"\n\n/**\n * @since 1.0.0\n * @category server\n */\nexport interface RpcServer<A extends Rpc.Any> {\n  readonly write: (clientId: number, message: FromClient<A>) => Effect.Effect<void>\n  readonly disconnect: (clientId: number) => Effect.Effect<void>\n}\n\n/**\n * @since 1.0.0\n * @category server\n */\nexport const makeNoSerialization: <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>\n    readonly disableTracing?: boolean | undefined\n    readonly disableSpanPropagation?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly disableClientAcks?: boolean | undefined\n    readonly concurrency?: number | \"unbounded\" | undefined\n    readonly disableFatalDefects?: boolean | undefined\n  }\n) => Effect.Effect<\n  RpcServer<Rpcs>,\n  never,\n  Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Scope.Scope\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly onFromServer: (response: FromServer<Rpcs>) => Effect.Effect<void>\n    readonly disableTracing?: boolean | undefined\n    readonly disableSpanPropagation?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly disableClientAcks?: boolean | undefined\n    readonly concurrency?: number | \"unbounded\" | undefined\n    readonly disableFatalDefects?: boolean | undefined\n  }\n) {\n  const enableTracing = options.disableTracing !== true\n  const enableSpanPropagation = options.disableSpanPropagation !== true\n  const supportsAck = options.disableClientAcks !== true\n  const spanPrefix = options.spanPrefix ?? \"RpcServer\"\n  const concurrency = options.concurrency ?? \"unbounded\"\n  const disableFatalDefects = options.disableFatalDefects ?? false\n  const context = yield* Effect.context<Rpc.ToHandler<Rpcs> | Scope.Scope>()\n  const scope = Context.get(context, Scope.Scope)\n  const fiberSet = yield* FiberSet.make()\n  const runFork = yield* FiberSet.runtime(fiberSet)().pipe(\n    Effect.interruptible\n  )\n  const concurrencySemaphore = concurrency === \"unbounded\"\n    ? undefined\n    : yield* Effect.makeSemaphore(concurrency)\n\n  type Client = {\n    readonly id: number\n    readonly latches: Map<RequestId, Effect.Latch>\n    readonly fibers: Map<RequestId, Fiber.RuntimeFiber<unknown, any>>\n    ended: boolean\n  }\n\n  const clients = new Map<number, Client>()\n  let isShutdown = false\n  const shutdownLatch = Effect.unsafeMakeLatch(false)\n  yield* Scope.addFinalizer(\n    scope,\n    Effect.fiberIdWith((fiberId) => {\n      isShutdown = true\n      for (const client of clients.values()) {\n        client.ended = true\n        if (client.fibers.size === 0) {\n          runFork(endClient(client))\n          continue\n        }\n        for (const fiber of client.fibers.values()) {\n          fiber.unsafeInterruptAsFork(fiberId)\n        }\n      }\n      if (clients.size === 0) {\n        return Effect.void\n      }\n      return shutdownLatch.await\n    })\n  )\n\n  const disconnect = (clientId: number) =>\n    Effect.fiberIdWith((fiberId) => {\n      const client = clients.get(clientId)\n      if (!client) return Effect.void\n      for (const fiber of client.fibers.values()) {\n        fiber.unsafeInterruptAsFork(fiberId)\n      }\n      clients.delete(clientId)\n      return Effect.void\n    })\n\n  const write = (clientId: number, message: FromClient<Rpcs>): Effect.Effect<void> =>\n    Effect.catchAllDefect(\n      Effect.withFiberRuntime((requestFiber) => {\n        if (isShutdown) return Effect.interrupt\n        let client = clients.get(clientId)\n        if (!client) {\n          client = {\n            id: clientId,\n            latches: new Map(),\n            fibers: new Map(),\n            ended: false\n          }\n          clients.set(clientId, client)\n        } else if (client.ended) {\n          return Effect.interrupt\n        }\n\n        switch (message._tag) {\n          case \"Request\": {\n            return handleRequest(requestFiber, client, message)\n          }\n          case \"Ack\": {\n            const latch = client.latches.get(message.requestId)\n            return latch ? latch.open : Effect.void\n          }\n          case \"Interrupt\": {\n            const fiber = client.fibers.get(message.requestId)\n            return fiber ? Fiber.interruptFork(fiber) : options.onFromServer({\n              _tag: \"Exit\",\n              clientId,\n              requestId: message.requestId,\n              exit: Exit.interrupt(FiberId.none)\n            })\n          }\n          case \"Eof\": {\n            client.ended = true\n            if (client.fibers.size > 0) return Effect.void\n            return endClient(client)\n          }\n          default: {\n            return sendDefect(client, `Unknown request tag: ${(message as any)._tag}`)\n          }\n        }\n      }),\n      (defect) => sendDefect(clients.get(clientId)!, defect)\n    )\n\n  const endClient = (client: Client) => {\n    clients.delete(client.id)\n    const write = options.onFromServer({\n      _tag: \"ClientEnd\",\n      clientId: client.id\n    })\n    if (isShutdown && clients.size === 0) {\n      return Effect.zipRight(write, shutdownLatch.open)\n    }\n    return write\n  }\n\n  const handleRequest = (\n    requestFiber: Fiber.RuntimeFiber<any, any>,\n    client: Client,\n    request: Request<Rpcs>\n  ): Effect.Effect<void> => {\n    if (client.fibers.has(request.id)) {\n      return Effect.interrupt\n    }\n    const rpc = group.requests.get(request.tag) as any as Rpc.AnyWithProps\n    const entry = context.unsafeMap.get(rpc?.key) as Rpc.Handler<Rpcs[\"_tag\"]>\n    if (!rpc || !entry) {\n      const write = Effect.catchAllDefect(\n        options.onFromServer({\n          _tag: \"Exit\",\n          clientId: client.id,\n          requestId: request.id,\n          exit: Exit.die(`Unknown request tag: ${request.tag}`)\n        }),\n        (defect) => sendDefect(client, defect)\n      )\n      if (!client.ended || client.fibers.size > 0) return write\n      return Effect.zipRight(write, endClient(client))\n    }\n    const isStream = RpcSchema.isStreamSchema(rpc.successSchema)\n    const result = entry.handler(request.payload, request.headers)\n\n    // if the handler requested forking, then we skip the concurrency control\n    const isFork = Rpc.isFork(result)\n    // unwrap the fork data type\n    const streamOrEffect = isFork ? result.value : result\n\n    let responded = false\n    let effect = Effect.uninterruptible(Effect.matchCauseEffect(\n      Effect.interruptible(applyMiddleware(\n        rpc,\n        context,\n        client.id,\n        request.payload,\n        request.headers,\n        isStream\n          ? streamEffect(client, request, streamOrEffect)\n          : streamOrEffect as Effect.Effect<any>\n      )),\n      {\n        onSuccess: (value) => {\n          responded = true\n          return options.onFromServer({\n            _tag: \"Exit\",\n            clientId: client.id,\n            requestId: request.id,\n            exit: Exit.succeed(value as any)\n          })\n        },\n        onFailure: (cause) => {\n          responded = true\n          if (!disableFatalDefects && Cause.isDie(cause)) {\n            return sendDefect(client, Cause.squash(cause))\n          }\n          return options.onFromServer({\n            _tag: \"Exit\",\n            clientId: client.id,\n            requestId: request.id,\n            exit: Exit.failCause(cause)\n          })\n        }\n      }\n    ))\n    if (enableTracing) {\n      const parentSpan = requestFiber.currentContext.unsafeMap.get(Tracer.ParentSpan.key) as Tracer.AnySpan | undefined\n      effect = Effect.withSpan(effect, `${spanPrefix}.${request.tag}`, {\n        captureStackTrace: false,\n        attributes: options.spanAttributes,\n        parent: enableSpanPropagation && request.spanId ?\n          {\n            _tag: \"ExternalSpan\",\n            traceId: request.traceId!,\n            spanId: request.spanId,\n            sampled: request.sampled!,\n            context: Context.empty()\n          } :\n          undefined,\n        links: enableSpanPropagation && parentSpan ?\n          [{\n            _tag: \"SpanLink\",\n            span: parentSpan,\n            attributes: {}\n          }] :\n          undefined\n      })\n    }\n    if (!isFork && concurrencySemaphore) {\n      effect = concurrencySemaphore.withPermits(1)(effect)\n    }\n    const runtime = Runtime.make({\n      context: Context.merge(entry.context, requestFiber.currentContext),\n      fiberRefs: requestFiber.getFiberRefs(),\n      runtimeFlags: Runtime.defaultRuntime.runtimeFlags\n    })\n    const fiber = Runtime.runFork(runtime, effect)\n    FiberSet.unsafeAdd(fiberSet, fiber)\n    client.fibers.set(request.id, fiber)\n    fiber.addObserver((exit) => {\n      if (!responded && exit._tag === \"Failure\") {\n        FiberSet.unsafeAdd(\n          fiberSet,\n          Runtime.runFork(\n            runtime,\n            options.onFromServer({\n              _tag: \"Exit\",\n              clientId: client.id,\n              requestId: request.id,\n              exit: Exit.interrupt(FiberId.none)\n            })\n          )\n        )\n      }\n      client.fibers.delete(request.id)\n      client.latches.delete(request.id)\n      if (client.ended && client.fibers.size === 0) {\n        FiberSet.unsafeAdd(\n          fiberSet,\n          Runtime.runFork(runtime, endClient(client))\n        )\n      }\n    })\n    return Effect.void\n  }\n\n  const streamEffect = (\n    client: Client,\n    request: Request<Rpcs>,\n    stream: Stream.Stream<any, any> | Effect.Effect<Mailbox.ReadonlyMailbox<any, any>, any, Scope.Scope>\n  ) => {\n    let latch = client.latches.get(request.id)\n    if (supportsAck && !latch) {\n      latch = Effect.unsafeMakeLatch(false)\n      client.latches.set(request.id, latch)\n    }\n    if (Effect.isEffect(stream)) {\n      let done = false\n      return stream.pipe(\n        Effect.flatMap((mailbox) =>\n          Effect.whileLoop({\n            while: () => !done,\n            body: constant(Effect.flatMap(mailbox.takeAll, ([chunk, done_]) => {\n              done = done_\n              if (!Chunk.isNonEmpty(chunk)) return Effect.void\n              const write = options.onFromServer({\n                _tag: \"Chunk\",\n                clientId: client.id,\n                requestId: request.id,\n                values: Chunk.toReadonlyArray(chunk)\n              })\n              if (!latch) return write\n              latch.unsafeClose()\n              return Effect.zipRight(write, latch.await)\n            })),\n            step: constVoid\n          })\n        ),\n        Effect.scoped\n      )\n    }\n    return Stream.runForEachChunk(stream, (chunk) => {\n      if (!Chunk.isNonEmpty(chunk)) return Effect.void\n      const write = options.onFromServer({\n        _tag: \"Chunk\",\n        clientId: client.id,\n        requestId: request.id,\n        values: Chunk.toReadonlyArray(chunk)\n      })\n      if (!latch) return write\n      latch.unsafeClose()\n      return Effect.zipRight(write, latch.await)\n    })\n  }\n\n  const sendDefect = (client: Client, defect: unknown) =>\n    Effect.suspend(() => {\n      const shouldEnd = client.ended && client.fibers.size === 0\n      const write = options.onFromServer({\n        _tag: \"Defect\",\n        clientId: client.id,\n        defect\n      })\n      if (!shouldEnd) return write\n      return Effect.zipRight(write, endClient(client))\n    })\n\n  return identity<RpcServer<Rpcs>>({\n    write,\n    disconnect\n  })\n})\n\nconst applyMiddleware = <A, E, R>(\n  rpc: Rpc.AnyWithProps,\n  context: Context.Context<never>,\n  clientId: number,\n  payload: A,\n  headers: Headers.Headers,\n  handler: Effect.Effect<A, E, R>\n) => {\n  if (rpc.middlewares.size === 0) {\n    return handler\n  }\n\n  const options = {\n    rpc,\n    payload,\n    headers,\n    clientId\n  }\n\n  for (const tag of rpc.middlewares) {\n    if (tag.wrap) {\n      const middleware = Context.unsafeGet(context, tag)\n      handler = middleware({ ...options, next: handler as any })\n    } else if (tag.optional) {\n      const middleware = Context.unsafeGet(context, tag) as RpcMiddleware<any, any>\n      const previous = handler\n      handler = Effect.matchEffect(middleware(options), {\n        onFailure: () => previous,\n        onSuccess: tag.provides !== undefined\n          ? (value) => Effect.provideService(previous, tag.provides as any, value)\n          : (_) => previous\n      })\n    } else {\n      const middleware = Context.unsafeGet(context, tag) as RpcMiddleware<any, any>\n      handler = tag.provides !== undefined\n        ? Effect.provideServiceEffect(handler, tag.provides as any, middleware(options))\n        : Effect.zipRight(middleware(options), handler)\n    }\n  }\n\n  return handler\n}\n\n/**\n * @since 1.0.0\n * @category server\n */\nexport const make: <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?:\n    | {\n      readonly disableTracing?: boolean | undefined\n      readonly spanPrefix?: string | undefined\n      readonly spanAttributes?: Record<string, unknown> | undefined\n      readonly concurrency?: number | \"unbounded\" | undefined\n      readonly disableFatalDefects?: boolean | undefined\n    }\n    | undefined\n) => Effect.Effect<\n  never,\n  never,\n  Protocol | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly concurrency?: number | \"unbounded\" | undefined\n    readonly disableFatalDefects?: boolean | undefined\n  }\n) {\n  const { disconnects, end, run, send, supportsAck, supportsSpanPropagation, supportsTransferables } = yield* Protocol\n  const context = yield* Effect.context<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs>>()\n  const scope = yield* Scope.make()\n\n  const server = yield* makeNoSerialization(group, {\n    ...options,\n    disableClientAcks: !supportsAck,\n    disableSpanPropagation: !supportsSpanPropagation,\n    onFromServer(response): Effect.Effect<void> {\n      const client = clients.get(response.clientId)\n      if (!client) return Effect.void\n      switch (response._tag) {\n        case \"Chunk\": {\n          const schemas = client.schemas.get(response.requestId)\n          if (!schemas) return Effect.void\n          return handleEncode(\n            client,\n            response.requestId,\n            schemas.collector,\n            Effect.provide(schemas.encodeChunk(response.values), schemas.context),\n            (values) => ({ _tag: \"Chunk\", requestId: String(response.requestId), values })\n          )\n        }\n        case \"Exit\": {\n          const schemas = client.schemas.get(response.requestId)\n          if (!schemas) return Effect.void\n          client.schemas.delete(response.requestId)\n          return handleEncode(\n            client,\n            response.requestId,\n            schemas.collector,\n            Effect.provide(schemas.encodeExit(response.exit), schemas.context),\n            (exit) => ({ _tag: \"Exit\", requestId: String(response.requestId), exit })\n          )\n        }\n        case \"Defect\": {\n          return sendDefect(client, response.defect)\n        }\n        case \"ClientEnd\": {\n          clients.delete(response.clientId)\n          return end(response.clientId)\n        }\n      }\n    }\n  }).pipe(Scope.extend(scope))\n\n  // handle disconnects\n  yield* Effect.fork(Effect.interruptible(Effect.whileLoop({\n    while: constTrue,\n    body: constant(Effect.flatMap(disconnects.take, (clientId) => {\n      clients.delete(clientId)\n      return server.disconnect(clientId)\n    })),\n    step: constVoid\n  })))\n\n  type Schemas = {\n    readonly decode: (u: unknown) => Effect.Effect<Rpc.Payload<Rpcs>, ParseError>\n    readonly encodeChunk: (u: ReadonlyArray<unknown>) => Effect.Effect<NonEmptyReadonlyArray<unknown>, ParseError>\n    readonly encodeExit: (u: unknown) => Effect.Effect<Schema.ExitEncoded<unknown, unknown, unknown>, ParseError>\n    readonly context: Context.Context<never>\n    readonly collector?: Transferable.CollectorService | undefined\n  }\n\n  const schemasCache = new WeakMap<any, Schemas>()\n  const getSchemas = (rpc: Rpc.AnyWithProps) => {\n    let schemas = schemasCache.get(rpc)\n    if (!schemas) {\n      const entry = context.unsafeMap.get(rpc.key) as Rpc.Handler<Rpcs[\"_tag\"]>\n      const streamSchemas = RpcSchema.getStreamSchemas(rpc.successSchema.ast)\n      schemas = {\n        decode: Schema.decodeUnknown(rpc.payloadSchema as any),\n        encodeChunk: Schema.encodeUnknown(\n          Schema.Array(Option.isSome(streamSchemas) ? streamSchemas.value.success : Schema.Any)\n        ) as any,\n        encodeExit: Schema.encodeUnknown(Rpc.exitSchema(rpc as any)) as any,\n        context: entry.context\n      }\n      schemasCache.set(rpc, schemas)\n    }\n    return schemas\n  }\n\n  type Client = {\n    readonly id: number\n    readonly schemas: Map<RequestId, Schemas>\n  }\n  const clients = new Map<number, Client>()\n\n  const handleEncode = <A, R>(\n    client: Client,\n    requestId: RequestId,\n    collector: Transferable.CollectorService | undefined,\n    effect: Effect.Effect<A, ParseError, R>,\n    onSuccess: (a: A) => FromServerEncoded\n  ) =>\n    (collector ? Effect.provideService(effect, Transferable.Collector, collector) : effect).pipe(\n      Effect.flatMap((a) => send(client.id, onSuccess(a), collector && collector.unsafeClear())),\n      Effect.catchAllCause((cause) => {\n        client.schemas.delete(requestId)\n        const defect = Cause.squash(Cause.map(cause, TreeFormatter.formatErrorSync))\n        return Effect.zipRight(\n          sendRequestDefect(client, requestId, defect),\n          server.write(client.id, { _tag: \"Interrupt\", requestId, interruptors: [] })\n        )\n      })\n    )\n\n  const sendRequestDefect = (client: Client, requestId: RequestId, defect: unknown) =>\n    Effect.catchAllCause(\n      send(client.id, {\n        _tag: \"Exit\",\n        requestId: String(requestId),\n        exit: {\n          _tag: \"Failure\",\n          cause: {\n            _tag: \"Die\",\n            defect\n          }\n        }\n      }),\n      (cause) => sendDefect(client, Cause.squash(cause))\n    )\n\n  const sendDefect = (client: Client, defect: unknown) =>\n    Effect.catchAllCause(\n      send(client.id, { _tag: \"Defect\", defect }),\n      (cause) =>\n        Effect.annotateLogs(Effect.logDebug(cause), {\n          module: \"RpcServer\",\n          method: \"sendDefect\"\n        })\n    )\n\n  // main server loop\n  return yield* run((clientId, request) => {\n    let client = clients.get(clientId)\n    if (!client) {\n      client = {\n        id: clientId,\n        schemas: new Map()\n      }\n      clients.set(clientId, client)\n    }\n\n    switch (request._tag) {\n      case \"Request\": {\n        const tag = Predicate.hasProperty(request, \"tag\") ? request.tag as string : \"\"\n        const rpc = group.requests.get(tag)\n        if (!rpc) {\n          return sendDefect(client, `Unknown request tag: ${tag}`)\n        }\n        let requestId: RequestId\n        switch (typeof request.id) {\n          case \"bigint\":\n          case \"string\": {\n            requestId = RequestId(request.id)\n            break\n          }\n          default: {\n            return sendDefect(client, `Invalid request id: ${request.id}`)\n          }\n        }\n        const schemas = getSchemas(rpc as any)\n        return Effect.matchEffect(\n          Effect.provide(schemas.decode(request.payload), schemas.context),\n          {\n            onFailure: (error) => sendRequestDefect(client, requestId, TreeFormatter.formatErrorSync(error)),\n            onSuccess: (payload) => {\n              client.schemas.set(\n                requestId,\n                supportsTransferables ?\n                  {\n                    ...schemas,\n                    collector: Transferable.unsafeMakeCollector()\n                  } :\n                  schemas\n              )\n              return server.write(clientId, {\n                ...request,\n                id: requestId,\n                payload,\n                headers: Headers.fromInput(request.headers)\n              } as any)\n            }\n          }\n        )\n      }\n      case \"Ping\": {\n        return Effect.catchAllCause(\n          send(client.id, constPong),\n          (cause) => sendDefect(client, Cause.squash(cause))\n        )\n      }\n      case \"Eof\": {\n        return server.write(clientId, request)\n      }\n      case \"Ack\": {\n        return server.write(clientId, {\n          ...request,\n          requestId: RequestId(request.requestId)\n        })\n      }\n      case \"Interrupt\": {\n        return server.write(clientId, {\n          ...request,\n          requestId: RequestId(request.requestId),\n          interruptors: []\n        })\n      }\n      default: {\n        return sendDefect(client, `Unknown request tag: ${(request as any)._tag}`)\n      }\n    }\n  }).pipe(\n    Effect.interruptible,\n    Effect.tapErrorCause((cause) => Effect.logFatal(\"BUG: RpcServer protocol crashed\", cause)),\n    Effect.onExit((exit) => Scope.close(scope, exit))\n  )\n})\n\n/**\n * @since 1.0.0\n * @category server\n */\nexport const layer = <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly concurrency?: number | \"unbounded\" | undefined\n  }\n): Layer.Layer<\n  never,\n  never,\n  | Protocol\n  | Rpc.ToHandler<Rpcs>\n  | Rpc.Middleware<Rpcs>\n> => Layer.scopedDiscard(Effect.forkScoped(Effect.interruptible(make(group, options))))\n\n/**\n * Create a RPC server that registers a HTTP route with a `HttpLayerRouter`.\n *\n * It defaults to using websockets for communication, but can be configured to\n * use HTTP.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerHttpRouter = <Rpcs extends Rpc.Any>(options: {\n  readonly group: RpcGroup.RpcGroup<Rpcs>\n  readonly path: HttpRouter.PathInput\n  readonly protocol?: \"http\" | \"websocket\" | undefined\n  readonly disableTracing?: boolean | undefined\n  readonly spanPrefix?: string | undefined\n  readonly spanAttributes?: Record<string, unknown> | undefined\n  readonly concurrency?: number | \"unbounded\" | undefined\n}): Layer.Layer<\n  never,\n  never,\n  | RpcSerialization.RpcSerialization\n  | HttpLayerRouter.HttpRouter\n  | Rpc.ToHandler<Rpcs>\n  | Rpc.Middleware<Rpcs>\n> =>\n  layer(options.group, options).pipe(\n    Layer.provide(\n      options.protocol === \"http\"\n        ? layerProtocolHttpRouter(options)\n        : layerProtocolWebsocketRouter(options)\n    )\n  )\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport class Protocol extends Context.Tag(\"@effect/rpc/RpcServer/Protocol\")<Protocol, {\n  readonly run: (\n    f: (clientId: number, data: FromClientEncoded) => Effect.Effect<void>\n  ) => Effect.Effect<never>\n  readonly disconnects: Mailbox.ReadonlyMailbox<number>\n  readonly send: (\n    clientId: number,\n    response: FromServerEncoded,\n    transferables?: ReadonlyArray<globalThis.Transferable>\n  ) => Effect.Effect<void>\n  readonly end: (clientId: number) => Effect.Effect<void>\n  readonly clientIds: Effect.Effect<Iterable<number>>\n  readonly initialMessage: Effect.Effect<Option.Option<unknown>>\n  readonly supportsAck: boolean\n  readonly supportsTransferables: boolean\n  readonly supportsSpanPropagation: boolean\n}>() {\n  /**\n   * @since 1.0.0\n   */\n  static make = withRun<Protocol[\"Type\"]>()\n}\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolSocketServer = Effect.gen(function*() {\n  const server = yield* SocketServer.SocketServer\n  const { onSocket, protocol } = yield* makeSocketProtocol\n  yield* Effect.forkScoped(Effect.interruptible(\n    server.run(Effect.fnUntraced(onSocket, Effect.scoped))\n  ))\n  return protocol\n})\n\n/**\n * A rpc protocol that uses `SocketServer` for communication.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolSocketServer: Layer.Layer<\n  Protocol,\n  never,\n  RpcSerialization.RpcSerialization | SocketServer.SocketServer\n> = Layer.scoped(Protocol, makeProtocolSocketServer)\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWithHttpAppWebsocket: Effect.Effect<\n  {\n    readonly protocol: Protocol[\"Type\"]\n    readonly httpApp: HttpApp.Default<never, Scope.Scope>\n  },\n  never,\n  RpcSerialization.RpcSerialization\n> = Effect.gen(function*() {\n  const { onSocket, protocol } = yield* makeSocketProtocol\n\n  const httpApp: HttpApp.Default<never, Scope.Scope> = Effect.gen(function*() {\n    const request = yield* HttpServerRequest.HttpServerRequest\n    const socket = yield* Effect.orDie(request.upgrade)\n    yield* onSocket(socket)\n    return HttpServerResponse.empty()\n  })\n\n  return { protocol, httpApp } as const\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWebsocket: <I = HttpRouter.Default>(\n  options: {\n    readonly path: HttpRouter.PathInput\n    readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>\n  }\n) => Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  RpcSerialization.RpcSerialization | I\n> = Effect.fnUntraced(function*<I = HttpRouter.Default>(options: {\n  readonly path: HttpRouter.PathInput\n  readonly routerTag?: Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>\n}) {\n  const { httpApp, protocol } = yield* makeProtocolWithHttpAppWebsocket\n  const router =\n    yield* (options.routerTag ?? HttpRouter.Default as any as Context.Tag<I, HttpRouter.HttpRouter.Service<any, any>>)\n  yield* router.get(options.path, httpApp)\n  return protocol\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWebsocketRouter: (\n  options: {\n    readonly path: HttpRouter.PathInput\n  }\n) => Effect.Effect<\n  Protocol[\"Type\"],\n  never,\n  RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter\n> = Effect.fnUntraced(function*(options: {\n  readonly path: HttpRouter.PathInput\n}) {\n  const router = yield* HttpLayerRouter.HttpRouter\n  const { httpApp, protocol } = yield* makeProtocolWithHttpAppWebsocket\n  yield* router.add(\"GET\", options.path, httpApp)\n  return protocol\n})\n\n/**\n * A rpc protocol that uses websockets for communication.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolWebsocket = <I = HttpRouter.Default>(options: {\n  readonly path: HttpRouter.PathInput\n  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization> => {\n  const routerTag = options.routerTag ??\n    HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>\n  return Layer.effect(Protocol, makeProtocolWebsocket(options)).pipe(\n    Layer.provide(routerTag.Live)\n  )\n}\n\n/**\n * A rpc protocol that uses websockets for communication.\n *\n * Uses a `HttpLayerRouter` to provide the websocket endpoint.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolWebsocketRouter = (options: {\n  readonly path: HttpLayerRouter.PathInput\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter> =>\n  Layer.effect(Protocol, makeProtocolWebsocketRouter(options))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWithHttpApp: Effect.Effect<\n  {\n    readonly protocol: Protocol[\"Type\"]\n    readonly httpApp: HttpApp.Default<never, Scope.Scope>\n  },\n  never,\n  RpcSerialization.RpcSerialization\n> = Effect.gen(function*() {\n  const serialization = yield* RpcSerialization.RpcSerialization\n  const includesFraming = serialization.includesFraming\n\n  const disconnects = yield* Mailbox.make<number>()\n  let writeRequest!: (clientId: number, message: FromClientEncoded) => Effect.Effect<void>\n\n  let clientId = 0\n\n  const clients = new Map<number, {\n    readonly write: (bytes: FromServerEncoded) => Effect.Effect<void>\n    readonly end: Effect.Effect<void>\n  }>()\n\n  const httpApp: HttpApp.Default<never, Scope.Scope> = Effect.gen(function*() {\n    const request = yield* HttpServerRequest.HttpServerRequest\n    const data = yield* Effect.orDie(request.arrayBuffer)\n    const id = clientId++\n    const mailbox = yield* Mailbox.make<Uint8Array | FromServerEncoded>()\n    const parser = serialization.unsafeMake()\n    const encoder = new TextEncoder()\n\n    const offer = (data: Uint8Array | string) =>\n      typeof data === \"string\" ? mailbox.offer(encoder.encode(data)) : mailbox.offer(data)\n\n    clients.set(id, {\n      write: (response) => {\n        try {\n          if (!includesFraming) return mailbox.offer(response)\n          const encoded = parser.encode(response)\n          if (encoded === undefined) return Effect.void\n          return offer(encoded)\n        } catch (cause) {\n          return !includesFraming\n            ? mailbox.offer(ResponseDefectEncoded(cause))\n            : offer(parser.encode(ResponseDefectEncoded(cause))!)\n        }\n      },\n      end: mailbox.end\n    })\n\n    const requestIds: Array<RequestId> = []\n\n    try {\n      const decoded = parser.decode(new Uint8Array(data)) as ReadonlyArray<FromClientEncoded>\n      for (const message of decoded) {\n        if (message._tag === \"Request\") {\n          requestIds.push(RequestId(message.id))\n        }\n        yield* writeRequest(id, message)\n      }\n    } catch (cause) {\n      yield* offer(parser.encode(ResponseDefectEncoded(cause))!)\n    }\n\n    yield* writeRequest(id, constEof)\n\n    if (!includesFraming) {\n      let done = false\n      yield* Effect.addFinalizer(() => {\n        clients.delete(id)\n        disconnects.unsafeOffer(id)\n        if (done) return Effect.void\n        return Effect.forEach(\n          requestIds,\n          (requestId) => writeRequest(id, { _tag: \"Interrupt\", requestId: String(requestId) }),\n          { discard: true }\n        )\n      })\n      const responses = Arr.empty<FromServerEncoded>()\n      while (true) {\n        const [items, done] = yield* mailbox.takeAll\n        // eslint-disable-next-line no-restricted-syntax\n        responses.push(...items as any)\n        if (done) break\n      }\n      done = true\n      return HttpServerResponse.text(parser.encode(responses) as string, { contentType: serialization.contentType })\n    }\n\n    return HttpServerResponse.stream(\n      Stream.ensuringWith(Mailbox.toStream(mailbox as Mailbox.ReadonlyMailbox<Uint8Array>), (exit) => {\n        clients.delete(id)\n        disconnects.unsafeOffer(id)\n        if (!Exit.isInterrupted(exit)) return Effect.void\n        return Effect.forEach(\n          requestIds,\n          (requestId) => writeRequest(id, { _tag: \"Interrupt\", requestId: String(requestId) }),\n          { discard: true }\n        )\n      }),\n      { contentType: serialization.contentType }\n    )\n  }).pipe(Effect.interruptible)\n\n  const protocol = yield* Protocol.make((writeRequest_) => {\n    writeRequest = writeRequest_\n    return Effect.succeed({\n      disconnects,\n      send(clientId, response) {\n        const client = clients.get(clientId)\n        if (!client) return Effect.void\n        return client.write(response)\n      },\n      end(clientId) {\n        const client = clients.get(clientId)\n        if (!client) return Effect.void\n        return client.end\n      },\n      clientIds: Effect.sync(() => clients.keys()),\n      initialMessage: Effect.succeedNone,\n      supportsAck: false,\n      supportsTransferables: false,\n      supportsSpanPropagation: false\n    })\n  })\n\n  return { protocol, httpApp } as const\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolHttp = Effect.fnUntraced(function*<I = HttpRouter.Default>(options: {\n  readonly path: HttpRouter.PathInput\n  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>\n}) {\n  const { httpApp, protocol } = yield* makeProtocolWithHttpApp\n  const router =\n    yield* (options.routerTag ?? HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>)\n  yield* router.post(options.path, httpApp)\n  return protocol\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolHttpRouter = Effect.fnUntraced(function*(options: {\n  readonly path: HttpRouter.PathInput\n}) {\n  const router = yield* HttpLayerRouter.HttpRouter\n  const { httpApp, protocol } = yield* makeProtocolWithHttpApp\n  yield* router.add(\"POST\", options.path, httpApp)\n  return protocol\n})\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolWorkerRunner: Effect.Effect<\n  Protocol[\"Type\"],\n  WorkerError,\n  WorkerRunner.PlatformRunner | Scope.Scope\n> = Protocol.make(Effect.fnUntraced(function*(writeRequest) {\n  const fiber = yield* Effect.withFiberRuntime<Fiber.RuntimeFiber<void>>(Effect.succeed as any)\n  const runner = yield* WorkerRunner.PlatformRunner\n  const closeLatch = yield* WorkerRunner.CloseLatch\n  const backing = yield* runner.start<FromClientEncoded | InitialMessage.Encoded, FromServerEncoded>(closeLatch)\n  const initialMessage = yield* Deferred.make<unknown>()\n  const clientIds = new Set<number>()\n  const disconnects = yield* Mailbox.make<number>()\n\n  yield* Deferred.await(closeLatch).pipe(\n    Effect.onExit(() => {\n      fiber.currentScheduler.scheduleTask(() => fiber.unsafeInterruptAsFork(fiber.id()), 0)\n      return Effect.void\n    }),\n    Effect.forkScoped\n  )\n\n  yield* backing.run((clientId, message) => {\n    clientIds.add(clientId)\n    if (message._tag === \"InitialMessage\") {\n      return Deferred.succeed(initialMessage, message.value)\n    }\n    return writeRequest(clientId, message)\n  })\n\n  yield* disconnects.take.pipe(\n    Effect.tap((clientId) => {\n      clientIds.delete(clientId)\n      return disconnects.offer(clientId)\n    }),\n    Effect.forkScoped\n  )\n\n  return {\n    disconnects,\n    send: backing.send,\n    end(_clientId) {\n      return Effect.void\n    },\n    clientIds: Effect.sync(() => clientIds.values()),\n    initialMessage: Effect.asSome(Deferred.await(initialMessage)),\n    supportsAck: true,\n    supportsTransferables: true,\n    supportsSpanPropagation: true\n  }\n}))\n\n/**\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolWorkerRunner: Layer.Layer<\n  Protocol,\n  WorkerError,\n  WorkerRunner.PlatformRunner\n> = Layer.scoped(Protocol, makeProtocolWorkerRunner)\n\n/**\n * A rpc protocol that uses streaming http for communication.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolHttp = <I = HttpRouter.Default>(options: {\n  readonly path: HttpRouter.PathInput\n  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization> => {\n  const routerTag = options.routerTag ??\n    HttpRouter.Default as any as HttpRouter.HttpRouter.TagClass<I, string, any, any>\n  return Layer.effect(Protocol, makeProtocolHttp(options)).pipe(\n    Layer.provide(routerTag.Live)\n  )\n}\n\n/**\n * A rpc protocol that uses streaming http for communication.\n *\n * Uses a `HttpLayerRouter` to provide the http endpoint.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolHttpRouter = (options: {\n  readonly path: HttpRouter.PathInput\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | HttpLayerRouter.HttpRouter> =>\n  Layer.effect(Protocol, makeProtocolHttpRouter(options))\n\n/**\n * @since 1.0.0\n * @category http app\n */\nexport const toHttpApp: <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n  } | undefined\n) => Effect.Effect<\n  HttpApp.Default<never, Scope.Scope>,\n  never,\n  | Scope.Scope\n  | RpcSerialization.RpcSerialization\n  | Rpc.ToHandler<Rpcs>\n  | Rpc.Middleware<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n  }\n) {\n  const { httpApp, protocol } = yield* makeProtocolWithHttpApp\n  yield* make(group, options).pipe(\n    Effect.provideService(Protocol, protocol),\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n  return httpApp\n})\n\n/**\n * @since 1.0.0\n * @category http app\n */\nexport const toHttpAppWebsocket: <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n  } | undefined\n) => Effect.Effect<\n  HttpApp.Default<never, Scope.Scope>,\n  never,\n  | Scope.Scope\n  | RpcSerialization.RpcSerialization\n  | Rpc.ToHandler<Rpcs>\n  | Rpc.Middleware<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options?: {\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n  }\n) {\n  const { httpApp, protocol } = yield* makeProtocolWithHttpAppWebsocket\n  yield* make(group, options).pipe(\n    Effect.provideService(Protocol, protocol),\n    Effect.interruptible,\n    Effect.forkScoped\n  )\n  return httpApp\n})\n\n/**\n * Construct an http web handler from an `RpcGroup`.\n *\n * @since 1.0.0\n * @category constructors\n */\nexport const toWebHandler = <Rpcs extends Rpc.Any, LE>(\n  group: RpcGroup.RpcGroup<Rpcs>,\n  options: {\n    readonly layer: Layer.Layer<\n      | Rpc.ToHandler<Rpcs>\n      | Rpc.Middleware<Rpcs>\n      | RpcSerialization.RpcSerialization\n      | HttpRouter.HttpRouter.DefaultServices,\n      LE\n    >\n    readonly disableTracing?: boolean | undefined\n    readonly spanPrefix?: string | undefined\n    readonly spanAttributes?: Record<string, unknown> | undefined\n    readonly middleware?: (\n      httpApp: HttpApp.Default\n    ) => HttpApp.Default<\n      never,\n      HttpRouter.HttpRouter.DefaultServices\n    >\n    readonly memoMap?: Layer.MemoMap\n  }\n): {\n  readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>\n  readonly dispose: () => Promise<void>\n} => {\n  const runtime = ManagedRuntime.make(Layer.mergeAll(options.layer, Layer.scope), options?.memoMap)\n  let handlerCached:\n    | ((request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>)\n    | undefined\n  const handlerPromise = Effect.gen(function*() {\n    const app = yield* toHttpApp(group, options)\n    const rt = yield* runtime.runtimeEffect\n    const handler = HttpApp.toWebHandlerRuntime(rt)(options?.middleware ? options.middleware(app as any) as any : app)\n    handlerCached = handler\n    return handler\n  }).pipe(runtime.runPromise)\n  function handler(request: globalThis.Request, context?: Context.Context<never> | undefined): Promise<Response> {\n    if (handlerCached !== undefined) {\n      return handlerCached(request, context)\n    }\n    return handlerPromise.then((handler) => handler(request, context))\n  }\n  return { handler, dispose: runtime.dispose } as const\n}\n\n/**\n * Create a protocol that uses the provided `Stream` and `Sink` for communication.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const makeProtocolStdio = Effect.fnUntraced(function*<EIn, EOut, RIn, ROut>(options: {\n  readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>\n  readonly stdout: Sink.Sink<void, Uint8Array | string, unknown, EOut, ROut>\n}) {\n  const serialization = yield* RpcSerialization.RpcSerialization\n\n  return yield* Protocol.make(Effect.fnUntraced(function*(writeRequest) {\n    const mailbox = yield* Mailbox.make<Uint8Array | string>()\n    const parser = serialization.unsafeMake()\n\n    yield* options.stdin.pipe(\n      Stream.runForEach((data) => {\n        const decoded = parser.decode(data) as ReadonlyArray<FromClientEncoded>\n        if (decoded.length === 0) return Effect.void\n        let i = 0\n        return Effect.whileLoop({\n          while: () => i < decoded.length,\n          body: () => writeRequest(0, decoded[i++]),\n          step: constVoid\n        })\n      }),\n      Effect.retry(Schedule.spaced(500)),\n      Effect.forkScoped,\n      Effect.interruptible\n    )\n\n    yield* Mailbox.toStream(mailbox).pipe(\n      Stream.run(options.stdout),\n      Effect.retry(Schedule.spaced(500)),\n      Effect.forkScoped,\n      Effect.interruptible\n    )\n\n    return {\n      disconnects: yield* Mailbox.make<number>(),\n      send(_clientId, response) {\n        const responseEncoded = parser.encode(response)\n        if (responseEncoded === undefined) {\n          return Effect.void\n        }\n        return mailbox.offer(responseEncoded)\n      },\n      end(_clientId) {\n        return mailbox.end\n      },\n      clientIds: Effect.succeed([0]),\n      initialMessage: Effect.succeedNone,\n      supportsAck: true,\n      supportsTransferables: false,\n      supportsSpanPropagation: true\n    }\n  }))\n})\n\n/**\n * Create a protocol that uses the provided `Stream` and `Sink` for communication.\n *\n * @since 1.0.0\n * @category protocol\n */\nexport const layerProtocolStdio = <EIn, EOut, RIn, ROut>(options: {\n  readonly stdin: Stream.Stream<Uint8Array, EIn, RIn>\n  readonly stdout: Sink.Sink<void, Uint8Array | string, unknown, EOut, ROut>\n}): Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | RIn | ROut> =>\n  Layer.scoped(Protocol, makeProtocolStdio(options))\n\n// internal\n\nconst makeSocketProtocol = Effect.gen(function*() {\n  const serialization = yield* RpcSerialization.RpcSerialization\n  const disconnects = yield* Mailbox.make<number>()\n\n  let clientId = 0\n  const clients = new Map<number, {\n    readonly write: (bytes: FromServerEncoded) => Effect.Effect<void>\n  }>()\n\n  let writeRequest!: (clientId: number, message: FromClientEncoded) => Effect.Effect<void>\n\n  const onSocket = function*(socket: Socket.Socket) {\n    const scope = yield* Effect.scope\n    const parser = serialization.unsafeMake()\n    const id = clientId++\n    yield* Scope.addFinalizerExit(scope, () => {\n      clients.delete(id)\n      return disconnects.offer(id)\n    })\n\n    const writeRaw = yield* socket.writer\n    const write = (response: FromServerEncoded) => {\n      try {\n        const encoded = parser.encode(response)\n        if (encoded === undefined) {\n          return Effect.void\n        }\n        return Effect.orDie(writeRaw(encoded))\n      } catch (cause) {\n        return Effect.orDie(\n          writeRaw(parser.encode(ResponseDefectEncoded(cause))!)\n        )\n      }\n    }\n    clients.set(id, { write })\n\n    yield* socket.runRaw((data) => {\n      try {\n        const decoded = parser.decode(data) as ReadonlyArray<FromClientEncoded>\n        if (decoded.length === 0) return Effect.void\n        let i = 0\n        return Effect.whileLoop({\n          while: () => i < decoded.length,\n          body: () => writeRequest(id, decoded[i++]),\n          step: constVoid\n        })\n      } catch (cause) {\n        return writeRaw(parser.encode(ResponseDefectEncoded(cause))!)\n      }\n    }).pipe(\n      Effect.interruptible,\n      Effect.catchIf((error) => error.reason === \"Close\", () => Effect.void),\n      Effect.orDie\n    )\n  }\n\n  const protocol = yield* Protocol.make((writeRequest_) => {\n    writeRequest = writeRequest_\n    return Effect.succeed({\n      disconnects,\n      send: (clientId, response) => {\n        const client = clients.get(clientId)\n        if (!client) return Effect.void\n        return Effect.orDie(client.write(response))\n      },\n      end(_clientId) {\n        return Effect.void\n      },\n      clientIds: Effect.sync(() => clients.keys()),\n      initialMessage: Effect.succeedNone,\n      supportsAck: true,\n      supportsTransferables: false,\n      supportsSpanPropagation: true\n    })\n  })\n\n  return { protocol, onSocket } as const\n})\n", "/**\n * @since 1.0.0\n */\nimport * as Effect from \"effect/Effect\"\nimport type * as Scope from \"effect/Scope\"\nimport type * as Rpc from \"./Rpc.js\"\nimport * as RpcClient from \"./RpcClient.js\"\nimport type * as RpcGroup from \"./RpcGroup.js\"\nimport * as RpcServer from \"./RpcServer.js\"\n\n/**\n * @since 1.0.0\n * @category constructors\n */\nexport const makeClient: <Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>\n) => Effect.Effect<\n  RpcClient.RpcClient<Rpcs>,\n  never,\n  Scope.Scope | Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | Rpc.MiddlewareClient<Rpcs>\n> = Effect.fnUntraced(function*<Rpcs extends Rpc.Any>(\n  group: RpcGroup.RpcGroup<Rpcs>\n) {\n  // eslint-disable-next-line prefer-const\n  let client!: Effect.Effect.Success<ReturnType<typeof RpcClient.makeNoSerialization<Rpcs, never>>>\n  const server = yield* RpcServer.makeNoSerialization(group, {\n    onFromServer(response) {\n      return client.write(response)\n    }\n  })\n  client = yield* RpcClient.makeNoSerialization(group, {\n    supportsAck: true,\n    onFromClient({ message }) {\n      return server.write(0, message)\n    }\n  })\n  return client.client\n})\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAIA;;;;;cAAAA;EAAA;;;cAAAC;;;;ACAA;;;;;;;;AAYO,IAAMC,iBAAgCC,OAAOC,IAAI,8BAA8B;AAM/E,IAAMC,iBAAkBC,YAC7BA,OAAOC,IAAIC,YAAgBC,oBAAoB,MAAMP;AAMhD,IAAMQ,uBAAwBJ,YACnCD,eAAsBM,cAAcL,MAAM,CAAC;AAMtC,IAAMM,mBACXL,SAIIA,IAAIC,YAAYN,cAAc,IAAWW,KAAKN,IAAIC,YAAYN,cAAc,CAAQ,IAAWY,KAAI;AAqBlG,IAAMC,SAASA,CACpB;EAAEC;EAASC;AAAO,MAKlBC,OAAOC,OACEC,QACL,CAACH,SAASD,OAAO,GACjB;EACEK,QAAQA,CAACJ,UAASD,aAChBM,YACcC,cAAqBC,cAAcP,QAAO,CAAC,GAC3CM,cAAcP,QAAO,CAAC;EAEtCS,QAAQA,CAACR,UAASD,aAChBM,YACcI,cAAqBF,cAAcP,QAAO,CAAC,GAC3CS,cAAcV,QAAO,CAAC;GAGxC;EACEW,UAAUzB;EACV,CAACA,cAAc,GAAG;IAAEe;IAASD;EAAO;CACrC,GAEH;EACEC;EACAD;CACD;AAGL,IAAMY,WAAYC,OAAsDC,YAAYD,GAAWE,YAAY;AAE3G,IAAMT,cAAcA,CAClBU,eAIAC,kBAEF,CAACJ,GAAYK,SAA2B3B,QAC/B4B,QACEC,QAAO,GACbA,CAAAA,aAAW;AACV,MAAI,CAACR,SAASC,CAAC,EAAG,QAAcQ,KAAK,IAAgBC,KAAK/B,KAAKsB,CAAC,CAAC;AACjE,SAAcU,SAAQV,EAAEW,KACdC,gBAAiBC,WAAUV,cAAcU,OAAOR,OAAO,CAAC,GACxDS,SAAUC,WAAS;AACzB,QAAgBC,aAAaD,KAAK,EAAG,QAAeE,KAAIF,KAAK;AAC7D,WAAcG,YAAYd,cAAcW,OAAOV,OAAO,GAAG;MACvDc,WAAkBF;MAClBG,WAAkBZ;KACnB;EACH,CAAC,GACOa,eAAed,QAAO,CAAC,CAChC;AACH,CAAC;;;AD/FE,IAAMe,SAAwBC,OAAOC,IAAI,iBAAiB;AAY1D,IAAMC,QAASC,OAAkDC,YAAYD,GAAGJ,MAAM;AAwd7F,IAAMM,QAAQ;EACZ,CAACN,MAAM,GAAGA;EACVO,OAAI;AACF,WAAOC,cAAc,MAAMC,SAAS;EACtC;EACAC,WAEEC,gBAAgC;AAEhC,WAAOC,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAe,KAAKA;MACpBH,eAAAA;MACAI,aAAa,KAAKA;MAClBC,aAAa,KAAKA;MAClBC,aAAa,KAAKA;KACnB;EACH;EACAC,SAA6BH,aAA8B;AACzD,WAAOH,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAe,KAAKA;MACpBH,eAAe,KAAKA;MACpBI;MACAC,aAAa,KAAKA;MAClBC,aAAa,KAAKA;KACnB;EACH;EACAE,WAA+BL,eAAwD;AACrF,WAAOF,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAsBM,SAASN,aAAa,IAAIA,gBAA8BO,OAAOP,aAAoB;MACzGH,eAAe,KAAKA;MACpBI,aAAa,KAAKA;MAClBC,aAAa,KAAKA;MAClBC,aAAa,KAAKA;KACnB;EACH;EACAK,WAA+BA,YAAqC;AAClE,WAAOV,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAe,KAAKA;MACpBH,eAAe,KAAKA;MACpBI,aAAa,KAAKA;MAClBC,aAAa,KAAKA;MAClBC,aAAa,oBAAIM,IAAI,CAAC,GAAG,KAAKN,aAAaK,UAAU,CAAC;KACvD;EACH;EACAE,OAA2BA,QAAc;AACvC,WAAOZ,UAAU;MACfC,MAAM,GAAGW,MAAM,GAAG,KAAKX,IAAI;MAC3BC,eAAe,KAAKA;MACpBH,eAAe,KAAKA;MACpBI,aAAa,KAAKA;MAClBC,aAAa,KAAKA;MAClBC,aAAa,KAAKA;KACnB;EACH;EACAQ,SAA6BC,KAA6BC,OAAU;AAClE,WAAOf,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAe,KAAKA;MACpBH,eAAe,KAAKA;MACpBI,aAAa,KAAKA;MAClBE,aAAa,KAAKA;MAClBD,aAAsBY,IAAI,KAAKZ,aAAaU,KAAKC,KAAK;KACvD;EACH;EACAE,gBAAoCC,UAA8B;AAChE,WAAOlB,UAAU;MACfC,MAAM,KAAKA;MACXC,eAAe,KAAKA;MACpBH,eAAe,KAAKA;MACpBI,aAAa,KAAKA;MAClBE,aAAa,KAAKA;MAClBD,aAAsBe,MAAM,KAAKf,aAAac,QAAO;KACtD;EACH;;AAGF,IAAMlB,YAMJoB,aAOkD;AAClD,WAASC,MAAG;EAAI;AAChBC,SAAOC,eAAeF,KAAK3B,KAAK;AAChC4B,SAAOE,OAAOH,KAAKD,OAAO;AAC1BC,MAAII,MAAM,mBAAmBL,QAAQnB,IAAI;AACzC,SAAOoB;AACT;AAMO,IAAMK,QAAOA,CAMlBZ,KAAUM,YAaR;AACF,QAAMrB,iBAAgBqB,SAASO,WAAkBC;AACjD,QAAMzB,cAAciB,SAASS,SAAgBC;AAC7C,MAAI5B;AACJ,MAAIkB,SAASW,YAAY;AACvB7B,oBAAgB,MAAM8B,gBAAuBC,MAAe,mBAAmBnB,GAAG,EAAE,EAAEM,QAAQc,OAAc,EAAC;MAC3G,CAAYC,MAAM,IAAC;AACjB,eAAOf,QAAQW,WAAY,IAAW;MACxC;;EAEJ,OAAO;AACL7B,oBAAuBM,SAASY,SAASc,OAAO,IAC5Cd,SAASc,UACTd,SAASc,UACFzB,OAAOW,SAASc,OAAc,IAC9BN;EACb;AACA,SAAO5B,UAAU;IACfC,MAAMa;IACNZ;IACAH,eAAeqB,SAASgB,SACZC,OAAO;MACfV,SAAS5B;MACTuC,SAASnC;KACV,IACDJ;IACFI,aAAaiB,SAASgB,SAAgBN,QAAQ3B;IAC9CC,aAAsBmC,OAAK;IAC3BlC,aAAa,oBAAIM,IAAG;GACrB;AACH;AA8BO,IAAM6B,oBACXC,YAEAzC,UAAU;EACRC,MAAMwC,OAAOxC;EACbC,eAAeuC;EACf1C,eAAe0C,OAAOd;EACtBxB,aAAasC,OAAOH;EACpBlC,aAAsBmC,OAAK;EAC3BlC,aAAa,oBAAIM,IAAG;CACrB;AAEH,IAAM+B,kBAAkBC,YAAY,mCAAmC,MAAM,oBAAIC,QAAO,CAA0B;AAM3G,IAAMC,aACXC,UACsD;AACtD,MAAIJ,gBAAgBK,IAAID,IAAI,GAAG;AAC7B,WAAOJ,gBAAgBM,IAAIF,IAAI;EACjC;AACA,QAAMG,MAAMH;AACZ,QAAMI,WAAW,oBAAIvC,IAAuB,CAACsC,IAAI9C,WAAW,CAAC;AAC7D,QAAMgD,gBAA0BC,iBAAiBH,IAAIlD,cAAcsD,GAAG;AACtE,MAAWC,OAAOH,aAAa,GAAG;AAChCD,aAASlC,IAAImC,cAAcpC,MAAMuB,OAAO;EAC1C;AACA,aAAW5B,cAAcuC,IAAI5C,aAAa;AACxC6C,aAASlC,IAAIN,WAAW4B,OAAO;EACjC;AACA,QAAMG,SAAgBc,KAAK;IACzB5B,SAAgB2B,OAAOH,aAAa,IAAWvB,OAAOqB,IAAIlD;IAC1DuC,SAAgBkB,MAAM,GAAGN,QAAQ;IACjCO,QAAeC;GAChB;AACDhB,kBAAgBiB,IAAIb,MAAML,MAAM;AAChC,SAAOA;AACT;AAMO,IAAMmB,aAA4BvE,OAAOC,IAAI,sBAAsB;AAyBnE,IAAMuE,QAAW9C,YAAuB;EAAE,CAAC6C,UAAU,GAAGA;EAAY7C;AAAK;AAMzE,IAAM+C,SAAUtE,OAA8BoE,cAAcpE;;;AEjwBnE;;;;;;;cAAAuE;EAAA;;;;;;;;;ACIO,IAAMC,UAAUA,MAKdC,OACAC,QAAQ,MAAK;AAClB,QAAMC,YAAmBC,oBAAoB,CAAC;AAC9C,MAAIC,SAAsD,CAAA;AAC1D,MAAIC,QAAQA,IAAIC,SACPC,YAAaC,CAAAA,aAAW;AAC7BJ,WAAOK,KAAK,CAACH,MAAME,QAAO,CAAC;EAC7B,CAAC;AACH,SAAcE,KAAIV,EAAE,IAAIM,SAASD,MAAM,GAAGC,IAAI,CAAC,GAAIK,QAAO;IACxD,GAAGA;IACHC,IAAIZ,IAAC;AACH,aAAOE,UAAUW,YAAY,CAAC,EAASC,IAAI,aAAS;AAClD,cAAMC,OAAOV;AACbA,gBAAQL;AAER,mBAAW,CAACM,MAAME,QAAO,KAAKJ,QAAQ;AACpC,iBAAcY,QAAQX,MAAM,GAAGC,IAAI,GAAGE,QAAO;QAC/C;AACAJ,iBAAS,CAAA;AAET,eAAO,OAAca,OAAcC,OAAO,MAAK;AAC7Cb,kBAAQU;AACR,iBAAcI;QAChB,CAAC;MACH,CAAC,CAAC;IACJ;IACK;AACT,CAAC;;;AC7BH;;;;;;;;;;AAmBO,IAAMC,kBAAiCC,OAAOC,IAAI,iCAAiC;AAkBnF,IAAMC,YAAaC,QACxB,OAAOA,OAAO,WAAWA,KAAkBC,OAAOD,EAAE;AAyF/C,IAAME,WAAgB;EAAEC,MAAM;AAAK;AAMnC,IAAMC,YAAkB;EAAED,MAAM;AAAM;AAsBtC,IAAME,mBAAkCR,OAAOC,IAAI,kCAAkC;AAiE5F,IAAMQ,eAAsBC,WAAkBC,MAAM;AAM7C,IAAMC,wBAAyBC,YAA2C;EAC/EP,MAAM;EACNQ,QAAQL,aAAaI,KAAK;;AAkCrB,IAAME,YAAkB;EAAET,MAAM;AAAM;;;AC7Q7C;;;;;;;;;;;;;;AAaM,IAAOU,mBAAP,cAAwCC,IAAI,8BAA8B,EAAC,EAI7E;AAAA;AAeG,IAAMC,OAAiCF,iBAAiBG,GAAG;EAChEC,aAAa;EACbC,iBAAiB;EACjBC,YAAYA,MAAK;AACf,UAAMC,UAAU,IAAIC,YAAW;AAC/B,WAAO;MACLC,QAASC,WAAU,CAACC,KAAKC,MAAM,OAAOF,UAAU,WAAWA,QAAQH,QAAQE,OAAOC,KAAK,CAAC,CAAC;MACzFG,QAASC,cAAaH,KAAKI,UAAUD,QAAQ;;EAEjD;CACD;AAMM,IAAME,SAAmChB,iBAAiBG,GAAG;EAClEC,aAAa;EACbC,iBAAiB;EACjBC,YAAYA,MAAK;AACf,UAAMC,UAAU,IAAIC,YAAW;AAC/B,QAAIS,SAAS;AACb,WAAQ;MACNR,QAASC,WAAS;AAChBO,kBAAU,OAAOP,UAAU,WAAWA,QAAQH,QAAQE,OAAOC,KAAK;AAClE,YAAIQ,WAAW;AACf,YAAIC,UAAUF,OAAOG,QAAQ,MAAMF,QAAQ;AAC3C,cAAMG,QAAwB,CAAA;AAC9B,eAAOF,YAAY,IAAI;AACrB,gBAAMG,OAAOX,KAAKC,MAAMK,OAAOM,MAAML,UAAUC,OAAO,CAAC;AACvDE,gBAAMG,KAAKF,IAAI;AACfJ,qBAAWC,UAAU;AACrBA,oBAAUF,OAAOG,QAAQ,MAAMF,QAAQ;QACzC;AACAD,iBAASA,OAAOM,MAAML,QAAQ;AAC9B,eAAOG;MACT;MACAR,QAASC,cAAY;AACnB,YAAIW,MAAMC,QAAQZ,QAAQ,GAAG;AAC3B,cAAIA,SAASa,WAAW,EAAG,QAAOC;AAClC,cAAIC,OAAO;AACX,mBAASC,IAAI,GAAGA,IAAIhB,SAASa,QAAQG,KAAK;AACxCD,oBAAQlB,KAAKI,UAAUD,SAASgB,CAAC,CAAC,IAAI;UACxC;AACA,iBAAOD;QACT;AACA,eAAOlB,KAAKI,UAAUD,QAAQ,IAAI;MACpC;;EAEJ;CACD;AAMM,IAAMiB,UAAWC,aAGtBhC,iBAAiBG,GAAG;EAClBC,aAAa4B,SAAS5B,eAAe;EACrCC,iBAAiB;EACjBC,YAAYA,MAAK;AACf,UAAMC,UAAU,IAAIC,YAAW;AAC/B,UAAMyB,UAAU,oBAAIC,IAAG;AAIvB,WAAO;MACLzB,QAASC,WAAS;AAChB,cAAMyB,UAAkDxB,KAAKC,MAC3D,OAAOF,UAAU,WAAWA,QAAQH,QAAQE,OAAOC,KAAK,CAAC;AAE3D,eAAO0B,iBAAiBD,SAASF,OAAO;MAC1C;MACApB,QAASC,cAAY;AACnB,YAAIW,MAAMC,QAAQZ,QAAQ,GAAG;AAC3B,cAAIA,SAASa,WAAW,EAAG,QAAOC;AAClC,iBAAOjB,KAAKI,UAAUD,SAASuB,IAAIC,oBAAoB,CAAC;QAC1D;AACA,cAAMC,UAAUC,iBAAiB1B,UAAiBmB,OAAO;AACzD,eAAOM,WAAW5B,KAAKI,UAAUwB,OAAO;MAC1C;;EAEJ;CACD;AAMI,IAAME,YAAaT,aAGxBhC,iBAAiBG,GAAG;EAClBC,aAAa4B,SAAS5B,eAAe;EACrCC,iBAAiB;EACjBC,YAAYA,MAAK;AACf,UAAMoC,SAAS1B,OAAOV,WAAU;AAChC,UAAM2B,UAAU,oBAAIC,IAAG;AAIvB,WAAQ;MACNzB,QAASC,WAAS;AAChB,cAAMiC,SAASD,OAAOjC,OAAOC,KAAK;AAClC,YAAIiC,OAAOhB,WAAW,EAAG,QAAO,CAAA;AAChC,cAAMiB,WAA+E,CAAA;AACrF,iBAASd,IAAI,GAAGA,IAAIa,OAAOhB,QAAQG,KAAK;AACtC,gBAAMe,QAAQF,OAAOb,CAAC;AAEtBc,mBAASpB,KAAK,GAAGY,iBAAiBS,OAAcZ,OAAO,CAAQ;QACjE;AACA,eAAOW;MACT;MACA/B,QAASC,cAAY;AACnB,YAAIW,MAAMC,QAAQZ,QAAQ,GAAG;AAC3B,iBAAO4B,OAAO7B,OAAOC,SAASuB,IAAIC,oBAAoB,CAAC;QACzD;AACA,cAAMC,UAAUC,iBAAiB1B,UAAiBmB,OAAO;AACzD,eAAOM,WAAWG,OAAO7B,OAAO0B,OAAO;MACzC;;EAEJ;CACD;AAEH,SAASH,iBACPD,SACAF,SAGE;AAEF,MAAIR,MAAMC,QAAQS,OAAO,GAAG;AAC1B,UAAMW,QAAQ;MACZC,MAAM;MACNC,WAAW,oBAAId,IAAG;;AAEpB,UAAMU,WAA+E,CAAA;AACrF,aAASd,IAAI,GAAGA,IAAIK,QAAQR,QAAQG,KAAK;AACvC,YAAMmB,UAAUC,qBAAqBf,QAAQL,CAAC,CAAC;AAC/C,UAAImB,QAAQE,SAAS,WAAW;AAC9BL,cAAMC;AACNd,gBAAQmB,IAAIH,QAAQI,IAAIP,KAAK;MAC/B;IACF;AACA,WAAOF;EACT;AACA,SAAOnB,MAAMC,QAAQS,OAAO,IAAIA,QAAQE,IAAIa,oBAAoB,IAAI,CAACA,qBAAqBf,OAAO,CAAC;AACpG;AAEA,SAASe,qBAAqBf,SAAuB;AACnD,MAAI,YAAYA,SAAS;AACvB,QAAI,CAACA,QAAQkB,MAAMlB,QAAQmB,OAAOC,WAAW,cAAc,GAAG;AAC5D,YAAMC,MAAMrB,QAAQmB,OAAO/B,MAAM,eAAeI,MAAM;AAGtD,YAAM8B,YAAatB,QAAgBuB,QAAQD;AAC3C,aAAOA,YACL;QACEN,MAAMK;QACNC,WAAWE,OAAOF,SAAS;UAE7B;QAAEN,MAAMK;MAAG;IACf;AACA,WAAO;MACLL,MAAM;MACNE,IAAIlB,QAAQkB,KAAKM,OAAOxB,QAAQkB,EAAE,IAAI;MACtCG,KAAKrB,QAAQmB;MACbM,SAASzB,QAAQuB;MACjBG,SAAS1B,QAAQ0B,WAAW,CAAA;MAC5BC,SAAS3B,QAAQ2B;MACjBC,QAAQ5B,QAAQ4B;MAChBC,SAAS7B,QAAQ6B;;EAErB,WAAW7B,QAAQ8B,SAAS9B,QAAQ8B,MAAMd,SAAS,UAAU;AAC3D,WAAO;MACLA,MAAM;MACNe,QAAQ/B,QAAQ8B,MAAMpC;;EAE1B,WAAWM,QAAQgC,UAAU,MAAM;AACjC,WAAO;MACLhB,MAAM;MACNM,WAAWE,OAAOxB,QAAQkB,EAAE;MAC5Be,QAAQjC,QAAQkC;;EAEpB;AACA,SAAO;IACLlB,MAAM;IACNM,WAAWE,OAAOxB,QAAQkB,EAAE;IAC5BiB,MAAMnC,QAAQ8B,SAAS,OACrB;MACEd,MAAM;MACNoB,OAAOpC,QAAQ8B,MAAMd,SAAS,UAC5BhB,QAAQ8B,MAAMpC,OACd;QACEsB,MAAM;QACNe,QAAQ/B,QAAQ8B;;QAGtB;MACEd,MAAM;MACNqB,OAAOrC,QAAQkC;;;AAGvB;AAEA,SAAS7B,iBACP1B,UACAmB,SAGE;AAEF,MAAI,EAAE,eAAenB,WAAW;AAC9B,WAAOwB,qBAAqBxB,QAAQ;EACtC;AACA,QAAMgC,QAAQb,QAAQwC,IAAI3D,SAAS2C,SAAS;AAC5C,MAAIX,OAAO;AACTb,YAAQyC,OAAO5D,SAAS2C,SAAS;AACjCX,UAAME,UAAUI,IAAItC,SAAS2C,WAAW3C,QAAe;AACvD,QAAIgC,MAAMC,SAASD,MAAME,UAAUD,MAAM;AACvC,aAAOtB,MAAMkD,KAAK7B,MAAME,UAAUoB,OAAM,GAAI9B,oBAAoB;IAClE;AACA,WAAOV;EACT;AACA,SAAOU,qBAAqBxB,QAAQ;AACtC;AAEA,SAASwB,qBAAqBxB,UAAqE;AACjG,UAAQA,SAASqC,MAAI;IACnB,KAAK;AACH,aAAO;QACLyB,SAAS;QACTtB,QAAQxC,SAAS0C;QACjBE,QAAQ5C,SAAS8C;QACjBP,IAAIvC,SAASuC,MAAMwB,OAAO/D,SAASuC,EAAE;QACrCQ,SAAS/C,SAAS+C;QAClBC,SAAShD,SAASgD;QAClBC,QAAQjD,SAASiD;QACjBC,SAASlD,SAASkD;;IAEtB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,aAAO;QACLY,SAAS;QACTtB,QAAQ,eAAexC,SAASqC,IAAI;QACpCO,QAAQ,eAAe5C,WAAW;UAAE2C,WAAW3C,SAAS2C;QAAS,IAAK7B;;IAE1E,KAAK;AACH,aAAO;QACLgD,SAAS;QACTT,OAAO;QACPd,IAAIwB,OAAO/D,SAAS2C,SAAS;QAC7BY,QAAQvD,SAASsD;;IAErB,KAAK;AACH,aAAO;QACLQ,SAAS;QACTvB,IAAIvC,SAAS2C,YAAYoB,OAAO/D,SAAS2C,SAAS,IAAI7B;QACtDyC,QAAQvD,SAASwD,KAAKnB,SAAS,YAAYrC,SAASwD,KAAKE,QAAQ5C;QACjEqC,OAAOnD,SAASwD,KAAKnB,SAAS,YAC5B;UACEA,MAAM;UACN2B,MAAMhE,SAASwD,KAAKC,MAAMpB,SAAS,UAAU4B,YAAYjE,SAASwD,KAAKC,MAAMN,OAAO,MAAM,IACtFY,OAAO/D,SAASwD,KAAKC,MAAMN,MAAMa,IAAI,IACrC;UACJ7B,SAASnC,SAASwD,KAAKC,MAAMpB,SAAS,UAAU4B,YAAYjE,SAASwD,KAAKC,MAAMN,OAAO,SAAS,IAC5FnD,SAASwD,KAAKC,MAAMN,MAAMhB,UAC1BtC,KAAKI,UAAUD,SAASwD,KAAKC,KAAK;UACtC1C,MAAMf,SAASwD,KAAKC;YAEtB3C;;IAEN,KAAK;AACH,aAAO;QACLgD,SAAS;QACTvB,IAAI2B;QACJf,OAAO;UACLd,MAAM;UACN2B,MAAM;UACN7B,SAAS;UACTpB,MAAMf,SAASoD;;;EAGvB;AACF;AAEA,IAAMc,uBAAuB;AAgCtB,IAAMC,UAAoCjF,iBAAiBG,GAAG;EACnEC,aAAa;EACbC,iBAAiB;EACjBC,YAAYA,MAAK;AACf,UAAM4E,UAAU,IAAIC,iBAASC,QAAO;AACpC,UAAMC,QAAQ,IAAIF,iBAASG,MAAK;AAChC,UAAMC,UAAU,IAAIC,YAAW;AAC/B,WAAO;MACL/E,QAASC,WAAUwE,QAAQO,eAAe,OAAO/E,UAAU,WAAW6E,QAAQ1E,OAAOH,KAAK,IAAIA,KAAK;MACnGG,QAASC,cAAauE,MAAMK,KAAK5E,QAAQ;;EAE7C;CACD;AAWM,IAAM6E,YAAiDC,SAAQ5F,kBAAkBE,IAAI;AAWrF,IAAM2F,cAAmDD,SAAQ5F,kBAAkBgB,MAAM;AAQzF,IAAM8E,eAAgB9D,aAEc4D,SAAQ5F,kBAAkB+B,QAAQC,OAAO,CAAC;AAS9E,IAAM+D,iBAAkB/D,aAEY4D,SAAQ5F,kBAAkByC,UAAUT,OAAO,CAAC;AAWhF,IAAMgE,eAAoDJ,SAAQ5F,kBAAkBiF,OAAO;;;ACralG;;;;;;;AAgBM,IAAOgB,iBAAP,cAAsCC,IAAI,sCAAsC,EAAC,EAQpF;AAAA;AAiBH,IAAMC,cAAuCC,WAAW,gCAAgC;AAMjF,IAAMC,qBAAqBA,CAChCC,QACAC,YAMOC,QAAQD,SAASE,WAAS;AAC/B,QAAMC,YAAyBC,oBAAmB;AAClD,SAAcC,OAAON,MAAM,EAAEG,KAAK,EAAEI,KAC3BC,eAA4BC,WAAWL,SAAS,GAChDM,KAAKC,aAAY,CAACA,SAASP,UAAUQ,YAAW,CAAE,CAAU,CAAC;AAExE,CAAC;AAMI,IAAMC,sBAAsBA,CACjCb,QACAc,UAEMb,OACJN,gBACOoB,YAAaC,CAAAA,aACXC,QAAeC,MAAMnB,mBAAmBC,QAAQc,KAAK,CAAC,GAAGE,QAAO,CAAC,CACzE;AAOE,IAAMG,iBACXnB,YAEAH,YAAYU,KACHL,QAASkB,cAAaA,SAASD,cAAc,GAC7CE,SACAnB,QAAeoB,eAActB,MAAM,CAAC,CAAC;;;AJoGhD,IAAIuB,mBAAmBC,OAAO,CAAC;AAMxB,IAAMC,sBAwBFC,WAAW,WACpBC,OACAC,SAcC;AAED,QAAMC,aAAaD,SAASC,cAAc;AAC1C,QAAMC,cAAcF,SAASE,eAAe;AAC5C,QAAMC,iBAAiBH,SAASG,kBAAkB;AAClD,QAAMC,oBAAoBJ,SAASI,sBAAsB,MAAMT;AAE/D,QAAMU,WAAU,OAAcA,QAAO;AACrC,QAAMC,SAAgBC,IAAIF,UAAeG,KAAK;AAc9C,QAAMC,UAAU,oBAAIC,IAAG;AAEvB,MAAIC,aAAa;AACjB,SAAaC,aACXN,QACOO,YAAaC,aAAW;AAC7BH,iBAAa;AACb,WAAOI,aAAkBC,UAAUF,OAAO,CAAC;EAC7C,CAAC,CAAC;AAGJ,QAAMC,eAAsBjB,WAAW,WAAUmB,MAAsB;AACrE,eAAW,CAACC,IAAIC,KAAK,KAAKV,SAAS;AACjCA,cAAQW,OAAOF,EAAE;AACjB,UAAIC,MAAME,SAAS,WAAW;AAC5B,eAAOF,MAAMG,QAAQC,KAAKN,IAAI;MAChC,OAAO;AACLE,cAAMK,OAAOP,IAAI;MACnB;IACF;EACF,CAAC;AAED,QAAMQ,YAAaC,SAAyB;AAC1C,UAAMC,YAAqBC,eAAeF,IAAIG,aAAa;AAC3D,UAAMC,aAAaC,uBAAuBL,GAAG;AAC7C,WAAO,CAACM,SAAcC,SAMjB;AACH,YAAMC,UAAUD,MAAMC,UAAkBC,UAAUF,KAAKC,OAAO,IAAYE;AAC1E,YAAM/B,WAAU4B,MAAM5B,WAAmB+B,OAAK;AAC9C,UAAI,CAACT,WAAU;AACb,cAAMF,aAAaY,UACjBC,gBACEZ,KACAI,YACAO,MACAX,IAAIa,cAAcC,OAAOd,IAAIa,cAAcC,KAAKR,OAAO,IAAIA,SAC3DE,SACA7B,UACA4B,MAAMQ,WAAW,KAAK;AAE1B,eAAOtC,iBAAiBsB,WAAUiB,MAAS,IAAWC,QACpD,GAAG1C,UAAU,IAAIyB,IAAIL,IAAI,IACzB;UAAEuB,mBAAmB;UAAOC,YAAY7C,QAAQ8C;QAAc,GAC9DrB,UAAS;MAEb;AACA,YAAMH,UAAUyB,gBACdrB,KACAI,YACAJ,IAAIa,cAAcC,OAAOd,IAAIa,cAAcC,KAAKR,OAAO,IAAIA,SAC3DE,SACAD,MAAMe,oBAAoB,IAC1B3C,QAAO;AAET,UAAI4B,MAAMgB,UAAW,QAAO3B;AAC5B,aAAc4B,aAAoBC,KAAI7B,SAAiB8B,QAAQ,CAAC;IAClE;EACF;AAEA,QAAMd,kBAAkBA,CACtBZ,KACAI,YACAO,MACAL,SACAE,SACA7B,UACAoC,YAEOY,iBAAiCC,iBAAe;AACrD,QAAI3C,YAAY;AACd,aAAcK;IAChB;AACA,UAAME,KAAKd,kBAAiB;AAC5B,UAAMmD,OAAOzB,WAAW;MACtBT,MAAM;MACNH;MACAsC,KAAK9B,IAAIL;MACTW;MACAyB,SAASpB,MAAMoB;MACfC,QAAQrB,MAAMqB;MACdC,SAAStB,MAAMsB;MACfzB,SAAiB0B,OAAMN,YAAYO,YAAYC,cAAc,GAAG5B,OAAO;KACxE;AACD,QAAIO,SAAS;AACX,aAAcsB,QAAQR,MAAOS,aAC3BhE,QAAQiE,aAAa;QACnBD;QACA3D,SAAAA;QACAoC;OACD,CAAC;IACN;AACA,UAAMyB,WAAkB1B,MAAK;MAC3BnC,SAASiD,YAAYa;MACrBC,WAAWd,YAAYe,aAAY;MACnCC,cAAsBC,eAAeD;KACtC;AACD,QAAIE;AACJ,WAAcC,YACLC,MAAiBlD,YAAU;AAChC,YAAML,QAAqB;QACzBE,MAAM;QACNK;QACArB,SAAAA;QACAmB,OAAOP,MAAI;AACTO,iBAAOP,IAAI;AACX,cAAIuD,SAAS,CAACA,MAAMG,WAAU,GAAI;AAChCrB,wBAAYsB,iBAAiBC,aAAa,MAAK;AAC7CL,oBAAMM,sBAAsBxB,YAAYpC,GAAE,CAAE;YAC9C,GAAG,CAAC;UACN;QACF;;AAEFT,cAAQsE,IAAI7D,IAAIC,KAAK;AACrBqD,cAAQjB,KAAKyB,KACJjB,QAASkB,aACdjF,QAAQiE,aAAa;QACnBD,SAASiB;QACT5E,SAAAA;QACAoC;OACD,CAAC,GAEJJ,OAAc6C,eAAe7C,IAAI,IAAI8C,UAC7BC,QAAQlB,QAAO,CAAC;AAE1BM,YAAMa,YAAapE,UAAQ;AACzB,YAAIA,KAAKI,SAAS,WAAW;AAC3B,iBAAOG,OAAOP,IAAI;QACpB;MACF,CAAC;IACH,CAAC,GACAqE,CAAAA,kBAAgB;AACf7E,cAAQW,OAAOF,EAAE;AACjB,YAAMqE,MAAMC,MAAMC,KAAKH,aAAY,EAAEvB,QAAS7C,CAAAA,QAAOsE,MAAMC,KAAaC,MAAMxE,GAAE,CAAC,CAAC;AAClF,aAAcyE,SACN3E,WAAUwD,KAAK,GACrBoB,cAAc1E,IAAIqE,KAAKlF,QAAO,CAAC;IAEnC,CAAC;EAEL,CAAC;AAEH,QAAM0C,kBAAyBjD,WAAW,WACxC4B,KACAI,YACAE,SACAE,SACAc,kBACA3C,UAA+B;AAE/B,QAAIM,YAAY;AACd,aAAO,OAAcK;IACvB;AAEA,UAAMqB,OAAOlC,iBAAiBuC,SAAY,OAAcmD,eAAe,GAAG5F,UAAU,IAAIyB,IAAIL,IAAI,IAAI;MAClGuB,mBAAmB;MACnBC,YAAY7C,QAAQ8C;KACrB;AACD,UAAM0B,QAAesB,WAAiBC,gBAAe,CAAE;AACvD,UAAM7E,KAAKd,kBAAiB;AAE5B,UAAME,SAAgB0F,UAAUxB,MAAML,gBAAsB3D,KAAK;AACjE,WAAayF,iBACX3F,QACCW,UAAQ;AACP,UAAI,CAACR,QAAQyF,IAAIhF,EAAE,EAAG,QAAciF;AACpC1F,cAAQW,OAAOF,EAAE;AACjB,aAAO0E,cACL1E,IACKkF,UAAUnF,IAAI,IACfuE,MAAMC,KAAWH,aAAarE,KAAKoF,KAAK,CAAC,EAAEtC,QAAS7C,CAAAA,QAAOsE,MAAMC,KAAaC,MAAMxE,GAAE,CAAC,CAAC,IACxF,CAAA,GACJb,QAAO;IAEX,CAAC;AAGH,UAAMiB,UAAU,OAAekB,MAAeQ,gBAAgB;AAC9DvC,YAAQsE,IAAI7D,IAAI;MACdG,MAAM;MACNK;MACAJ;MACAhB,OAAAA;MACAD,SAAAA;KACD;AAED,WAAOyB,WAAW;MAChBT,MAAM;MACNH;MACAsC,KAAK9B,IAAIL;MACToC,SAASpB,MAAMoB;MACfzB;MACA0B,QAAQrB,MAAMqB;MACdC,SAAStB,MAAMsB;MACfzB,SAAiB0B,OAAMY,MAAMX,YAAYC,cAAc,GAAG5B,OAAO;KAClE,EAAE8C,KACMjB,QACJkB,aACCjF,QAAQiE,aAAa;MACnBD,SAASiB;MACT5E,SAAAA;MACAoC,SAAS;KACV,CAAC,GAENJ,OAAc6C,eAAe7C,IAAI,IAAI8C,UAC9BmB,cAAeC,WAAUjF,QAAQkF,UAAUD,KAAK,CAAC,GACjDE,eACAC,OAAOpG,MAAK,CAAC;AAGtB,WAAOgB;EACT,CAAC;AAED,QAAMS,yBAA0BL,SAAmF;AACjH,UAAMiF,cAAwD,CAAA;AAC9D,eAAWnD,OAAO9B,IAAIiF,YAAYC,OAAM,GAAI;AAC1C,YAAM9E,aAAazB,SAAQwG,UAAUtG,IAAI,GAAGiD,IAAIsD,GAAG,SAAS;AAC5D,UAAI,CAAChF,WAAY;AACjB6E,kBAAYI,KAAKjF,UAAU;IAC7B;AACA,WAAO6E,YAAYK,WAAW,IACnBC,WACP,SAAShC,SAAO;AAChB,UAAIiC,IAAI;AACR,aAAc/D,KACLgE,UAAU;QACfC,OAAOA,MAAMF,IAAIP,YAAYK;QAC7BK,MAAMA,MACJV,YAAYO,CAAC,EAAE;UACbxF;UACAuD;SACD;QACHqC,KAAKC,aAAW;AACdtC,oBAAUsC;AACVL;QACF;OACD,GACD,MAAMjC,OAAO;IAEjB;EACJ;AAEA,QAAMW,gBAAgBA,CACpB4B,WACAlC,eACAjF,aAEOqE,MAAalD,YAAU;AAC5B,UAAM8B,cAAqBwC,WAAiBC,gBAAe,CAAE;AAC7D,UAAM7B,WAAkB1B,MAAK;MAC3BnC,SAASiD,YAAYa;MACrBC,WAAWd,YAAYe,aAAY;MACnCC,cAAsBC,eAAeD;KACtC;AACD,UAAME,QAAQxE,QAAQiE,aAAa;MACjCD,SAAS;QAAE3C,MAAM;QAAamG;QAAWlC,cAAAA;MAAY;MACrDjF,SAAAA;MACAoC,SAAS;KACV,EAAEuC,KACMyC,QAAQ,GAAI,GACXrC,QAAQlB,QAAO,CAAC;AAE1BM,UAAMa,YAAY,MAAK;AACrB7D,aAAc2E,KAAI;IACpB,CAAC;EACH,CAAC;AAEH,QAAMuB,QAAS1D,aAAkD;AAC/D,YAAQA,QAAQ3C,MAAI;MAClB,KAAK,SAAS;AACZ,cAAMmG,YAAYxD,QAAQwD;AAC1B,cAAMrG,QAAQV,QAAQF,IAAIiH,SAAS;AACnC,YAAI,CAACrG,SAASA,MAAME,SAAS,UAAW,QAAc8E;AACtD,eAAOhF,MAAMG,QAAQqG,SAAS3D,QAAQ4C,MAAM,EAAE5B,KAC5C9E,cACWyF,SACP3F,QAAQiE,aAAa;UACnBD,SAAS;YAAE3C,MAAM;YAAOmG,WAAWxD,QAAQwD;UAAS;UACpDnH,SAASc,MAAMd;UACfoC,SAAS;SACV,CAAC,IAEF0C,UACGmB,cAAeD,WAAUlF,MAAMG,QAAQC,KAAUiF,UAAUH,KAAK,CAAC,CAAC,CAAC;MAE9E;MACA,KAAK,QAAQ;AACX,cAAMmB,YAAYxD,QAAQwD;AAC1B,cAAMrG,QAAQV,QAAQF,IAAIiH,SAAS;AACnC,YAAI,CAACrG,MAAO,QAAcgF;AAC1B1F,gBAAQW,OAAOoG,SAAS;AACxB,YAAIrG,MAAME,SAAS,UAAU;AAC3BF,gBAAMK,OAAOwC,QAAQ/C,IAAI;AACzB,iBAAckF;QAChB;AACA,eAAOhF,MAAMG,QAAQC,KAAUqG,OAAO5D,QAAQ/C,IAAI,CAAC;MACrD;MACA,KAAK,UAAU;AACb,eAAOF,aAAkB8G,IAAI7D,QAAQ8D,MAAM,CAAC;MAC9C;MACA,KAAK,aAAa;AAChB,eAAc3B;MAChB;IACF;EACF;AAEA,MAAI4B;AACJ,MAAI/H,QAAQgI,SAAS;AACnB,UAAMC,MAAM,oBAAIvH,IAAG;AACnBqH,aAAS,SAASA,QAAOvE,KAAaxB,SAAchC,UAAY;AAC9D,UAAIkI,KAAKD,IAAI1H,IAAIiD,GAAG;AACpB,UAAI,CAAC0E,IAAI;AACPA,aAAKzG,UAAU1B,MAAMoI,SAAS5H,IAAIiD,GAAG,CAAS;AAC9CyE,YAAIlD,IAAIvB,KAAK0E,EAAE;MACjB;AACA,aAAOA,GAAGlG,SAAShC,QAAO;IAC5B;EACF,OAAO;AACL+H,aAAS,CAAA;AACT,eAAWrG,OAAO3B,MAAMoI,SAASvB,OAAM,GAAI;AACzC,YAAMwB,MAAM1G,IAAIL,KAAKgH,QAAQ,GAAG;AAChC,YAAMC,SAASF,QAAQ,KAAK1F,SAAYhB,IAAIL,KAAKkH,MAAM,GAAGH,GAAG;AAC7D,UAAIE,WAAW5F,UAAa,EAAE4F,UAAUP,SAAS;AAC/C;AAAEA,eAAeO,MAAM,IAAI,CAAA;MAC7B;AACA,YAAME,SAASF,WAAW5F,SAAaqF,OAAeO,MAAM,IAAIP;AAChE,YAAMvE,MAAM8E,WAAW5F,SAAYhB,IAAIL,KAAKkH,MAAMH,MAAM,CAAC,IAAI1G,IAAIL;AACjEmH,aAAOhF,GAAG,IAAI/B,UAAUC,GAAU;IACpC;EACF;AAEA,SAAO;IAAEqG;IAAQL;EAAK;AACxB,CAAC;AAMM,IAAMlF,SAaF1C,WAAW,WACpBC,OACAC,SAMa;AAEb,QAAM;IAAEyI,KAAAA;IAAKlF;IAAMrD;IAAawI;EAAqB,IAAK,OAAOC;AASjE,QAAMlI,UAAU,oBAAIC,IAAG;AAEvB,QAAM;IAAEqH;IAAQL;EAAK,IAAK,OAAO7H,oBAAoBE,OAAO;IAC1D,GAAGC;IACHE;IACA+D,aAAa;MAAED;IAAO,GAAE;AACtB,cAAQA,QAAQ3C,MAAI;QAClB,KAAK,WAAW;AACd,gBAAMK,MAAM3B,MAAMoI,SAAS5H,IAAIyD,QAAQR,GAAG;AAC1C,gBAAMoF,UAAoBC,iBAAiBnH,IAAIG,cAAciH,GAAG;AAChE,gBAAMC,YAAYL,wBAAqCM,oBAAmB,IAAKtG;AAE/E,gBAAM8B,QAAesB,WAAiBC,gBAAe,CAAE;AAEvD,gBAAM5E,QAAqB;YACzBO;YACArB,SAAS0I,YACGE,IAAIzE,MAAML,gBAA6B+E,WAAWH,SAAS,IACnEvE,MAAML;YACVgF,aAAoBC,OAAOR,OAAO,IACvBS,eAAqBC,cAAcV,QAAQW,MAAMC,OAAO,CAAC,IAChE9G;;AAENjC,kBAAQsE,IAAIf,QAAQ9C,IAAIC,KAAK;AAE7B,iBAAcsI,OAAO/H,IAAIa,aAAa,EAAEyB,QAAQhC,OAAO,EAAEgD,KAChD0E,QAAiBvF,gBAAgBhD,MAAMd,OAAO,GAC9CsJ,OACA5F,QAAS/B,aACduB,KAAK;YACH,GAAGS;YACH9C,IAAI0I,OAAO5F,QAAQ9C,EAAE;YACrBc;YACAE,SAAS2H,OAAOpJ,QAAQuD,QAAQ9B,OAAO;aACtC6G,aAAaA,UAAUe,YAAW,CAAE,CAAC,CACzC;QAEL;QACA,KAAK,OAAO;AACV,gBAAM3I,QAAQV,QAAQF,IAAIyD,QAAQwD,SAAS;AAC3C,cAAI,CAACrG,MAAO,QAAcgF;AAC1B,iBAAO5C,KAAK;YACVlC,MAAM;YACNmG,WAAWoC,OAAO5F,QAAQwD,SAAS;WACpC;QACH;QACA,KAAK,aAAa;AAChB,gBAAMrG,QAAQV,QAAQF,IAAIyD,QAAQwD,SAAS;AAC3C,cAAI,CAACrG,MAAO,QAAcgF;AAC1B1F,kBAAQW,OAAO4C,QAAQwD,SAAS;AAChC,iBAAOjE,KAAK;YACVlC,MAAM;YACNmG,WAAWoC,OAAO5F,QAAQwD,SAAS;WACpC;QACH;QACA,KAAK,OAAO;AACV,iBAAcrB;QAChB;MACF;IACF;GACD;AAED,SAAOsC,KAAKzE,aAAW;AACrB,YAAQA,QAAQ3C,MAAI;MAClB,KAAK,SAAS;AACZ,cAAMmG,YAAYuC,UAAU/F,QAAQwD,SAAS;AAC7C,cAAMrG,QAAQV,QAAQF,IAAIiH,SAAS;AACnC,YAAI,CAACrG,SAAS,CAACA,MAAMgI,YAAa,QAAchD;AAChD,eAAOhF,MAAMgI,YAAYnF,QAAQ4C,MAAM,EAAE5B,KAChC0E,QAAiBvF,gBAAgBhD,MAAMd,OAAO,GAC9CsJ,OACA5F,QAASiG,WACdtC,MAAM;UAAErG,MAAM;UAAS4I,UAAU;UAAGzC,WAAWuC,UAAU/F,QAAQwD,SAAS;UAAGZ,QAAQoD;QAAK,CAAE,CAAC,GAExFE,QAAS7D,WACdqB,MAAM;UACJrG,MAAM;UACN4I,UAAU;UACVzC,WAAWuC,UAAU/F,QAAQwD,SAAS;UACtCvG,MAAWuF,UAAUH,KAAK;SAC3B,CAAC,CACH;MAEL;MACA,KAAK,QAAQ;AACX,cAAMmB,YAAYuC,UAAU/F,QAAQwD,SAAS;AAC7C,cAAMrG,QAAQV,QAAQF,IAAIiH,SAAS;AACnC,YAAI,CAACrG,MAAO,QAAcgF;AAC1B1F,gBAAQW,OAAOoG,SAAS;AACxB,eAAc2C,OAAWC,WAAWjJ,MAAMO,GAAU,CAAC,EAAEsC,QAAQ/C,IAAI,EAAE+D,KAC5D0E,QAAiBvF,gBAAgBhD,MAAMd,OAAO,GAC9CsJ,OACAU,iBAAiB;UACtBC,WAAYrJ,UAASyG,MAAM;YAAErG,MAAM;YAAQ4I,UAAU;YAAGzC;YAAWvG;UAAI,CAAE;UACzEsJ,WAAYlE,WAAUqB,MAAM;YAAErG,MAAM;YAAQ4I,UAAU;YAAGzC;YAAWvG,MAAWuF,UAAUH,KAAK;UAAC,CAAE;SAClG,CAAC;MAEN;MACA,KAAK,UAAU;AACb,eAAOqB,MAAM;UAAErG,MAAM;UAAU4I,UAAU;UAAGnC,QAAQ0C,aAAaxG,QAAQ8D,MAAM;QAAC,CAAE;MACpF;MACA,SAAS;AACP,eAAc3B;MAChB;IACF;EACF,CAAC,EAAEnB,KACMsB,cAAqBmE,QAAQ,GAC7BhE,eACAiE,UAAU;AAGnB,SAAO3C;AACT,CAAC;AAMM,IAAMjE,iBAAqD6G,YAChE,wCACA,MAAeC,YAAmBxI,MAAK,CAAC;AAOnC,IAAMyI,cAWTC,KACF,GACA,CAAUC,SAAgC7I,YACjC8I,YAAYD,SAAQjH,gBAAwBF,OAAczB,UAAUD,OAAO,CAAC,CAAC,CAAC;AAOlF,IAAM+I,oBAcTH,KACF,GACA,CACEC,SACA7I,YAC4C6B,QAAQ7B,SAAUA,CAAAA,aAAY2I,YAAYE,SAAQ7I,QAAO,CAAC,CAAC;AAOrG,IAAOyG,WAAP,cAAgCuC,IAAI,gCAAgC,EAAC,EAUvE;;;;EAIF,OAAO1I,OAAO2I,QAAO;;AAOhB,IAAMC,mBAAoBrD,YAK/BY,SAASnG,KAAY1C,WAAW,WAAUuL,eAAa;AACrD,QAAMC,gBAAgB,OAAwBC;AAC9C,QAAMC,SAASF,cAAcG,gBAAgB;AAE7C,QAAMlI,OAAQ0B,aAAmD;AAC/D,QAAIA,QAAQ5D,SAAS,WAAW;AAC9B,aAAc8E;IAChB;AAEA,UAAMuF,SAASJ,cAAcV,WAAU;AAEvC,UAAMe,UAAUD,OAAOjC,OAAOxE,OAAO;AACrC,UAAMoC,OAAO,OAAOsE,YAAY,WACrBC,KAAKD,SAASL,cAAcG,WAAW,IACvCI,WAAWF,SAASL,cAAcG,WAAW;AAExD,QAAID,QAAQ;AACV,aAAOzD,OAAO+D,KAAK,IAAI;QAAEzE;MAAI,CAAE,EAAErC,KACxBjB,QAASgI,OAAMA,EAAEC,IAAI,GACrBC,QACAlI,QAASmI,OAAK;AACnB,YAAI,CAAC1G,MAAM2G,QAAQD,CAAC,GAAG;AACrB,iBAAcE,WAAW,4CAA4CF,CAAC,EAAE;QAC1E;AACA,YAAIhF,IAAI;AACR,eAAcC,UAAU;UACtBC,OAAOA,MAAMF,IAAIgF,EAAElF;UACnBK,MAAMA,MAAMgE,cAAca,EAAEhF,GAAG,CAAC;UAChCI,MAAM+E;SACP;MACH,CAAC,GACM1C,KAAK;IAEhB;AAEA,WAAO5B,OAAO+D,KAAK,IAAI;MAAEzE;IAAI,CAAE,EAAErC,KACxBjB,QAASgI,OACPO,gBAAgBP,EAAEQ,QAASvC,WAAS;AACzC,YAAMwC,YAAkBC,gBAAgBzC,KAAK,EAAEjG,QAAQ2H,OAAOvB,MAAM;AACpE,UAAIqC,UAAUxF,WAAW,EAAG,QAAcb;AAC1C,UAAIe,IAAI;AACR,aAAcC,UAAU;QACtBC,OAAOA,MAAMF,IAAIsF,UAAUxF;QAC3BK,MAAMA,MAAMgE,cAAcmB,UAAUtF,GAAG,CAAC;QACxCI,MAAM+E;OACP;IACH,CAAC,CAAC,GAEG1C,KAAK;EAEhB;AAEA,SAAO;IACLpG;IACArD,aAAa;IACbwI,uBAAuB;;AAE3B,CAAC,CAAC;AAMG,IAAMgE,oBAAqB1M,aAI1BiM,QACJtD,UACO5E,QACM4I,YACV5E,YAAU;AACTA,WAAoB6E,WAAW7E,QAA0B8E,WAAW7M,QAAQ8M,GAAG,CAAC;AAChF,SAAO1B,iBAAiBpL,QAAQ+M,kBAAkB/M,QAAQ+M,gBAAgBhF,MAAM,IAAIA,MAAM;AAC5F,CAAC,CACF;AAOE,IAAMiF,qBAAsBhN,aAOjC2I,SAASnG,KAAY1C,WAAW,WAAUuL,eAAa;AACrD,QAAM4B,SAAS,OAAcC;AAC7B,QAAM5B,gBAAgB,OAAwBC;AAE9C,QAAM7D,QAAQ,OAAOuF,OAAOE;AAE5B,MAAIzB,SAASJ,cAAcV,WAAU;AAErC,QAAMwC,SAAS,OAAOC,WAAW3F,MAAMgE,OAAOjC,OAAO6D,SAAS,CAAE,CAAC;AAEjE,SAAcC,QAAQ,MAAK;AACzB7B,aAASJ,cAAcV,WAAU;AACjCwC,WAAOI,MAAK;AACZ,WAAOP,OAAOQ,OAAQzJ,aAAW;AAC/B,UAAI;AACF,cAAMwI,YAAYd,OAAOvB,OAAOnG,OAAO;AACvC,YAAIwI,UAAUxF,WAAW,EAAG;AAC5B,YAAIE,IAAI;AACR,eAAcC,UAAU;UACtBC,OAAOA,MAAMF,IAAIsF,UAAUxF;UAC3BK,MAAMA,MAAK;AACT,kBAAMqG,WAAWlB,UAAUtF,GAAG;AAC9B,gBAAIwG,SAASrM,SAAS,QAAQ;AAC5B+L,qBAAOO,OAAM;YACf;AACA,mBAAOtC,cAAcqC,QAAQ;UAC/B;UACApG,MAAM+E;SACP;MACH,SAASvE,QAAQ;AACf,eAAOuD,cAAc;UAAEhK,MAAM;UAAUyG;QAAM,CAAE;MACjD;IACF,CAAC,EAAE9C,KACM4I,UAAiBjI,SACtByH,OAAO3F,SACAoG,KACL,IAAWC,mBAAmB;MAC5BC,QAAQ;MACR1H,OAAO,IAAI2H,MAAM,cAAc;KAChC,CAAC,CACH,CACF,CAAC;EAEN,CAAC,EAAEhJ,KACMW,SAAgBkI,KACrB,IAAWI,iBAAiB;IAC1BF,QAAQ;IACRG,MAAM;GACP,CAAC,CACH,GACMC,cAAe9H,WAAS;AAC7B,UAAME,QAAc6H,cAAc/H,KAAK;AACvC,QACErG,SAASqO,wBAA+BjF,OAAO7C,KAAK,MACnDA,MAAMgD,MAAMwE,WAAW,UAAUxH,MAAMgD,MAAMwE,WAAW,gBACzD;AACA,aAAc5H;IAChB;AACA,WAAOkF,cAAc;MAAEhK,MAAM;MAAUyG,QAAcwG,OAAOjI,KAAK;IAAC,CAAE;EACtE,CAAC,GACMkI,MAAeC,OAAO,GAAI,CAAC,GAC3BC,aAAa;IAClBC,QAAQ;IACRC,QAAQ;GACT,GACMlI,eACAiE,UAAU;AAGnB,SAAO;IACLnH,KAAK0B,SAAO;AACV,YAAM0G,UAAUD,OAAOjC,OAAOxE,OAAO;AACrC,UAAI0G,YAAYjJ,OAAW,QAAcyD;AACzC,aAAcwD,MAAMjC,MAAMiE,OAAO,CAAC;IACpC;IACAzL,aAAa;IACbwI,uBAAuB;;AAE3B,CAAC,CAAC;AAEJ,IAAM2E,aAAoBvN,WAAW,WAAmB8O,WAAiC;AACvF,MAAIC,eAAe;AACnB,QAAMC,QAAeC,gBAAe;AACpC,QAAMvB,QAAQA,MAAK;AACjBqB,mBAAe;AACfC,UAAME,YAAW;EACnB;AACA,QAAMrB,SAASA,MAAK;AAClBkB,mBAAe;EACjB;AACA,SAActB,QAAQ,MAAK;AACzB,QAAI,CAACsB,aAAc,QAAOC,MAAMG;AAChCJ,mBAAe;AACf,WAAOD;EACT,CAAC,EAAE5J,KACMkK,MAAM,YAAY,GAClBC,QACAC,SACA3I,eACAiE,UAAU;AAEnB,SAAO;IAAEjD,SAASqH,MAAMO;IAAO7B;IAAOG;EAAM;AAC9C,CAAC;AAMM,IAAM2B,qBACXtP,aAgBA2I,SAASnG,KAAY1C,WAAW,WAAUuL,eAAa;AACrD,QAAMkE,SAAS,OAAcC;AAC7B,QAAMlP,SAAQ,OAAcA;AAC5B,MAAImP,WAAW;AACf,QAAMC,kBAAiB,OAAcC,cAAwBC,cAAc;AAE3E,QAAMnP,UAAU,oBAAIC,IAAG;AAKvB,QAAMmP,UAAiBC,IAAI,aAAS;AAClC,UAAM5O,KAAKuO;AACX,UAAMM,UAAU,OAAOR,OAAOS,MAA+E9O,EAAE;AAC/G,UAAM+O,aAAa,OAAcC,UAAS;AAE1C,WAAOH,QAAQtH,IAAKzE,aAAW;AAC7B,UAAIA,QAAQ,CAAC,MAAM,GAAG;AACpB,eAAOiM,WAAWhB;MACpB;AACA,YAAMvB,WAAW1J,QAAQ,CAAC;AAC1B,UAAI0J,SAASrM,SAAS,QAAQ;AAC5B,cAAMF,QAAQV,QAAQF,IAAImN,SAASlG,SAAS;AAC5C,YAAIrG,OAAO;AACTV,kBAAQW,OAAOsM,SAASlG,SAAS;AACjCrG,gBAAM2N,MAAMqB,WAAU;AACtB,iBAAO9E,cAAcqC,QAAQ;QAC/B;MACF,WAAWA,SAASrM,SAAS,UAAU;AACrC,mBAAW,CAACmG,WAAWrG,KAAK,KAAKV,SAAS;AACxCA,kBAAQW,OAAOoG,SAAS;AACxBrG,gBAAM2N,MAAMqB,WAAU;QACxB;AACA,eAAO9E,cAAcqC,QAAQ;MAC/B;AACA,aAAOrC,cAAcqC,QAAQ;IAC/B,CAAC,EAAE1I,KACMmJ,cAAe9H,WAAUgF,cAAc;MAAEhK,MAAM;MAAUyG,QAAcwG,OAAOjI,KAAK;IAAC,CAAE,CAAC,GACvFkI,MAAeC,OAAO,GAAI,CAAC,GAC3BC,aAAa;MAClBC,QAAQ;MACRC,QAAQ;KACT,GACMlI,eACAiE,UAAU;AAGnB,WAAOuF,WAAWZ;AAElB,QAAWjG,OAAOsG,eAAc,GAAG;AACjC,YAAM,CAACnG,OAAO6G,SAAS,IAAI,OAAOV,gBAAenG;AACjD,aAAOwG,QAAQxM,KAAK;QAAElC,MAAM;QAAkBkI;MAAK,GAAI6G,SAAS;IAClE;AAEA,WAAOL;EACT,CAAC;AAED,QAAMM,OAAO,aAAarQ,UACxB,OAAYsQ,YAAY;IACtBT;IACAU,KAAKvQ,QAAQwQ;IACbC,KAAKzQ,QAAQ0Q;IACbC,aAAa3Q,QAAQ2Q;IACrBC,mBAAmB5Q,QAAQ4Q;IAC3BC,YAAY7Q,QAAQ6Q;GACrB,IACD,OAAYrO,MAAK;IACfqN;IACAiB,MAAM9Q,QAAQ8Q;IACdH,aAAa3Q,QAAQ2Q;IACrBC,mBAAmB5Q,QAAQ4Q;GAC5B;AAEH,SAAahQ,aACXN,QACOyQ,KAAK,MAAK;AACf,eAAW5P,SAASV,QAAQmG,OAAM,GAAI;AACpCzF,YAAM2N,MAAMqB,WAAU;IACxB;AACA1P,YAAQuQ,MAAK;EACf,CAAC,CAAC;AAGJ,QAAMzN,OAAOA,CAAC0B,SAA4BgM,kBAA0D;AAClG,YAAQhM,QAAQ5D,MAAI;MAClB,KAAK,WAAW;AACd,eAAOgP,KAAK9P,IAAIyE,KACPjB,QAASwL,CAAAA,YAAU;AACxB,gBAAMT,QAAeC,gBAAgB,KAAK;AAC1CtO,kBAAQsE,IAAIE,QAAQ/D,IAAI;YAAEqO,QAAAA;YAAQT;UAAK,CAAE;AACzC,iBAAcnJ,SAAS4J,QAAOhM,KAAK0B,SAASgM,aAAa,GAAGnC,MAAMO,KAAK;QACzE,CAAC,GACMpD,QACAtC,KAAK;MAEhB;MACA,KAAK,aAAa;AAChB,cAAMxI,QAAQV,QAAQF,IAAI0E,QAAQuC,SAAS;AAC3C,YAAI,CAACrG,MAAO,QAAcgF;AAC1B1F,gBAAQW,OAAO6D,QAAQuC,SAAS;AAChCrG,cAAM2N,MAAMqB,WAAU;AACtB,eAAcxG,MAAMxI,MAAMoO,OAAOhM,KAAK0B,OAAO,CAAC;MAChD;MACA,KAAK,OAAO;AACV,cAAM9D,QAAQV,QAAQF,IAAI0E,QAAQuC,SAAS;AAC3C,YAAI,CAACrG,MAAO,QAAcgF;AAC1B,eAAcwD,MAAMxI,MAAMoO,OAAOhM,KAAK0B,OAAO,CAAC;MAChD;IACF;AACA,WAAckB;EAChB;AAEA,SAAc8F,OAAOoE,KAAK9P,GAAG;AAE7B,SAAO;IACLgD;IACArD,aAAa;IACbwI,uBAAuB;;AAE3B,CAAC,CAAC;AAMG,IAAMwI,sBACXlR,aAYMiM,QAAOtD,UAAU2G,mBAAmBtP,OAAO,CAAC;AAM7C,IAAMmR,sBAAuBnR,aAMzBiM,QAAOtD,UAAUqE,mBAAmBhN,OAAO,CAAC;AAIvD,IAAMwK,eAAsB4G,WAAkBC,MAAM;;;AK1qCpD;;gBAAAC;EAAA,YAAAC;;AAiBO,IAAMC,UAAwBC,OAAOC,IAAI,sBAAsB;AAuMtE,IAAMC,gBAAgB;EACpBC,OAA4BC,MAAgB;AAC1C,WAAOC,WAAU;MACfC,UAAUC,aACR,GAAG,KAAKD,SAASE,OAAM,GACvB,GAAGJ,IAAI;MAETK,aAAa,KAAKA;KACnB;EACH;EACAC,SAA8BC,QAAoC;AAChE,UAAML,WAAW,IAAIM,IAAI,KAAKN,QAAQ;AACtC,UAAMG,cAAc,IAAIG,IAAI,KAAKH,YAAYI,SAAS;AAEtD,eAAWC,SAASH,QAAQ;AAC1B,iBAAW,CAACI,KAAKC,GAAG,KAAKF,MAAMR,UAAU;AACvCA,iBAASW,IAAIF,KAAKC,GAAG;MACvB;AACA,iBAAW,CAACE,KAAKC,KAAK,KAAKL,MAAML,YAAYI,WAAW;AACtDJ,oBAAYQ,IAAIC,KAAKC,KAAK;MAC5B;IACF;AAEA,WAAOd,WAAU;MACfC;MACAG,aAAqBW,WAAWX,WAAW;KAC5C;EACH;EACAY,WAAgCA,YAAqC;AACnE,UAAMf,WAAW,oBAAIM,IAAG;AACxB,eAAW,CAACG,KAAKC,GAAG,KAAK,KAAKV,UAAU;AACtCA,eAASW,IAAIF,KAAKC,IAAIK,WAAWA,UAAU,CAAC;IAC9C;AACA,WAAOhB,WAAU;MACfC;MACAG,aAAa,KAAKA;KACnB;EACH;EACAa,kBAAuCC,OAA2D;AAChG,WAAcC,IAAI,MAAM,aAAS;AAC/B,YAAMC,WAAU,OAAcA,QAAO;AACrC,YAAMC,WAAkBC,SAASJ,KAAK,IAAI,OAAOA,QAAQA;AACzD,YAAMK,aAAa,oBAAIhB,IAAG;AAC1B,iBAAW,CAACG,KAAKc,OAAO,KAAKC,OAAOC,QAAQL,QAAQ,GAAG;AACrD,cAAMV,MAAM,KAAKV,SAAS0B,IAAIjB,GAAG;AACjCa,mBAAWX,IAAID,IAAIE,KAAK;UACtBW;UACAJ,SAAAA;SACD;MACH;AACA,aAAeL,WAAWQ,UAAU;IACtC,CAAC;EACH;EACAK,OAAyDA,QAAc;AACrE,UAAM3B,WAAW,oBAAIM,IAAG;AACxB,eAAW,CAACI,GAAG,KAAK,KAAKV,SAASE,OAAM,GAAI;AAC1C,YAAM0B,SAASlB,IAAIiB,OAAOA,MAAM;AAChC3B,eAASW,IAAIiB,OAAOC,MAAMD,MAAM;IAClC;AACA,WAAO7B,WAAU;MACfC;MACAG,aAAa,KAAKA;KACnB;EACH;EACA2B,QAA6Bb,OAA2D;AACtF,WAAac,cAAc,KAAKf,kBAAkBC,KAAK,CAAC;EAC1D;EACAe,IAAIC;EACJC,eAAoCzB,KAAaQ,OAA2D;AAC1G,WAAac,cAAqBb,IAAI,MAAM,aAAS;AACnD,YAAMC,WAAU,OAAcA,QAAO;AACrC,YAAMI,UAAiBF,SAASJ,KAAK,IAAI,OAAOA,QAAQA;AACxD,YAAMK,aAAa,oBAAIhB,IAAG;AAC1B,YAAMI,MAAM,KAAKV,SAAS0B,IAAIjB,GAAG;AACjCa,iBAAWX,IAAID,IAAIE,KAAK;QACtBW;QACAJ,SAAAA;OACD;AACD,aAAeL,WAAWQ,UAAU;IACtC,CAAC,CAAC;EACJ;EACAa,cAAmC1B,KAAW;AAC5C,WAAc2B,YAAaC,mBAAuC;AAChE,YAAM3B,MAAM,KAAKV,SAAS0B,IAAIjB,GAAG;AACjC,YAAM;QAAEU,SAAAA;QAASI;MAAO,IAAKc,cAAc9B,UAAUmB,IAAIhB,IAAIE,GAAG;AAChE,aAAO,CAAC0B,SAA2BC,YAAoB;AACrD,cAAMC,SAASjB,QAAQe,SAASC,OAAO;AACvC,cAAME,iBAAqBC,OAAOF,MAAM,IAAIA,OAAO3B,QAAQ2B;AAC3D,eAAcnB,SAASoB,cAAc,IAC1BE,QAAQF,gBAAgBtB,QAAO,IAC/ByB,eAAeH,gBAAgBtB,QAAO;MACnD;IACF,CAAC;EACH;EACA0B,SAA8BpC,KAA4BI,OAAU;AAClE,WAAOd,WAAU;MACfC,UAAU,KAAKA;MACfG,aAAqBN,IAAI,KAAKM,aAAaM,KAAKI,KAAK;KACtD;EACH;EACAiC,aAAkCrC,KAA4BI,OAAU;AACtE,WAAO,KAAKkC,oBAA4BC,KAAKvC,KAAKI,KAAK,CAAC;EAC1D;EACAoC,gBAAqC9B,UAA6B;AAChE,WAAOpB,WAAU;MACfC,UAAU,KAAKA;MACfG,aAAqBC,MAAM,KAAKD,aAAagB,QAAO;KACrD;EACH;EACA4B,oBAAyC5B,UAA6B;AACpE,UAAMnB,WAAW,oBAAIM,IAAG;AACxB,eAAW,CAACG,KAAKC,GAAG,KAAK,KAAKV,UAAU;AACtCA,eAASW,IAAIF,KAAKC,IAAIuC,gBAAwB7C,MAAMe,UAAST,IAAIP,WAAW,CAAC,CAAC;IAChF;AACA,WAAOJ,WAAU;MACfC;MACAG,aAAa,KAAKA;KACnB;EACH;;AAGF,IAAMJ,aAAmCmD,aAIvC1B,OAAO2B,OAAO,WAAA;AAAY,GAAGvD,eAAe;EAC1CI,UAAUkD,QAAQlD;EAClBG,aAAa+C,QAAQ/C;CACtB;AAEH,IAAMF,eAAeA,IAChBH,SACkC;AACrC,QAAME,WAAW,oBAAIM,IAAG;AACxB,aAAWI,OAAOZ,MAAM;AACtBE,aAASW,IAAID,IAAImB,MAAauB,SAAS1C,GAAG,IAAQ2C,kBAAkB3C,GAAU,IAAIA,GAAU;EAC9F;AACA,SAAOV;AACT;AAMO,IAAMgD,SAAOA,IACflD,SAEHC,WAAU;EACRC,UAAUC,aAAa,GAAGH,IAAI;EAC9BK,aAAqBmD,OAAK;CAC3B;;;AC9WH;;;aAAAC;EAAA,cAAAC;EAAA;;AAaO,IAAMC,UAAwBC,OAAOC,IAAI,2BAA2B;AAuCpE,IAAMC,eAA8BF,OAAOC,IAAI,wCAAwC;AAoLvF,IAAME,OAAMA,MAanB,CACEC,IACAC,YAOE;AACF,QAAMC,MAAMC,WAAWC;AACvB,QAAMC,QAAQH,IAAII;AAClBJ,MAAII,kBAAkB;AACtB,QAAMC,gBAAgB,IAAIL,IAAG;AAC7BA,MAAII,kBAAkBD;AAEtB,WAASG,WAAQ;EAAI;AACrB,QAAMC,YAAYD;AAClBE,SAAOC,eAAeH,UAAUE,OAAOE,eAAuBC,WAAsBb,EAAE,CAAC,CAAC;AACxFQ,WAASM,MAAMd;AACfU,SAAOK,eAAeP,UAAU,SAAS;IACvCQ,MAAG;AACD,aAAOT,cAAcU;IACvB;GACD;AACDR,YAAUd,OAAM,IAAIA;AACpBc,YAAUS,UAAUjB,SAASkB,aAAa,QAAQlB,SAASiB,YAAYE,SAAmBC,QAAQpB,QAAQiB;AAC1G,MAAIjB,SAASqB,UAAU;AACrBb,cAAUa,WAAWrB,QAAQqB;EAC/B;AACAb,YAAUU,WAAWlB,SAASkB,YAAY;AAC1CV,YAAUc,oBAAoBtB,SAASsB,qBAAqB;AAC5Dd,YAAUe,OAAOvB,SAASuB,QAAQ;AAClC,SAAOhB;AACT;AAMO,IAAMiB,cAAcA,CACzBC,KACAC,YAEMC,cAAqBC,IAAI,aAAS;AACtC,QAAMC,YAAW,OAAcA,QAAO,GAAeC,KAC3CC,KAAKC,KAAK,CAAC;AAErB,QAAMC,aAAoBC,SAASR,OAAO,IAAI,OAAOA,UAAUA;AAC/D,SAAeS,WACb,oBAAIC,IAAI,CAAC,CACP,GAAGX,IAAIZ,GAAG,WACTb,aACQqC,gBACLJ,WAAWjC,OAAO,GACjBsC,oBAA2BC,MAAMV,UAASS,cAAc,CAAC,CAC3D,CACJ,CAAC,CAAC;AAEP,CAAC,CAAC;;;ACpTJ;;kBAAAE;EAAA;;2BAAAC;EAAA;;;;;;cAAAC;EAAA,2BAAAC;EAAA,wBAAAC;EAAA;;;;;;;;;;;;AAuEO,IAAMC,uBAgBFC,WAAW,WACpBC,OACAC,SASC;AAED,QAAMC,gBAAgBD,QAAQE,mBAAmB;AACjD,QAAMC,wBAAwBH,QAAQI,2BAA2B;AACjE,QAAMC,cAAcL,QAAQM,sBAAsB;AAClD,QAAMC,aAAaP,QAAQO,cAAc;AACzC,QAAMC,cAAcR,QAAQQ,eAAe;AAC3C,QAAMC,sBAAsBT,QAAQS,uBAAuB;AAC3D,QAAMC,WAAU,OAAcA,QAAO;AACrC,QAAMC,SAAgBC,IAAIF,UAAeG,KAAK;AAC9C,QAAMC,WAAW,OAAgBC,MAAI;AACrC,QAAMC,WAAU,OAAgBC,QAAQH,QAAQ,EAAC,EAAGI,KAC3CC,aAAa;AAEtB,QAAMC,uBAAuBZ,gBAAgB,cACzCa,SACA,OAAcC,cAAcd,WAAW;AAS3C,QAAMe,UAAU,oBAAIC,IAAG;AACvB,MAAIC,aAAa;AACjB,QAAMC,gBAAuBC,gBAAgB,KAAK;AAClD,SAAaC,aACXjB,QACOkB,YAAaC,aAAW;AAC7BL,iBAAa;AACb,eAAWM,UAAUR,QAAQS,OAAM,GAAI;AACrCD,aAAOE,QAAQ;AACf,UAAIF,OAAOG,OAAOC,SAAS,GAAG;AAC5BnB,QAAAA,SAAQoB,UAAUL,MAAM,CAAC;AACzB;MACF;AACA,iBAAWM,SAASN,OAAOG,OAAOF,OAAM,GAAI;AAC1CK,cAAMC,sBAAsBR,OAAO;MACrC;IACF;AACA,QAAIP,QAAQY,SAAS,GAAG;AACtB,aAAcI;IAChB;AACA,WAAOb,cAAcc;EACvB,CAAC,CAAC;AAGJ,QAAMC,aAAcC,cACXb,YAAaC,aAAW;AAC7B,UAAMC,SAASR,QAAQX,IAAI8B,QAAQ;AACnC,QAAI,CAACX,OAAQ,QAAcQ;AAC3B,eAAWF,SAASN,OAAOG,OAAOF,OAAM,GAAI;AAC1CK,YAAMC,sBAAsBR,OAAO;IACrC;AACAP,YAAQoB,OAAOD,QAAQ;AACvB,WAAcH;EAChB,CAAC;AAEH,QAAMK,QAAQA,CAACF,UAAkBG,YACxBC,eACEC,iBAAkBC,kBAAgB;AACvC,QAAIvB,WAAY,QAAcwB;AAC9B,QAAIlB,SAASR,QAAQX,IAAI8B,QAAQ;AACjC,QAAI,CAACX,QAAQ;AACXA,eAAS;QACPmB,IAAIR;QACJS,SAAS,oBAAI3B,IAAG;QAChBU,QAAQ,oBAAIV,IAAG;QACfS,OAAO;;AAETV,cAAQ6B,IAAIV,UAAUX,MAAM;IAC9B,WAAWA,OAAOE,OAAO;AACvB,aAAcgB;IAChB;AAEA,YAAQJ,QAAQQ,MAAI;MAClB,KAAK,WAAW;AACd,eAAOC,cAAcN,cAAcjB,QAAQc,OAAO;MACpD;MACA,KAAK,OAAO;AACV,cAAMU,QAAQxB,OAAOoB,QAAQvC,IAAIiC,QAAQW,SAAS;AAClD,eAAOD,QAAQA,MAAME,OAAclB;MACrC;MACA,KAAK,aAAa;AAChB,cAAMF,QAAQN,OAAOG,OAAOtB,IAAIiC,QAAQW,SAAS;AACjD,eAAOnB,QAAcqB,cAAcrB,KAAK,IAAIrC,QAAQ2D,aAAa;UAC/DN,MAAM;UACNX;UACAc,WAAWX,QAAQW;UACnBI,MAAWX,UAAkBY,KAAI;SAClC;MACH;MACA,KAAK,OAAO;AACV9B,eAAOE,QAAQ;AACf,YAAIF,OAAOG,OAAOC,OAAO,EAAG,QAAcI;AAC1C,eAAOH,UAAUL,MAAM;MACzB;MACA,SAAS;AACP,eAAO+B,WAAW/B,QAAQ,wBAAyBc,QAAgBQ,IAAI,EAAE;MAC3E;IACF;EACF,CAAC,GACAU,YAAWD,WAAWvC,QAAQX,IAAI8B,QAAQ,GAAIqB,MAAM,CAAC;AAG1D,QAAM3B,YAAaL,YAAkB;AACnCR,YAAQoB,OAAOZ,OAAOmB,EAAE;AACxB,UAAMN,SAAQ5C,QAAQ2D,aAAa;MACjCN,MAAM;MACNX,UAAUX,OAAOmB;KAClB;AACD,QAAIzB,cAAcF,QAAQY,SAAS,GAAG;AACpC,aAAc6B,SAASpB,QAAOlB,cAAc+B,IAAI;IAClD;AACA,WAAOb;EACT;AAEA,QAAMU,gBAAgBA,CACpBN,cACAjB,QACAkC,YACuB;AACvB,QAAIlC,OAAOG,OAAOgC,IAAID,QAAQf,EAAE,GAAG;AACjC,aAAcD;IAChB;AACA,UAAMkB,MAAMpE,MAAMqE,SAASxD,IAAIqD,QAAQI,GAAG;AAC1C,UAAMC,QAAQ5D,SAAQ6D,UAAU3D,IAAIuD,KAAKK,GAAG;AAC5C,QAAI,CAACL,OAAO,CAACG,OAAO;AAClB,YAAM1B,SAAeE,eACnB9C,QAAQ2D,aAAa;QACnBN,MAAM;QACNX,UAAUX,OAAOmB;QACjBM,WAAWS,QAAQf;QACnBU,MAAWa,IAAI,wBAAwBR,QAAQI,GAAG,EAAE;OACrD,GACAN,YAAWD,WAAW/B,QAAQgC,MAAM,CAAC;AAExC,UAAI,CAAChC,OAAOE,SAASF,OAAOG,OAAOC,OAAO,EAAG,QAAOS;AACpD,aAAcoB,SAASpB,QAAOR,UAAUL,MAAM,CAAC;IACjD;AACA,UAAM2C,YAAqBC,eAAeR,IAAIS,aAAa;AAC3D,UAAMC,SAASP,MAAMQ,QAAQb,QAAQc,SAASd,QAAQe,OAAO;AAG7D,UAAMC,UAAaA,OAAOJ,MAAM;AAEhC,UAAMK,iBAAiBD,UAASJ,OAAOM,QAAQN;AAE/C,QAAIO,YAAY;AAChB,QAAIC,UAAgBC,gBAAuBC,iBAClCpE,cAAcqE,gBACnBrB,KACAzD,UACAqB,OAAOmB,IACPe,QAAQc,SACRd,QAAQe,SACRN,YACIe,aAAa1D,QAAQkC,SAASiB,cAAc,IAC5CA,cAAoC,CACzC,GACD;MACEQ,WAAYP,WAAS;AACnBC,oBAAY;AACZ,eAAOpF,QAAQ2D,aAAa;UAC1BN,MAAM;UACNX,UAAUX,OAAOmB;UACjBM,WAAWS,QAAQf;UACnBU,MAAW+B,SAAQR,KAAY;SAChC;MACH;MACAS,WAAYC,WAAS;AACnBT,oBAAY;AACZ,YAAI,CAAC3E,uBAA6BqF,MAAMD,KAAK,GAAG;AAC9C,iBAAO/B,WAAW/B,QAAcgE,OAAOF,KAAK,CAAC;QAC/C;AACA,eAAO7F,QAAQ2D,aAAa;UAC1BN,MAAM;UACNX,UAAUX,OAAOmB;UACjBM,WAAWS,QAAQf;UACnBU,MAAWoC,UAAUH,KAAK;SAC3B;MACH;KACD,CACF;AACD,QAAI5F,eAAe;AACjB,YAAMgG,aAAajD,aAAakD,eAAe3B,UAAU3D,IAAWuF,WAAW3B,GAAG;AAClFa,MAAAA,UAAgBe,SAASf,SAAQ,GAAG9E,UAAU,IAAI0D,QAAQI,GAAG,IAAI;QAC/DgC,mBAAmB;QACnBC,YAAYtG,QAAQuG;QACpBC,QAAQrG,yBAAyB8D,QAAQwC,SACvC;UACEpD,MAAM;UACNqD,SAASzC,QAAQyC;UACjBD,QAAQxC,QAAQwC;UAChBE,SAAS1C,QAAQ0C;UACjBjG,SAAiBkG,OAAK;YAExBvF;QACFwF,OAAO1G,yBAAyB8F,aAC9B,CAAC;UACC5C,MAAM;UACNyD,MAAMb;UACNK,YAAY,CAAA;SACb,IACDjF;OACH;IACH;AACA,QAAI,CAAC4D,WAAU7D,sBAAsB;AACnCiE,MAAAA,UAASjE,qBAAqB2F,YAAY,CAAC,EAAE1B,OAAM;IACrD;AACA,UAAMpE,WAAkBF,MAAK;MAC3BL,SAAiBsG,MAAM1C,MAAM5D,SAASsC,aAAakD,cAAc;MACjEe,WAAWjE,aAAakE,aAAY;MACpCC,cAAsBC,eAAeD;KACtC;AACD,UAAM9E,QAAgBrB,QAAQC,UAASoE,OAAM;AAC7CgC,IAASC,UAAUxG,UAAUuB,KAAK;AAClCN,WAAOG,OAAOkB,IAAIa,QAAQf,IAAIb,KAAK;AACnCA,UAAMkF,YAAa3D,UAAQ;AACzB,UAAI,CAACwB,aAAaxB,KAAKP,SAAS,WAAW;AACzCgE,QAASC,UACPxG,UACQE,QACNC,UACAjB,QAAQ2D,aAAa;UACnBN,MAAM;UACNX,UAAUX,OAAOmB;UACjBM,WAAWS,QAAQf;UACnBU,MAAWX,UAAkBY,KAAI;SAClC,CAAC,CACH;MAEL;AACA9B,aAAOG,OAAOS,OAAOsB,QAAQf,EAAE;AAC/BnB,aAAOoB,QAAQR,OAAOsB,QAAQf,EAAE;AAChC,UAAInB,OAAOE,SAASF,OAAOG,OAAOC,SAAS,GAAG;AAC5CkF,QAASC,UACPxG,UACQE,QAAQC,UAASmB,UAAUL,MAAM,CAAC,CAAC;MAE/C;IACF,CAAC;AACD,WAAcQ;EAChB;AAEA,QAAMkD,eAAeA,CACnB1D,QACAkC,SACAuD,YACE;AACF,QAAIjE,QAAQxB,OAAOoB,QAAQvC,IAAIqD,QAAQf,EAAE;AACzC,QAAI7C,eAAe,CAACkD,OAAO;AACzBA,cAAe5B,gBAAgB,KAAK;AACpCI,aAAOoB,QAAQC,IAAIa,QAAQf,IAAIK,KAAK;IACtC;AACA,QAAWkE,SAASD,OAAM,GAAG;AAC3B,UAAIE,OAAO;AACX,aAAOF,QAAOtG,KACLyG,QAASC,aACPC,UAAU;QACfC,OAAOA,MAAM,CAACJ;QACdK,MAAMC,SAAgBL,QAAQC,QAAQK,SAAS,CAAC,CAACC,OAAOC,KAAK,MAAK;AAChET,iBAAOS;AACP,cAAI,CAAOC,WAAWF,KAAK,EAAG,QAAc3F;AAC5C,gBAAMK,SAAQ5C,QAAQ2D,aAAa;YACjCN,MAAM;YACNX,UAAUX,OAAOmB;YACjBM,WAAWS,QAAQf;YACnBlB,QAAcqG,gBAAgBH,KAAK;WACpC;AACD,cAAI,CAAC3E,MAAO,QAAOX;AACnBW,gBAAM+E,YAAW;AACjB,iBAActE,SAASpB,QAAOW,MAAMf,KAAK;QAC3C,CAAC,CAAC;QACF+F,MAAMC;OACP,CAAC,GAEGC,MAAM;IAEjB;AACA,WAAcC,gBAAgBlB,SAASU,WAAS;AAC9C,UAAI,CAAOE,WAAWF,KAAK,EAAG,QAAc3F;AAC5C,YAAMK,SAAQ5C,QAAQ2D,aAAa;QACjCN,MAAM;QACNX,UAAUX,OAAOmB;QACjBM,WAAWS,QAAQf;QACnBlB,QAAcqG,gBAAgBH,KAAK;OACpC;AACD,UAAI,CAAC3E,MAAO,QAAOX;AACnBW,YAAM+E,YAAW;AACjB,aAActE,SAASpB,QAAOW,MAAMf,KAAK;IAC3C,CAAC;EACH;AAEA,QAAMsB,aAAaA,CAAC/B,QAAgBgC,WAC3B4E,QAAQ,MAAK;AAClB,UAAMC,YAAY7G,OAAOE,SAASF,OAAOG,OAAOC,SAAS;AACzD,UAAMS,SAAQ5C,QAAQ2D,aAAa;MACjCN,MAAM;MACNX,UAAUX,OAAOmB;MACjBa;KACD;AACD,QAAI,CAAC6E,UAAW,QAAOhG;AACvB,WAAcoB,SAASpB,QAAOR,UAAUL,MAAM,CAAC;EACjD,CAAC;AAEH,SAAO8G,SAA0B;IAC/BjG;IACAH;GACD;AACH,CAAC;AAED,IAAM+C,kBAAkBA,CACtBrB,KACAzD,UACAgC,UACAqC,SACAC,SACAF,YACE;AACF,MAAIX,IAAI2E,YAAY3G,SAAS,GAAG;AAC9B,WAAO2C;EACT;AAEA,QAAM9E,UAAU;IACdmE;IACAY;IACAC;IACAtC;;AAGF,aAAW2B,OAAOF,IAAI2E,aAAa;AACjC,QAAIzE,IAAI0E,MAAM;AACZ,YAAMC,aAAqBC,UAAUvI,UAAS2D,GAAG;AACjDS,gBAAUkE,WAAW;QAAE,GAAGhJ;QAASkJ,MAAMpE;MAAc,CAAE;IAC3D,WAAWT,IAAI8E,UAAU;AACvB,YAAMH,aAAqBC,UAAUvI,UAAS2D,GAAG;AACjD,YAAM+E,WAAWtE;AACjBA,gBAAiBuE,YAAYL,WAAWhJ,OAAO,GAAG;QAChD4F,WAAWA,MAAMwD;QACjB1D,WAAWrB,IAAIiF,aAAajI,SACvB8D,WAAiBoE,eAAeH,UAAU/E,IAAIiF,UAAiBnE,KAAK,IACpEqE,OAAMJ;OACZ;IACH,OAAO;AACL,YAAMJ,aAAqBC,UAAUvI,UAAS2D,GAAG;AACjDS,gBAAUT,IAAIiF,aAAajI,SAChBoI,qBAAqB3E,SAAST,IAAIiF,UAAiBN,WAAWhJ,OAAO,CAAC,IACtEgE,SAASgF,WAAWhJ,OAAO,GAAG8E,OAAO;IAClD;EACF;AAEA,SAAOA;AACT;AAMO,IAAM/D,SAeFjB,WAAW,WACpBC,OACAC,SAMC;AAED,QAAM;IAAE0J;IAAaC;IAAKC,KAAAA;IAAKC;IAAMxJ;IAAayJ;IAAyBC;EAAqB,IAAK,OAAOC;AAC5G,QAAMtJ,WAAU,OAAcA,QAAO;AACrC,QAAMC,SAAQ,OAAaI,MAAI;AAE/B,QAAMkJ,SAAS,OAAOpK,qBAAoBE,OAAO;IAC/C,GAAGC;IACHM,mBAAmB,CAACD;IACpBD,wBAAwB,CAAC0J;IACzBnG,aAAauG,UAAQ;AACnB,YAAMnI,SAASR,QAAQX,IAAIsJ,SAASxH,QAAQ;AAC5C,UAAI,CAACX,OAAQ,QAAcQ;AAC3B,cAAQ2H,SAAS7G,MAAI;QACnB,KAAK,SAAS;AACZ,gBAAM8G,UAAUpI,OAAOoI,QAAQvJ,IAAIsJ,SAAS1G,SAAS;AACrD,cAAI,CAAC2G,QAAS,QAAc5H;AAC5B,iBAAO6H,aACLrI,QACAmI,SAAS1G,WACT2G,QAAQE,WACDC,QAAQH,QAAQI,YAAYL,SAASlI,MAAM,GAAGmI,QAAQzJ,OAAO,GACnEsB,aAAY;YAAEqB,MAAM;YAASG,WAAWgH,OAAON,SAAS1G,SAAS;YAAGxB;UAAM,EAAG;QAElF;QACA,KAAK,QAAQ;AACX,gBAAMmI,UAAUpI,OAAOoI,QAAQvJ,IAAIsJ,SAAS1G,SAAS;AACrD,cAAI,CAAC2G,QAAS,QAAc5H;AAC5BR,iBAAOoI,QAAQxH,OAAOuH,SAAS1G,SAAS;AACxC,iBAAO4G,aACLrI,QACAmI,SAAS1G,WACT2G,QAAQE,WACDC,QAAQH,QAAQM,WAAWP,SAAStG,IAAI,GAAGuG,QAAQzJ,OAAO,GAChEkD,WAAU;YAAEP,MAAM;YAAQG,WAAWgH,OAAON,SAAS1G,SAAS;YAAGI;UAAI,EAAG;QAE7E;QACA,KAAK,UAAU;AACb,iBAAOE,WAAW/B,QAAQmI,SAASnG,MAAM;QAC3C;QACA,KAAK,aAAa;AAChBxC,kBAAQoB,OAAOuH,SAASxH,QAAQ;AAChC,iBAAOiH,IAAIO,SAASxH,QAAQ;QAC9B;MACF;IACF;GACD,EAAExB,KAAWwJ,OAAO/J,MAAK,CAAC;AAG3B,SAAcgK,KAAYxJ,cAAqB0G,UAAU;IACvDC,OAAO8C;IACP7C,MAAMC,SAAgBL,QAAQ+B,YAAYmB,MAAOnI,cAAY;AAC3DnB,cAAQoB,OAAOD,QAAQ;AACvB,aAAOuH,OAAOxH,WAAWC,QAAQ;IACnC,CAAC,CAAC;IACF6F,MAAMC;GACP,CAAC,CAAC;AAUH,QAAMsC,eAAe,oBAAIC,QAAO;AAChC,QAAMC,aAAc7G,SAAyB;AAC3C,QAAIgG,UAAUW,aAAalK,IAAIuD,GAAG;AAClC,QAAI,CAACgG,SAAS;AACZ,YAAM7F,QAAQ5D,SAAQ6D,UAAU3D,IAAIuD,IAAIK,GAAG;AAC3C,YAAMyG,gBAA0BC,iBAAiB/G,IAAIS,cAAcuG,GAAG;AACtEhB,gBAAU;QACRiB,QAAeC,eAAclH,IAAImH,aAAoB;QACrDf,aAAoBgB,eACXC,OAAaC,OAAOR,aAAa,IAAIA,cAAc9F,MAAMuG,UAAiBC,GAAG,CAAC;QAEvFlB,YAAmBc,eAAkBK,WAAWzH,GAAU,CAAC;QAC3DzD,SAAS4D,MAAM5D;;AAEjBoK,mBAAa1H,IAAIe,KAAKgG,OAAO;IAC/B;AACA,WAAOA;EACT;AAMA,QAAM5I,UAAU,oBAAIC,IAAG;AAEvB,QAAM4I,eAAeA,CACnBrI,QACAyB,WACA6G,WACAhF,SACAK,eAEC2E,YAAmBd,eAAelE,SAAqBwG,WAAWxB,SAAS,IAAIhF,SAAQnE,KAC/EyG,QAASmE,OAAMjC,KAAK9H,OAAOmB,IAAIwC,UAAUoG,CAAC,GAAGzB,aAAaA,UAAU0B,YAAW,CAAE,CAAC,GAClFC,cAAenG,WAAS;AAC7B9D,WAAOoI,QAAQxH,OAAOa,SAAS;AAC/B,UAAMO,SAAegC,OAAakG,IAAIpG,OAAOqG,cAAcC,eAAe,CAAC;AAC3E,WAAcnI,SACZoI,kBAAkBrK,QAAQyB,WAAWO,MAAM,GAC3CkG,OAAOrH,MAAMb,OAAOmB,IAAI;MAAEG,MAAM;MAAaG;MAAW6I,cAAc,CAAA;IAAE,CAAE,CAAC;EAE/E,CAAC,CAAC;AAGN,QAAMD,oBAAoBA,CAACrK,QAAgByB,WAAsBO,WACxDiI,cACLnC,KAAK9H,OAAOmB,IAAI;IACdG,MAAM;IACNG,WAAWgH,OAAOhH,SAAS;IAC3BI,MAAM;MACJP,MAAM;MACNwC,OAAO;QACLxC,MAAM;QACNU;;;GAGL,GACA8B,WAAU/B,WAAW/B,QAAcgE,OAAOF,KAAK,CAAC,CAAC;AAGtD,QAAM/B,aAAaA,CAAC/B,QAAgBgC,WAC3BiI,cACLnC,KAAK9H,OAAOmB,IAAI;IAAEG,MAAM;IAAUU;EAAM,CAAE,GACzC8B,WACQyG,aAAoBC,SAAS1G,KAAK,GAAG;IAC1C2G,QAAQ;IACRC,QAAQ;GACT,CAAC;AAIR,SAAO,OAAO7C,KAAI,CAAClH,UAAUuB,YAAW;AACtC,QAAIlC,SAASR,QAAQX,IAAI8B,QAAQ;AACjC,QAAI,CAACX,QAAQ;AACXA,eAAS;QACPmB,IAAIR;QACJyH,SAAS,oBAAI3I,IAAG;;AAElBD,cAAQ6B,IAAIV,UAAUX,MAAM;IAC9B;AAEA,YAAQkC,QAAQZ,MAAI;MAClB,KAAK,WAAW;AACd,cAAMgB,MAAgBqI,YAAYzI,SAAS,KAAK,IAAIA,QAAQI,MAAgB;AAC5E,cAAMF,MAAMpE,MAAMqE,SAASxD,IAAIyD,GAAG;AAClC,YAAI,CAACF,KAAK;AACR,iBAAOL,WAAW/B,QAAQ,wBAAwBsC,GAAG,EAAE;QACzD;AACA,YAAIb;AACJ,gBAAQ,OAAOS,QAAQf,IAAE;UACvB,KAAK;UACL,KAAK,UAAU;AACbM,wBAAYmJ,UAAU1I,QAAQf,EAAE;AAChC;UACF;UACA,SAAS;AACP,mBAAOY,WAAW/B,QAAQ,uBAAuBkC,QAAQf,EAAE,EAAE;UAC/D;QACF;AACA,cAAMiH,UAAUa,WAAW7G,GAAU;AACrC,eAAckF,YACLiB,QAAQH,QAAQiB,OAAOnH,QAAQc,OAAO,GAAGoF,QAAQzJ,OAAO,GAC/D;UACEkF,WAAYgH,WAAUR,kBAAkBrK,QAAQyB,WAAW0I,cAAcC,gBAAgBS,KAAK,CAAC;UAC/FlH,WAAYX,aAAW;AACrBhD,mBAAOoI,QAAQ/G,IACbI,WACAuG,wBACE;cACE,GAAGI;cACHE,WAAwBwC,oBAAmB;gBAE7C1C,OAAO;AAEX,mBAAOF,OAAOrH,MAAMF,UAAU;cAC5B,GAAGuB;cACHf,IAAIM;cACJuB;cACAC,SAAiB8H,UAAU7I,QAAQe,OAAO;aACpC;UACV;SACD;MAEL;MACA,KAAK,QAAQ;AACX,eAAcgH,cACZnC,KAAK9H,OAAOmB,IAAI6J,SAAS,GACxBlH,WAAU/B,WAAW/B,QAAcgE,OAAOF,KAAK,CAAC,CAAC;MAEtD;MACA,KAAK,OAAO;AACV,eAAOoE,OAAOrH,MAAMF,UAAUuB,OAAO;MACvC;MACA,KAAK,OAAO;AACV,eAAOgG,OAAOrH,MAAMF,UAAU;UAC5B,GAAGuB;UACHT,WAAWmJ,UAAU1I,QAAQT,SAAS;SACvC;MACH;MACA,KAAK,aAAa;AAChB,eAAOyG,OAAOrH,MAAMF,UAAU;UAC5B,GAAGuB;UACHT,WAAWmJ,UAAU1I,QAAQT,SAAS;UACtC6I,cAAc,CAAA;SACf;MACH;MACA,SAAS;AACP,eAAOvI,WAAW/B,QAAQ,wBAAyBkC,QAAgBZ,IAAI,EAAE;MAC3E;IACF;EACF,CAAC,EAAEnC,KACMC,eACA6L,cAAenH,WAAiBoH,SAAS,mCAAmCpH,KAAK,CAAC,GAClFqH,OAAQtJ,UAAeuJ,MAAMxM,QAAOiD,IAAI,CAAC,CAAC;AAErD,CAAC;AAMM,IAAMwJ,QAAQA,CACnBrN,OACAC,YAYSqN,cAAqBC,WAAkBnM,cAAcJ,OAAKhB,OAAOC,OAAO,CAAC,CAAC,CAAC;AAW/E,IAAMuN,kBAAyCvN,aAgBpDoN,MAAMpN,QAAQD,OAAOC,OAAO,EAAEkB,KACtBoJ,SACJtK,QAAQwN,aAAa,SACjBC,wBAAwBzN,OAAO,IAC/B0N,6BAA6B1N,OAAO,CAAC,CAC1C;AAOC,IAAOgK,YAAP,cAAgC2D,IAAI,gCAAgC,EAAC,EAgBvE;;;;EAIF,OAAO5M,OAAO6M,QAAO;;AAOhB,IAAMC,2BAAkCC,IAAI,aAAS;AAC1D,QAAM7D,SAAS,OAAoB8D;AACnC,QAAM;IAAEC;IAAUR;EAAQ,IAAK,OAAOS;AACtC,SAAcX,WAAkBnM,cAC9B8I,OAAOL,IAAW9J,WAAWkO,UAAiBvF,MAAM,CAAC,CAAC,CACvD;AACD,SAAO+E;AACT,CAAC;AAQM,IAAMU,4BAIHzF,QAAOuB,WAAU6D,wBAAwB;AAM5C,IAAMM,mCAOFL,IAAI,aAAS;AACtB,QAAM;IAAEE;IAAUR;EAAQ,IAAK,OAAOS;AAEtC,QAAMG,UAAsDN,IAAI,aAAS;AACvE,UAAM7J,UAAU,OAAyBoK;AACzC,UAAMC,SAAS,OAAcC,MAAMtK,QAAQuK,OAAO;AAClD,WAAOR,SAASM,MAAM;AACtB,WAA0B1H,OAAK;EACjC,CAAC;AAED,SAAO;IAAE4G;IAAUY;EAAO;AAC5B,CAAC;AAMM,IAAMK,wBASF3O,WAAW,WAAkCE,SAGvD;AACC,QAAM;IAAEoO;IAASZ;EAAQ,IAAK,OAAOW;AACrC,QAAMO,SACJ,OAAQ1O,QAAQ2O,aAAwBC;AAC1C,SAAOF,OAAO9N,IAAIZ,QAAQ6O,MAAMT,OAAO;AACvC,SAAOZ;AACT,CAAC;AAMM,IAAMsB,8BAQFhP,WAAW,WAAUE,SAE/B;AACC,QAAM0O,SAAS,OAAuBK;AACtC,QAAM;IAAEX;IAASZ;EAAQ,IAAK,OAAOW;AACrC,SAAOO,OAAOM,IAAI,OAAOhP,QAAQ6O,MAAMT,OAAO;AAC9C,SAAOZ;AACT,CAAC;AAQM,IAAMyB,yBAAkDjP,aAGO;AACpE,QAAM2O,YAAY3O,QAAQ2O,aACbC;AACb,SAAavJ,OAAO2E,WAAUyE,sBAAsBzO,OAAO,CAAC,EAAEkB,KACtDoJ,SAAQqE,UAAUO,IAAI,CAAC;AAEjC;AAUO,IAAMxB,+BAAgC1N,aAGrCqF,OAAO2E,WAAU8E,4BAA4B9O,OAAO,CAAC;AAMtD,IAAMmP,0BAOFrB,IAAI,aAAS;AACtB,QAAMsB,gBAAgB,OAAwBC;AAC9C,QAAMC,kBAAkBF,cAAcE;AAEtC,QAAM5F,cAAc,OAAe3I,MAAI;AACvC,MAAIwO;AAEJ,MAAI7M,WAAW;AAEf,QAAMnB,UAAU,oBAAIC,IAAG;AAKvB,QAAM4M,UAAsDN,IAAI,aAAS;AACvE,UAAM7J,UAAU,OAAyBoK;AACzC,UAAMmB,OAAO,OAAcjB,MAAMtK,QAAQwL,WAAW;AACpD,UAAMvM,KAAKR;AACX,UAAMkF,UAAU,OAAe7G,MAAI;AACnC,UAAM2O,SAASN,cAAcO,WAAU;AACvC,UAAMC,UAAU,IAAIC,YAAW;AAE/B,UAAMC,QAASN,CAAAA,UACb,OAAOA,UAAS,WAAW5H,QAAQkI,MAAMF,QAAQG,OAAOP,KAAI,CAAC,IAAI5H,QAAQkI,MAAMN,KAAI;AAErFjO,YAAQ6B,IAAIF,IAAI;MACdN,OAAQsH,cAAY;AAClB,YAAI;AACF,cAAI,CAACoF,gBAAiB,QAAO1H,QAAQkI,MAAM5F,QAAQ;AACnD,gBAAM8F,UAAUN,OAAOK,OAAO7F,QAAQ;AACtC,cAAI8F,YAAY3O,OAAW,QAAckB;AACzC,iBAAOuN,MAAME,OAAO;QACtB,SAASnK,OAAO;AACd,iBAAO,CAACyJ,kBACJ1H,QAAQkI,MAAMG,sBAAsBpK,KAAK,CAAC,IAC1CiK,MAAMJ,OAAOK,OAAOE,sBAAsBpK,KAAK,CAAC,CAAE;QACxD;MACF;MACA8D,KAAK/B,QAAQ+B;KACd;AAED,UAAMuG,aAA+B,CAAA;AAErC,QAAI;AACF,YAAMC,UAAUT,OAAOtE,OAAO,IAAIgF,WAAWZ,IAAI,CAAC;AAClD,iBAAW3M,WAAWsN,SAAS;AAC7B,YAAItN,QAAQQ,SAAS,WAAW;AAC9B6M,qBAAWG,KAAK1D,UAAU9J,QAAQK,EAAE,CAAC;QACvC;AACA,eAAOqM,aAAarM,IAAIL,OAAO;MACjC;IACF,SAASgD,OAAO;AACd,aAAOiK,MAAMJ,OAAOK,OAAOE,sBAAsBpK,KAAK,CAAC,CAAE;IAC3D;AAEA,WAAO0J,aAAarM,IAAIoN,QAAQ;AAEhC,QAAI,CAAChB,iBAAiB;AACpB,UAAI5H,OAAO;AACX,aAAc9F,cAAa,MAAK;AAC9BL,gBAAQoB,OAAOO,EAAE;AACjBwG,oBAAY6G,YAAYrN,EAAE;AAC1B,YAAIwE,KAAM,QAAcnF;AACxB,eAAciO,QACZN,YACC1M,eAAc+L,aAAarM,IAAI;UAAEG,MAAM;UAAaG,WAAWgH,OAAOhH,SAAS;QAAC,CAAE,GACnF;UAAEiN,SAAS;QAAI,CAAE;MAErB,CAAC;AACD,YAAMC,YAAgB9J,MAAK;AAC3B,aAAO,MAAM;AACX,cAAM,CAAC+J,OAAOjJ,KAAI,IAAI,OAAOE,QAAQK;AAErCyI,kBAAUL,KAAK,GAAGM,KAAY;AAC9B,YAAIjJ,MAAM;MACZ;AACAA,aAAO;AACP,aAA0BkJ,MAAKlB,OAAOK,OAAOW,SAAS,GAAa;QAAEG,aAAazB,cAAcyB;MAAW,CAAE;IAC/G;AAEA,WAA0BrJ,OACjBsJ,aAAqBC,SAASnJ,OAA8C,GAAIhE,UAAQ;AAC7FrC,cAAQoB,OAAOO,EAAE;AACjBwG,kBAAY6G,YAAYrN,EAAE;AAC1B,UAAI,CAAM8N,cAAcpN,IAAI,EAAG,QAAcrB;AAC7C,aAAciO,QACZN,YACC1M,eAAc+L,aAAarM,IAAI;QAAEG,MAAM;QAAaG,WAAWgH,OAAOhH,SAAS;MAAC,CAAE,GACnF;QAAEiN,SAAS;MAAI,CAAE;IAErB,CAAC,GACD;MAAEI,aAAazB,cAAcyB;IAAW,CAAE;EAE9C,CAAC,EAAE3P,KAAYC,aAAa;AAE5B,QAAMqM,WAAW,OAAOxD,UAASjJ,KAAMkQ,mBAAiB;AACtD1B,mBAAe0B;AACf,WAActL,SAAQ;MACpB+D;MACAG,KAAKnH,WAAUwH,UAAQ;AACrB,cAAMnI,SAASR,QAAQX,IAAI8B,SAAQ;AACnC,YAAI,CAACX,OAAQ,QAAcQ;AAC3B,eAAOR,OAAOa,MAAMsH,QAAQ;MAC9B;MACAP,IAAIjH,WAAQ;AACV,cAAMX,SAASR,QAAQX,IAAI8B,SAAQ;AACnC,YAAI,CAACX,OAAQ,QAAcQ;AAC3B,eAAOR,OAAO4H;MAChB;MACAuH,WAAkBC,KAAK,MAAM5P,QAAQ6P,KAAI,CAAE;MAC3CC,gBAAuBC;MACvBjR,aAAa;MACb0J,uBAAuB;MACvBD,yBAAyB;KAC1B;EACH,CAAC;AAED,SAAO;IAAE0D;IAAUY;EAAO;AAC5B,CAAC;AAMM,IAAMmD,oBAA0BzR,WAAW,WAAkCE,SAGnF;AACC,QAAM;IAAEoO;IAASZ;EAAQ,IAAK,OAAO2B;AACrC,QAAMT,SACJ,OAAQ1O,QAAQ2O,aAAwBC;AAC1C,SAAOF,OAAO8C,KAAKxR,QAAQ6O,MAAMT,OAAO;AACxC,SAAOZ;AACT,CAAC;AAMM,IAAMiE,yBAAgC3R,WAAW,WAAUE,SAEjE;AACC,QAAM0O,SAAS,OAAuBK;AACtC,QAAM;IAAEX;IAASZ;EAAQ,IAAK,OAAO2B;AACrC,SAAOT,OAAOM,IAAI,QAAQhP,QAAQ6O,MAAMT,OAAO;AAC/C,SAAOZ;AACT,CAAC;AAMM,IAAMkE,2BAIT1H,UAASjJ,KAAYjB,WAAW,WAAUyP,cAAY;AACxD,QAAMlN,QAAQ,OAAcU,iBAAkD4C,QAAc;AAC5F,QAAMgM,SAAS,OAAoBC;AACnC,QAAMC,aAAa,OAAoBC;AACvC,QAAMC,UAAU,OAAOJ,OAAOK,MAAqEH,UAAU;AAC7G,QAAMR,kBAAiB,OAAgBtQ,MAAI;AAC3C,QAAMmQ,YAAY,oBAAIe,IAAG;AACzB,QAAMvI,cAAc,OAAe3I,MAAI;AAEvC,SAAgByB,OAAMqP,UAAU,EAAE3Q,KACzBgM,OAAO,MAAK;AACjB7K,UAAM6P,iBAAiBC,aAAa,MAAM9P,MAAMC,sBAAsBD,MAAMa,GAAE,CAAE,GAAG,CAAC;AACpF,WAAcX;EAChB,CAAC,GACM+K,UAAU;AAGnB,SAAOyE,QAAQnI,IAAI,CAAClH,UAAUG,YAAW;AACvCqO,cAAUlC,IAAItM,QAAQ;AACtB,QAAIG,QAAQQ,SAAS,kBAAkB;AACrC,aAAgBsC,QAAQ0L,iBAAgBxO,QAAQsC,KAAK;IACvD;AACA,WAAOoK,aAAa7M,UAAUG,OAAO;EACvC,CAAC;AAED,SAAO6G,YAAYmB,KAAK3J,KACfkR,IAAK1P,cAAY;AACtBwO,cAAUvO,OAAOD,QAAQ;AACzB,WAAOgH,YAAYoG,MAAMpN,QAAQ;EACnC,CAAC,GACM4K,UAAU;AAGnB,SAAO;IACL5D;IACAG,MAAMkI,QAAQlI;IACdF,IAAI0I,WAAS;AACX,aAAc9P;IAChB;IACA2O,WAAkBC,KAAK,MAAMD,UAAUlP,OAAM,CAAE;IAC/CqP,gBAAuBiB,OAAgB9P,OAAM6O,eAAc,CAAC;IAC5DhR,aAAa;IACb0J,uBAAuB;IACvBD,yBAAyB;;AAE7B,CAAC,CAAC;AAMK,IAAMyI,4BAIH9J,QAAOuB,WAAU0H,wBAAwB;AAQ5C,IAAMc,qBAA6CxS,aAGY;AACpE,QAAM2O,YAAY3O,QAAQ2O,aACbC;AACb,SAAavJ,OAAO2E,WAAUuH,kBAAiBvR,OAAO,CAAC,EAAEkB,KACjDoJ,SAAQqE,UAAUO,IAAI,CAAC;AAEjC;AAUO,IAAMzB,0BAA2BzN,aAGhCqF,OAAO2E,WAAUyH,uBAAuBzR,OAAO,CAAC;AAMjD,IAAMyS,YAcF3S,WAAW,WACpBC,OACAC,SAIC;AAED,QAAM;IAAEoO;IAASZ;EAAQ,IAAK,OAAO2B;AACrC,SAAOpO,OAAKhB,OAAOC,OAAO,EAAEkB,KACnBqI,eAAeS,WAAUwD,QAAQ,GACjCrM,eACAmM,UAAU;AAEnB,SAAOc;AACT,CAAC;AAMM,IAAMsE,qBAcF5S,WAAW,WACpBC,OACAC,SAIC;AAED,QAAM;IAAEoO;IAASZ;EAAQ,IAAK,OAAOW;AACrC,SAAOpN,OAAKhB,OAAOC,OAAO,EAAEkB,KACnBqI,eAAeS,WAAUwD,QAAQ,GACjCrM,eACAmM,UAAU;AAEnB,SAAOc;AACT,CAAC;AAQM,IAAMuE,eAAeA,CAC1B5S,OACAC,YAsBE;AACF,QAAMiB,WAAyBF,MAAW6R,SAAS5S,QAAQoN,OAAazM,MAAK,GAAGX,SAAS6S,OAAO;AAChG,MAAIC;AAGJ,QAAMC,iBAAwBjF,IAAI,aAAS;AACzC,UAAMkF,MAAM,OAAOP,UAAU1S,OAAOC,OAAO;AAC3C,UAAMiT,KAAK,OAAOhS,SAAQiS;AAC1B,UAAMpO,WAAkBqO,oBAAoBF,EAAE,EAAEjT,SAASgJ,aAAahJ,QAAQgJ,WAAWgK,GAAU,IAAWA,GAAG;AACjHF,oBAAgBhO;AAChB,WAAOA;EACT,CAAC,EAAE5D,KAAKD,SAAQmS,UAAU;AAC1B,WAAStO,QAAQb,SAA6BvD,UAA4C;AACxF,QAAIoS,kBAAkBzR,QAAW;AAC/B,aAAOyR,cAAc7O,SAASvD,QAAO;IACvC;AACA,WAAOqS,eAAeM,KAAMvO,CAAAA,aAAYA,SAAQb,SAASvD,QAAO,CAAC;EACnE;AACA,SAAO;IAAEoE;IAASwO,SAASrS,SAAQqS;EAAO;AAC5C;AAQO,IAAMC,oBAA2BzT,WAAW,WAAgCE,SAGlF;AACC,QAAMoP,gBAAgB,OAAwBC;AAE9C,SAAO,OAAOrF,UAASjJ,KAAYjB,WAAW,WAAUyP,cAAY;AAClE,UAAM3H,UAAU,OAAe7G,MAAI;AACnC,UAAM2O,SAASN,cAAcO,WAAU;AAEvC,WAAO3P,QAAQwT,MAAMtS,KACZuS,WAAYjE,UAAQ;AACzB,YAAMW,UAAUT,OAAOtE,OAAOoE,IAAI;AAClC,UAAIW,QAAQuD,WAAW,EAAG,QAAcnR;AACxC,UAAIoR,IAAI;AACR,aAAc9L,UAAU;QACtBC,OAAOA,MAAM6L,IAAIxD,QAAQuD;QACzB3L,MAAMA,MAAMwH,aAAa,GAAGY,QAAQwD,GAAG,CAAC;QACxCpL,MAAMC;OACP;IACH,CAAC,GACMoL,MAAeC,OAAO,GAAG,CAAC,GAC1BvG,YACAnM,aAAa;AAGtB,WAAe4P,SAASnJ,OAAO,EAAE1G,KACxB0I,IAAI5J,QAAQ8T,MAAM,GAClBF,MAAeC,OAAO,GAAG,CAAC,GAC1BvG,YACAnM,aAAa;AAGtB,WAAO;MACLuI,aAAa,OAAe3I,MAAI;MAChC8I,KAAKwI,WAAWnI,UAAQ;AACtB,cAAM6J,kBAAkBrE,OAAOK,OAAO7F,QAAQ;AAC9C,YAAI6J,oBAAoB1S,QAAW;AACjC,iBAAckB;QAChB;AACA,eAAOqF,QAAQkI,MAAMiE,eAAe;MACtC;MACApK,IAAI0I,WAAS;AACX,eAAOzK,QAAQ+B;MACjB;MACAuH,WAAkBvL,SAAQ,CAAC,CAAC,CAAC;MAC7B0L,gBAAuBC;MACvBjR,aAAa;MACb0J,uBAAuB;MACvBD,yBAAyB;;EAE7B,CAAC,CAAC;AACJ,CAAC;AAQM,IAAMkK,qBAA4ChU,aAIjDyI,QAAOuB,WAAUuJ,kBAAkBvT,OAAO,CAAC;AAInD,IAAMiO,qBAA4BH,IAAI,aAAS;AAC7C,QAAMsB,gBAAgB,OAAwBC;AAC9C,QAAM3F,cAAc,OAAe3I,MAAI;AAEvC,MAAI2B,WAAW;AACf,QAAMnB,UAAU,oBAAIC,IAAG;AAIvB,MAAI+N;AAEJ,QAAMvB,WAAW,WAAUM,QAAqB;AAC9C,UAAM3N,SAAQ,OAAcA;AAC5B,UAAM+O,SAASN,cAAcO,WAAU;AACvC,UAAMzM,KAAKR;AACX,WAAauR,iBAAiBtT,QAAO,MAAK;AACxCY,cAAQoB,OAAOO,EAAE;AACjB,aAAOwG,YAAYoG,MAAM5M,EAAE;IAC7B,CAAC;AAED,UAAMgR,WAAW,OAAO5F,OAAO6F;AAC/B,UAAMvR,QAASsH,cAA+B;AAC5C,UAAI;AACF,cAAM8F,UAAUN,OAAOK,OAAO7F,QAAQ;AACtC,YAAI8F,YAAY3O,QAAW;AACzB,iBAAckB;QAChB;AACA,eAAcgM,MAAM2F,SAASlE,OAAO,CAAC;MACvC,SAASnK,OAAO;AACd,eAAc0I,MACZ2F,SAASxE,OAAOK,OAAOE,sBAAsBpK,KAAK,CAAC,CAAE,CAAC;MAE1D;IACF;AACAtE,YAAQ6B,IAAIF,IAAI;MAAEN;IAAK,CAAE;AAEzB,WAAO0L,OAAO8F,OAAQ5E,UAAQ;AAC5B,UAAI;AACF,cAAMW,UAAUT,OAAOtE,OAAOoE,IAAI;AAClC,YAAIW,QAAQuD,WAAW,EAAG,QAAcnR;AACxC,YAAIoR,IAAI;AACR,eAAc9L,UAAU;UACtBC,OAAOA,MAAM6L,IAAIxD,QAAQuD;UACzB3L,MAAMA,MAAMwH,aAAarM,IAAIiN,QAAQwD,GAAG,CAAC;UACzCpL,MAAMC;SACP;MACH,SAAS3C,OAAO;AACd,eAAOqO,SAASxE,OAAOK,OAAOE,sBAAsBpK,KAAK,CAAC,CAAE;MAC9D;IACF,CAAC,EAAE3E,KACMC,eACAkT,QAASzH,WAAUA,MAAM0H,WAAW,SAAS,MAAa/R,KAAI,GAC9DgM,KAAK;EAEhB;AAEA,QAAMf,WAAW,OAAOxD,UAASjJ,KAAMkQ,mBAAiB;AACtD1B,mBAAe0B;AACf,WAActL,SAAQ;MACpB+D;MACAG,MAAMA,CAACnH,WAAUwH,aAAY;AAC3B,cAAMnI,SAASR,QAAQX,IAAI8B,SAAQ;AACnC,YAAI,CAACX,OAAQ,QAAcQ;AAC3B,eAAcgM,MAAMxM,OAAOa,MAAMsH,QAAQ,CAAC;MAC5C;MACAP,IAAI0I,WAAS;AACX,eAAc9P;MAChB;MACA2O,WAAkBC,KAAK,MAAM5P,QAAQ6P,KAAI,CAAE;MAC3CC,gBAAuBC;MACvBjR,aAAa;MACb0J,uBAAuB;MACvBD,yBAAyB;KAC1B;EACH,CAAC;AAED,SAAO;IAAE0D;IAAUQ;EAAQ;AAC7B,CAAC;;;AC35CD;;;;AAcO,IAAMuG,aAMFC,WAAW,WACpBC,OAA8B;AAG9B,MAAIC;AACJ,QAAMC,SAAS,OAAiBC,qBAAoBH,OAAO;IACzDI,aAAaC,UAAQ;AACnB,aAAOJ,OAAOK,MAAMD,QAAQ;IAC9B;GACD;AACDJ,WAAS,OAAiBE,oBAAoBH,OAAO;IACnDO,aAAa;IACbC,aAAa;MAAEC;IAAO,GAAE;AACtB,aAAOP,OAAOI,MAAM,GAAGG,OAAO;IAChC;GACD;AACD,SAAOR,OAAOA;AAChB,CAAC;",
  "names": ["fork", "make", "StreamSchemaId", "Symbol", "for", "isStreamSchema", "schema", "ast", "annotations", "SchemaIdAnnotationId", "isStreamSerializable", "successSchema", "getStreamSchemas", "some", "none", "Stream", "failure", "success", "Object", "assign", "declare", "decode", "parseStream", "decodeUnknown", "ChunkFromSelf", "encode", "encodeUnknown", "schemaId", "isStream", "u", "hasProperty", "StreamTypeId", "decodeSuccess", "decodeFailure", "options", "flatMap", "context", "fail", "Type", "succeed", "pipe", "mapChunksEffect", "value", "catchAll", "error", "isParseError", "die", "matchEffect", "onFailure", "onSuccess", "provideContext", "TypeId", "Symbol", "for", "isRpc", "u", "hasProperty", "Proto", "pipe", "pipeArguments", "arguments", "setSuccess", "successSchema", "makeProto", "_tag", "payloadSchema", "errorSchema", "annotations", "middlewares", "setError", "setPayload", "isSchema", "Struct", "middleware", "Set", "prefix", "annotate", "tag", "value", "add", "annotateContext", "context", "merge", "options", "Rpc", "Object", "setPrototypeOf", "assign", "key", "make", "success", "Void", "error", "Never", "primaryKey", "Payload", "Class", "payload", "symbol", "stream", "Stream", "failure", "empty", "fromTaggedRequest", "schema", "exitSchemaCache", "globalValue", "WeakMap", "exitSchema", "self", "has", "get", "rpc", "failures", "streamSchemas", "getStreamSchemas", "ast", "isSome", "Exit", "Union", "defect", "Defect", "set", "ForkTypeId", "fork", "isFork", "make", "withRun", "f", "suspend", "semaphore", "unsafeMakeSemaphore", "buffer", "write", "args", "contextWith", "context", "push", "map", "a", "run", "withPermits", "gen", "prev", "provide", "onExit", "never", "void", "RequestIdTypeId", "Symbol", "for", "RequestId", "id", "BigInt", "constEof", "_tag", "constPing", "ResponseIdTypeId", "encodeDefect", "encodeSync", "Defect", "ResponseDefectEncoded", "input", "defect", "constPong", "RpcSerialization", "Tag", "json", "of", "contentType", "includesFraming", "unsafeMake", "decoder", "TextDecoder", "decode", "bytes", "JSON", "parse", "encode", "response", "stringify", "ndjson", "buffer", "position", "nlIndex", "indexOf", "items", "item", "slice", "push", "Array", "isArray", "length", "undefined", "data", "i", "jsonRpc", "options", "batches", "Map", "decoded", "decodeJsonRpcRaw", "map", "encodeJsonRpcMessage", "encoded", "encodeJsonRpcRaw", "ndJsonRpc", "parser", "frames", "messages", "frame", "batch", "size", "responses", "message", "decodeJsonRpcMessage", "_tag", "set", "id", "method", "startsWith", "tag", "requestId", "params", "String", "payload", "headers", "traceId", "spanId", "sampled", "error", "defect", "chunk", "values", "result", "exit", "cause", "value", "get", "delete", "from", "jsonrpc", "Number", "code", "hasProperty", "jsonRpcInternalError", "msgPack", "unpackr", "Msgpackr", "Unpackr", "packr", "Packr", "encoder", "TextEncoder", "unpackMultiple", "pack", "layerJson", "succeed", "layerNdjson", "layerJsonRpc", "layerNdJsonRpc", "layerMsgPack", "InitialMessage", "Tag", "ProtocolTag", "GenericTag", "makeInitialMessage", "schema", "effect", "flatMap", "value", "collector", "unsafeMakeCollector", "encode", "pipe", "provideService", "Collector", "map", "encoded", "unsafeClear", "layerInitialMessage", "build", "contextWith", "context", "provide", "orDie", "initialMessage", "protocol", "flatten", "decodeUnknown", "requestIdCounter", "BigInt", "makeNoSerialization", "fnUntraced", "group", "options", "spanPrefix", "supportsAck", "disableTracing", "generateRequestId", "context", "scope", "get", "Scope", "entries", "Map", "isShutdown", "addFinalizer", "fiberIdWith", "fiberId", "clearEntries", "interrupt", "exit", "id", "entry", "delete", "_tag", "mailbox", "done", "resume", "onRequest", "rpc", "isStream", "isStreamSchema", "successSchema", "middleware", "getRpcClientMiddleware", "payload", "opts", "headers", "fromInput", "empty", "span", "onEffectRequest", "payloadSchema", "make", "discard", "undefined", "useSpan", "captureStackTrace", "attributes", "spanAttributes", "onStreamRequest", "streamBufferSize", "asMailbox", "unwrapScoped", "map", "toStream", "withFiberRuntime", "parentFiber", "send", "tag", "traceId", "spanId", "sampled", "merge", "getFiberRef", "currentHeaders", "flatMap", "message", "onFromClient", "runtime", "currentContext", "fiberRefs", "getFiberRefs", "runtimeFlags", "defaultRuntime", "fiber", "onInterrupt", "async", "unsafePoll", "currentScheduler", "scheduleTask", "unsafeInterruptAsFork", "set", "pipe", "request", "withParentSpan", "identity", "runFork", "addObserver", "interruptors", "ids", "Array", "from", "toSet", "zipRight", "sendInterrupt", "makeSpanScoped", "getOrThrow", "getCurrentFiber", "unsafeGet", "addFinalizerExit", "has", "void", "isFailure", "cause", "catchAllCause", "error", "failCause", "interruptible", "forkIn", "middlewares", "values", "unsafeMap", "key", "push", "length", "succeed", "i", "whileLoop", "while", "body", "step", "nextRequest", "requestId", "timeout", "write", "offerAll", "asVoid", "die", "defect", "client", "flatten", "fns", "fn", "requests", "dot", "indexOf", "prefix", "slice", "target", "run", "supportsTransferables", "Protocol", "schemas", "getStreamSchemas", "ast", "collector", "unsafeMakeCollector", "add", "Collector", "decodeChunk", "isSome", "decodeUnknown", "NonEmptyArray", "value", "success", "encode", "locally", "orDie", "String", "Object", "unsafeClear", "RequestId", "chunk", "clientId", "onError", "decode", "exitSchema", "matchCauseEffect", "onSuccess", "onFailure", "decodeDefect", "logError", "forkScoped", "globalValue", "unsafeMake", "withHeaders", "dual", "effect", "locallyWith", "withHeadersEffect", "Tag", "withRun", "makeProtocolHttp", "writeResponse", "serialization", "RpcSerialization", "isJson", "contentType", "parser", "encoded", "text", "uint8Array", "post", "r", "json", "scoped", "u", "isArray", "dieMessage", "constVoid", "runForEachChunk", "stream", "responses", "toReadonlyArray", "layerProtocolHttp", "HttpClient", "mapRequest", "prependUrl", "url", "transformClient", "makeProtocolSocket", "socket", "Socket", "writer", "pinger", "makePinger", "constPing", "suspend", "reset", "runRaw", "response", "onPong", "raceFirst", "fail", "SocketGenericError", "reason", "Error", "SocketCloseError", "code", "tapErrorCause", "failureOption", "retryTransientErrors", "squash", "retry", "spaced", "annotateLogs", "module", "method", "writePing", "recievedPong", "latch", "unsafeMakeLatch", "unsafeClose", "open", "delay", "ignore", "forever", "await", "makeProtocolWorker", "worker", "PlatformWorker", "workerId", "initialMessage", "serviceOption", "InitialMessage", "acquire", "gen", "backing", "spawn", "readyLatch", "makeLatch", "unsafeOpen", "transfers", "pool", "makeWithTTL", "min", "minSize", "max", "maxSize", "concurrency", "targetUtilization", "timeToLive", "size", "sync", "clear", "transferables", "layerProtocolWorker", "layerProtocolSocket", "decodeSync", "Defect", "TypeId", "make", "TypeId", "Symbol", "for", "RpcGroupProto", "add", "rpcs", "makeProto", "requests", "resolveInput", "values", "annotations", "merge", "groups", "Map", "unsafeMap", "group", "tag", "rpc", "set", "key", "value", "unsafeMake", "middleware", "toHandlersContext", "build", "gen", "context", "handlers", "isEffect", "contextMap", "handler", "Object", "entries", "get", "prefix", "newRpc", "_tag", "toLayer", "scopedContext", "of", "identity", "toLayerHandler", "accessHandler", "contextWith", "parentContext", "payload", "headers", "result", "effectOrStream", "isFork", "provide", "provideContext", "annotate", "annotateRpcs", "annotateRpcsContext", "make", "annotateContext", "options", "assign", "isSchema", "fromTaggedRequest", "empty", "Tag", "TypeId", "TypeId", "Symbol", "for", "SuccessValue", "Tag", "id", "options", "Err", "globalThis", "Error", "limit", "stackTraceLimit", "creationError", "TagClass", "TagClass_", "Object", "setPrototypeOf", "getPrototypeOf", "GenericTag", "key", "defineProperty", "get", "stack", "failure", "optional", "undefined", "Never", "provides", "requiredForClient", "wrap", "layerClient", "tag", "service", "scopedContext", "gen", "context", "pipe", "omit", "Scope", "middleware", "isEffect", "unsafeMake", "Map", "mapInputContext", "requestContext", "merge", "Protocol", "layerProtocolHttp", "make", "makeNoSerialization", "makeProtocolHttp", "makeNoSerialization", "fnUntraced", "group", "options", "enableTracing", "disableTracing", "enableSpanPropagation", "disableSpanPropagation", "supportsAck", "disableClientAcks", "spanPrefix", "concurrency", "disableFatalDefects", "context", "scope", "get", "Scope", "fiberSet", "make", "runFork", "runtime", "pipe", "interruptible", "concurrencySemaphore", "undefined", "makeSemaphore", "clients", "Map", "isShutdown", "shutdownLatch", "unsafeMakeLatch", "addFinalizer", "fiberIdWith", "fiberId", "client", "values", "ended", "fibers", "size", "endClient", "fiber", "unsafeInterruptAsFork", "void", "await", "disconnect", "clientId", "delete", "write", "message", "catchAllDefect", "withFiberRuntime", "requestFiber", "interrupt", "id", "latches", "set", "_tag", "handleRequest", "latch", "requestId", "open", "interruptFork", "onFromServer", "exit", "none", "sendDefect", "defect", "zipRight", "request", "has", "rpc", "requests", "tag", "entry", "unsafeMap", "key", "die", "isStream", "isStreamSchema", "successSchema", "result", "handler", "payload", "headers", "isFork", "streamOrEffect", "value", "responded", "effect", "uninterruptible", "matchCauseEffect", "applyMiddleware", "streamEffect", "onSuccess", "succeed", "onFailure", "cause", "isDie", "squash", "failCause", "parentSpan", "currentContext", "ParentSpan", "withSpan", "captureStackTrace", "attributes", "spanAttributes", "parent", "spanId", "traceId", "sampled", "empty", "links", "span", "withPermits", "merge", "fiberRefs", "getFiberRefs", "runtimeFlags", "defaultRuntime", "FiberSet", "unsafeAdd", "addObserver", "stream", "isEffect", "done", "flatMap", "mailbox", "whileLoop", "while", "body", "constant", "takeAll", "chunk", "done_", "isNonEmpty", "toReadonlyArray", "unsafeClose", "step", "constVoid", "scoped", "runForEachChunk", "suspend", "shouldEnd", "identity", "middlewares", "wrap", "middleware", "unsafeGet", "next", "optional", "previous", "matchEffect", "provides", "provideService", "_", "provideServiceEffect", "disconnects", "end", "run", "send", "supportsSpanPropagation", "supportsTransferables", "Protocol", "server", "response", "schemas", "handleEncode", "collector", "provide", "encodeChunk", "String", "encodeExit", "extend", "fork", "constTrue", "take", "schemasCache", "WeakMap", "getSchemas", "streamSchemas", "getStreamSchemas", "ast", "decode", "decodeUnknown", "payloadSchema", "encodeUnknown", "Array", "isSome", "success", "Any", "exitSchema", "Collector", "a", "unsafeClear", "catchAllCause", "map", "TreeFormatter", "formatErrorSync", "sendRequestDefect", "interruptors", "annotateLogs", "logDebug", "module", "method", "hasProperty", "RequestId", "error", "unsafeMakeCollector", "fromInput", "constPong", "tapErrorCause", "logFatal", "onExit", "close", "layer", "scopedDiscard", "forkScoped", "layerHttpRouter", "protocol", "layerProtocolHttpRouter", "layerProtocolWebsocketRouter", "Tag", "withRun", "makeProtocolSocketServer", "gen", "SocketServer", "onSocket", "makeSocketProtocol", "layerProtocolSocketServer", "makeProtocolWithHttpAppWebsocket", "httpApp", "HttpServerRequest", "socket", "orDie", "upgrade", "makeProtocolWebsocket", "router", "routerTag", "Default", "path", "makeProtocolWebsocketRouter", "HttpRouter", "add", "layerProtocolWebsocket", "Live", "makeProtocolWithHttpApp", "serialization", "RpcSerialization", "includesFraming", "writeRequest", "data", "arrayBuffer", "parser", "unsafeMake", "encoder", "TextEncoder", "offer", "encode", "encoded", "ResponseDefectEncoded", "requestIds", "decoded", "Uint8Array", "push", "constEof", "unsafeOffer", "forEach", "discard", "responses", "items", "text", "contentType", "ensuringWith", "toStream", "isInterrupted", "writeRequest_", "clientIds", "sync", "keys", "initialMessage", "succeedNone", "makeProtocolHttp", "post", "makeProtocolHttpRouter", "makeProtocolWorkerRunner", "runner", "PlatformRunner", "closeLatch", "CloseLatch", "backing", "start", "Set", "currentScheduler", "scheduleTask", "tap", "_clientId", "asSome", "layerProtocolWorkerRunner", "layerProtocolHttp", "toHttpApp", "toHttpAppWebsocket", "toWebHandler", "mergeAll", "memoMap", "handlerCached", "handlerPromise", "app", "rt", "runtimeEffect", "toWebHandlerRuntime", "runPromise", "then", "dispose", "makeProtocolStdio", "stdin", "runForEach", "length", "i", "retry", "spaced", "stdout", "responseEncoded", "layerProtocolStdio", "addFinalizerExit", "writeRaw", "writer", "runRaw", "catchIf", "reason", "makeClient", "fnUntraced", "group", "client", "server", "makeNoSerialization", "onFromServer", "response", "write", "supportsAck", "onFromClient", "message"]
}
