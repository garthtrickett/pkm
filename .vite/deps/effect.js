import {
  ConfigProviderPathPatch_exports,
  ConfigProvider_exports,
  DefaultServices_exports,
  Logger_exports
} from "./chunk-SNTQKOXV.js";
import {
  PrimaryKey_exports
} from "./chunk-2YJSV6UP.js";
import {
  ArbitraryAnnotationId,
  Array_exports,
  BackPressure,
  BigDecimal_exports,
  BigInt_exports,
  Boolean_exports,
  BothRunning,
  Brand_exports,
  BufferSliding,
  CacheTypeId,
  Cause_exports,
  Channel_exports,
  ChildExecutorDecisionTypeId,
  Chunk_exports,
  Class2 as Class,
  ClockTypeId,
  Clock_exports,
  Close,
  CommitPrototype,
  ConfigError_exports,
  Config_exports,
  ConsumerCacheTypeId,
  Context_exports,
  Continue,
  CooperativeYielding,
  CounterKeyTypeTypeId,
  CounterStateTypeId,
  Cron_exports,
  CurrentMemoMap,
  Data_exports,
  DateFromSelfSchemaId,
  DateTime_exports,
  Deferred_exports,
  Differ_exports,
  Duration_exports,
  Effect_exports,
  Effectable_exports,
  Either_exports,
  EmptyMutableQueue,
  Encoding_exports,
  Equal_exports,
  Equivalence_exports,
  ExceededCapacityException,
  ExecutionStrategy_exports,
  Exit_exports,
  FastCheck_exports,
  FiberId_exports,
  FiberRef_exports,
  FiberRefsPatch_exports,
  FiberRefs_exports,
  FiberSet_exports,
  FiberStatus_exports,
  Fiber_exports,
  FrequencyKeyTypeTypeId,
  FrequencyStateTypeId,
  Function_exports,
  GaugeKeyTypeTypeId,
  GaugeStateTypeId,
  GenericTag,
  GlobalValue_exports,
  GroupByTypeId,
  HashMap_exports,
  HashSet_exports,
  Hash_exports,
  HistogramKeyTypeTypeId,
  HistogramStateTypeId,
  IllegalArgumentException,
  Inspectable_exports,
  Interruption,
  Iterable_exports,
  JSONSchema_exports,
  Layer_exports,
  LeftDone,
  List_exports,
  LogLevel_exports,
  LogSpan_exports,
  Mailbox_exports,
  ManagedRuntime_exports,
  MergeDecision_exports,
  MergeStateTypeId,
  MergeStrategyTypeId,
  MetricBoundariesTypeId,
  MetricHookTypeId,
  MetricKeyTypeId,
  MetricKeyTypeTypeId,
  MetricLabelTypeId,
  MetricPairTypeId,
  MetricRegistryTypeId,
  MetricStateTypeId,
  MetricTypeId,
  Micro_exports,
  MutableHashMap_exports,
  MutableList_exports,
  MutableQueue_exports,
  MutableRef_exports,
  NoUpstream,
  NodeInspectSymbol,
  NonNaNSchemaId,
  None,
  Number_exports,
  OpSupervision,
  Option_exports,
  Order,
  Order2,
  Order_exports,
  PCGRandom,
  ParseResult_exports,
  Pipeable_exports,
  Pool_exports,
  Predicate_exports,
  PrettyAnnotationId,
  ProxySupervisor,
  PubSub_exports,
  PullAfterAllEnqueued,
  PullAfterNext,
  Pulled,
  Queue_exports,
  Random_exports,
  RcRef_exports,
  Readable_exports,
  Record_exports,
  RedBlackTree_exports,
  Redacted_exports,
  RefTypeId,
  Ref_exports,
  RegExp_exports,
  RequestResolverImpl,
  RequestResolverTypeId,
  Request_exports,
  RightDone,
  RuntimeFlagsPatch_exports,
  RuntimeMetrics,
  Runtime_exports,
  STMTypeId,
  ScheduleDecision_exports,
  ScheduleInterval_exports,
  ScheduleIntervals_exports,
  Schedule_exports,
  Scheduler_exports,
  SchemaAST_exports,
  SchemaIdAnnotationId,
  Schema_exports,
  Scope,
  Scope_exports,
  SecretTypeId,
  Sink_exports,
  SortedSet_exports,
  StreamHaltStrategy_exports,
  StreamTypeId,
  Stream_exports,
  String_exports,
  Struct_exports,
  SummaryKeyTypeTypeId,
  SummaryStateTypeId,
  SupervisorTypeId,
  SynchronizedTypeId,
  TDequeueTypeId,
  TPubSub_exports,
  TQueue_exports,
  TRefImpl,
  TRefTypeId,
  TakeTypeId,
  Tracer_exports,
  Tuple_exports,
  TypeId,
  TypeId2,
  TypeId3,
  Unify_exports,
  UpstreamPullRequestTypeId,
  UpstreamPullStrategyTypeId,
  Utils_exports,
  WindDown,
  Yield,
  Zip,
  __export,
  _await,
  _await2,
  _void,
  absurd,
  acquireRelease,
  acquireRelease2,
  acquireReleaseInterruptible,
  acquireUseRelease,
  acquireUseRelease3 as acquireUseRelease2,
  add,
  add2,
  addFinalizer,
  addFinalizerExit,
  addSupervisor,
  all,
  all2,
  all3,
  append2 as append,
  appendAll2 as appendAll,
  as,
  as2,
  as3,
  asSome,
  asSome3 as asSome2,
  asSomeError,
  asVoid,
  asVoid3 as asVoid2,
  asVoid4 as asVoid3,
  assert,
  async_,
  attempt,
  bind2 as bind,
  bindTo2 as bindTo,
  build,
  buildWithMemoMap,
  cached,
  catchAll2 as catchAll,
  catchSome,
  catchTag2 as catchTag,
  catchTags2 as catchTags,
  check,
  chunk,
  chunksOf,
  clear,
  clear2,
  clock,
  clockTag,
  clockWith,
  close,
  collect,
  collectSTM,
  combine,
  combine2,
  commit,
  commitEither,
  compareAndSet,
  complete2 as complete,
  concat,
  cond,
  consoleTag,
  consoleWith,
  constFalse,
  constVoid,
  context,
  context2,
  context3,
  contextWith,
  contextWith2,
  contextWithSTM,
  cooperativeYielding,
  count,
  countReset,
  counter,
  counter2,
  counter3,
  counter4,
  counter5,
  currentContext,
  currentServices,
  debug,
  decode,
  decrementAndGet,
  defaultParseOption,
  defaultRuntime,
  deferredAwait,
  deferredDone,
  deferredFailCause,
  deferredMake,
  deferredSucceed,
  deferredUnsafeMake,
  delay,
  descriptorWith,
  die,
  die5 as die2,
  die6 as die3,
  dieMessage2 as dieMessage,
  dieMessage3 as dieMessage2,
  dieSync,
  diff,
  diff2,
  diffFiberRefs,
  differ,
  dir,
  dirxml,
  disable,
  disableAll,
  disableCooperativeYielding,
  disableInterruption,
  disableOpSupervision,
  disableRuntimeMetrics,
  disableWindDown,
  done,
  done2,
  dual,
  effect,
  effect2,
  either,
  empty,
  empty10 as empty6,
  empty13 as empty7,
  empty14 as empty8,
  empty5 as empty2,
  empty6 as empty3,
  empty7 as empty4,
  empty9 as empty5,
  enable,
  enableAll,
  enableCooperativeYielding,
  enableInterruption,
  enableOpSupervision,
  enableRuntimeMetrics,
  enableWindDown,
  end,
  ensuring,
  ensuring2,
  ensuring3,
  equals,
  error,
  evaluate,
  eventually,
  eventually2,
  every,
  exists,
  exit,
  exit2,
  exitFail,
  exitMatch,
  exitSucceed,
  exitVoid,
  exponential,
  fail,
  fail6 as fail2,
  fail7 as fail3,
  failCause,
  failCause5 as failCause2,
  failSync,
  fiberActive,
  fiberFailures,
  fiberId,
  fiberId2,
  fiberIdWith,
  fiberLifetimes,
  fiberRefGet,
  fiberRefGetWith,
  fiberRefLocally,
  fiberRefLocallyScopedWith,
  fiberRefLocallyWith,
  fiberRefMake,
  fiberRefUnsafeMake,
  fiberRefUnsafeMakeContext,
  fiberStarted,
  fiberSuccesses,
  fibersIn,
  filter,
  filter2,
  filter4 as filter3,
  filter5 as filter4,
  filter6 as filter5,
  filterNot,
  filterOrDie,
  filterOrDieMessage,
  filterOrElse2 as filterOrElse,
  filterOrFail,
  filterOrFail3 as filterOrFail2,
  findFirst2 as findFirst,
  findFirst3 as findFirst2,
  first,
  first2,
  flatMap2 as flatMap,
  flatMap3 as flatMap2,
  flatMap4 as flatMap3,
  flatten,
  flatten3 as flatten2,
  flip,
  flipWith,
  flow,
  fnUntraced,
  fnUntraced2,
  forEach2 as forEach,
  forEach3 as forEach2,
  forEachConcurrentDiscard,
  forEachSequential,
  forEachSequentialDiscard,
  forever,
  fork,
  forkDaemon,
  forkDaemon2,
  forkIn,
  forkScoped,
  format,
  formatPropertyKey,
  formatUnknown,
  frequency,
  frequency2,
  frequency3,
  frequency4,
  frequency5,
  fromEffect,
  fromEffect2,
  fromEither,
  fromExit,
  fromIterable,
  fromIterable2,
  fromIterable3,
  fromIterable5 as fromIterable4,
  fromIterable6 as fromIterable5,
  fromIterable7 as fromIterable6,
  fromIterable8 as fromIterable7,
  fromMetricKey,
  fromNullable,
  fromOption,
  fromPubSub,
  fromPull,
  fromString,
  fromTQueue,
  gauge,
  gauge2,
  gauge3,
  gauge4,
  gauge5,
  gen,
  gen2,
  gen3,
  get10 as get9,
  get2 as get,
  get3 as get2,
  get4 as get3,
  get5 as get4,
  get6 as get5,
  get7 as get6,
  get8 as get7,
  get9 as get8,
  getAndSet,
  getAndSet2,
  getAndSet3,
  getAndUpdate,
  getAndUpdate2,
  getAndUpdate3,
  getAndUpdateEffect,
  getAndUpdateSome,
  getAndUpdateSome2,
  getAndUpdateSome3,
  getAndUpdateSomeEffect,
  getAnnotation,
  getArbitraryEmptyEnumErrorMessage,
  getArbitraryMissingAnnotationErrorMessage,
  getBugErrorMessage,
  getCompiler,
  getCurrentVersion,
  getJSONSchemaAnnotation,
  getKeysForIndexSignature,
  getOrElse,
  getOrUndefined,
  getOrder,
  getPrettyMissingAnnotationErrorMessage,
  getPrettyNeverErrorMessage,
  getPrettyNoMatchingSchemaErrorMessage,
  getSchemaIdAnnotation,
  globalMetricRegistry,
  globalValue,
  greaterThan,
  group,
  has,
  has2,
  has3,
  has4,
  hasProperty,
  hash,
  head,
  headNonEmpty,
  histogram,
  histogram2,
  histogram3,
  histogram4,
  histogram5,
  hole,
  identity,
  ids,
  if_,
  ignore2 as ignore,
  ignoreLogged,
  increment,
  incrementAndGet,
  incrementBy,
  infinity,
  info,
  insert,
  interrupt,
  interrupt5 as interrupt2,
  interrupt6 as interrupt3,
  interruptAllAs,
  interruptAs,
  interruptAs2,
  interruptFiber,
  interruptible,
  interruptible2,
  interruptible3,
  interruptibleMask,
  interruption,
  intoDeferred,
  invokeWithInterrupt,
  is,
  isBackPressure,
  isBigInt,
  isBoolean,
  isBothRunning,
  isBufferSliding,
  isChildExecutorDecision,
  isClose,
  isContinue,
  isCounterKey,
  isCounterState,
  isDate,
  isDisabled,
  isDone,
  isDone2,
  isEffect,
  isEither,
  isEmpty2 as isEmpty,
  isEnabled,
  isExecutionPlan,
  isFailure,
  isFailure2,
  isFailure3,
  isFinite,
  isFrequencyKey,
  isFrequencyState,
  isGaugeKey,
  isGaugeState,
  isHistogramKey,
  isHistogramState,
  isInterruptedOnly,
  isLayer,
  isLeft,
  isLeftDone,
  isMergeState,
  isMergeStrategy,
  isMetricBoundaries,
  isMetricKey,
  isMetricKeyType,
  isMetricLabel,
  isMetricState,
  isNoUpstream,
  isNonEmpty,
  isNonEmptyArray,
  isNonEmptyReadonlyArray,
  isNone,
  isNull,
  isNumber,
  isPropertyKey,
  isPullAfterAllEnqueued,
  isPullAfterNext,
  isPulled,
  isReadonlyRecord,
  isRecord,
  isRequestResolver,
  isRight,
  isRightDone,
  isSTM,
  isSecret,
  isSome,
  isString,
  isSuccess,
  isSuccess2,
  isSuccess3,
  isSummaryKey,
  isSummaryState,
  isSuspended,
  isSymbol,
  isTagged,
  isUndefined,
  isUpstreamPullRequest,
  isUpstreamPullStrategy,
  isYield,
  iterate,
  keys,
  keys2,
  last,
  left,
  lessThan,
  let_,
  linear,
  liveServices,
  locally,
  log,
  logWarning,
  loop,
  make,
  make10 as make9,
  make11 as make10,
  make12 as make11,
  make13 as make12,
  make14 as make13,
  make15 as make14,
  make16 as make15,
  make17 as make16,
  make18 as make17,
  make19 as make18,
  make2,
  make20 as make19,
  make21 as make20,
  make22 as make21,
  make24 as make22,
  make3,
  make4,
  make5,
  make6,
  make7,
  make9 as make8,
  makeCacheStats,
  makeEntryStats,
  makeKeySet,
  makeMapKey,
  makeMemoMap,
  makeSemaphore,
  makeSynchronized,
  makeWith,
  makeWithTTL,
  map11 as map7,
  map12 as map8,
  map13 as map9,
  map14 as map10,
  map2 as map,
  map3 as map2,
  map5 as map3,
  map6 as map4,
  map7 as map5,
  map9 as map6,
  mapAttempt,
  mapBoth,
  mapEffect,
  mapError2 as mapError,
  mapInput,
  mapInput3 as mapInput2,
  mapInputContext,
  mapInputContext3 as mapInputContext2,
  mapRequestResolvers,
  mapType,
  match,
  match10 as match9,
  match2,
  match4 as match3,
  match5 as match4,
  match6 as match5,
  match7 as match6,
  match8 as match7,
  match9 as match8,
  matchCauseEffect,
  matchCauseEffect2,
  matchEffect,
  matchEffect3 as matchEffect2,
  matchSTM,
  memoize,
  memoizeThunk,
  merge,
  merge2,
  merge3,
  mergeAll2 as mergeAll,
  millis,
  modify,
  modify2,
  modify3,
  modify4,
  modifyEffect,
  modifySome,
  modifySome2,
  modifySome3,
  modifySomeEffect,
  negate,
  never,
  none,
  none3 as none2,
  none4 as none3,
  none6 as none4,
  none7 as none5,
  of,
  of3 as of2,
  offer,
  offer2,
  onError,
  onInterrupt,
  onModify,
  onUpdate,
  opSupervision,
  option,
  orDie2 as orDie,
  orDieWith,
  orElse3 as orElse,
  orElseEither,
  orElseFail,
  orElseOptional,
  orElseSucceed2 as orElseSucceed,
  orTry,
  par,
  partition,
  partition2,
  partitionMap,
  patch,
  patch2,
  pick,
  pipe,
  pipeArguments,
  poll,
  prepend,
  prepend2,
  provide2 as provide,
  provideContext,
  provideContext2,
  provideMerge,
  provideService2 as provideService,
  provideServiceSTM,
  provideSomeContext,
  publish,
  publish2,
  race,
  reduce,
  reduce2,
  reduce3,
  reduce4,
  reduce5,
  reduce7 as reduce6,
  reduceAll,
  reduceRight,
  reduceWithContext,
  refVariance,
  refineOrDie,
  refineOrDieWith,
  reject,
  rejectSTM,
  remove3 as remove,
  remove4 as remove2,
  removeFirst,
  render,
  repeatUntil,
  repeatWhile,
  replicate,
  replicateSTM,
  replicateSTMDiscard,
  resolverLocally,
  retry2 as retry,
  retryUntil,
  retryWhile,
  retry_Effect,
  right,
  runFork,
  runFork2,
  runtime2 as runtime,
  runtimeMetrics,
  scheduleForked,
  schedule_Effect,
  scopeClose,
  scopeExtend,
  scopeMake,
  scopeTag,
  scopeWith,
  scoped,
  scoped3 as scoped2,
  scopedContext,
  scopedEffect,
  seconds,
  seq,
  set2 as set,
  set3 as set2,
  set4 as set3,
  set5 as set4,
  set6 as set5,
  set7 as set6,
  set9 as set7,
  setAndGet,
  setAndGet2,
  setAndGet3,
  setConsole,
  setCurrentVersion,
  shutdown,
  single,
  size,
  size2,
  size3,
  sleep,
  snapshot,
  some,
  some2,
  some3,
  sort,
  splitAt,
  squash,
  string,
  struct,
  subscribe,
  succeed,
  succeed3 as succeed2,
  succeed5 as succeed3,
  succeed6 as succeed4,
  succeed8 as succeed5,
  succeedContext,
  succeedNone,
  succeedNone3 as succeedNone2,
  succeedSome,
  summarized,
  summary,
  summary2,
  summary3,
  summary4,
  summary5,
  summaryTimestamp,
  supervisorVariance,
  suspend,
  suspend2,
  suspend3,
  symbol,
  symbol2,
  symbol3,
  sync,
  sync3 as sync2,
  sync4 as sync3,
  sync6 as sync4,
  syncContext,
  synchronizedVariance,
  tDequeueVariance,
  tRefVariance,
  table,
  tagged,
  tagged2,
  taggedWithLabels,
  taggedWithLabels2,
  taggedWithLabelsInput,
  tailNonEmpty,
  tap,
  tap2,
  tap3,
  tap4,
  tapBoth,
  tapError2 as tapError,
  threadName,
  time,
  timeLog,
  timer,
  timerWithBoundaries,
  toChannel2 as toChannel,
  toJSON,
  toMillis,
  toSet2 as toSet,
  toValues,
  trace,
  track,
  trackAll,
  trackDefect,
  trackDefectWith,
  trackDuration,
  trackDurationWith,
  trackError,
  trackErrorWith,
  trackSuccess,
  trackSuccessWith,
  try_3 as try_,
  unbounded,
  unbounded2,
  unbounded3,
  unbounded4,
  uninterruptible,
  uninterruptibleMask,
  uninterruptibleMask2,
  union,
  union3 as union2,
  unless,
  unlessSTM,
  unsafeCoerce,
  unsafeDone,
  unsafeFromArray,
  unsafeGet,
  unsafeGet2,
  unsafeGet3,
  unsafeGet4,
  unsafeHead,
  unsafeMake,
  unsafeMake3 as unsafeMake2,
  unsafeMake4 as unsafeMake3,
  unsafeMake5 as unsafeMake4,
  unsafeMake6 as unsafeMake5,
  unsafeMakeSemaphore,
  unsafeMakeSynchronized,
  unsafeSet,
  unsafeSnapshot,
  unsafeTrack,
  unsafeWipe,
  unsome,
  unwrap,
  unwrap3 as unwrap2,
  unwrapScoped,
  unwrapScoped2,
  update,
  update2,
  update3,
  update4,
  update6 as update5,
  updateAndGet,
  updateAndGet2,
  updateAndGet3,
  updateAndGetEffect,
  updateEffect,
  updateSome,
  updateSome2,
  updateSome3,
  updateSomeAndGet,
  updateSomeAndGet2,
  updateSomeAndGet3,
  updateSomeAndGetEffectSynchronized,
  updateSomeEffect,
  validateAll,
  validateFirst,
  value,
  value2,
  values,
  void_,
  void_2,
  void_3,
  warn,
  when,
  when2,
  whenSTM,
  whileLoop,
  windDown,
  withClockScoped,
  withConsole,
  withConstantInput,
  withFiberRuntime,
  withFiberRuntime2,
  withGroup,
  withNow,
  withSTMRuntime,
  withTime,
  yieldNow,
  zip,
  zip3 as zip2,
  zip5 as zip3,
  zipLeft2 as zipLeft,
  zipLeft3 as zipLeft2,
  zipLeftOptions,
  zipRight,
  zipRight3 as zipRight2,
  zipRight4 as zipRight3,
  zipWith,
  zipWith2,
  zipWithOptions
} from "./chunk-6XTNYBYF.js";

// node_modules/effect/dist/esm/Arbitrary.js
var Arbitrary_exports = {};
__export(Arbitrary_exports, {
  getDescription: () => getDescription,
  make: () => make23,
  makeArrayConstraints: () => makeArrayConstraints,
  makeBigIntConstraints: () => makeBigIntConstraints,
  makeDateConstraints: () => makeDateConstraints,
  makeLazy: () => makeLazy,
  makeNumberConstraints: () => makeNumberConstraints,
  makeStringConstraints: () => makeStringConstraints
});
var makeLazy = (schema) => {
  const description = getDescription(schema.ast, []);
  return go(description, {
    maxDepth: 2
  });
};
var make23 = (schema) => makeLazy(schema)(FastCheck_exports);
var makeStringConstraints = (options) => {
  const out = {
    _tag: "StringConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  if (isString(options.pattern)) {
    out.pattern = options.pattern;
  }
  return out;
};
var makeNumberConstraints = (options) => {
  const out = {
    _tag: "NumberConstraints",
    constraints: {},
    isInteger: options.isInteger ?? false
  };
  if (isNumber(options.min)) {
    out.constraints.min = Math.fround(options.min);
  }
  if (isBoolean(options.minExcluded)) {
    out.constraints.minExcluded = options.minExcluded;
  }
  if (isNumber(options.max)) {
    out.constraints.max = Math.fround(options.max);
  }
  if (isBoolean(options.maxExcluded)) {
    out.constraints.maxExcluded = options.maxExcluded;
  }
  if (isBoolean(options.noNaN)) {
    out.constraints.noNaN = options.noNaN;
  }
  if (isBoolean(options.noDefaultInfinity)) {
    out.constraints.noDefaultInfinity = options.noDefaultInfinity;
  }
  return out;
};
var makeBigIntConstraints = (options) => {
  const out = {
    _tag: "BigIntConstraints",
    constraints: {}
  };
  if (isBigInt(options.min)) {
    out.constraints.min = options.min;
  }
  if (isBigInt(options.max)) {
    out.constraints.max = options.max;
  }
  return out;
};
var makeArrayConstraints = (options) => {
  const out = {
    _tag: "ArrayConstraints",
    constraints: {}
  };
  if (isNumber(options.minLength)) {
    out.constraints.minLength = options.minLength;
  }
  if (isNumber(options.maxLength)) {
    out.constraints.maxLength = options.maxLength;
  }
  return out;
};
var makeDateConstraints = (options) => {
  const out = {
    _tag: "DateConstraints",
    constraints: {}
  };
  if (isDate(options.min)) {
    out.constraints.min = options.min;
  }
  if (isDate(options.max)) {
    out.constraints.max = options.max;
  }
  if (isBoolean(options.noInvalidDate)) {
    out.constraints.noInvalidDate = options.noInvalidDate;
  }
  return out;
};
var getArbitraryAnnotation = getAnnotation(ArbitraryAnnotationId);
var getASTConstraints = (ast) => {
  const TypeAnnotationId = ast.annotations[SchemaIdAnnotationId];
  if (isPropertyKey(TypeAnnotationId)) {
    const out = ast.annotations[TypeAnnotationId];
    if (isReadonlyRecord(out)) {
      return out;
    }
  }
};
var idMemoMap = globalValue(Symbol.for("effect/Arbitrary/IdMemoMap"), () => /* @__PURE__ */ new Map());
var counter6 = 0;
function wrapGetDescription(f, g) {
  return (ast, path) => f(ast, g(ast, path));
}
function parseMeta(ast) {
  const jsonSchema = getJSONSchemaAnnotation(ast).pipe(filter(isReadonlyRecord), getOrUndefined);
  const schemaId = getOrElse(getSchemaIdAnnotation(ast), () => void 0);
  const schemaParams = fromNullable(schemaId).pipe(map((id) => ast.annotations[id]), filter(isReadonlyRecord), getOrUndefined);
  return [schemaId, {
    ...schemaParams,
    ...jsonSchema
  }];
}
var getDescription = wrapGetDescription((ast, description) => {
  const annotation = getArbitraryAnnotation(ast);
  if (isSome(annotation)) {
    return {
      ...description,
      annotations: [...description.annotations, annotation.value]
    };
  }
  return description;
}, (ast, path) => {
  const [schemaId, meta] = parseMeta(ast);
  switch (ast._tag) {
    case "Refinement": {
      const from = getDescription(ast.from, path);
      switch (from._tag) {
        case "StringKeyword":
          return {
            ...from,
            constraints: [...from.constraints, makeStringConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        case "NumberKeyword": {
          const c = schemaId === NonNaNSchemaId ? makeNumberConstraints({
            noNaN: true
          }) : makeNumberConstraints({
            isInteger: "type" in meta && meta.type === "integer",
            noNaN: "type" in meta && meta.type === "number" ? true : void 0,
            noDefaultInfinity: "type" in meta && meta.type === "number" ? true : void 0,
            min: meta.exclusiveMinimum ?? meta.minimum,
            minExcluded: "exclusiveMinimum" in meta ? true : void 0,
            max: meta.exclusiveMaximum ?? meta.maximum,
            maxExcluded: "exclusiveMaximum" in meta ? true : void 0
          });
          return {
            ...from,
            constraints: [...from.constraints, c],
            refinements: [...from.refinements, ast]
          };
        }
        case "BigIntKeyword": {
          const c = getASTConstraints(ast);
          return {
            ...from,
            constraints: c !== void 0 ? [...from.constraints, makeBigIntConstraints(c)] : from.constraints,
            refinements: [...from.refinements, ast]
          };
        }
        case "TupleType":
          return {
            ...from,
            constraints: [...from.constraints, makeArrayConstraints({
              minLength: meta.minItems,
              maxLength: meta.maxItems
            })],
            refinements: [...from.refinements, ast]
          };
        case "DateFromSelf":
          return {
            ...from,
            constraints: [...from.constraints, makeDateConstraints(meta)],
            refinements: [...from.refinements, ast]
          };
        default:
          return {
            ...from,
            refinements: [...from.refinements, ast]
          };
      }
    }
    case "Declaration": {
      if (schemaId === DateFromSelfSchemaId) {
        return {
          _tag: "DateFromSelf",
          constraints: [makeDateConstraints(meta)],
          path,
          refinements: [],
          annotations: []
        };
      }
      return {
        _tag: "Declaration",
        typeParameters: ast.typeParameters.map((ast2) => getDescription(ast2, path)),
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "Literal": {
      return {
        _tag: "Literal",
        literal: ast.literal,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "UniqueSymbol": {
      return {
        _tag: "UniqueSymbol",
        symbol: ast.symbol,
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Enums": {
      return {
        _tag: "Enums",
        enums: ast.enums,
        path,
        refinements: [],
        annotations: [],
        ast
      };
    }
    case "TemplateLiteral": {
      return {
        _tag: "TemplateLiteral",
        head: ast.head,
        spans: ast.spans.map((span) => ({
          description: getDescription(span.type, path),
          literal: span.literal
        })),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "StringKeyword":
      return {
        _tag: "StringKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "NumberKeyword":
      return {
        _tag: "NumberKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "BigIntKeyword":
      return {
        _tag: "BigIntKeyword",
        constraints: [],
        path,
        refinements: [],
        annotations: []
      };
    case "TupleType":
      return {
        _tag: "TupleType",
        constraints: [],
        elements: ast.elements.map((element, i) => ({
          isOptional: element.isOptional,
          description: getDescription(element.type, [...path, i])
        })),
        rest: ast.rest.map((element, i) => getDescription(element.type, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "TypeLiteral":
      return {
        _tag: "TypeLiteral",
        propertySignatures: ast.propertySignatures.map((ps) => ({
          isOptional: ps.isOptional,
          name: ps.name,
          value: getDescription(ps.type, [...path, ps.name])
        })),
        indexSignatures: ast.indexSignatures.map((is4) => ({
          parameter: getDescription(is4.parameter, path),
          value: getDescription(is4.type, path)
        })),
        path,
        refinements: [],
        annotations: []
      };
    case "Union":
      return {
        _tag: "Union",
        members: ast.types.map((member, i) => getDescription(member, [...path, i])),
        path,
        refinements: [],
        annotations: []
      };
    case "Suspend": {
      const memoId = idMemoMap.get(ast);
      if (memoId !== void 0) {
        return {
          _tag: "Ref",
          id: memoId,
          ast,
          path,
          refinements: [],
          annotations: []
        };
      }
      counter6++;
      const id = `__id-${counter6}__`;
      idMemoMap.set(ast, id);
      return {
        _tag: "Suspend",
        id,
        ast,
        description: () => getDescription(ast.f(), path),
        path,
        refinements: [],
        annotations: []
      };
    }
    case "Transformation":
      return getDescription(ast.to, path);
    case "NeverKeyword":
      return {
        _tag: "NeverKeyword",
        path,
        refinements: [],
        annotations: [],
        ast
      };
    default: {
      return {
        _tag: "Keyword",
        value: ast._tag,
        path,
        refinements: [],
        annotations: []
      };
    }
  }
});
function getMax(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n2 : n1;
}
function getMin(n1, n2) {
  return n1 === void 0 ? n2 : n2 === void 0 ? n1 : n1 <= n2 ? n1 : n2;
}
var getOr = (a, b) => {
  return a === void 0 ? b : b === void 0 ? a : a || b;
};
function mergePattern(pattern1, pattern2) {
  if (pattern1 === void 0) {
    return pattern2;
  }
  if (pattern2 === void 0) {
    return pattern1;
  }
  return `(?:${pattern1})|(?:${pattern2})`;
}
function mergeStringConstraints(c1, c2) {
  return makeStringConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength),
    pattern: mergePattern(c1.pattern, c2.pattern)
  });
}
function buildStringConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeStringConstraints);
}
function mergeNumberConstraints(c1, c2) {
  return makeNumberConstraints({
    isInteger: c1.isInteger || c2.isInteger,
    min: getMax(c1.constraints.min, c2.constraints.min),
    minExcluded: getOr(c1.constraints.minExcluded, c2.constraints.minExcluded),
    max: getMin(c1.constraints.max, c2.constraints.max),
    maxExcluded: getOr(c1.constraints.maxExcluded, c2.constraints.maxExcluded),
    noNaN: getOr(c1.constraints.noNaN, c2.constraints.noNaN),
    noDefaultInfinity: getOr(c1.constraints.noDefaultInfinity, c2.constraints.noDefaultInfinity)
  });
}
function buildNumberConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeNumberConstraints);
}
function mergeBigIntConstraints(c1, c2) {
  return makeBigIntConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max)
  });
}
function buildBigIntConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeBigIntConstraints);
}
function mergeDateConstraints(c1, c2) {
  return makeDateConstraints({
    min: getMax(c1.constraints.min, c2.constraints.min),
    max: getMin(c1.constraints.max, c2.constraints.max),
    noInvalidDate: getOr(c1.constraints.noInvalidDate, c2.constraints.noInvalidDate)
  });
}
function buildDateConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeDateConstraints);
}
var constArrayConstraints = makeArrayConstraints({});
function mergeArrayConstraints(c1, c2) {
  return makeArrayConstraints({
    minLength: getMax(c1.constraints.minLength, c2.constraints.minLength),
    maxLength: getMin(c1.constraints.maxLength, c2.constraints.maxLength)
  });
}
function buildArrayConstraints(description) {
  return description.constraints.length === 0 ? void 0 : description.constraints.reduce(mergeArrayConstraints);
}
var arbitraryMemoMap = globalValue(Symbol.for("effect/Arbitrary/arbitraryMemoMap"), () => /* @__PURE__ */ new WeakMap());
function applyFilters(filters, arb) {
  return (fc) => filters.reduce((arb2, filter10) => arb2.filter(filter10), arb(fc));
}
function absurd2(message) {
  return () => {
    throw new Error(message);
  };
}
function getContextConstraints(description) {
  switch (description._tag) {
    case "StringKeyword":
      return buildStringConstraints(description);
    case "NumberKeyword":
      return buildNumberConstraints(description);
    case "BigIntKeyword":
      return buildBigIntConstraints(description);
    case "DateFromSelf":
      return buildDateConstraints(description);
    case "TupleType":
      return buildArrayConstraints(description);
  }
}
function wrapGo(f, g) {
  return (description, ctx) => f(description, ctx, g(description, ctx));
}
var go = wrapGo((description, ctx, lazyArb) => {
  const annotation = description.annotations[description.annotations.length - 1];
  if (annotation === void 0) {
    switch (description._tag) {
      case "Declaration":
      case "NeverKeyword":
        throw new Error(getArbitraryMissingAnnotationErrorMessage(description.path, description.ast));
      case "Enums":
        if (description.enums.length === 0) {
          throw new Error(getArbitraryEmptyEnumErrorMessage(description.path));
        }
    }
  }
  const filters = description.refinements.map((ast) => (a) => isNone(ast.filter(a, defaultParseOption, ast)));
  if (annotation === void 0) {
    return applyFilters(filters, lazyArb);
  }
  const constraints = getContextConstraints(description);
  if (constraints !== void 0) {
    ctx = {
      ...ctx,
      constraints
    };
  }
  if (description._tag === "Declaration") {
    return applyFilters(filters, annotation(...description.typeParameters.map((p) => go(p, ctx)), ctx));
  }
  if (description.refinements.length > 0) {
    return applyFilters(filters, annotation(lazyArb, ctx));
  }
  return annotation(ctx);
}, (description, ctx) => {
  switch (description._tag) {
    case "DateFromSelf": {
      const constraints = buildDateConstraints(description);
      return (fc) => fc.date(constraints?.constraints);
    }
    case "Declaration":
    case "NeverKeyword":
      return absurd2(`BUG: cannot generate an arbitrary for ${description._tag}`);
    case "Literal":
      return (fc) => fc.constant(description.literal);
    case "UniqueSymbol":
      return (fc) => fc.constant(description.symbol);
    case "Keyword": {
      switch (description.value) {
        case "UndefinedKeyword":
          return (fc) => fc.constant(void 0);
        case "VoidKeyword":
        case "UnknownKeyword":
        case "AnyKeyword":
          return (fc) => fc.anything();
        case "BooleanKeyword":
          return (fc) => fc.boolean();
        case "SymbolKeyword":
          return (fc) => fc.string().map((s) => Symbol.for(s));
        case "ObjectKeyword":
          return (fc) => fc.oneof(fc.object(), fc.array(fc.anything()));
      }
    }
    case "Enums":
      return (fc) => fc.oneof(...description.enums.map(([_, value7]) => fc.constant(value7)));
    case "TemplateLiteral": {
      return (fc) => {
        const string3 = fc.string({
          maxLength: 5
        });
        const number2 = fc.float({
          noDefaultInfinity: true,
          noNaN: true
        });
        const getTemplateLiteralArb = (description2) => {
          const components = description2.head !== "" ? [fc.constant(description2.head)] : [];
          const getTemplateLiteralSpanTypeArb = (description3) => {
            switch (description3._tag) {
              case "StringKeyword":
                return string3;
              case "NumberKeyword":
                return number2;
              case "Literal":
                return fc.constant(String(description3.literal));
              case "Union":
                return fc.oneof(...description3.members.map(getTemplateLiteralSpanTypeArb));
              case "TemplateLiteral":
                return getTemplateLiteralArb(description3);
              default:
                return fc.constant("");
            }
          };
          description2.spans.forEach((span) => {
            components.push(getTemplateLiteralSpanTypeArb(span.description));
            if (span.literal !== "") {
              components.push(fc.constant(span.literal));
            }
          });
          return fc.tuple(...components).map((spans) => spans.join(""));
        };
        return getTemplateLiteralArb(description);
      };
    }
    case "StringKeyword": {
      const constraints = buildStringConstraints(description);
      const pattern = constraints?.pattern;
      return pattern !== void 0 ? (fc) => fc.stringMatching(new RegExp(pattern)) : (fc) => fc.string(constraints?.constraints);
    }
    case "NumberKeyword": {
      const constraints = buildNumberConstraints(description);
      return constraints?.isInteger ? (fc) => fc.integer(constraints.constraints) : (fc) => fc.float(constraints?.constraints);
    }
    case "BigIntKeyword": {
      const constraints = buildBigIntConstraints(description);
      return (fc) => fc.bigInt(constraints?.constraints ?? {});
    }
    case "TupleType": {
      const elements = [];
      let hasOptionals = false;
      for (const element of description.elements) {
        elements.push(go(element.description, ctx));
        if (element.isOptional) {
          hasOptionals = true;
        }
      }
      const rest = description.rest.map((d) => go(d, ctx));
      return (fc) => {
        let output = fc.tuple(...elements.map((arb) => arb(fc)));
        if (hasOptionals) {
          const indexes = fc.tuple(...description.elements.map((element) => element.isOptional ? fc.boolean() : fc.constant(true)));
          output = output.chain((tuple) => indexes.map((booleans) => {
            for (const [i, b] of booleans.reverse().entries()) {
              if (!b) {
                tuple.splice(booleans.length - i, 1);
              }
            }
            return tuple;
          }));
        }
        if (isNonEmptyReadonlyArray(rest)) {
          const constraints = buildArrayConstraints(description) ?? constArrayConstraints;
          const [head3, ...tail] = rest;
          const item = head3(fc);
          output = output.chain((as5) => {
            const len = as5.length;
            const restArrayConstraints = subtractElementsLength(constraints.constraints, len);
            if (restArrayConstraints.maxLength === 0) {
              return fc.constant(as5);
            }
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, restArrayConstraints) : fc.array(item, restArrayConstraints);
            if (len === 0) {
              return arr;
            }
            return arr.map((rest2) => [...as5, ...rest2]);
          });
          for (let j = 0; j < tail.length; j++) {
            output = output.chain((as5) => tail[j](fc).map((a) => [...as5, a]));
          }
        }
        return output;
      };
    }
    case "TypeLiteral": {
      const propertySignatures = [];
      const requiredKeys = [];
      for (const ps of description.propertySignatures) {
        if (!ps.isOptional) {
          requiredKeys.push(ps.name);
        }
        propertySignatures.push(go(ps.value, ctx));
      }
      const indexSignatures = description.indexSignatures.map((is4) => [go(is4.parameter, ctx), go(is4.value, ctx)]);
      return (fc) => {
        const pps = {};
        for (let i = 0; i < propertySignatures.length; i++) {
          const ps = description.propertySignatures[i];
          pps[ps.name] = propertySignatures[i](fc);
        }
        let output = fc.record(pps, {
          requiredKeys
        });
        for (let i = 0; i < indexSignatures.length; i++) {
          const key = indexSignatures[i][0](fc);
          const value7 = indexSignatures[i][1](fc);
          output = output.chain((o) => {
            const item = fc.tuple(key, value7);
            const arr = ctx.depthIdentifier !== void 0 ? getSuspendedArray(fc, ctx.depthIdentifier, ctx.maxDepth, item, {
              maxLength: 2
            }) : fc.array(item);
            return arr.map((tuples) => ({
              ...Object.fromEntries(tuples),
              ...o
            }));
          });
        }
        return output;
      };
    }
    case "Union": {
      const members = description.members.map((member) => go(member, ctx));
      return (fc) => fc.oneof(...members.map((arb) => arb(fc)));
    }
    case "Suspend": {
      const memo = arbitraryMemoMap.get(description.ast);
      if (memo) {
        return memo;
      }
      if (ctx.depthIdentifier === void 0) {
        ctx = {
          ...ctx,
          depthIdentifier: description.id
        };
      }
      const get37 = memoizeThunk(() => {
        return go(description.description(), ctx);
      });
      const out = (fc) => fc.constant(null).chain(() => get37()(fc));
      arbitraryMemoMap.set(description.ast, out);
      return out;
    }
    case "Ref": {
      const memo = arbitraryMemoMap.get(description.ast);
      if (memo) {
        return memo;
      }
      throw new Error(`BUG: Ref ${JSON.stringify(description.id)} not found`);
    }
  }
});
function subtractElementsLength(constraints, len) {
  if (len === 0 || constraints.minLength === void 0 && constraints.maxLength === void 0) {
    return constraints;
  }
  const out = {
    ...constraints
  };
  if (out.minLength !== void 0) {
    out.minLength = Math.max(out.minLength - len, 0);
  }
  if (out.maxLength !== void 0) {
    out.maxLength = Math.max(out.maxLength - len, 0);
  }
  return out;
}
var getSuspendedArray = (fc, depthIdentifier, maxDepth, item, constraints) => {
  const maxLengthLimit = Math.max(2, constraints.minLength ?? 0);
  if (constraints.maxLength !== void 0 && constraints.maxLength > maxLengthLimit) {
    constraints = {
      ...constraints,
      maxLength: maxLengthLimit
    };
  }
  return fc.oneof({
    maxDepth,
    depthIdentifier
  }, fc.constant([]), fc.array(item, constraints));
};

// node_modules/effect/dist/esm/Cache.js
var Cache_exports = {};
__export(Cache_exports, {
  CacheTypeId: () => CacheTypeId2,
  ConsumerCacheTypeId: () => ConsumerCacheTypeId2,
  make: () => make24,
  makeCacheStats: () => makeCacheStats2,
  makeEntryStats: () => makeEntryStats2,
  makeWith: () => makeWith2
});
var CacheTypeId2 = CacheTypeId;
var ConsumerCacheTypeId2 = ConsumerCacheTypeId;
var make24 = make14;
var makeWith2 = makeWith;
var makeCacheStats2 = makeCacheStats;
var makeEntryStats2 = makeEntryStats;

// node_modules/effect/dist/esm/ChildExecutorDecision.js
var ChildExecutorDecision_exports = {};
__export(ChildExecutorDecision_exports, {
  ChildExecutorDecisionTypeId: () => ChildExecutorDecisionTypeId2,
  Close: () => Close2,
  Continue: () => Continue2,
  Yield: () => Yield2,
  isChildExecutorDecision: () => isChildExecutorDecision2,
  isClose: () => isClose2,
  isContinue: () => isContinue2,
  isYield: () => isYield2,
  match: () => match10
});
var ChildExecutorDecisionTypeId2 = ChildExecutorDecisionTypeId;
var Continue2 = Continue;
var Close2 = Close;
var Yield2 = Yield;
var isChildExecutorDecision2 = isChildExecutorDecision;
var isContinue2 = isContinue;
var isClose2 = isClose;
var isYield2 = isYield;
var match10 = match3;

// node_modules/effect/dist/esm/Console.js
var Console_exports = {};
__export(Console_exports, {
  Console: () => Console,
  TypeId: () => TypeId4,
  assert: () => assert2,
  clear: () => clear3,
  consoleWith: () => consoleWith2,
  count: () => count2,
  countReset: () => countReset2,
  debug: () => debug2,
  dir: () => dir2,
  dirxml: () => dirxml2,
  error: () => error2,
  group: () => group2,
  info: () => info2,
  log: () => log2,
  setConsole: () => setConsole2,
  table: () => table2,
  time: () => time2,
  timeLog: () => timeLog2,
  trace: () => trace2,
  warn: () => warn2,
  withConsole: () => withConsole2,
  withGroup: () => withGroup2,
  withTime: () => withTime2
});
var TypeId4 = TypeId;
var Console = consoleTag;
var withConsole2 = withConsole;
var setConsole2 = setConsole;
var consoleWith2 = consoleWith;
var assert2 = assert;
var clear3 = clear2;
var count2 = count;
var countReset2 = countReset;
var debug2 = debug;
var dir2 = dir;
var dirxml2 = dirxml;
var error2 = error;
var group2 = group;
var info2 = info;
var log2 = log;
var table2 = table;
var time2 = time;
var timeLog2 = timeLog;
var trace2 = trace;
var warn2 = warn;
var withGroup2 = withGroup;
var withTime2 = withTime;

// node_modules/effect/dist/esm/ExecutionPlan.js
var ExecutionPlan_exports = {};
__export(ExecutionPlan_exports, {
  TypeId: () => TypeId5,
  isExecutionPlan: () => isExecutionPlan2,
  make: () => make25,
  merge: () => merge4
});
var TypeId5 = TypeId3;
var isExecutionPlan2 = isExecutionPlan;
var make25 = (...steps) => makeProto(steps.map((options, i) => {
  if (options.attempts && options.attempts < 1) {
    throw new Error(`ExecutionPlan.make: step[${i}].attempts must be greater than 0`);
  }
  return {
    schedule: options.schedule,
    attempts: options.attempts,
    while: options.while ? (input) => suspend2(() => {
      const result = options.while(input);
      return typeof result === "boolean" ? succeed4(result) : result;
    }) : void 0,
    provide: options.provide
  };
}));
var Proto = {
  [TypeId5]: TypeId5,
  get withRequirements() {
    const self = this;
    return contextWith((context5) => makeProto(self.steps.map((step) => ({
      ...step,
      provide: isLayer(step.provide) ? provide(step.provide, succeedContext(context5)) : step.provide
    }))));
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeProto = (steps) => {
  const self = Object.create(Proto);
  self.steps = steps;
  return self;
};
var merge4 = (...plans) => makeProto(plans.flatMap((plan) => plan.steps));

// node_modules/effect/dist/esm/FiberHandle.js
var FiberHandle_exports = {};
__export(FiberHandle_exports, {
  TypeId: () => TypeId6,
  awaitEmpty: () => awaitEmpty,
  clear: () => clear4,
  get: () => get10,
  isFiberHandle: () => isFiberHandle,
  join: () => join,
  make: () => make26,
  makeRuntime: () => makeRuntime,
  makeRuntimePromise: () => makeRuntimePromise,
  run: () => run,
  runtime: () => runtime2,
  runtimePromise: () => runtimePromise,
  set: () => set8,
  unsafeGet: () => unsafeGet5,
  unsafeSet: () => unsafeSet2
});
var TypeId6 = Symbol.for("effect/FiberHandle");
var isFiberHandle = (u) => hasProperty(u, TypeId6);
var Proto2 = {
  [TypeId6]: TypeId6,
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberHandle",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake6 = (deferred) => {
  const self = Object.create(Proto2);
  self.state = {
    _tag: "Open",
    fiber: void 0
  };
  self.deferred = deferred;
  return self;
};
var make26 = () => acquireRelease2(map7(make7(), (deferred) => unsafeMake6(deferred)), (handle) => withFiberRuntime2((parent) => {
  const state = handle.state;
  if (state._tag === "Closed") return _void;
  handle.state = {
    _tag: "Closed"
  };
  return state.fiber ? intoDeferred(asVoid2(interruptAs(state.fiber, combine2(parent.id(), internalFiberId))), handle.deferred) : done(handle.deferred, void_2);
}));
var makeRuntime = () => flatMap2(make26(), (self) => runtime2(self)());
var makeRuntimePromise = () => flatMap2(make26(), (self) => runtimePromise(self)());
var internalFiberIdId = -1;
var internalFiberId = make4(internalFiberIdId, 0);
var isInternalInterruption = reduceWithContext(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId4) => has(ids(fiberId4), internalFiberIdId),
  sequentialCase: (_, left2, right2) => left2 || right2,
  parallelCase: (_, left2, right2) => left2 || right2
});
var unsafeSet2 = dual((args) => isFiberHandle(args[0]), (self, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId));
    return;
  } else if (self.state.fiber !== void 0) {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId));
      return;
    } else if (self.state.fiber === fiber) {
      return;
    }
    self.state.fiber.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId));
    self.state.fiber = void 0;
  }
  self.state.fiber = fiber;
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Open" && fiber === self.state.fiber) {
      self.state.fiber = void 0;
    }
    if (isFailure(exit3) && (options?.propagateInterruption === true ? !isInternalInterruption(exit3.cause) : !isInterruptedOnly(exit3.cause))) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var set8 = dual((args) => isFiberHandle(args[0]), (self, fiber, options) => fiberIdWith((fiberId4) => sync3(() => unsafeSet2(self, fiber, {
  interruptAs: fiberId4,
  onlyIfMissing: options?.onlyIfMissing,
  propagateInterruption: options?.propagateInterruption
}))));
var unsafeGet5 = (self) => self.state._tag === "Closed" ? none() : fromNullable(self.state.fiber);
var get10 = (self) => suspend2(() => unsafeGet5(self));
var clear4 = (self) => uninterruptibleMask2((restore) => withFiberRuntime2((fiber) => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return zipRight2(restore(interruptAs(self.state.fiber, combine2(fiber.id(), internalFiberId))), sync3(() => {
    if (self.state._tag === "Open") {
      self.state.fiber = void 0;
    }
  }));
}));
var constInterruptedFiber = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork(interrupt2);
    }
    return fiber;
  };
}();
var run = function() {
  const self = arguments[0];
  if (isEffect(arguments[1])) {
    return runImpl(self, arguments[1], arguments[2]);
  }
  const options = arguments[1];
  return (effect3) => runImpl(self, effect3, options);
};
var runImpl = (self, effect3, options) => fiberIdWith((fiberId4) => {
  if (self.state._tag === "Closed") {
    return interrupt2;
  } else if (self.state.fiber !== void 0 && options?.onlyIfMissing === true) {
    return sync3(constInterruptedFiber);
  }
  return tap2(forkDaemon2(effect3), (fiber) => unsafeSet2(self, fiber, {
    ...options,
    interruptAs: fiberId4
  }));
});
var runtime2 = (self) => () => map7(runtime(), (runtime4) => {
  const runFork3 = runFork2(runtime4);
  return (effect3, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber();
    } else if (self.state.fiber !== void 0 && options?.onlyIfMissing === true) {
      return constInterruptedFiber();
    }
    const fiber = runFork3(effect3, options);
    unsafeSet2(self, fiber, options);
    return fiber;
  };
});
var runtimePromise = (self) => () => map7(runtime2(self)(), (runFork3) => (effect3, options) => new Promise((resolve, reject3) => runFork3(effect3, options).addObserver((exit3) => {
  if (isSuccess(exit3)) {
    resolve(exit3.value);
  } else {
    reject3(squash(exit3.cause));
  }
})));
var join = (self) => _await(self.deferred);
var awaitEmpty = (self) => suspend2(() => {
  if (self.state._tag === "Closed" || self.state.fiber === void 0) {
    return _void;
  }
  return _await2(self.state.fiber);
});

// node_modules/effect/dist/esm/FiberMap.js
var FiberMap_exports = {};
__export(FiberMap_exports, {
  TypeId: () => TypeId7,
  awaitEmpty: () => awaitEmpty2,
  clear: () => clear5,
  get: () => get11,
  has: () => has5,
  isFiberMap: () => isFiberMap,
  join: () => join2,
  make: () => make27,
  makeRuntime: () => makeRuntime2,
  makeRuntimePromise: () => makeRuntimePromise2,
  remove: () => remove3,
  run: () => run2,
  runtime: () => runtime3,
  runtimePromise: () => runtimePromise2,
  set: () => set9,
  size: () => size4,
  unsafeGet: () => unsafeGet6,
  unsafeHas: () => unsafeHas,
  unsafeSet: () => unsafeSet3
});
var TypeId7 = Symbol.for("effect/FiberMap");
var isFiberMap = (u) => hasProperty(u, TypeId7);
var Proto3 = {
  [TypeId7]: TypeId7,
  [Symbol.iterator]() {
    if (this.state._tag === "Closed") {
      return empty();
    }
    return this.state.backing[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "FiberMap",
      state: this.state
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var unsafeMake7 = (backing, deferred) => {
  const self = Object.create(Proto3);
  self.state = {
    _tag: "Open",
    backing
  };
  self.deferred = deferred;
  return self;
};
var make27 = () => acquireRelease2(map7(make7(), (deferred) => unsafeMake7(empty6(), deferred)), (map18) => withFiberRuntime2((parent) => {
  const state = map18.state;
  if (state._tag === "Closed") return _void;
  map18.state = {
    _tag: "Closed"
  };
  return interruptAllAs(map2(state.backing, ([, fiber]) => fiber), combine2(parent.id(), internalFiberId2)).pipe(intoDeferred(map18.deferred));
}));
var makeRuntime2 = () => flatMap2(make27(), (self) => runtime3(self)());
var makeRuntimePromise2 = () => flatMap2(make27(), (self) => runtimePromise2(self)());
var internalFiberIdId2 = -1;
var internalFiberId2 = make4(internalFiberIdId2, 0);
var isInternalInterruption2 = reduceWithContext(void 0, {
  emptyCase: constFalse,
  failCase: constFalse,
  dieCase: constFalse,
  interruptCase: (_, fiberId4) => has(ids(fiberId4), internalFiberIdId2),
  sequentialCase: (_, left2, right2) => left2 || right2,
  parallelCase: (_, left2, right2) => left2 || right2
});
var unsafeSet3 = dual((args) => isFiberMap(args[0]), (self, key, fiber, options) => {
  if (self.state._tag === "Closed") {
    fiber.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId2));
    return;
  }
  const previous = get4(self.state.backing, key);
  if (previous._tag === "Some") {
    if (options?.onlyIfMissing === true) {
      fiber.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId2));
      return;
    } else if (previous.value === fiber) {
      return;
    }
    previous.value.unsafeInterruptAsFork(combine2(options?.interruptAs ?? none2, internalFiberId2));
  }
  set3(self.state.backing, key, fiber);
  fiber.addObserver((exit3) => {
    if (self.state._tag === "Closed") {
      return;
    }
    const current = get4(self.state.backing, key);
    if (isSome(current) && fiber === current.value) {
      remove2(self.state.backing, key);
    }
    if (isFailure(exit3) && (options?.propagateInterruption === true ? !isInternalInterruption2(exit3.cause) : !isInterruptedOnly(exit3.cause))) {
      unsafeDone(self.deferred, exit3);
    }
  });
});
var set9 = dual((args) => isFiberMap(args[0]), (self, key, fiber, options) => fiberIdWith((fiberId4) => sync3(() => unsafeSet3(self, key, fiber, {
  ...options,
  interruptAs: fiberId4
}))));
var unsafeGet6 = dual(2, (self, key) => self.state._tag === "Closed" ? none() : get4(self.state.backing, key));
var get11 = dual(2, (self, key) => suspend2(() => unsafeGet6(self, key)));
var unsafeHas = dual(2, (self, key) => self.state._tag === "Closed" ? false : has3(self.state.backing, key));
var has5 = dual(2, (self, key) => sync3(() => unsafeHas(self, key)));
var remove3 = dual(2, (self, key) => withFiberRuntime2((removeFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  const fiber = get4(self.state.backing, key);
  if (fiber._tag === "None") {
    return _void;
  }
  return interruptAs(fiber.value, combine2(removeFiber.id(), internalFiberId2));
}));
var clear5 = (self) => withFiberRuntime2((clearFiber) => {
  if (self.state._tag === "Closed") {
    return _void;
  }
  return forEach(self.state.backing, ([, fiber]) => (
    // will be removed by the observer
    interruptAs(fiber, combine2(clearFiber.id(), internalFiberId2))
  ));
});
var constInterruptedFiber2 = /* @__PURE__ */ function() {
  let fiber = void 0;
  return () => {
    if (fiber === void 0) {
      fiber = runFork(interrupt2);
    }
    return fiber;
  };
}();
var run2 = function() {
  const self = arguments[0];
  if (isEffect(arguments[2])) {
    return runImpl2(self, arguments[1], arguments[2], arguments[3]);
  }
  const key = arguments[1];
  const options = arguments[2];
  return (effect3) => runImpl2(self, key, effect3, options);
};
var runImpl2 = (self, key, effect3, options) => fiberIdWith((fiberId4) => {
  if (self.state._tag === "Closed") {
    return interrupt2;
  } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
    return sync3(constInterruptedFiber2);
  }
  return tap2(forkDaemon2(effect3), (fiber) => unsafeSet3(self, key, fiber, {
    ...options,
    interruptAs: fiberId4
  }));
});
var runtime3 = (self) => () => map7(runtime(), (runtime4) => {
  const runFork3 = runFork2(runtime4);
  return (key, effect3, options) => {
    if (self.state._tag === "Closed") {
      return constInterruptedFiber2();
    } else if (options?.onlyIfMissing === true && unsafeHas(self, key)) {
      return constInterruptedFiber2();
    }
    const fiber = runFork3(effect3, options);
    unsafeSet3(self, key, fiber, options);
    return fiber;
  };
});
var runtimePromise2 = (self) => () => map7(runtime3(self)(), (runFork3) => (key, effect3, options) => new Promise((resolve, reject3) => runFork3(key, effect3, options).addObserver((exit3) => {
  if (isSuccess(exit3)) {
    resolve(exit3.value);
  } else {
    reject3(squash(exit3.cause));
  }
})));
var size4 = (self) => sync3(() => self.state._tag === "Closed" ? 0 : size2(self.state.backing));
var join2 = (self) => _await(self.deferred);
var awaitEmpty2 = (self) => whileLoop({
  while: () => self.state._tag === "Open" && size2(self.state.backing) > 0,
  body: () => _await2(unsafeHead(self)[1]),
  step: constVoid
});

// node_modules/effect/dist/esm/GroupBy.js
var GroupBy_exports = {};
__export(GroupBy_exports, {
  GroupByTypeId: () => GroupByTypeId2,
  evaluate: () => evaluate2,
  filter: () => filter6,
  first: () => first3,
  make: () => make28
});
var GroupByTypeId2 = GroupByTypeId;
var evaluate2 = evaluate;
var filter6 = filter5;
var first3 = first2;
var make28 = make22;

// node_modules/effect/dist/esm/HKT.js
var HKT_exports = {};

// node_modules/effect/dist/esm/KeyedPool.js
var KeyedPool_exports = {};
__export(KeyedPool_exports, {
  KeyedPoolTypeId: () => KeyedPoolTypeId2,
  get: () => get13,
  invalidate: () => invalidate2,
  make: () => make30,
  makeWith: () => makeWith4,
  makeWithTTL: () => makeWithTTL3,
  makeWithTTLBy: () => makeWithTTLBy2
});

// node_modules/effect/dist/esm/internal/keyedPool.js
var KeyedPoolSymbolKey = "effect/KeyedPool";
var KeyedPoolTypeId = Symbol.for(KeyedPoolSymbolKey);
var KeyedPoolMapValueSymbol = Symbol.for("effect/KeyedPool/MapValue");
var keyedPoolVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var KeyedPoolImpl = class {
  getOrCreatePool;
  activePools;
  [KeyedPoolTypeId] = keyedPoolVariance;
  constructor(getOrCreatePool, activePools) {
    this.getOrCreatePool = getOrCreatePool;
    this.activePools = activePools;
  }
  get(key) {
    return flatMap(this.getOrCreatePool(key), get9);
  }
  invalidate(item) {
    return flatMap(this.activePools, forEachSequentialDiscard((pool) => pool.invalidate(item)));
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var Complete = class {
  pool;
  _tag = "Complete";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(pool) {
    this.pool = pool;
  }
  [symbol2]() {
    return pipe(string("effect/KeyedPool/Complete"), combine(hash(this.pool)), cached(this));
  }
  [symbol3](u) {
    return isComplete(u) && equals(this.pool, u.pool);
  }
};
var isComplete = (u) => isTagged(u, "Complete") && KeyedPoolMapValueSymbol in u;
var Pending = class {
  deferred;
  _tag = "Pending";
  [KeyedPoolMapValueSymbol] = KeyedPoolMapValueSymbol;
  constructor(deferred) {
    this.deferred = deferred;
  }
  [symbol2]() {
    return pipe(string("effect/KeyedPool/Pending"), combine(hash(this.deferred)), cached(this));
  }
  [symbol3](u) {
    return isPending(u) && equals(this.deferred, u.deferred);
  }
};
var isPending = (u) => isTagged(u, "Pending") && KeyedPoolMapValueSymbol in u;
var makeImpl = (get37, min, max, timeToLive) => pipe(all([context(), fiberId, sync(() => make3(empty4())), scopeMake()]), map5(([context5, fiberId4, map18, scope]) => {
  const getOrCreatePool = (key) => suspend(() => {
    let value7 = getOrUndefined(get3(get2(map18), key));
    if (value7 === void 0) {
      return uninterruptibleMask((restore) => {
        const deferred = deferredUnsafeMake(fiberId4);
        value7 = new Pending(deferred);
        let previous = void 0;
        if (has2(get2(map18), key)) {
          previous = getOrUndefined(get3(get2(map18), key));
        } else {
          update(map18, set2(key, value7));
        }
        if (previous === void 0) {
          return pipe(restore(scopeExtend(makeWithTTL({
            acquire: provideContext(get37(key), context5),
            min: min(key),
            max: max(key),
            timeToLive: getOrElse(timeToLive(key), () => infinity)
          }), scope)), matchCauseEffect({
            onFailure: (cause) => {
              const current = getOrUndefined(get3(get2(map18), key));
              if (equals(current, value7)) {
                update(map18, remove(key));
              }
              return zipRight(deferredFailCause(deferred, cause), failCause(cause));
            },
            onSuccess: (pool) => {
              update(map18, set2(key, new Complete(pool)));
              return as(deferredSucceed(deferred, pool), pool);
            }
          }));
        }
        switch (previous._tag) {
          case "Complete": {
            return succeed(previous.pool);
          }
          case "Pending": {
            return restore(deferredAwait(previous.deferred));
          }
        }
      });
    }
    switch (value7._tag) {
      case "Complete": {
        return succeed(value7.pool);
      }
      case "Pending": {
        return deferredAwait(value7.deferred);
      }
    }
  });
  const activePools = suspend(() => forEachSequential(toValues(get2(map18)), (value7) => {
    switch (value7._tag) {
      case "Complete": {
        return succeed(value7.pool);
      }
      case "Pending": {
        return deferredAwait(value7.deferred);
      }
    }
  }));
  return new KeyedPoolImpl(getOrCreatePool, activePools);
}));
var make29 = (options) => makeImpl(options.acquire, () => options.size, () => options.size, () => none());
var makeWith3 = (options) => makeImpl(options.acquire, options.size, options.size, () => none());
var makeWithTTL2 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeImpl(options.acquire, options.min, options.max, () => some(timeToLive));
};
var makeWithTTLBy = (options) => makeImpl(options.acquire, options.min, options.max, (key) => some(decode(options.timeToLive(key))));
var get12 = dual(2, (self, key) => self.get(key));
var invalidate = dual(2, (self, item) => self.invalidate(item));

// node_modules/effect/dist/esm/KeyedPool.js
var KeyedPoolTypeId2 = KeyedPoolTypeId;
var make30 = make29;
var makeWith4 = makeWith3;
var makeWithTTL3 = makeWithTTL2;
var makeWithTTLBy2 = makeWithTTLBy;
var get13 = get12;
var invalidate2 = invalidate;

// node_modules/effect/dist/esm/LayerMap.js
var LayerMap_exports = {};
__export(LayerMap_exports, {
  Service: () => Service,
  TypeId: () => TypeId10,
  fromRecord: () => fromRecord,
  make: () => make33
});

// node_modules/effect/dist/esm/RcMap.js
var RcMap_exports = {};
__export(RcMap_exports, {
  TypeId: () => TypeId9,
  get: () => get15,
  invalidate: () => invalidate4,
  keys: () => keys4,
  make: () => make32,
  touch: () => touch2
});

// node_modules/effect/dist/esm/internal/rcMap.js
var TypeId8 = Symbol.for("effect/RcMap");
var variance = {
  _K: identity,
  _A: identity,
  _E: identity
};
var RcMapImpl = class {
  lookup;
  context;
  scope;
  idleTimeToLive;
  capacity;
  [TypeId8];
  state = {
    _tag: "Open",
    map: empty6()
  };
  semaphore = unsafeMakeSemaphore(1);
  constructor(lookup, context5, scope, idleTimeToLive, capacity) {
    this.lookup = lookup;
    this.context = context5;
    this.scope = scope;
    this.idleTimeToLive = idleTimeToLive;
    this.capacity = capacity;
    this[TypeId8] = variance;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make31 = (options) => withFiberRuntime((fiber) => {
  const context5 = fiber.getFiberRef(currentContext);
  const scope = get(context5, scopeTag);
  const self = new RcMapImpl(options.lookup, context5, scope, options.idleTimeToLive ? decode(options.idleTimeToLive) : void 0, Math.max(options.capacity ?? Number.POSITIVE_INFINITY, 0));
  return as(scope.addFinalizer(() => suspend(() => {
    if (self.state._tag === "Closed") {
      return void_;
    }
    const map18 = self.state.map;
    self.state = {
      _tag: "Closed"
    };
    return forEachSequentialDiscard(map18, ([, entry]) => scopeClose(entry.scope, exitVoid)).pipe(tap(() => {
      clear(map18);
    }), self.semaphore.withPermits(1));
  })), self);
});
var get14 = dual(2, (self_, key) => {
  const self = self_;
  return uninterruptibleMask((restore) => getImpl(self, key, restore));
});
var getImpl = fnUntraced(function* (self, key, restore) {
  if (self.state._tag === "Closed") {
    return yield* interrupt;
  }
  const state = self.state;
  const o = get4(state.map, key);
  let entry;
  if (o._tag === "Some") {
    entry = o.value;
    entry.refCount++;
  } else if (Number.isFinite(self.capacity) && size2(self.state.map) >= self.capacity) {
    return yield* fail(new ExceededCapacityException(`RcMap attempted to exceed capacity of ${self.capacity}`));
  } else {
    entry = yield* self.semaphore.withPermits(1)(acquire(self, key, restore));
  }
  const scope = yield* scopeTag;
  yield* scope.addFinalizer(() => entry.finalizer);
  return yield* restore(deferredAwait(entry.deferred));
});
var acquire = fnUntraced(function* (self, key, restore) {
  const scope = yield* scopeMake();
  const deferred = yield* deferredMake();
  const acquire4 = self.lookup(key);
  const contextMap = new Map(self.context.unsafeMap);
  yield* restore(mapInputContext(acquire4, (inputContext) => {
    inputContext.unsafeMap.forEach((value7, key2) => {
      contextMap.set(key2, value7);
    });
    contextMap.set(scopeTag.key, scope);
    return unsafeMake(contextMap);
  })).pipe(exit, flatMap((exit3) => deferredDone(deferred, exit3)), forkIn(scope));
  const entry = {
    deferred,
    scope,
    finalizer: void 0,
    fiber: void 0,
    expiresAt: 0,
    refCount: 1
  };
  entry.finalizer = release(self, key, entry);
  if (self.state._tag === "Open") {
    set3(self.state.map, key, entry);
  }
  return entry;
});
var release = (self, key, entry) => clockWith((clock2) => {
  entry.refCount--;
  if (entry.refCount > 0) {
    return void_;
  } else if (self.state._tag === "Closed" || !has3(self.state.map, key) || self.idleTimeToLive === void 0) {
    if (self.state._tag === "Open") {
      remove2(self.state.map, key);
    }
    return scopeClose(entry.scope, exitVoid);
  }
  if (!isFinite(self.idleTimeToLive)) {
    return void_;
  }
  entry.expiresAt = clock2.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  if (entry.fiber) return void_;
  return interruptibleMask(function loop3(restore) {
    const now = clock2.unsafeCurrentTimeMillis();
    const remaining = entry.expiresAt - now;
    if (remaining <= 0) {
      if (self.state._tag === "Closed" || entry.refCount > 0) return void_;
      remove2(self.state.map, key);
      return restore(scopeClose(entry.scope, exitVoid));
    }
    return flatMap(clock2.sleep(millis(remaining)), () => loop3(restore));
  }).pipe(ensuring(sync(() => {
    entry.fiber = void 0;
  })), forkIn(self.scope), tap((fiber) => {
    entry.fiber = fiber;
  }), self.semaphore.withPermits(1));
});
var keys3 = (self) => {
  const impl = self;
  return suspend(() => impl.state._tag === "Closed" ? interrupt : succeed(keys(impl.state.map)));
};
var invalidate3 = dual(2, fnUntraced(function* (self_, key) {
  const self = self_;
  if (self.state._tag === "Closed") return;
  const o = get4(self.state.map, key);
  if (o._tag === "None") return;
  const entry = o.value;
  remove2(self.state.map, key);
  if (entry.refCount > 0) return;
  yield* scopeClose(entry.scope, exitVoid);
  if (entry.fiber) yield* interruptFiber(entry.fiber);
}));
var touch = dual(2, (self_, key) => clockWith((clock2) => {
  const self = self_;
  if (!self.idleTimeToLive || self.state._tag === "Closed") return void_;
  const o = get4(self.state.map, key);
  if (o._tag === "None") return void_;
  o.value.expiresAt = clock2.unsafeCurrentTimeMillis() + toMillis(self.idleTimeToLive);
  return void_;
}));

// node_modules/effect/dist/esm/RcMap.js
var TypeId9 = TypeId8;
var make32 = make31;
var get15 = get14;
var keys4 = keys3;
var invalidate4 = invalidate3;
var touch2 = touch;

// node_modules/effect/dist/esm/LayerMap.js
var TypeId10 = Symbol.for("effect/LayerMap");
var make33 = fnUntraced2(function* (lookup, options) {
  const context5 = yield* context2();
  const memoMap = context5.unsafeMap.has(CurrentMemoMap.key) ? get(context5, CurrentMemoMap) : yield* makeMemoMap;
  const rcMap = yield* make32({
    lookup: (key) => scopeWith((scope) => diffFiberRefs(buildWithMemoMap(lookup(key), memoMap, scope))).pipe(map7(([patch4, context6]) => ({
      layer: scopedContext(withFiberRuntime((fiber) => {
        const scope = unsafeGet(fiber.currentContext, Scope);
        const oldRefs = fiber.getFiberRefs();
        const newRefs = patch2(patch4, fiber.id(), oldRefs);
        const revert = diff2(newRefs, oldRefs);
        fiber.setFiberRefs(newRefs);
        return as2(addFinalizerExit(scope, () => {
          fiber.setFiberRefs(patch2(revert, fiber.id(), fiber.getFiberRefs()));
          return _void;
        }), context6);
      })),
      runtimeEffect: withFiberRuntime2((fiber) => {
        const fiberRefs = patch2(patch4, fiber.id(), fiber.getFiberRefs());
        return succeed4(make17({
          context: context6,
          fiberRefs,
          runtimeFlags: defaultRuntime.runtimeFlags
        }));
      })
    }))),
    idleTimeToLive: options?.idleTimeToLive
  });
  return identity({
    [TypeId10]: TypeId10,
    rcMap,
    get: (key) => unwrapScoped(map7(get15(rcMap, key), ({
      layer
    }) => layer)),
    runtime: (key) => flatMap2(get15(rcMap, key), ({
      runtimeEffect
    }) => runtimeEffect),
    invalidate: (key) => invalidate4(rcMap, key)
  });
});
var fromRecord = (layers, options) => make33((key) => layers[key], options);
var Service = () => (id, options) => {
  const Err = globalThis.Error;
  const limit = Err.stackTraceLimit;
  Err.stackTraceLimit = 2;
  const creationError = new Err();
  Err.stackTraceLimit = limit;
  function TagClass() {
  }
  const TagClass_ = TagClass;
  Object.setPrototypeOf(TagClass, Object.getPrototypeOf(GenericTag(id)));
  TagClass.key = id;
  Object.defineProperty(TagClass, "stack", {
    get() {
      return creationError.stack;
    }
  });
  TagClass_.DefaultWithoutDependencies = scoped2(TagClass_, "lookup" in options ? make33(options.lookup, options) : fromRecord(options.layers, options));
  TagClass_.Default = options.dependencies && options.dependencies.length > 0 ? provide(TagClass_.DefaultWithoutDependencies, options.dependencies) : TagClass_.DefaultWithoutDependencies;
  TagClass_.get = (key) => unwrapScoped(map7(TagClass_, (layerMap) => layerMap.get(key)));
  TagClass_.runtime = (key) => flatMap2(TagClass_, (layerMap) => layerMap.runtime(key));
  TagClass_.invalidate = (key) => flatMap2(TagClass_, (layerMap) => layerMap.invalidate(key));
  return TagClass;
};

// node_modules/effect/dist/esm/Match.js
var Match_exports = {};
__export(Match_exports, {
  MatcherTypeId: () => MatcherTypeId,
  SafeRefinementId: () => SafeRefinementId,
  any: () => any2,
  bigint: () => bigint,
  boolean: () => boolean,
  date: () => date,
  defined: () => defined2,
  discriminator: () => discriminator2,
  discriminatorStartsWith: () => discriminatorStartsWith2,
  discriminators: () => discriminators2,
  discriminatorsExhaustive: () => discriminatorsExhaustive2,
  either: () => either3,
  exhaustive: () => exhaustive2,
  instanceOf: () => instanceOf2,
  instanceOfUnsafe: () => instanceOfUnsafe,
  is: () => is3,
  nonEmptyString: () => nonEmptyString2,
  not: () => not2,
  null: () => _null,
  number: () => number,
  option: () => option3,
  orElse: () => orElse3,
  orElseAbsurd: () => orElseAbsurd2,
  record: () => record,
  string: () => string2,
  symbol: () => symbol4,
  tag: () => tag2,
  tagStartsWith: () => tagStartsWith2,
  tags: () => tags2,
  tagsExhaustive: () => tagsExhaustive2,
  type: () => type2,
  typeTags: () => typeTags2,
  undefined: () => _undefined,
  value: () => value4,
  valueTags: () => valueTags2,
  when: () => when4,
  whenAnd: () => whenAnd2,
  whenOr: () => whenOr2,
  withReturnType: () => withReturnType2
});

// node_modules/effect/dist/esm/internal/matcher.js
var TypeId11 = Symbol.for("@effect/matcher/Matcher");
var TypeMatcherProto = {
  [TypeId11]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _return: identity
  },
  _tag: "TypeMatcher",
  add(_case) {
    return makeTypeMatcher([...this.cases, _case]);
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeTypeMatcher(cases) {
  const matcher = Object.create(TypeMatcherProto);
  matcher.cases = cases;
  return matcher;
}
var ValueMatcherProto = {
  [TypeId11]: {
    _input: identity,
    _filters: identity,
    _remaining: identity,
    _result: identity,
    _provided: identity,
    _return: identity
  },
  _tag: "ValueMatcher",
  add(_case) {
    if (this.value._tag === "Right") {
      return this;
    }
    if (_case._tag === "When" && _case.guard(this.provided) === true) {
      return makeValueMatcher(this.provided, right(_case.evaluate(this.provided)));
    } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
      return makeValueMatcher(this.provided, right(_case.evaluate(this.provided)));
    }
    return this;
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
function makeValueMatcher(provided, value7) {
  const matcher = Object.create(ValueMatcherProto);
  matcher.provided = provided;
  matcher.value = value7;
  return matcher;
}
var makeWhen = (guard, evaluate3) => ({
  _tag: "When",
  guard,
  evaluate: evaluate3
});
var makeNot = (guard, evaluate3) => ({
  _tag: "Not",
  guard,
  evaluate: evaluate3
});
var makePredicate = (pattern) => {
  if (typeof pattern === "function") {
    return pattern;
  } else if (Array.isArray(pattern)) {
    const predicates = pattern.map(makePredicate);
    const len = predicates.length;
    return (u) => {
      if (!Array.isArray(u)) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (predicates[i](u[i]) === false) {
          return false;
        }
      }
      return true;
    };
  } else if (pattern !== null && typeof pattern === "object") {
    const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
    const len = keysAndPredicates.length;
    return (u) => {
      if (typeof u !== "object" || u === null) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        const [key, predicate] = keysAndPredicates[i];
        if (!(key in u) || predicate(u[key]) === false) {
          return false;
        }
      }
      return true;
    };
  }
  return (u) => u === pattern;
};
var makeOrPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === true) {
        return true;
      }
    }
    return false;
  };
};
var makeAndPredicate = (patterns) => {
  const predicates = patterns.map(makePredicate);
  const len = predicates.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (predicates[i](u) === false) {
        return false;
      }
    }
    return true;
  };
};
var type = () => makeTypeMatcher([]);
var value3 = (i) => makeValueMatcher(i, left(i));
var valueTags = dual(2, (input, fields) => {
  const match19 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return match19(input);
});
var typeTags = () => (fields) => {
  const match19 = tagsExhaustive(fields)(makeTypeMatcher([]));
  return (input) => match19(input);
};
var withReturnType = () => (self) => self;
var when3 = (pattern, f) => (self) => self.add(makeWhen(makePredicate(pattern), f));
var whenOr = (...args) => (self) => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeOrPredicate(patterns), onMatch));
};
var whenAnd = (...args) => (self) => {
  const onMatch = args[args.length - 1];
  const patterns = args.slice(0, -1);
  return self.add(makeWhen(makeAndPredicate(patterns), onMatch));
};
var discriminator = (field) => (...pattern) => {
  const f = pattern[pattern.length - 1];
  const values7 = pattern.slice(0, -1);
  const pred = values7.length === 1 ? (_) => _[field] === values7[0] : (_) => values7.includes(_[field]);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminatorStartsWith = (field) => (pattern, f) => {
  const pred = (_) => typeof _[field] === "string" && _[field].startsWith(pattern);
  return (self) => self.add(makeWhen(pred, f));
};
var discriminators = (field) => (fields) => {
  const predicate = makeWhen((arg) => arg != null && arg[field] in fields, (data) => fields[data[field]](data));
  return (self) => self.add(predicate);
};
var discriminatorsExhaustive = (field) => (fields) => {
  const addCases = discriminators(field)(fields);
  return (matcher) => exhaustive(addCases(matcher));
};
var tag = discriminator("_tag");
var tagStartsWith = discriminatorStartsWith("_tag");
var tags = discriminators("_tag");
var tagsExhaustive = discriminatorsExhaustive("_tag");
var not = (pattern, f) => (self) => self.add(makeNot(makePredicate(pattern), f));
var nonEmptyString = (u) => typeof u === "string" && u.length > 0;
var is2 = (...literals) => {
  const len = literals.length;
  return (u) => {
    for (let i = 0; i < len; i++) {
      if (u === literals[i]) {
        return true;
      }
    }
    return false;
  };
};
var any = () => true;
var defined = (u) => u !== void 0 && u !== null;
var instanceOf = (constructor) => (u) => u instanceof constructor;
var orElse2 = (f) => (self) => {
  const result = either2(self);
  if (isEither(result)) {
    return result._tag === "Right" ? result.right : f(result.left);
  }
  return (input) => {
    const a = result(input);
    return a._tag === "Right" ? a.right : f(a.left);
  };
};
var orElseAbsurd = (self) => orElse2(() => {
  throw new Error("effect/Match/orElseAbsurd: absurd");
})(self);
var either2 = (self) => {
  if (self._tag === "ValueMatcher") {
    return self.value;
  }
  const len = self.cases.length;
  if (len === 1) {
    const _case = self.cases[0];
    return (input) => {
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right(_case.evaluate(input));
      }
      return left(input);
    };
  }
  return (input) => {
    for (let i = 0; i < len; i++) {
      const _case = self.cases[i];
      if (_case._tag === "When" && _case.guard(input) === true) {
        return right(_case.evaluate(input));
      } else if (_case._tag === "Not" && _case.guard(input) === false) {
        return right(_case.evaluate(input));
      }
    }
    return left(input);
  };
};
var option2 = (self) => {
  const toEither = either2(self);
  if (isEither(toEither)) {
    return match(toEither, {
      onLeft: () => none(),
      onRight: some
    });
  }
  return (input) => match(toEither(input), {
    onLeft: () => none(),
    onRight: some
  });
};
var getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
var exhaustive = (self) => {
  const toEither = either2(self);
  if (isEither(toEither)) {
    if (toEither._tag === "Right") {
      return toEither.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  }
  return (u) => {
    const result = toEither(u);
    if (result._tag === "Right") {
      return result.right;
    }
    throw new Error(getExhaustiveAbsurdErrorMessage);
  };
};

// node_modules/effect/dist/esm/Match.js
var MatcherTypeId = TypeId11;
var type2 = type;
var value4 = value3;
var valueTags2 = valueTags;
var typeTags2 = typeTags;
var withReturnType2 = withReturnType;
var when4 = when3;
var whenOr2 = whenOr;
var whenAnd2 = whenAnd;
var discriminator2 = discriminator;
var discriminatorStartsWith2 = discriminatorStartsWith;
var discriminators2 = discriminators;
var discriminatorsExhaustive2 = discriminatorsExhaustive;
var tag2 = tag;
var tagStartsWith2 = tagStartsWith;
var tags2 = tags;
var tagsExhaustive2 = tagsExhaustive;
var not2 = not;
var nonEmptyString2 = nonEmptyString;
var is3 = is2;
var string2 = isString;
var number = isNumber;
var any2 = any;
var defined2 = defined;
var boolean = isBoolean;
var _undefined = isUndefined;
var _null = isNull;
var bigint = isBigInt;
var symbol4 = isSymbol;
var date = isDate;
var record = isRecord;
var instanceOf2 = instanceOf;
var instanceOfUnsafe = instanceOf;
var orElse3 = orElse2;
var orElseAbsurd2 = orElseAbsurd;
var either3 = either2;
var option3 = option2;
var exhaustive2 = exhaustive;
var SafeRefinementId = Symbol.for("effect/SafeRefinement");
var Fail = Symbol.for("effect/Fail");

// node_modules/effect/dist/esm/MergeState.js
var MergeState_exports = {};
__export(MergeState_exports, {
  BothRunning: () => BothRunning2,
  LeftDone: () => LeftDone2,
  MergeStateTypeId: () => MergeStateTypeId2,
  RightDone: () => RightDone2,
  isBothRunning: () => isBothRunning2,
  isLeftDone: () => isLeftDone2,
  isMergeState: () => isMergeState2,
  isRightDone: () => isRightDone2,
  match: () => match11
});
var MergeStateTypeId2 = MergeStateTypeId;
var BothRunning2 = BothRunning;
var LeftDone2 = LeftDone;
var RightDone2 = RightDone;
var isMergeState2 = isMergeState;
var isBothRunning2 = isBothRunning;
var isLeftDone2 = isLeftDone;
var isRightDone2 = isRightDone;
var match11 = match6;

// node_modules/effect/dist/esm/MergeStrategy.js
var MergeStrategy_exports = {};
__export(MergeStrategy_exports, {
  BackPressure: () => BackPressure2,
  BufferSliding: () => BufferSliding2,
  MergeStrategyTypeId: () => MergeStrategyTypeId2,
  isBackPressure: () => isBackPressure2,
  isBufferSliding: () => isBufferSliding2,
  isMergeStrategy: () => isMergeStrategy2,
  match: () => match12
});
var MergeStrategyTypeId2 = MergeStrategyTypeId;
var BackPressure2 = BackPressure;
var BufferSliding2 = BufferSliding;
var isMergeStrategy2 = isMergeStrategy;
var isBackPressure2 = isBackPressure;
var isBufferSliding2 = isBufferSliding;
var match12 = match7;

// node_modules/effect/dist/esm/Metric.js
var Metric_exports = {};
__export(Metric_exports, {
  MetricTypeId: () => MetricTypeId2,
  counter: () => counter7,
  fiberActive: () => fiberActive2,
  fiberFailures: () => fiberFailures2,
  fiberLifetimes: () => fiberLifetimes2,
  fiberStarted: () => fiberStarted2,
  fiberSuccesses: () => fiberSuccesses2,
  frequency: () => frequency6,
  fromMetricKey: () => fromMetricKey2,
  gauge: () => gauge6,
  globalMetricRegistry: () => globalMetricRegistry2,
  histogram: () => histogram6,
  increment: () => increment2,
  incrementBy: () => incrementBy2,
  make: () => make34,
  map: () => map11,
  mapInput: () => mapInput3,
  mapType: () => mapType2,
  modify: () => modify5,
  set: () => set10,
  snapshot: () => snapshot2,
  succeed: () => succeed6,
  summary: () => summary6,
  summaryTimestamp: () => summaryTimestamp2,
  sync: () => sync5,
  tagged: () => tagged3,
  taggedWithLabels: () => taggedWithLabels3,
  taggedWithLabelsInput: () => taggedWithLabelsInput2,
  timer: () => timer2,
  timerWithBoundaries: () => timerWithBoundaries2,
  trackAll: () => trackAll2,
  trackDefect: () => trackDefect2,
  trackDefectWith: () => trackDefectWith2,
  trackDuration: () => trackDuration2,
  trackDurationWith: () => trackDurationWith2,
  trackError: () => trackError2,
  trackErrorWith: () => trackErrorWith2,
  trackSuccess: () => trackSuccess2,
  trackSuccessWith: () => trackSuccessWith2,
  unsafeSnapshot: () => unsafeSnapshot2,
  update: () => update6,
  value: () => value5,
  withConstantInput: () => withConstantInput2,
  withNow: () => withNow2,
  zip: () => zip4
});
var MetricTypeId2 = MetricTypeId;
var globalMetricRegistry2 = globalMetricRegistry;
var make34 = make13;
var mapInput3 = mapInput2;
var counter7 = counter5;
var frequency6 = frequency5;
var withConstantInput2 = withConstantInput;
var fromMetricKey2 = fromMetricKey;
var gauge6 = gauge5;
var histogram6 = histogram5;
var increment2 = increment;
var incrementBy2 = incrementBy;
var map11 = map6;
var mapType2 = mapType;
var modify5 = modify2;
var set10 = set6;
var snapshot2 = snapshot;
var succeed6 = succeed3;
var sync5 = sync2;
var summary6 = summary5;
var summaryTimestamp2 = summaryTimestamp;
var tagged3 = tagged2;
var taggedWithLabelsInput2 = taggedWithLabelsInput;
var taggedWithLabels3 = taggedWithLabels2;
var timer2 = timer;
var timerWithBoundaries2 = timerWithBoundaries;
var trackAll2 = trackAll;
var trackDefect2 = trackDefect;
var trackDefectWith2 = trackDefectWith;
var trackDuration2 = trackDuration;
var trackDurationWith2 = trackDurationWith;
var trackError2 = trackError;
var trackErrorWith2 = trackErrorWith;
var trackSuccess2 = trackSuccess;
var trackSuccessWith2 = trackSuccessWith;
var update6 = update4;
var value5 = value;
var withNow2 = withNow;
var zip4 = zip2;
var unsafeSnapshot2 = unsafeSnapshot;
var fiberStarted2 = fiberStarted;
var fiberSuccesses2 = fiberSuccesses;
var fiberFailures2 = fiberFailures;
var fiberLifetimes2 = fiberLifetimes;
var fiberActive2 = fiberActive;

// node_modules/effect/dist/esm/MetricBoundaries.js
var MetricBoundaries_exports = {};
__export(MetricBoundaries_exports, {
  MetricBoundariesTypeId: () => MetricBoundariesTypeId2,
  exponential: () => exponential2,
  fromIterable: () => fromIterable8,
  isMetricBoundaries: () => isMetricBoundaries2,
  linear: () => linear2
});
var MetricBoundariesTypeId2 = MetricBoundariesTypeId;
var isMetricBoundaries2 = isMetricBoundaries;
var fromIterable8 = fromIterable5;
var linear2 = linear;
var exponential2 = exponential;

// node_modules/effect/dist/esm/MetricHook.js
var MetricHook_exports = {};
__export(MetricHook_exports, {
  MetricHookTypeId: () => MetricHookTypeId2,
  counter: () => counter8,
  frequency: () => frequency7,
  gauge: () => gauge7,
  histogram: () => histogram7,
  make: () => make35,
  onModify: () => onModify2,
  onUpdate: () => onUpdate2,
  summary: () => summary7
});
var MetricHookTypeId2 = MetricHookTypeId;
var make35 = make10;
var counter8 = counter4;
var frequency7 = frequency4;
var gauge7 = gauge4;
var histogram7 = histogram4;
var summary7 = summary4;
var onUpdate2 = onUpdate;
var onModify2 = onModify;

// node_modules/effect/dist/esm/MetricKey.js
var MetricKey_exports = {};
__export(MetricKey_exports, {
  MetricKeyTypeId: () => MetricKeyTypeId2,
  counter: () => counter9,
  frequency: () => frequency8,
  gauge: () => gauge8,
  histogram: () => histogram8,
  isMetricKey: () => isMetricKey2,
  summary: () => summary8,
  tagged: () => tagged4,
  taggedWithLabels: () => taggedWithLabels4
});
var MetricKeyTypeId2 = MetricKeyTypeId;
var isMetricKey2 = isMetricKey;
var counter9 = counter2;
var frequency8 = frequency2;
var gauge8 = gauge2;
var histogram8 = histogram2;
var summary8 = summary2;
var tagged4 = tagged;
var taggedWithLabels4 = taggedWithLabels;

// node_modules/effect/dist/esm/MetricKeyType.js
var MetricKeyType_exports = {};
__export(MetricKeyType_exports, {
  CounterKeyTypeTypeId: () => CounterKeyTypeTypeId2,
  FrequencyKeyTypeTypeId: () => FrequencyKeyTypeTypeId2,
  GaugeKeyTypeTypeId: () => GaugeKeyTypeTypeId2,
  HistogramKeyTypeTypeId: () => HistogramKeyTypeTypeId2,
  MetricKeyTypeTypeId: () => MetricKeyTypeTypeId2,
  SummaryKeyTypeTypeId: () => SummaryKeyTypeTypeId2,
  counter: () => counter10,
  frequency: () => frequency9,
  gauge: () => gauge9,
  histogram: () => histogram9,
  isCounterKey: () => isCounterKey2,
  isFrequencyKey: () => isFrequencyKey2,
  isGaugeKey: () => isGaugeKey2,
  isHistogramKey: () => isHistogramKey2,
  isMetricKeyType: () => isMetricKeyType2,
  isSummaryKey: () => isSummaryKey2,
  summary: () => summary9
});
var MetricKeyTypeTypeId2 = MetricKeyTypeTypeId;
var CounterKeyTypeTypeId2 = CounterKeyTypeTypeId;
var FrequencyKeyTypeTypeId2 = FrequencyKeyTypeTypeId;
var GaugeKeyTypeTypeId2 = GaugeKeyTypeTypeId;
var HistogramKeyTypeTypeId2 = HistogramKeyTypeTypeId;
var SummaryKeyTypeTypeId2 = SummaryKeyTypeTypeId;
var counter10 = counter;
var frequency9 = frequency;
var gauge9 = gauge;
var histogram9 = histogram;
var summary9 = summary;
var isMetricKeyType2 = isMetricKeyType;
var isCounterKey2 = isCounterKey;
var isFrequencyKey2 = isFrequencyKey;
var isGaugeKey2 = isGaugeKey;
var isHistogramKey2 = isHistogramKey;
var isSummaryKey2 = isSummaryKey;

// node_modules/effect/dist/esm/MetricLabel.js
var MetricLabel_exports = {};
__export(MetricLabel_exports, {
  MetricLabelTypeId: () => MetricLabelTypeId2,
  isMetricLabel: () => isMetricLabel2,
  make: () => make36
});
var MetricLabelTypeId2 = MetricLabelTypeId;
var make36 = make9;
var isMetricLabel2 = isMetricLabel;

// node_modules/effect/dist/esm/MetricPair.js
var MetricPair_exports = {};
__export(MetricPair_exports, {
  MetricPairTypeId: () => MetricPairTypeId2,
  make: () => make37,
  unsafeMake: () => unsafeMake8
});
var MetricPairTypeId2 = MetricPairTypeId;
var make37 = make11;
var unsafeMake8 = unsafeMake3;

// node_modules/effect/dist/esm/MetricPolling.js
var MetricPolling_exports = {};
__export(MetricPolling_exports, {
  MetricPollingTypeId: () => MetricPollingTypeId2,
  collectAll: () => collectAll2,
  launch: () => launch2,
  make: () => make39,
  poll: () => poll3,
  pollAndUpdate: () => pollAndUpdate2,
  retry: () => retry3,
  zip: () => zip6
});

// node_modules/effect/dist/esm/internal/metric/polling.js
var MetricPollingSymbolKey = "effect/MetricPolling";
var MetricPollingTypeId = Symbol.for(MetricPollingSymbolKey);
var make38 = (metric, poll6) => {
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric,
    poll: poll6
  };
};
var collectAll = (iterable) => {
  const metrics = Array.from(iterable);
  return {
    [MetricPollingTypeId]: MetricPollingTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    metric: make13(Array.of(void 0), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeUpdate(input, extraTags);
      }
    }, (extraTags) => Array.from(metrics.map((pollingMetric) => pollingMetric.metric.unsafeValue(extraTags))), (inputs, extraTags) => {
      for (let i = 0; i < inputs.length; i++) {
        const pollingMetric = metrics[i];
        const input = pipe(inputs, (x) => x[i]);
        pollingMetric.metric.unsafeModify(input, extraTags);
      }
    }),
    poll: forEachSequential(metrics, (metric) => metric.poll)
  };
};
var launch = dual(2, (self, schedule) => pipe(pollAndUpdate(self), zipRight(value(self.metric)), scheduleForked(schedule)));
var poll2 = (self) => self.poll;
var pollAndUpdate = (self) => flatMap(self.poll, (value7) => update4(self.metric, value7));
var retry2 = dual(2, (self, policy) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: self.metric,
  poll: retry_Effect(self.poll, policy)
}));
var zip5 = dual(2, (self, that) => ({
  [MetricPollingTypeId]: MetricPollingTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  metric: pipe(self.metric, zip2(that.metric)),
  poll: zip(self.poll, that.poll)
}));

// node_modules/effect/dist/esm/MetricPolling.js
var MetricPollingTypeId2 = MetricPollingTypeId;
var make39 = make38;
var collectAll2 = collectAll;
var launch2 = launch;
var poll3 = poll2;
var pollAndUpdate2 = pollAndUpdate;
var retry3 = retry2;
var zip6 = zip5;

// node_modules/effect/dist/esm/MetricRegistry.js
var MetricRegistry_exports = {};
__export(MetricRegistry_exports, {
  MetricRegistryTypeId: () => MetricRegistryTypeId2,
  make: () => make40
});
var MetricRegistryTypeId2 = MetricRegistryTypeId;
var make40 = make12;

// node_modules/effect/dist/esm/MetricState.js
var MetricState_exports = {};
__export(MetricState_exports, {
  CounterStateTypeId: () => CounterStateTypeId2,
  FrequencyStateTypeId: () => FrequencyStateTypeId2,
  GaugeStateTypeId: () => GaugeStateTypeId2,
  HistogramStateTypeId: () => HistogramStateTypeId2,
  MetricStateTypeId: () => MetricStateTypeId2,
  SummaryStateTypeId: () => SummaryStateTypeId2,
  counter: () => counter11,
  frequency: () => frequency10,
  gauge: () => gauge10,
  histogram: () => histogram10,
  isCounterState: () => isCounterState2,
  isFrequencyState: () => isFrequencyState2,
  isGaugeState: () => isGaugeState2,
  isHistogramState: () => isHistogramState2,
  isMetricState: () => isMetricState2,
  isSummaryState: () => isSummaryState2,
  summary: () => summary10
});
var MetricStateTypeId2 = MetricStateTypeId;
var CounterStateTypeId2 = CounterStateTypeId;
var FrequencyStateTypeId2 = FrequencyStateTypeId;
var GaugeStateTypeId2 = GaugeStateTypeId;
var HistogramStateTypeId2 = HistogramStateTypeId;
var SummaryStateTypeId2 = SummaryStateTypeId;
var counter11 = counter3;
var frequency10 = frequency3;
var gauge10 = gauge3;
var histogram10 = histogram3;
var summary10 = summary3;
var isMetricState2 = isMetricState;
var isCounterState2 = isCounterState;
var isFrequencyState2 = isFrequencyState;
var isGaugeState2 = isGaugeState;
var isHistogramState2 = isHistogramState;
var isSummaryState2 = isSummaryState;

// node_modules/effect/dist/esm/ModuleVersion.js
var ModuleVersion_exports = {};
__export(ModuleVersion_exports, {
  getCurrentVersion: () => getCurrentVersion2,
  setCurrentVersion: () => setCurrentVersion2
});
var getCurrentVersion2 = getCurrentVersion;
var setCurrentVersion2 = setCurrentVersion;

// node_modules/effect/dist/esm/MutableHashSet.js
var MutableHashSet_exports = {};
__export(MutableHashSet_exports, {
  add: () => add3,
  clear: () => clear6,
  empty: () => empty9,
  fromIterable: () => fromIterable9,
  has: () => has6,
  make: () => make41,
  remove: () => remove4,
  size: () => size5
});
var TypeId12 = Symbol.for("effect/MutableHashSet");
var MutableHashSetProto = {
  [TypeId12]: TypeId12,
  [Symbol.iterator]() {
    return Array.from(this.keyMap).map(([_]) => _)[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "MutableHashSet",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var fromHashMap = (keyMap) => {
  const set22 = Object.create(MutableHashSetProto);
  set22.keyMap = keyMap;
  return set22;
};
var empty9 = () => fromHashMap(empty6());
var fromIterable9 = (keys10) => fromHashMap(fromIterable4(Array.from(keys10).map((k) => [k, true])));
var make41 = (...keys10) => fromIterable9(keys10);
var add3 = dual(2, (self, key) => (set3(self.keyMap, key, true), self));
var has6 = dual(2, (self, key) => has3(self.keyMap, key));
var remove4 = dual(2, (self, key) => (remove2(self.keyMap, key), self));
var size5 = (self) => size2(self.keyMap);
var clear6 = (self) => (clear(self.keyMap), self);

// node_modules/effect/dist/esm/NonEmptyIterable.js
var NonEmptyIterable_exports = {};
__export(NonEmptyIterable_exports, {
  unprepend: () => unprepend
});
var unprepend = (self) => {
  const iterator = self[Symbol.iterator]();
  const next3 = iterator.next();
  if (next3.done) {
    throw new Error("BUG: NonEmptyIterator should not be empty - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  return [next3.value, iterator];
};

// node_modules/effect/dist/esm/Ordering.js
var Ordering_exports = {};
__export(Ordering_exports, {
  combine: () => combine3,
  combineAll: () => combineAll,
  combineMany: () => combineMany,
  match: () => match13,
  reverse: () => reverse
});
var reverse = (o) => o === -1 ? 1 : o === 1 ? -1 : 0;
var match13 = dual(2, (self, {
  onEqual,
  onGreaterThan,
  onLessThan
}) => self === -1 ? onLessThan() : self === 0 ? onEqual() : onGreaterThan());
var combine3 = dual(2, (self, that) => self !== 0 ? self : that);
var combineMany = dual(2, (self, collection) => {
  let ordering = self;
  if (ordering !== 0) {
    return ordering;
  }
  for (ordering of collection) {
    if (ordering !== 0) {
      return ordering;
    }
  }
  return ordering;
});
var combineAll = (collection) => combineMany(0, collection);

// node_modules/effect/dist/esm/Pretty.js
var Pretty_exports = {};
__export(Pretty_exports, {
  make: () => make42,
  match: () => match14
});
var make42 = (schema) => compile(schema.ast, []);
var getPrettyAnnotation = getAnnotation(PrettyAnnotationId);
var getMatcher = (defaultPretty) => (ast) => match2(getPrettyAnnotation(ast), {
  onNone: () => defaultPretty,
  onSome: (handler) => handler()
});
var toString = getMatcher((a) => String(a));
var stringify = getMatcher((a) => JSON.stringify(a));
var formatUnknown2 = getMatcher(formatUnknown);
var match14 = {
  "Declaration": (ast, go2, path) => {
    const annotation = getPrettyAnnotation(ast);
    if (isSome(annotation)) {
      return annotation.value(...ast.typeParameters.map((tp) => go2(tp, path)));
    }
    throw new Error(getPrettyMissingAnnotationErrorMessage(path, ast));
  },
  "VoidKeyword": getMatcher(() => "void(0)"),
  "NeverKeyword": getMatcher(() => {
    throw new Error(getPrettyNeverErrorMessage);
  }),
  "Literal": getMatcher((literal) => typeof literal === "bigint" ? `${String(literal)}n` : JSON.stringify(literal)),
  "SymbolKeyword": toString,
  "UniqueSymbol": toString,
  "TemplateLiteral": stringify,
  "UndefinedKeyword": toString,
  "UnknownKeyword": formatUnknown2,
  "AnyKeyword": formatUnknown2,
  "ObjectKeyword": formatUnknown2,
  "StringKeyword": stringify,
  "NumberKeyword": toString,
  "BooleanKeyword": toString,
  "BigIntKeyword": getMatcher((a) => `${String(a)}n`),
  "Enums": stringify,
  "TupleType": (ast, go2, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome(hook)) {
      return hook.value();
    }
    const elements = ast.elements.map((e, i) => go2(e.type, path.concat(i)));
    const rest = ast.rest.map((annotatedAST) => go2(annotatedAST.type, path));
    return (input) => {
      const output = [];
      let i = 0;
      for (; i < elements.length; i++) {
        if (input.length < i + 1) {
          if (ast.elements[i].isOptional) {
            continue;
          }
        } else {
          output.push(elements[i](input[i]));
        }
      }
      if (isNonEmptyReadonlyArray(rest)) {
        const [head3, ...tail] = rest;
        for (; i < input.length - tail.length; i++) {
          output.push(head3(input[i]));
        }
        for (let j = 0; j < tail.length; j++) {
          i += j;
          output.push(tail[j](input[i]));
        }
      }
      return "[" + output.join(", ") + "]";
    };
  },
  "TypeLiteral": (ast, go2, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome(hook)) {
      return hook.value();
    }
    const propertySignaturesTypes = ast.propertySignatures.map((ps) => go2(ps.type, path.concat(ps.name)));
    const indexSignatureTypes = ast.indexSignatures.map((is4) => go2(is4.type, path));
    const expectedKeys = {};
    for (let i = 0; i < propertySignaturesTypes.length; i++) {
      expectedKeys[ast.propertySignatures[i].name] = null;
    }
    return (input) => {
      const output = [];
      for (let i = 0; i < propertySignaturesTypes.length; i++) {
        const ps = ast.propertySignatures[i];
        const name = ps.name;
        if (ps.isOptional && !Object.prototype.hasOwnProperty.call(input, name)) {
          continue;
        }
        output.push(`${formatPropertyKey(name)}: ${propertySignaturesTypes[i](input[name])}`);
      }
      if (indexSignatureTypes.length > 0) {
        for (let i = 0; i < indexSignatureTypes.length; i++) {
          const type3 = indexSignatureTypes[i];
          const keys10 = getKeysForIndexSignature(input, ast.indexSignatures[i].parameter);
          for (const key of keys10) {
            if (Object.prototype.hasOwnProperty.call(expectedKeys, key)) {
              continue;
            }
            output.push(`${formatPropertyKey(key)}: ${type3(input[key])}`);
          }
        }
      }
      return isNonEmptyReadonlyArray(output) ? "{ " + output.join(", ") + " }" : "{}";
    };
  },
  "Union": (ast, go2, path) => {
    const hook = getPrettyAnnotation(ast);
    if (isSome(hook)) {
      return hook.value();
    }
    const types = ast.types.map((ast2) => [is({
      ast: ast2
    }), go2(ast2, path)]);
    return (a) => {
      const index = types.findIndex(([is4]) => is4(a));
      if (index === -1) {
        throw new Error(getPrettyNoMatchingSchemaErrorMessage(a, path, ast));
      }
      return types[index][1](a);
    };
  },
  "Suspend": (ast, go2, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => {
        const get37 = memoizeThunk(() => go2(ast.f(), path));
        return (a) => get37()(a);
      },
      onSome: (handler) => handler()
    });
  },
  "Refinement": (ast, go2, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go2(ast.from, path),
      onSome: (handler) => handler()
    });
  },
  "Transformation": (ast, go2, path) => {
    return match2(getPrettyAnnotation(ast), {
      onNone: () => go2(ast.to, path),
      onSome: (handler) => handler()
    });
  }
};
var compile = getCompiler(match14);

// node_modules/effect/dist/esm/RateLimiter.js
var RateLimiter_exports = {};
__export(RateLimiter_exports, {
  make: () => make44,
  withCost: () => withCost2
});

// node_modules/effect/dist/esm/internal/rateLimiter.js
var make43 = ({
  algorithm = "token-bucket",
  interval,
  limit
}) => {
  switch (algorithm) {
    case "fixed-window": {
      return fixedWindow(limit, interval);
    }
    case "token-bucket": {
      return tokenBucket(limit, interval);
    }
  }
};
var tokenBucket = (limit, window) => gen2(function* () {
  const millisPerToken = Math.ceil(toMillis(window) / limit);
  const semaphore = yield* makeSemaphore(limit);
  const latch = yield* makeSemaphore(0);
  const refill = sleep(millisPerToken).pipe(zipRight2(latch.releaseAll), zipRight2(semaphore.release(1)), flatMap2((free) => free === limit ? _void : refill));
  yield* pipe(latch.take(1), zipRight2(refill), forever, forkScoped, interruptible3);
  const take3 = uninterruptibleMask2((restore) => flatMap2(get7(currentCost), (cost) => zipRight2(restore(semaphore.take(cost)), latch.release(1))));
  return (effect3) => zipRight2(take3, effect3);
});
var fixedWindow = (limit, window) => gen2(function* () {
  const semaphore = yield* makeSemaphore(limit);
  const latch = yield* makeSemaphore(0);
  yield* pipe(latch.take(1), zipRight2(sleep(window)), zipRight2(latch.releaseAll), zipRight2(semaphore.releaseAll), forever, forkScoped, interruptible3);
  const take3 = uninterruptibleMask2((restore) => flatMap2(get7(currentCost), (cost) => zipRight2(restore(semaphore.take(cost)), latch.release(1))));
  return (effect3) => zipRight2(take3, effect3);
});
var currentCost = globalValue(Symbol.for("effect/RateLimiter/currentCost"), () => unsafeMake4(1));
var withCost = (cost) => locally(currentCost, cost);

// node_modules/effect/dist/esm/RateLimiter.js
var make44 = make43;
var withCost2 = withCost;

// node_modules/effect/dist/esm/Reloadable.js
var Reloadable_exports = {};
__export(Reloadable_exports, {
  ReloadableTypeId: () => ReloadableTypeId2,
  auto: () => auto2,
  autoFromConfig: () => autoFromConfig2,
  get: () => get18,
  manual: () => manual2,
  reload: () => reload2,
  reloadFork: () => reloadFork2,
  tag: () => tag3
});

// node_modules/effect/dist/esm/internal/scopedRef.js
var ScopedRefSymbolKey = "effect/ScopedRef";
var ScopedRefTypeId = Symbol.for(ScopedRefSymbolKey);
var scopedRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var proto = {
  ...CommitPrototype,
  commit() {
    return get16(this);
  },
  [ScopedRefTypeId]: scopedRefVariance
};
var close2 = (self) => flatMap(get5(self.ref), (tuple) => tuple[0].close(exitVoid));
var fromAcquire = (acquire4) => uninterruptible(scopeMake().pipe(flatMap((newScope) => acquire4.pipe(mapInputContext(add(scopeTag, newScope)), onError((cause) => newScope.close(exitFail(cause))), flatMap((value7) => makeSynchronized([newScope, value7]).pipe(flatMap((ref) => {
  const scopedRef = Object.create(proto);
  scopedRef.ref = ref;
  return pipe(addFinalizer(() => close2(scopedRef)), as(scopedRef));
})))))));
var get16 = (self) => map5(get5(self.ref), (tuple) => tuple[1]);
var make45 = (evaluate3) => fromAcquire(sync(evaluate3));
var set11 = dual(2, (self, acquire4) => flatten(modifyEffect(self.ref, ([oldScope, value7]) => uninterruptible(scopeClose(oldScope, exitVoid).pipe(zipRight(scopeMake()), flatMap((newScope) => exit(scopeExtend(acquire4, newScope)).pipe(flatMap((exit3) => exitMatch(exit3, {
  onFailure: (cause) => scopeClose(newScope, exitVoid).pipe(as([failCause(cause), [oldScope, value7]])),
  onSuccess: (value8) => succeed([void_, [newScope, value8]])
})))))))));

// node_modules/effect/dist/esm/internal/reloadable.js
var ReloadableSymbolKey = "effect/Reloadable";
var ReloadableTypeId = Symbol.for(ReloadableSymbolKey);
var reloadableVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var auto = (tag4, options) => scoped(reloadableTag(tag4), pipe(build(manual(tag4, {
  layer: options.layer
})), map5(unsafeGet(reloadableTag(tag4))), tap((reloadable) => acquireRelease(pipe(reloadable.reload, ignoreLogged, schedule_Effect(options.schedule), forkDaemon), interruptFiber))));
var autoFromConfig = (tag4, options) => scoped(reloadableTag(tag4), pipe(context(), flatMap((env) => pipe(build(auto(tag4, {
  layer: options.layer,
  schedule: options.scheduleFromConfig(env)
})), map5(unsafeGet(reloadableTag(tag4)))))));
var get17 = (tag4) => flatMap(reloadableTag(tag4), (reloadable) => get16(reloadable.scopedRef));
var manual = (tag4, options) => scoped(reloadableTag(tag4), pipe(context(), flatMap((env) => pipe(fromAcquire(pipe(build(options.layer), map5(unsafeGet(tag4)))), map5((ref) => ({
  [ReloadableTypeId]: reloadableVariance,
  scopedRef: ref,
  reload: pipe(set11(ref, pipe(build(options.layer), map5(unsafeGet(tag4)))), provideContext(env))
}))))));
var reloadableTag = (tag4) => {
  return GenericTag(`effect/Reloadable<${tag4.key}>`);
};
var reload = (tag4) => flatMap(reloadableTag(tag4), (reloadable) => reloadable.reload);
var reloadFork = (tag4) => flatMap(reloadableTag(tag4), (reloadable) => pipe(reloadable.reload, ignoreLogged, forkDaemon, asVoid));

// node_modules/effect/dist/esm/Reloadable.js
var ReloadableTypeId2 = ReloadableTypeId;
var auto2 = auto;
var autoFromConfig2 = autoFromConfig;
var get18 = get17;
var manual2 = manual;
var reload2 = reload;
var tag3 = reloadableTag;
var reloadFork2 = reloadFork;

// node_modules/effect/dist/esm/RequestBlock.js
var RequestBlock_exports = {};
__export(RequestBlock_exports, {
  empty: () => empty10,
  mapRequestResolvers: () => mapRequestResolvers2,
  parallel: () => parallel,
  reduce: () => reduce7,
  sequential: () => sequential,
  single: () => single2
});
var single2 = single;
var empty10 = empty5;
var mapRequestResolvers2 = mapRequestResolvers;
var parallel = par;
var reduce7 = reduce3;
var sequential = seq;

// node_modules/effect/dist/esm/RequestResolver.js
var RequestResolver_exports = {};
__export(RequestResolver_exports, {
  RequestResolverTypeId: () => RequestResolverTypeId2,
  around: () => around2,
  aroundRequests: () => aroundRequests2,
  batchN: () => batchN2,
  contextFromEffect: () => contextFromEffect,
  contextFromServices: () => contextFromServices,
  eitherWith: () => eitherWith2,
  fromEffect: () => fromEffect4,
  fromEffectTagged: () => fromEffectTagged2,
  fromFunction: () => fromFunction2,
  fromFunctionBatched: () => fromFunctionBatched2,
  isRequestResolver: () => isRequestResolver2,
  locally: () => locally2,
  make: () => make47,
  makeBatched: () => makeBatched2,
  makeWithEntry: () => makeWithEntry2,
  mapInputContext: () => mapInputContext4,
  never: () => never3,
  provideContext: () => provideContext4,
  race: () => race3
});

// node_modules/effect/dist/esm/internal/dataSource.js
var make46 = (runAll) => new RequestResolverImpl((requests) => runAll(requests.map((_) => _.map((_2) => _2.request))));
var makeWithEntry = (runAll) => new RequestResolverImpl((requests) => runAll(requests));
var makeBatched = (run3) => new RequestResolverImpl((requests) => {
  if (requests.length > 1) {
    return forEachSequentialDiscard(requests, (block) => {
      const filtered = block.filter((_) => !_.state.completed).map((_) => _.request);
      if (!isNonEmptyArray(filtered)) {
        return void_;
      }
      return invokeWithInterrupt(run3(filtered), block);
    });
  } else if (requests.length === 1) {
    const filtered = requests[0].filter((_) => !_.state.completed).map((_) => _.request);
    if (!isNonEmptyArray(filtered)) {
      return void_;
    }
    return run3(filtered);
  }
  return void_;
});
var around = dual(3, (self, before, after) => new RequestResolverImpl((requests) => acquireUseRelease(before, () => self.runAll(requests), after), make2("Around", self, before, after)));
var aroundRequests = dual(3, (self, before, after) => new RequestResolverImpl((requests) => {
  const flatRequests = requests.flatMap((chunk3) => chunk3.map((entry) => entry.request));
  return acquireUseRelease(before(flatRequests), () => self.runAll(requests), (a2) => after(flatRequests, a2));
}, make2("AroundRequests", self, before, after)));
var batchN = dual(2, (self, n) => new RequestResolverImpl((requests) => {
  return n < 1 ? die(new IllegalArgumentException("RequestResolver.batchN: n must be at least 1")) : self.runAll(Array.from(map4(reduce(requests, empty2(), (acc, chunk3) => appendAll(acc, chunksOf(unsafeFromArray(chunk3), n))), (chunk3) => Array.from(chunk3))));
}, make2("BatchN", self, n)));
var mapInputContext3 = dual(2, (self, f) => new RequestResolverImpl((requests) => mapInputContext(self.runAll(requests), (context5) => f(context5)), make2("MapInputContext", self, f)));
var eitherWith = dual(3, (self, that, f) => new RequestResolverImpl((batch) => pipe(forEachSequential(batch, (requests) => {
  const [as5, bs] = pipe(requests, partitionMap(f));
  return zipWithOptions(self.runAll(Array.of(as5)), that.runAll(Array.of(bs)), () => void 0, {
    concurrent: true
  });
})), make2("EitherWith", self, that, f)));
var fromFunction = (f) => makeBatched((requests) => forEachSequentialDiscard(requests, (request) => complete(request, exitSucceed(f(request))))).identified("FromFunction", f);
var fromFunctionBatched = (f) => makeBatched((as5) => forEach(f(as5), (res, i) => complete(as5[i], exitSucceed(res)), {
  discard: true
})).identified("FromFunctionBatched", f);
var fromEffect3 = (f) => makeBatched((requests) => forEach(requests, (a) => flatMap2(exit2(f(a)), (e) => complete(a, e)), {
  concurrency: "unbounded",
  discard: true
})).identified("FromEffect", f);
var fromEffectTagged = () => (fns) => makeBatched((requests) => {
  const grouped = {};
  const tags3 = [];
  for (let i = 0, len = requests.length; i < len; i++) {
    if (tags3.includes(requests[i]._tag)) {
      grouped[requests[i]._tag].push(requests[i]);
    } else {
      grouped[requests[i]._tag] = [requests[i]];
      tags3.push(requests[i]._tag);
    }
  }
  return forEach(tags3, (tag4) => matchCauseEffect2(fns[tag4](grouped[tag4]), {
    onFailure: (cause) => forEach(grouped[tag4], (req) => complete(req, exitFail(cause)), {
      discard: true
    }),
    onSuccess: (res) => forEach(grouped[tag4], (req, i) => complete(req, exitSucceed(res[i])), {
      discard: true
    })
  }), {
    concurrency: "unbounded",
    discard: true
  });
}).identified("FromEffectTagged", fns);
var never2 = make46(() => never).identified("Never");
var provideContext3 = dual(2, (self, context5) => mapInputContext3(self, (_) => context5).identified("ProvideContext", self, context5));
var race2 = dual(2, (self, that) => new RequestResolverImpl((requests) => race(self.runAll(requests), that.runAll(requests))).identified("Race", self, that));

// node_modules/effect/dist/esm/RequestResolver.js
var RequestResolverTypeId2 = RequestResolverTypeId;
var contextFromEffect = (self) => contextWith((_) => provideContext4(self, _));
var contextFromServices = (...services) => (self) => contextWith((_) => provideContext4(self, pick(...services)(_)));
var isRequestResolver2 = isRequestResolver;
var make47 = make46;
var makeWithEntry2 = makeWithEntry;
var makeBatched2 = makeBatched;
var around2 = around;
var aroundRequests2 = aroundRequests;
var batchN2 = batchN;
var mapInputContext4 = mapInputContext3;
var eitherWith2 = eitherWith;
var fromFunction2 = fromFunction;
var fromFunctionBatched2 = fromFunctionBatched;
var fromEffect4 = fromEffect3;
var fromEffectTagged2 = fromEffectTagged;
var never3 = never2;
var provideContext4 = provideContext3;
var race3 = race2;
var locally2 = resolverLocally;

// node_modules/effect/dist/esm/Resource.js
var Resource_exports = {};
__export(Resource_exports, {
  ResourceTypeId: () => ResourceTypeId2,
  auto: () => auto4,
  get: () => get20,
  manual: () => manual4,
  refresh: () => refresh2
});

// node_modules/effect/dist/esm/internal/resource.js
var ResourceSymbolKey = "effect/Resource";
var ResourceTypeId = Symbol.for(ResourceSymbolKey);
var resourceVariance = {
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var proto2 = {
  ...CommitPrototype,
  commit() {
    return get19(this);
  },
  [ResourceTypeId]: resourceVariance
};
var auto3 = (acquire4, policy) => tap(manual3(acquire4), (manual5) => acquireRelease(pipe(refresh(manual5), schedule_Effect(policy), interruptible2, forkDaemon), interruptFiber));
var manual3 = (acquire4) => flatMap(context(), (env) => pipe(fromAcquire(exit(acquire4)), map5((ref) => {
  const resource = Object.create(proto2);
  resource.scopedRef = ref;
  resource.acquire = provideContext(acquire4, env);
  return resource;
})));
var get19 = (self) => flatMap(get16(self.scopedRef), identity);
var refresh = (self) => set11(self.scopedRef, map5(self.acquire, exitSucceed));

// node_modules/effect/dist/esm/Resource.js
var ResourceTypeId2 = ResourceTypeId;
var auto4 = auto3;
var get20 = get19;
var manual4 = manual3;
var refresh2 = refresh;

// node_modules/effect/dist/esm/RuntimeFlags.js
var RuntimeFlags_exports = {};
__export(RuntimeFlags_exports, {
  CooperativeYielding: () => CooperativeYielding2,
  Interruption: () => Interruption2,
  None: () => None2,
  OpSupervision: () => OpSupervision2,
  RuntimeMetrics: () => RuntimeMetrics2,
  WindDown: () => WindDown2,
  cooperativeYielding: () => cooperativeYielding2,
  diff: () => diff3,
  differ: () => differ2,
  disable: () => disable2,
  disableAll: () => disableAll2,
  disableCooperativeYielding: () => disableCooperativeYielding2,
  disableInterruption: () => disableInterruption2,
  disableOpSupervision: () => disableOpSupervision2,
  disableRuntimeMetrics: () => disableRuntimeMetrics2,
  disableWindDown: () => disableWindDown2,
  enable: () => enable2,
  enableAll: () => enableAll2,
  enableCooperativeYielding: () => enableCooperativeYielding2,
  enableInterruption: () => enableInterruption2,
  enableOpSupervision: () => enableOpSupervision2,
  enableRuntimeMetrics: () => enableRuntimeMetrics2,
  enableWindDown: () => enableWindDown2,
  interruptible: () => interruptible4,
  interruption: () => interruption2,
  isDisabled: () => isDisabled2,
  isEnabled: () => isEnabled2,
  make: () => make48,
  none: () => none6,
  opSupervision: () => opSupervision2,
  patch: () => patch3,
  render: () => render2,
  runtimeMetrics: () => runtimeMetrics2,
  toSet: () => toSet2,
  windDown: () => windDown2
});
var None2 = None;
var Interruption2 = Interruption;
var OpSupervision2 = OpSupervision;
var RuntimeMetrics2 = RuntimeMetrics;
var WindDown2 = WindDown;
var CooperativeYielding2 = CooperativeYielding;
var cooperativeYielding2 = cooperativeYielding;
var diff3 = diff;
var differ2 = differ;
var disable2 = disable;
var disableAll2 = disableAll;
var disableCooperativeYielding2 = disableCooperativeYielding;
var disableInterruption2 = disableInterruption;
var disableOpSupervision2 = disableOpSupervision;
var disableRuntimeMetrics2 = disableRuntimeMetrics;
var disableWindDown2 = disableWindDown;
var enable2 = enable;
var enableAll2 = enableAll;
var enableCooperativeYielding2 = enableCooperativeYielding;
var enableInterruption2 = enableInterruption;
var enableOpSupervision2 = enableOpSupervision;
var enableRuntimeMetrics2 = enableRuntimeMetrics;
var enableWindDown2 = enableWindDown;
var interruptible4 = interruptible;
var interruption2 = interruption;
var isEnabled2 = isEnabled;
var isDisabled2 = isDisabled;
var make48 = make6;
var none6 = none3;
var opSupervision2 = opSupervision;
var patch3 = patch;
var render2 = render;
var runtimeMetrics2 = runtimeMetrics;
var toSet2 = toSet;
var windDown2 = windDown;

// node_modules/effect/dist/esm/STM.js
var STM_exports = {};
__export(STM_exports, {
  Do: () => Do,
  STMTypeId: () => STMTypeId2,
  acquireUseRelease: () => acquireUseRelease3,
  all: () => all4,
  as: () => as4,
  asSome: () => asSome3,
  asSomeError: () => asSomeError2,
  asVoid: () => asVoid4,
  attempt: () => attempt2,
  bind: () => bind2,
  bindTo: () => bindTo2,
  catchAll: () => catchAll2,
  catchSome: () => catchSome2,
  catchTag: () => catchTag2,
  catchTags: () => catchTags2,
  check: () => check2,
  collect: () => collect2,
  collectSTM: () => collectSTM2,
  commit: () => commit2,
  commitEither: () => commitEither2,
  cond: () => cond2,
  context: () => context4,
  contextWith: () => contextWith3,
  contextWithSTM: () => contextWithSTM2,
  die: () => die4,
  dieMessage: () => dieMessage3,
  dieSync: () => dieSync2,
  either: () => either4,
  ensuring: () => ensuring4,
  eventually: () => eventually3,
  every: () => every2,
  exists: () => exists2,
  fail: () => fail4,
  failSync: () => failSync2,
  fiberId: () => fiberId3,
  filter: () => filter7,
  filterNot: () => filterNot2,
  filterOrDie: () => filterOrDie2,
  filterOrDieMessage: () => filterOrDieMessage2,
  filterOrElse: () => filterOrElse2,
  filterOrFail: () => filterOrFail3,
  firstSuccessOf: () => firstSuccessOf,
  flatMap: () => flatMap4,
  flatten: () => flatten3,
  flip: () => flip2,
  flipWith: () => flipWith2,
  forEach: () => forEach3,
  fromEither: () => fromEither2,
  fromOption: () => fromOption2,
  gen: () => gen4,
  head: () => head2,
  if: () => if_2,
  ignore: () => ignore2,
  interrupt: () => interrupt4,
  interruptAs: () => interruptAs3,
  isFailure: () => isFailure4,
  isSTM: () => isSTM2,
  isSuccess: () => isSuccess4,
  iterate: () => iterate2,
  let: () => let_2,
  loop: () => loop2,
  map: () => map12,
  mapAttempt: () => mapAttempt2,
  mapBoth: () => mapBoth2,
  mapError: () => mapError2,
  mapInputContext: () => mapInputContext5,
  match: () => match15,
  matchSTM: () => matchSTM2,
  merge: () => merge5,
  mergeAll: () => mergeAll2,
  negate: () => negate2,
  none: () => none7,
  option: () => option4,
  orDie: () => orDie2,
  orDieWith: () => orDieWith2,
  orElse: () => orElse4,
  orElseEither: () => orElseEither2,
  orElseFail: () => orElseFail2,
  orElseOptional: () => orElseOptional2,
  orElseSucceed: () => orElseSucceed2,
  orTry: () => orTry2,
  partition: () => partition3,
  provideContext: () => provideContext5,
  provideService: () => provideService2,
  provideServiceSTM: () => provideServiceSTM2,
  provideSomeContext: () => provideSomeContext2,
  reduce: () => reduce8,
  reduceAll: () => reduceAll2,
  reduceRight: () => reduceRight2,
  refineOrDie: () => refineOrDie2,
  refineOrDieWith: () => refineOrDieWith2,
  reject: () => reject2,
  rejectSTM: () => rejectSTM2,
  repeatUntil: () => repeatUntil2,
  repeatWhile: () => repeatWhile2,
  replicate: () => replicate2,
  replicateSTM: () => replicateSTM2,
  replicateSTMDiscard: () => replicateSTMDiscard2,
  retry: () => retry4,
  retryUntil: () => retryUntil2,
  retryWhile: () => retryWhile2,
  some: () => some4,
  succeed: () => succeed7,
  succeedNone: () => succeedNone3,
  succeedSome: () => succeedSome2,
  summarized: () => summarized2,
  suspend: () => suspend4,
  sync: () => sync6,
  tap: () => tap5,
  tapBoth: () => tapBoth2,
  tapError: () => tapError2,
  try: () => try_2,
  unless: () => unless2,
  unlessSTM: () => unlessSTM2,
  unsome: () => unsome2,
  validateAll: () => validateAll2,
  validateFirst: () => validateFirst2,
  void: () => void_4,
  when: () => when5,
  whenSTM: () => whenSTM2,
  zip: () => zip7,
  zipLeft: () => zipLeft3,
  zipRight: () => zipRight4,
  zipWith: () => zipWith3
});
var STMTypeId2 = STMTypeId;
var isSTM2 = isSTM;
var acquireUseRelease3 = acquireUseRelease2;
var all4 = all3;
var as4 = as3;
var asSome3 = asSome2;
var asSomeError2 = asSomeError;
var asVoid4 = asVoid3;
var attempt2 = attempt;
var catchAll2 = catchAll;
var catchSome2 = catchSome;
var catchTag2 = catchTag;
var catchTags2 = catchTags;
var check2 = check;
var collect2 = collect;
var collectSTM2 = collectSTM;
var commit2 = commit;
var commitEither2 = commitEither;
var cond2 = cond;
var context4 = context3;
var contextWith3 = contextWith2;
var contextWithSTM2 = contextWithSTM;
var mapInputContext5 = mapInputContext2;
var die4 = die2;
var dieMessage3 = dieMessage;
var dieSync2 = dieSync;
var either4 = either;
var ensuring4 = ensuring3;
var eventually3 = eventually2;
var every2 = every;
var exists2 = exists;
var fail4 = fail2;
var failSync2 = failSync;
var fiberId3 = fiberId2;
var filter7 = filter4;
var filterNot2 = filterNot;
var filterOrDie2 = filterOrDie;
var filterOrDieMessage2 = filterOrDieMessage;
var filterOrElse2 = filterOrElse;
var filterOrFail3 = filterOrFail2;
var flatMap4 = flatMap3;
var flatten3 = flatten2;
var flip2 = flip;
var flipWith2 = flipWith;
var match15 = match8;
var matchSTM2 = matchSTM;
var forEach3 = forEach2;
var fromEither2 = fromEither;
var fromOption2 = fromOption;
var gen4 = gen3;
var head2 = head;
var if_2 = if_;
var ignore2 = ignore;
var interrupt4 = interrupt3;
var interruptAs3 = interruptAs2;
var isFailure4 = isFailure2;
var isSuccess4 = isSuccess2;
var iterate2 = iterate;
var loop2 = loop;
var map12 = map8;
var mapAttempt2 = mapAttempt;
var mapBoth2 = mapBoth;
var mapError2 = mapError;
var merge5 = merge3;
var mergeAll2 = mergeAll;
var negate2 = negate;
var none7 = none5;
var option4 = option;
var orDie2 = orDie;
var orDieWith2 = orDieWith;
var orElse4 = orElse;
var orElseEither2 = orElseEither;
var orElseFail2 = orElseFail;
var orElseOptional2 = orElseOptional;
var orElseSucceed2 = orElseSucceed;
var orTry2 = orTry;
var partition3 = partition2;
var provideContext5 = provideContext2;
var provideSomeContext2 = provideSomeContext;
var provideService2 = provideService;
var provideServiceSTM2 = provideServiceSTM;
var reduce8 = reduce6;
var reduceAll2 = reduceAll;
var reduceRight2 = reduceRight;
var refineOrDie2 = refineOrDie;
var refineOrDieWith2 = refineOrDieWith;
var reject2 = reject;
var rejectSTM2 = rejectSTM;
var repeatUntil2 = repeatUntil;
var repeatWhile2 = repeatWhile;
var replicate2 = replicate;
var replicateSTM2 = replicateSTM;
var replicateSTMDiscard2 = replicateSTMDiscard;
var retry4 = retry;
var retryUntil2 = retryUntil;
var retryWhile2 = retryWhile;
var some4 = some3;
var succeed7 = succeed5;
var succeedNone3 = succeedNone2;
var succeedSome2 = succeedSome;
var summarized2 = summarized;
var suspend4 = suspend3;
var sync6 = sync4;
var tap5 = tap3;
var tapBoth2 = tapBoth;
var tapError2 = tapError;
var try_2 = try_;
var unless2 = unless;
var unlessSTM2 = unlessSTM;
var unsome2 = unsome;
var void_4 = void_3;
var validateAll2 = validateAll;
var validateFirst2 = validateFirst;
var when5 = when2;
var whenSTM2 = whenSTM;
var zip7 = zip3;
var zipLeft3 = zipLeft2;
var zipRight4 = zipRight3;
var zipWith3 = zipWith2;
var firstSuccessOf = (effects) => suspend4(() => {
  const list = fromIterable2(effects);
  if (!isNonEmpty(list)) {
    return dieSync2(() => new IllegalArgumentException(`Received an empty collection of effects`));
  }
  return reduce2(tailNonEmpty(list), headNonEmpty(list), (left2, right2) => orElse4(left2, () => right2));
});
var Do = succeed7({});
var bind2 = bind;
var let_2 = let_;
var bindTo2 = bindTo;

// node_modules/effect/dist/esm/ScopedCache.js
var ScopedCache_exports = {};
__export(ScopedCache_exports, {
  ScopedCacheTypeId: () => ScopedCacheTypeId2,
  make: () => make50,
  makeWith: () => makeWith6
});

// node_modules/effect/dist/esm/internal/scopedCache.js
var makeCacheState = (map18, keys10, accesses, updating, hits, misses) => ({
  map: map18,
  keys: keys10,
  accesses,
  updating,
  hits,
  misses
});
var initialCacheState = () => makeCacheState(empty6(), makeKeySet(), unbounded(), make3(false), 0, 0);
var complete2 = (key, exit3, ownerCount, entryStats, timeToLive) => struct({
  _tag: "Complete",
  key,
  exit: exit3,
  ownerCount,
  entryStats,
  timeToLive
});
var pending = (key, scoped3) => struct({
  _tag: "Pending",
  key,
  scoped: scoped3
});
var refreshing = (scoped3, complete3) => struct({
  _tag: "Refreshing",
  scoped: scoped3,
  complete: complete3
});
var toScoped = (self) => matchEffect(self.exit, {
  onFailure: (cause) => failCause(cause),
  onSuccess: ([value7]) => acquireRelease(as(sync(() => incrementAndGet(self.ownerCount)), value7), () => releaseOwner(self))
});
var releaseOwner = (self) => matchEffect(self.exit, {
  onFailure: () => void_,
  onSuccess: ([, finalizer]) => flatMap(sync(() => decrementAndGet(self.ownerCount)), (numOwner) => when(finalizer(void_2), () => numOwner === 0))
});
var ScopedCacheSymbolKey = "effect/ScopedCache";
var ScopedCacheTypeId = Symbol.for(ScopedCacheSymbolKey);
var scopedCacheVariance = {
  /* c8 ignore next */
  _Key: (_) => _,
  /* c8 ignore next */
  _Error: (_) => _,
  /* c8 ignore next */
  _Value: (_) => _
};
var ScopedCacheImpl = class {
  capacity;
  scopedLookup;
  clock;
  timeToLive;
  context;
  [ScopedCacheTypeId] = scopedCacheVariance;
  cacheState;
  constructor(capacity, scopedLookup, clock2, timeToLive, context5) {
    this.capacity = capacity;
    this.scopedLookup = scopedLookup;
    this.clock = clock2;
    this.timeToLive = timeToLive;
    this.context = context5;
    this.cacheState = initialCacheState();
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get cacheStats() {
    return sync(() => makeCacheStats({
      hits: this.cacheState.hits,
      misses: this.cacheState.misses,
      size: size2(this.cacheState.map)
    }));
  }
  getOption(key) {
    return suspend(() => match2(get4(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value7) => flatten(this.resolveMapValue(value7))
    }));
  }
  getOptionComplete(key) {
    return suspend(() => match2(get4(this.cacheState.map, key), {
      onNone: () => succeedNone,
      onSome: (value7) => flatten(this.resolveMapValue(value7, true))
    }));
  }
  contains(key) {
    return sync(() => has3(this.cacheState.map, key));
  }
  entryStats(key) {
    return sync(() => {
      const value7 = getOrUndefined(get4(this.cacheState.map, key));
      if (value7 === void 0) {
        return none();
      }
      switch (value7._tag) {
        case "Complete": {
          return some(makeEntryStats(value7.entryStats.loadedMillis));
        }
        case "Pending": {
          return none();
        }
        case "Refreshing": {
          return some(makeEntryStats(value7.complete.entryStats.loadedMillis));
        }
      }
    });
  }
  get(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap((lookupValue) => suspend(() => {
      let k = void 0;
      let value7 = getOrUndefined(get4(this.cacheState.map, key));
      if (value7 === void 0) {
        k = makeMapKey(key);
        if (has3(this.cacheState.map, key)) {
          value7 = getOrUndefined(get4(this.cacheState.map, key));
        } else {
          set3(this.cacheState.map, key, pending(k, lookupValue));
        }
      }
      if (value7 === void 0) {
        this.trackMiss();
        return zipRight(this.ensureMapSizeNotExceeded(k), lookupValue);
      }
      return map5(this.resolveMapValue(value7), flatMap(match2({
        onNone: () => {
          const val = value7;
          const current = getOrUndefined(get4(this.cacheState.map, key));
          if (equals(current, value7)) {
            remove2(this.cacheState.map, key);
          }
          return pipe(this.ensureMapSizeNotExceeded(val.key), zipRight(releaseOwner(val)), zipRight(this.get(key)));
        },
        onSome: succeed
      })));
    })), flatten);
  }
  invalidate(key) {
    return suspend(() => {
      if (has3(this.cacheState.map, key)) {
        const mapValue = getOrUndefined(get4(this.cacheState.map, key));
        remove2(this.cacheState.map, key);
        switch (mapValue._tag) {
          case "Complete": {
            return releaseOwner(mapValue);
          }
          case "Pending": {
            return void_;
          }
          case "Refreshing": {
            return releaseOwner(mapValue.complete);
          }
        }
      }
      return void_;
    });
  }
  get invalidateAll() {
    return forEachConcurrentDiscard(fromIterable3(Array.from(this.cacheState.map).map(([key]) => key)), (key) => this.invalidate(key), false, false);
  }
  refresh(key) {
    return pipe(this.lookupValueOf(key), memoize, flatMap((scoped3) => {
      let value7 = getOrUndefined(get4(this.cacheState.map, key));
      let newKey = void 0;
      if (value7 === void 0) {
        newKey = makeMapKey(key);
        if (has3(this.cacheState.map, key)) {
          value7 = getOrUndefined(get4(this.cacheState.map, key));
        } else {
          set3(this.cacheState.map, key, pending(newKey, scoped3));
        }
      }
      let finalScoped;
      if (value7 === void 0) {
        finalScoped = zipRight(this.ensureMapSizeNotExceeded(newKey), scoped3);
      } else {
        switch (value7._tag) {
          case "Complete": {
            if (this.hasExpired(value7.timeToLive)) {
              finalScoped = succeed(this.get(key));
            } else {
              const current = getOrUndefined(get4(this.cacheState.map, key));
              if (equals(current, value7)) {
                const mapValue = refreshing(scoped3, value7);
                set3(this.cacheState.map, key, mapValue);
                finalScoped = scoped3;
              } else {
                finalScoped = succeed(this.get(key));
              }
            }
            break;
          }
          case "Pending": {
            finalScoped = value7.scoped;
            break;
          }
          case "Refreshing": {
            finalScoped = value7.scoped;
            break;
          }
        }
      }
      return flatMap(finalScoped, (s) => scopedEffect(asVoid(s)));
    }));
  }
  get size() {
    return sync(() => size2(this.cacheState.map));
  }
  resolveMapValue(value7, ignorePending = false) {
    switch (value7._tag) {
      case "Complete": {
        this.trackHit();
        if (this.hasExpired(value7.timeToLive)) {
          return succeed(succeedNone);
        }
        return as(this.ensureMapSizeNotExceeded(value7.key), asSome(toScoped(value7)));
      }
      case "Pending": {
        this.trackHit();
        if (ignorePending) {
          return succeed(succeedNone);
        }
        return zipRight(this.ensureMapSizeNotExceeded(value7.key), map5(value7.scoped, asSome));
      }
      case "Refreshing": {
        this.trackHit();
        if (this.hasExpired(value7.complete.timeToLive)) {
          if (ignorePending) {
            return succeed(succeedNone);
          }
          return zipRight(this.ensureMapSizeNotExceeded(value7.complete.key), map5(value7.scoped, asSome));
        }
        return as(this.ensureMapSizeNotExceeded(value7.complete.key), asSome(toScoped(value7.complete)));
      }
    }
  }
  lookupValueOf(key) {
    return pipe(onInterrupt(flatMap(make15(), (scope) => pipe(this.scopedLookup(key), provideContext(pipe(this.context, add(Scope, scope))), exit, map5((exit3) => [exit3, (exit4) => close(scope, exit4)]))), () => sync(() => remove2(this.cacheState.map, key))), flatMap(([exit3, release4]) => {
      const now = this.clock.unsafeCurrentTimeMillis();
      const expiredAt = now + toMillis(this.timeToLive(exit3));
      switch (exit3._tag) {
        case "Success": {
          const exitWithFinalizer = succeed2([exit3.value, release4]);
          const completedResult = complete2(makeMapKey(key), exitWithFinalizer, make3(1), makeEntryStats(now), expiredAt);
          let previousValue = void 0;
          if (has3(this.cacheState.map, key)) {
            previousValue = getOrUndefined(get4(this.cacheState.map, key));
          }
          set3(this.cacheState.map, key, completedResult);
          return sync(() => flatten(as(this.cleanMapValue(previousValue), toScoped(completedResult))));
        }
        case "Failure": {
          const completedResult = complete2(makeMapKey(key), exit3, make3(0), makeEntryStats(now), expiredAt);
          let previousValue = void 0;
          if (has3(this.cacheState.map, key)) {
            previousValue = getOrUndefined(get4(this.cacheState.map, key));
          }
          set3(this.cacheState.map, key, completedResult);
          return zipRight(release4(exit3), sync(() => flatten(as(this.cleanMapValue(previousValue), toScoped(completedResult)))));
        }
      }
    }), memoize, flatten);
  }
  hasExpired(timeToLive) {
    return this.clock.unsafeCurrentTimeMillis() > timeToLive;
  }
  trackHit() {
    this.cacheState.hits = this.cacheState.hits + 1;
  }
  trackMiss() {
    this.cacheState.misses = this.cacheState.misses + 1;
  }
  trackAccess(key) {
    const cleanedKeys = [];
    offer(this.cacheState.accesses, key);
    if (compareAndSet(this.cacheState.updating, false, true)) {
      let loop3 = true;
      while (loop3) {
        const key2 = poll(this.cacheState.accesses, EmptyMutableQueue);
        if (key2 === EmptyMutableQueue) {
          loop3 = false;
        } else {
          this.cacheState.keys.add(key2);
        }
      }
      let size18 = size2(this.cacheState.map);
      loop3 = size18 > this.capacity;
      while (loop3) {
        const key2 = this.cacheState.keys.remove();
        if (key2 === void 0) {
          loop3 = false;
        } else {
          if (has3(this.cacheState.map, key2.current)) {
            const removed = getOrUndefined(get4(this.cacheState.map, key2.current));
            remove2(this.cacheState.map, key2.current);
            size18 = size18 - 1;
            cleanedKeys.push(removed);
            loop3 = size18 > this.capacity;
          }
        }
      }
      set(this.cacheState.updating, false);
    }
    return cleanedKeys;
  }
  cleanMapValue(mapValue) {
    if (mapValue === void 0) {
      return void_;
    }
    switch (mapValue._tag) {
      case "Complete": {
        return releaseOwner(mapValue);
      }
      case "Pending": {
        return void_;
      }
      case "Refreshing": {
        return releaseOwner(mapValue.complete);
      }
    }
  }
  ensureMapSizeNotExceeded(key) {
    return forEachConcurrentDiscard(this.trackAccess(key), (cleanedMapValue) => this.cleanMapValue(cleanedMapValue), false, false);
  }
};
var make49 = (options) => {
  const timeToLive = decode(options.timeToLive);
  return makeWith5({
    capacity: options.capacity,
    lookup: options.lookup,
    timeToLive: () => timeToLive
  });
};
var makeWith5 = (options) => flatMap(clock, (clock2) => buildWith(options.capacity, options.lookup, clock2, (exit3) => decode(options.timeToLive(exit3))));
var buildWith = (capacity, scopedLookup, clock2, timeToLive) => acquireRelease(flatMap(context(), (context5) => sync(() => new ScopedCacheImpl(capacity, scopedLookup, clock2, timeToLive, context5))), (cache) => cache.invalidateAll);

// node_modules/effect/dist/esm/ScopedCache.js
var ScopedCacheTypeId2 = ScopedCacheTypeId;
var make50 = make49;
var makeWith6 = makeWith5;

// node_modules/effect/dist/esm/ScopedRef.js
var ScopedRef_exports = {};
__export(ScopedRef_exports, {
  ScopedRefTypeId: () => ScopedRefTypeId2,
  fromAcquire: () => fromAcquire2,
  get: () => get21,
  make: () => make51,
  set: () => set12
});
var ScopedRefTypeId2 = ScopedRefTypeId;
var fromAcquire2 = fromAcquire;
var get21 = get16;
var make51 = make45;
var set12 = set11;

// node_modules/effect/dist/esm/Secret.js
var Secret_exports = {};
__export(Secret_exports, {
  SecretTypeId: () => SecretTypeId2,
  fromIterable: () => fromIterable10,
  fromString: () => fromString2,
  isSecret: () => isSecret2,
  make: () => make52,
  unsafeWipe: () => unsafeWipe2,
  value: () => value6
});
var SecretTypeId2 = SecretTypeId;
var isSecret2 = isSecret;
var make52 = make21;
var fromIterable10 = fromIterable7;
var fromString2 = fromString;
var value6 = value2;
var unsafeWipe2 = unsafeWipe;

// node_modules/effect/dist/esm/SingleProducerAsyncInput.js
var SingleProducerAsyncInput_exports = {};
__export(SingleProducerAsyncInput_exports, {
  make: () => make53
});
var make53 = make16;

// node_modules/effect/dist/esm/SortedMap.js
var SortedMap_exports = {};
__export(SortedMap_exports, {
  empty: () => empty11,
  entries: () => entries,
  fromIterable: () => fromIterable11,
  get: () => get22,
  getOrder: () => getOrder2,
  has: () => has7,
  headOption: () => headOption,
  isEmpty: () => isEmpty2,
  isNonEmpty: () => isNonEmpty2,
  isSortedMap: () => isSortedMap,
  keys: () => keys5,
  lastOption: () => lastOption,
  make: () => make54,
  map: () => map13,
  partition: () => partition4,
  reduce: () => reduce9,
  remove: () => remove5,
  set: () => set13,
  size: () => size6,
  values: () => values2
});
var TypeId13 = Symbol.for("effect/SortedMap");
var SortedMapProto = {
  [TypeId13]: {
    _K: (_) => _,
    _V: (_) => _
  },
  [symbol2]() {
    return pipe(hash(this.tree), combine(hash("effect/SortedMap")), cached(this));
  },
  [symbol3](that) {
    return isSortedMap(that) && equals(this.tree, that.tree);
  },
  [Symbol.iterator]() {
    return this.tree[Symbol.iterator]();
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "SortedMap",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl2 = (tree) => {
  const self = Object.create(SortedMapProto);
  self.tree = tree;
  return self;
};
var isSortedMap = (u) => hasProperty(u, TypeId13);
var empty11 = (ord) => makeImpl2(empty7(ord));
var fromIterable11 = dual(2, (iterable, ord) => makeImpl2(fromIterable6(iterable, ord)));
var make54 = (ord) => (...entries4) => fromIterable11(ord)(entries4);
var isEmpty2 = (self) => size6(self) === 0;
var isNonEmpty2 = (self) => size6(self) > 0;
var get22 = dual(2, (self, key) => findFirst2(self.tree, key));
var getOrder2 = (self) => getOrder(self.tree);
var has7 = dual(2, (self, key) => isSome(get22(self, key)));
var headOption = (self) => first(self.tree);
var map13 = dual(2, (self, f) => reduce9(self, empty11(getOrder(self.tree)), (acc, v, k) => set13(acc, k, f(v, k))));
var reduce9 = dual(3, (self, zero, f) => reduce5(self.tree, zero, f));
var remove5 = dual(2, (self, key) => makeImpl2(removeFirst(self.tree, key)));
var set13 = dual(3, (self, key, value7) => has4(self.tree, key) ? makeImpl2(insert(removeFirst(self.tree, key), key, value7)) : makeImpl2(insert(self.tree, key, value7)));
var size6 = (self) => size3(self.tree);
var keys5 = (self) => keys2(self.tree);
var values2 = (self) => values(self.tree);
var entries = (self) => {
  const iterator = self.tree[Symbol.iterator]();
  iterator[Symbol.iterator] = () => entries(self);
  return iterator;
};
var lastOption = (self) => last(self.tree);
var partition4 = dual(2, (self, predicate) => {
  const ord = getOrder(self.tree);
  let right2 = empty11(ord);
  let left2 = empty11(ord);
  for (const value7 of self) {
    if (predicate(value7[0])) {
      right2 = set13(right2, value7[0], value7[1]);
    } else {
      left2 = set13(left2, value7[0], value7[1]);
    }
  }
  return [left2, right2];
});

// node_modules/effect/dist/esm/StreamEmit.js
var StreamEmit_exports = {};

// node_modules/effect/dist/esm/Streamable.js
var Streamable_exports = {};
__export(Streamable_exports, {
  Class: () => Class2
});
var streamVariance = {
  /* c8 ignore next */
  _R: (_) => _,
  /* c8 ignore next */
  _E: (_) => _,
  /* c8 ignore next */
  _A: (_) => _
};
var Class2 = class {
  /**
   * @since 2.0.0
   */
  [StreamTypeId] = streamVariance;
  /**
   * @since 2.0.0
   */
  pipe() {
    return pipeArguments(this, arguments);
  }
  /**
   * @internal
   */
  get channel() {
    return toChannel(this.toStream());
  }
};

// node_modules/effect/dist/esm/Subscribable.js
var Subscribable_exports = {};
__export(Subscribable_exports, {
  TypeId: () => TypeId14,
  isSubscribable: () => isSubscribable,
  make: () => make55,
  map: () => map14,
  mapEffect: () => mapEffect2,
  unwrap: () => unwrap3
});
var TypeId14 = Symbol.for("effect/Subscribable");
var isSubscribable = (u) => hasProperty(u, TypeId14);
var Proto4 = {
  [TypeId2]: TypeId2,
  [TypeId14]: TypeId14,
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var make55 = (options) => Object.assign(Object.create(Proto4), options);
var map14 = dual(2, (self, f) => make55({
  get: map7(self.get, f),
  changes: map10(self.changes, f)
}));
var mapEffect2 = dual(2, (self, f) => make55({
  get: flatMap2(self.get, f),
  changes: mapEffect(self.changes, f)
}));
var unwrap3 = (effect3) => make55({
  get: flatMap2(effect3, (s) => s.get),
  changes: unwrap2(map7(effect3, (s) => s.changes))
});

// node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRef_exports = {};
__export(SubscriptionRef_exports, {
  SubscriptionRefTypeId: () => SubscriptionRefTypeId2,
  get: () => get25,
  getAndSet: () => getAndSet5,
  getAndUpdate: () => getAndUpdate5,
  getAndUpdateEffect: () => getAndUpdateEffect3,
  getAndUpdateSome: () => getAndUpdateSome5,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect3,
  make: () => make58,
  modify: () => modify8,
  modifyEffect: () => modifyEffect4,
  modifySome: () => modifySome5,
  modifySomeEffect: () => modifySomeEffect3,
  set: () => set16,
  setAndGet: () => setAndGet5,
  update: () => update8,
  updateAndGet: () => updateAndGet5,
  updateAndGetEffect: () => updateAndGetEffect3,
  updateEffect: () => updateEffect3,
  updateSome: () => updateSome5,
  updateSomeAndGet: () => updateSomeAndGet5,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect2,
  updateSomeEffect: () => updateSomeEffect3
});

// node_modules/effect/dist/esm/SynchronizedRef.js
var SynchronizedRef_exports = {};
__export(SynchronizedRef_exports, {
  SynchronizedRefTypeId: () => SynchronizedRefTypeId,
  get: () => get23,
  getAndSet: () => getAndSet4,
  getAndUpdate: () => getAndUpdate4,
  getAndUpdateEffect: () => getAndUpdateEffect2,
  getAndUpdateSome: () => getAndUpdateSome4,
  getAndUpdateSomeEffect: () => getAndUpdateSomeEffect2,
  make: () => make56,
  modify: () => modify6,
  modifyEffect: () => modifyEffect2,
  modifySome: () => modifySome4,
  modifySomeEffect: () => modifySomeEffect2,
  set: () => set14,
  setAndGet: () => setAndGet4,
  unsafeMake: () => unsafeMake9,
  update: () => update7,
  updateAndGet: () => updateAndGet4,
  updateAndGetEffect: () => updateAndGetEffect2,
  updateEffect: () => updateEffect2,
  updateSome: () => updateSome4,
  updateSomeAndGet: () => updateSomeAndGet4,
  updateSomeAndGetEffect: () => updateSomeAndGetEffect,
  updateSomeEffect: () => updateSomeEffect2
});
var SynchronizedRefTypeId = SynchronizedTypeId;
var make56 = makeSynchronized;
var get23 = get5;
var getAndSet4 = getAndSet;
var getAndUpdate4 = getAndUpdate;
var getAndUpdateEffect2 = getAndUpdateEffect;
var getAndUpdateSome4 = getAndUpdateSome;
var getAndUpdateSomeEffect2 = getAndUpdateSomeEffect;
var modify6 = modify3;
var modifyEffect2 = modifyEffect;
var modifySome4 = modifySome;
var modifySomeEffect2 = modifySomeEffect;
var set14 = set4;
var setAndGet4 = setAndGet;
var update7 = update2;
var updateEffect2 = updateEffect;
var updateAndGet4 = updateAndGet;
var updateAndGetEffect2 = updateAndGetEffect;
var updateSome4 = updateSome;
var updateSomeEffect2 = updateSomeEffect;
var updateSomeAndGet4 = updateSomeAndGet;
var updateSomeAndGetEffect = updateSomeAndGetEffectSynchronized;
var unsafeMake9 = unsafeMakeSynchronized;

// node_modules/effect/dist/esm/internal/subscriptionRef.js
var SubscriptionRefSymbolKey = "effect/SubscriptionRef";
var SubscriptionRefTypeId = Symbol.for(SubscriptionRefSymbolKey);
var subscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var SubscriptionRefImpl = class extends Class {
  ref;
  pubsub;
  semaphore;
  [TypeId2] = TypeId2;
  [TypeId14] = TypeId14;
  [RefTypeId] = refVariance;
  [SynchronizedRefTypeId] = synchronizedVariance;
  [SubscriptionRefTypeId] = subscriptionRefVariance;
  constructor(ref, pubsub, semaphore) {
    super();
    this.ref = ref;
    this.pubsub = pubsub;
    this.semaphore = semaphore;
    this.get = get6(this.ref);
  }
  commit() {
    return this.get;
  }
  get;
  get changes() {
    return pipe(get6(this.ref), flatMap2((a) => map7(fromPubSub(this.pubsub, {
      scoped: true
    }), (s) => concat(make20(a), s))), this.semaphore.withPermits(1), unwrapScoped2);
  }
  modify(f) {
    return this.modifyEffect((a) => succeed4(f(a)));
  }
  modifyEffect(f) {
    return pipe(get6(this.ref), flatMap2(f), flatMap2(([b, a]) => pipe(set5(this.ref, a), as2(b), zipLeft(publish(this.pubsub, a)))), this.semaphore.withPermits(1));
  }
};
var get24 = (self) => get6(self.ref);
var make57 = (value7) => pipe(all2([unbounded2(), make8(value7), makeSemaphore(1)]), map7(([pubsub, ref, semaphore]) => new SubscriptionRefImpl(ref, pubsub, semaphore)));
var modify7 = dual(2, (self, f) => self.modify(f));
var modifyEffect3 = dual(2, (self, f) => self.modifyEffect(f));
var set15 = dual(2, (self, value7) => pipe(set5(self.ref, value7), zipLeft(publish(self.pubsub, value7)), self.semaphore.withPermits(1)));

// node_modules/effect/dist/esm/SubscriptionRef.js
var SubscriptionRefTypeId2 = SubscriptionRefTypeId;
var get25 = get24;
var getAndSet5 = getAndSet2;
var getAndUpdate5 = getAndUpdate2;
var getAndUpdateEffect3 = getAndUpdateEffect2;
var getAndUpdateSome5 = getAndUpdateSome2;
var getAndUpdateSomeEffect3 = getAndUpdateSomeEffect2;
var make58 = make57;
var modify8 = modify7;
var modifyEffect4 = modifyEffect3;
var modifySome5 = modifySome2;
var modifySomeEffect3 = modifySomeEffect2;
var set16 = set15;
var setAndGet5 = setAndGet2;
var update8 = update3;
var updateEffect3 = updateEffect2;
var updateAndGet5 = updateAndGet2;
var updateAndGetEffect3 = updateAndGetEffect2;
var updateSome5 = updateSome2;
var updateSomeEffect3 = updateSomeEffect2;
var updateSomeAndGet5 = updateSomeAndGet2;
var updateSomeAndGetEffect2 = updateSomeAndGetEffect;

// node_modules/effect/dist/esm/Supervisor.js
var Supervisor_exports = {};
__export(Supervisor_exports, {
  AbstractSupervisor: () => AbstractSupervisor,
  SupervisorTypeId: () => SupervisorTypeId2,
  addSupervisor: () => addSupervisor2,
  fibersIn: () => fibersIn2,
  fromEffect: () => fromEffect5,
  none: () => none8,
  track: () => track2,
  unsafeTrack: () => unsafeTrack2
});
var SupervisorTypeId2 = SupervisorTypeId;
var addSupervisor2 = addSupervisor;
var fibersIn2 = fibersIn;
var fromEffect5 = fromEffect;
var none8 = none4;
var track2 = track;
var unsafeTrack2 = unsafeTrack;
var AbstractSupervisor = class {
  /**
   * @since 2.0.0
   */
  onStart(_context, _effect, _parent, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEnd(_value, _fiber) {
  }
  /**
   * @since 2.0.0
   */
  onEffect(_fiber, _effect) {
  }
  /**
   * @since 2.0.0
   */
  onSuspend(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  onResume(_fiber) {
  }
  /**
   * @since 2.0.0
   */
  map(f) {
    return new ProxySupervisor(this, map5(this.value, f));
  }
  /**
   * @since 2.0.0
   */
  zip(right2) {
    return new Zip(this, right2);
  }
  /**
   * @since 2.0.0
   */
  onRun(execution, _fiber) {
    return execution();
  }
  /**
   * @since 2.0.0
   */
  [SupervisorTypeId2] = supervisorVariance;
};

// node_modules/effect/dist/esm/Symbol.js
var Symbol_exports = {};
__export(Symbol_exports, {
  Equivalence: () => Equivalence,
  isSymbol: () => isSymbol2
});
var isSymbol2 = isSymbol;
var Equivalence = symbol;

// node_modules/effect/dist/esm/TArray.js
var TArray_exports = {};
__export(TArray_exports, {
  TArrayTypeId: () => TArrayTypeId2,
  collectFirst: () => collectFirst2,
  collectFirstSTM: () => collectFirstSTM2,
  contains: () => contains2,
  count: () => count4,
  countSTM: () => countSTM2,
  empty: () => empty13,
  every: () => every4,
  everySTM: () => everySTM2,
  findFirst: () => findFirst4,
  findFirstIndex: () => findFirstIndex2,
  findFirstIndexFrom: () => findFirstIndexFrom2,
  findFirstIndexWhere: () => findFirstIndexWhere2,
  findFirstIndexWhereFrom: () => findFirstIndexWhereFrom2,
  findFirstIndexWhereFromSTM: () => findFirstIndexWhereFromSTM2,
  findFirstIndexWhereSTM: () => findFirstIndexWhereSTM2,
  findFirstSTM: () => findFirstSTM2,
  findLast: () => findLast2,
  findLastIndex: () => findLastIndex2,
  findLastIndexFrom: () => findLastIndexFrom2,
  findLastSTM: () => findLastSTM2,
  forEach: () => forEach5,
  fromIterable: () => fromIterable13,
  get: () => get27,
  headOption: () => headOption3,
  lastOption: () => lastOption3,
  make: () => make60,
  maxOption: () => maxOption2,
  minOption: () => minOption2,
  reduce: () => reduce11,
  reduceOption: () => reduceOption2,
  reduceOptionSTM: () => reduceOptionSTM2,
  reduceSTM: () => reduceSTM2,
  size: () => size8,
  some: () => some6,
  someSTM: () => someSTM2,
  toArray: () => toArray2,
  transform: () => transform2,
  transformSTM: () => transformSTM2,
  update: () => update10,
  updateSTM: () => updateSTM2
});

// node_modules/effect/dist/esm/internal/stm/tArray.js
var TArraySymbolKey = "effect/TArray";
var TArrayTypeId = Symbol.for(TArraySymbolKey);
var tArrayVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TArrayImpl = class {
  chunk;
  [TArrayTypeId] = tArrayVariance;
  constructor(chunk3) {
    this.chunk = chunk3;
  }
};
var collectFirst = dual(2, (self, pf) => collectFirstSTM(self, (a) => pipe(pf(a), map(succeed5))));
var collectFirstSTM = dual(2, (self, pf) => withSTMRuntime((runtime4) => {
  let index = 0;
  let result = none();
  while (isNone(result) && index < self.chunk.length) {
    const element = pipe(self.chunk[index], unsafeGet4(runtime4.journal));
    const option5 = pf(element);
    if (isSome(option5)) {
      result = option5;
    }
    index = index + 1;
  }
  return pipe(result, match2({
    onNone: () => succeedNone2,
    onSome: map8(some)
  }));
}));
var contains = dual(2, (self, value7) => some5(self, (a) => equals(a)(value7)));
var count3 = dual(2, (self, predicate) => reduce10(self, 0, (n, a) => predicate(a) ? n + 1 : n));
var countSTM = dual(2, (self, predicate) => reduceSTM(self, 0, (n, a) => map8(predicate(a), (bool) => bool ? n + 1 : n)));
var empty12 = () => fromIterable12([]);
var every3 = dual(2, (self, predicate) => negate(some5(self, (a) => !predicate(a))));
var everySTM = dual(2, (self, predicate) => map8(countSTM(self, predicate), (count5) => count5 === self.chunk.length));
var findFirst3 = dual(2, (self, predicate) => collectFirst(self, (a) => predicate(a) ? some(a) : none()));
var findFirstIndex = dual(2, (self, value7) => findFirstIndexFrom(self, value7, 0));
var findFirstIndexFrom = dual(3, (self, value7, from) => findFirstIndexWhereFrom(self, (a) => equals(a)(value7), from));
var findFirstIndexWhere = dual(2, (self, predicate) => findFirstIndexWhereFrom(self, predicate, 0));
var findFirstIndexWhereFrom = dual(3, (self, predicate, from) => {
  if (from < 0) {
    return succeedNone2;
  }
  return effect2((journal) => {
    let index = from;
    let found = false;
    while (!found && index < self.chunk.length) {
      const element = unsafeGet4(self.chunk[index], journal);
      found = predicate(element);
      index = index + 1;
    }
    if (found) {
      return some(index - 1);
    }
    return none();
  });
});
var findFirstIndexWhereSTM = dual(2, (self, predicate) => findFirstIndexWhereFromSTM(self, predicate, 0));
var findFirstIndexWhereFromSTM = dual(3, (self, predicate, from) => {
  const forIndex = (index) => index < self.chunk.length ? pipe(get8(self.chunk[index]), flatMap3(predicate), flatMap3((bool) => bool ? succeed5(some(index)) : forIndex(index + 1))) : succeedNone2;
  return from < 0 ? succeedNone2 : forIndex(from);
});
var findFirstSTM = dual(2, (self, predicate) => {
  const init = [none(), 0];
  const cont = (state) => isNone(state[0]) && state[1] < self.chunk.length - 1;
  return map8(iterate(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get8(self.chunk[index]), flatMap3((value7) => map8(predicate(value7), (bool) => [bool ? some(value7) : none(), index + 1])));
    }
  }), (state) => state[0]);
});
var findLast = dual(2, (self, predicate) => effect2((journal) => {
  let index = self.chunk.length - 1;
  let result = none();
  while (isNone(result) && index >= 0) {
    const element = unsafeGet4(self.chunk[index], journal);
    if (predicate(element)) {
      result = some(element);
    }
    index = index - 1;
  }
  return result;
}));
var findLastIndex = dual(2, (self, value7) => findLastIndexFrom(self, value7, self.chunk.length - 1));
var findLastIndexFrom = dual(3, (self, value7, end3) => {
  if (end3 >= self.chunk.length) {
    return succeedNone2;
  }
  return effect2((journal) => {
    let index = end3;
    let found = false;
    while (!found && index >= 0) {
      const element = unsafeGet4(self.chunk[index], journal);
      found = equals(element)(value7);
      index = index - 1;
    }
    if (found) {
      return some(index + 1);
    }
    return none();
  });
});
var findLastSTM = dual(2, (self, predicate) => {
  const init = [none(), self.chunk.length - 1];
  const cont = (state) => isNone(state[0]) && state[1] >= 0;
  return map8(iterate(init, {
    while: cont,
    body: (state) => {
      const index = state[1];
      return pipe(get8(self.chunk[index]), flatMap3((value7) => map8(predicate(value7), (bool) => [bool ? some(value7) : none(), index - 1])));
    }
  }), (state) => state[0]);
});
var forEach4 = dual(2, (self, f) => reduceSTM(self, void 0, (_, a) => f(a)));
var fromIterable12 = (iterable) => map8(forEach2(iterable, make18), (chunk3) => new TArrayImpl(chunk3));
var get26 = dual(2, (self, index) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage("Index out of bounds");
  }
  return get8(self.chunk[index]);
});
var headOption2 = (self) => self.chunk.length === 0 ? succeed5(none()) : map8(get8(self.chunk[0]), some);
var lastOption2 = (self) => self.chunk.length === 0 ? succeedNone2 : map8(get8(self.chunk[self.chunk.length - 1]), some);
var make59 = (...elements) => fromIterable12(elements);
var maxOption = dual(2, (self, order) => {
  const greaterThan2 = greaterThan(order);
  return reduceOption(self, (acc, curr) => greaterThan2(acc)(curr) ? curr : acc);
});
var minOption = dual(2, (self, order) => {
  const lessThan2 = lessThan(order);
  return reduceOption(self, (acc, curr) => lessThan2(acc)(curr) ? curr : acc);
});
var reduce10 = dual(3, (self, zero, f) => effect2((journal) => {
  let index = 0;
  let result = zero;
  while (index < self.chunk.length) {
    const element = unsafeGet4(self.chunk[index], journal);
    result = f(result, element);
    index = index + 1;
  }
  return result;
}));
var reduceOption = dual(2, (self, f) => effect2((journal) => {
  let index = 0;
  let result = void 0;
  while (index < self.chunk.length) {
    const element = unsafeGet4(self.chunk[index], journal);
    result = result === void 0 ? element : f(result, element);
    index = index + 1;
  }
  return fromNullable(result);
}));
var reduceOptionSTM = dual(2, (self, f) => reduceSTM(self, none(), (acc, curr) => isSome(acc) ? map8(f(acc.value, curr), some) : succeedSome(curr)));
var reduceSTM = dual(3, (self, zero, f) => flatMap3(toArray(self), reduce6(zero, f)));
var size7 = (self) => self.chunk.length;
var some5 = dual(2, (self, predicate) => map8(findFirst3(self, predicate), isSome));
var someSTM = dual(2, (self, predicate) => map8(countSTM(self, predicate), (n) => n > 0));
var toArray = (self) => forEach2(self.chunk, get8);
var transform = dual(2, (self, f) => effect2((journal) => {
  let index = 0;
  while (index < self.chunk.length) {
    const ref = self.chunk[index];
    unsafeSet(ref, f(unsafeGet4(ref, journal)), journal);
    index = index + 1;
  }
  return void 0;
}));
var transformSTM = dual(2, (self, f) => flatMap3(forEach2(self.chunk, (ref) => flatMap3(get8(ref), f)), (chunk3) => effect2((journal) => {
  const iterator = chunk3[Symbol.iterator]();
  let index = 0;
  let next3;
  while ((next3 = iterator.next()) && !next3.done) {
    unsafeSet(self.chunk[index], next3.value, journal);
    index = index + 1;
  }
  return void 0;
})));
var update9 = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage("Index out of bounds");
  }
  return update5(self.chunk[index], f);
});
var updateSTM = dual(3, (self, index, f) => {
  if (index < 0 || index >= self.chunk.length) {
    return dieMessage("Index out of bounds");
  }
  return pipe(get8(self.chunk[index]), flatMap3(f), flatMap3((updated) => set7(self.chunk[index], updated)));
});

// node_modules/effect/dist/esm/TArray.js
var TArrayTypeId2 = TArrayTypeId;
var collectFirst2 = collectFirst;
var collectFirstSTM2 = collectFirstSTM;
var contains2 = contains;
var count4 = count3;
var countSTM2 = countSTM;
var empty13 = empty12;
var every4 = every3;
var everySTM2 = everySTM;
var findFirst4 = findFirst3;
var findFirstIndex2 = findFirstIndex;
var findFirstIndexFrom2 = findFirstIndexFrom;
var findFirstIndexWhere2 = findFirstIndexWhere;
var findFirstIndexWhereFrom2 = findFirstIndexWhereFrom;
var findFirstIndexWhereSTM2 = findFirstIndexWhereSTM;
var findFirstIndexWhereFromSTM2 = findFirstIndexWhereFromSTM;
var findFirstSTM2 = findFirstSTM;
var findLast2 = findLast;
var findLastIndex2 = findLastIndex;
var findLastIndexFrom2 = findLastIndexFrom;
var findLastSTM2 = findLastSTM;
var forEach5 = forEach4;
var fromIterable13 = fromIterable12;
var get27 = get26;
var headOption3 = headOption2;
var lastOption3 = lastOption2;
var make60 = make59;
var maxOption2 = maxOption;
var minOption2 = minOption;
var reduce11 = reduce10;
var reduceOption2 = reduceOption;
var reduceOptionSTM2 = reduceOptionSTM;
var reduceSTM2 = reduceSTM;
var size8 = size7;
var some6 = some5;
var someSTM2 = someSTM;
var toArray2 = toArray;
var transform2 = transform;
var transformSTM2 = transformSTM;
var update10 = update9;
var updateSTM2 = updateSTM;

// node_modules/effect/dist/esm/TDeferred.js
var TDeferred_exports = {};
__export(TDeferred_exports, {
  TDeferredTypeId: () => TDeferredTypeId2,
  await: () => _await4,
  done: () => done4,
  fail: () => fail6,
  make: () => make62,
  poll: () => poll5,
  succeed: () => succeed9
});

// node_modules/effect/dist/esm/internal/stm/tDeferred.js
var TDeferredSymbolKey = "effect/TDeferred";
var TDeferredTypeId = Symbol.for(TDeferredSymbolKey);
var tDeferredVariance = {
  /* c8 ignore next */
  _A: (_) => _,
  /* c8 ignore next */
  _E: (_) => _
};
var TDeferredImpl = class {
  ref;
  [TDeferredTypeId] = tDeferredVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var _await3 = (self) => flatten2(collect(get8(self.ref), (option5) => isSome(option5) ? some(fromEither(option5.value)) : none()));
var done3 = dual(2, (self, either5) => flatMap3(get8(self.ref), match2({
  onNone: () => zipRight3(set7(self.ref, some(either5)), succeed5(true)),
  onSome: () => succeed5(false)
})));
var fail5 = dual(2, (self, error3) => done3(self, left(error3)));
var make61 = () => map8(make18(none()), (ref) => new TDeferredImpl(ref));
var poll4 = (self) => get8(self.ref);
var succeed8 = dual(2, (self, value7) => done3(self, right(value7)));

// node_modules/effect/dist/esm/TDeferred.js
var TDeferredTypeId2 = TDeferredTypeId;
var _await4 = _await3;
var done4 = done3;
var fail6 = fail5;
var make62 = make61;
var poll5 = poll4;
var succeed9 = succeed8;

// node_modules/effect/dist/esm/TMap.js
var TMap_exports = {};
__export(TMap_exports, {
  TMapTypeId: () => TMapTypeId2,
  empty: () => empty15,
  find: () => find2,
  findAll: () => findAll2,
  findAllSTM: () => findAllSTM2,
  findSTM: () => findSTM2,
  forEach: () => forEach7,
  fromIterable: () => fromIterable15,
  get: () => get29,
  getOrElse: () => getOrElse3,
  has: () => has9,
  isEmpty: () => isEmpty4,
  keys: () => keys7,
  make: () => make64,
  merge: () => merge7,
  reduce: () => reduce13,
  reduceSTM: () => reduceSTM4,
  remove: () => remove7,
  removeAll: () => removeAll2,
  removeIf: () => removeIf2,
  retainIf: () => retainIf2,
  set: () => set18,
  setIfAbsent: () => setIfAbsent2,
  size: () => size10,
  takeFirst: () => takeFirst2,
  takeFirstSTM: () => takeFirstSTM2,
  takeSome: () => takeSome2,
  takeSomeSTM: () => takeSomeSTM2,
  toArray: () => toArray4,
  toChunk: () => toChunk2,
  toHashMap: () => toHashMap2,
  toMap: () => toMap2,
  transform: () => transform4,
  transformSTM: () => transformSTM4,
  transformValues: () => transformValues2,
  transformValuesSTM: () => transformValuesSTM2,
  updateWith: () => updateWith2,
  values: () => values4
});

// node_modules/effect/dist/esm/internal/stm/tMap.js
var TMapSymbolKey = "effect/TMap";
var TMapTypeId = Symbol.for(TMapSymbolKey);
var tMapVariance = {
  /* c8 ignore next */
  _K: (_) => _,
  /* c8 ignore next */
  _V: (_) => _
};
var TMapImpl = class {
  tBuckets;
  tSize;
  [TMapTypeId] = tMapVariance;
  constructor(tBuckets, tSize) {
    this.tBuckets = tBuckets;
    this.tSize = tSize;
  }
};
var isTMap = (u) => hasProperty(u, TMapTypeId);
var InitialCapacity = 16;
var LoadFactor = 0.75;
var nextPowerOfTwo = (size18) => {
  const n = -1 >>> Math.clz32(size18 - 1);
  return n < 0 ? 1 : n + 1;
};
var hash2 = (key) => {
  const h = hash(key);
  return h ^ h >>> 16;
};
var indexOf = (k, capacity) => hash2(k) & capacity - 1;
var allocate = (capacity, data) => {
  const buckets = Array.from({
    length: capacity
  }, () => empty2());
  const distinct = new Map(data);
  let size18 = 0;
  for (const entry of distinct) {
    const index = indexOf(entry[0], capacity);
    buckets[index] = pipe(buckets[index], prepend2(entry));
    size18 = size18 + 1;
  }
  return pipe(fromIterable12(buckets), flatMap3((buckets2) => pipe(make18(buckets2), flatMap3((tBuckets) => pipe(make18(size18), map8((tSize) => new TMapImpl(tBuckets, tSize)))))));
};
var empty14 = () => fromIterable14([]);
var find = dual(2, (self, pf) => findSTM(self, (key, value7) => {
  const option5 = pf(key, value7);
  if (isSome(option5)) {
    return succeed5(option5.value);
  }
  return fail2(none());
}));
var findSTM = dual(2, (self, f) => reduceSTM3(self, none(), (acc, value7, key) => isNone(acc) ? matchSTM(f(key, value7), {
  onFailure: match2({
    onNone: () => succeedNone2,
    onSome: fail2
  }),
  onSuccess: succeedSome
}) : succeed7(acc)));
var findAll = dual(2, (self, pf) => findAllSTM(self, (key, value7) => {
  const option5 = pf(key, value7);
  if (isSome(option5)) {
    return succeed5(option5.value);
  }
  return fail2(none());
}));
var findAllSTM = dual(2, (self, pf) => map8(reduceSTM3(self, empty2(), (acc, value7, key) => matchSTM(pf(key, value7), {
  onFailure: match2({
    onNone: () => succeed5(acc),
    onSome: fail2
  }),
  onSuccess: (a) => succeed5(append(acc, a))
})), (a) => Array.from(a)));
var forEach6 = dual(2, (self, f) => reduceSTM3(self, void 0, (_, value7, key) => asVoid3(f(key, value7))));
var fromIterable14 = (iterable) => suspend3(() => {
  const data = fromIterable2(iterable);
  const capacity = data.length < InitialCapacity ? InitialCapacity : nextPowerOfTwo(data.length);
  return allocate(capacity, data);
});
var get28 = dual(2, (self, key) => effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet4(buckets.chunk[index], journal);
  return pipe(findFirst(bucket, (entry) => equals(entry[0])(key)), map((entry) => entry[1]));
}));
var getOrElse2 = dual(3, (self, key, fallback) => map8(get28(self, key), getOrElse(fallback)));
var has8 = dual(2, (self, key) => map8(get28(self, key), isSome));
var isEmpty3 = (self) => map8(get8(self.tSize), (size18) => size18 === 0);
var keys6 = (self) => map8(toReadonlyArray(self), map3((entry) => entry[0]));
var make63 = (...entries4) => fromIterable14(entries4);
var merge6 = dual(4, (self, key, value7, f) => flatMap3(get28(self, key), match2({
  onNone: () => as3(set17(self, key, value7), value7),
  onSome: (v0) => {
    const v1 = f(v0, value7);
    return as3(set17(self, key, v1), v1);
  }
})));
var reduce12 = dual(3, (self, zero, f) => effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  let result = zero;
  let index = 0;
  while (index < buckets.chunk.length) {
    const bucket = buckets.chunk[index];
    const items = unsafeGet4(bucket, journal);
    result = reduce2(items, result, (acc, entry) => f(acc, entry[1], entry[0]));
    index = index + 1;
  }
  return result;
}));
var reduceSTM3 = dual(3, (self, zero, f) => flatMap3(toReadonlyArray(self), reduce6(zero, (acc, entry) => f(acc, entry[1], entry[0]))));
var remove6 = dual(2, (self, key) => effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const index = indexOf(key, buckets.chunk.length);
  const bucket = unsafeGet4(buckets.chunk[index], journal);
  const [toRemove, toRetain] = partition(bucket, (entry) => equals(entry[1], key));
  if (isNonEmpty(toRemove)) {
    const currentSize = unsafeGet4(self.tSize, journal);
    unsafeSet(buckets.chunk[index], toRetain, journal);
    unsafeSet(self.tSize, currentSize - 1, journal);
  }
}));
var removeAll = dual(2, (self, keys10) => effect2((journal) => {
  const iterator = keys10[Symbol.iterator]();
  let next3;
  while ((next3 = iterator.next()) && !next3.done) {
    const buckets = unsafeGet4(self.tBuckets, journal);
    const index = indexOf(next3.value, buckets.chunk.length);
    const bucket = unsafeGet4(buckets.chunk[index], journal);
    const [toRemove, toRetain] = partition(bucket, (entry) => equals(next3.value)(entry[0]));
    if (isNonEmpty(toRemove)) {
      const currentSize = unsafeGet4(self.tSize, journal);
      unsafeSet(buckets.chunk[index], toRetain, journal);
      unsafeSet(self.tSize, currentSize - 1, journal);
    }
  }
}));
var removeIf = dual((args) => isTMap(args[0]), (self, predicate, options) => effect2((journal) => {
  const discard = options?.discard === true;
  const buckets = unsafeGet4(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const removed = [];
  let index = 0;
  let newSize = 0;
  while (index < capacity) {
    const bucket = unsafeGet4(buckets.chunk[index], journal);
    const iterator = bucket[Symbol.iterator]();
    let next3;
    let newBucket = empty2();
    while ((next3 = iterator.next()) && !next3.done) {
      const [k, v] = next3.value;
      if (!predicate(k, v)) {
        newBucket = prepend2(newBucket, next3.value);
        newSize = newSize + 1;
      } else {
        if (!discard) {
          removed.push([k, v]);
        }
      }
    }
    unsafeSet(buckets.chunk[index], newBucket, journal);
    index = index + 1;
  }
  unsafeSet(self.tSize, newSize, journal);
  if (!discard) {
    return removed;
  }
}));
var retainIf = dual((args) => isTMap(args[0]), (self, predicate, options) => removeIf(self, (key, value7) => !predicate(key, value7), options));
var set17 = dual(3, (self, key, value7) => {
  const resize = (journal, buckets) => {
    const capacity = buckets.chunk.length;
    const newCapacity = capacity << 1;
    const newBuckets = Array.from({
      length: newCapacity
    }, () => empty2());
    let index = 0;
    while (index < capacity) {
      const pairs = unsafeGet4(buckets.chunk[index], journal);
      const iterator = pairs[Symbol.iterator]();
      let next3;
      while ((next3 = iterator.next()) && !next3.done) {
        const newIndex2 = indexOf(next3.value[0], newCapacity);
        newBuckets[newIndex2] = prepend2(newBuckets[newIndex2], next3.value);
      }
      index = index + 1;
    }
    const newIndex = indexOf(key, newCapacity);
    newBuckets[newIndex] = prepend2(newBuckets[newIndex], [key, value7]);
    const newArray = [];
    index = 0;
    while (index < newCapacity) {
      newArray[index] = new TRefImpl(newBuckets[index]);
      index = index + 1;
    }
    const newTArray = new TArrayImpl(newArray);
    unsafeSet(self.tBuckets, newTArray, journal);
  };
  return effect2((journal) => {
    const buckets = unsafeGet4(self.tBuckets, journal);
    const capacity = buckets.chunk.length;
    const index = indexOf(key, capacity);
    const bucket = unsafeGet4(buckets.chunk[index], journal);
    const shouldUpdate = some2(bucket, (entry) => equals(key)(entry[0]));
    if (shouldUpdate) {
      const newBucket = map4(bucket, (entry) => equals(key)(entry[0]) ? [key, value7] : entry);
      unsafeSet(buckets.chunk[index], newBucket, journal);
    } else {
      const newSize = unsafeGet4(self.tSize, journal) + 1;
      unsafeSet(self.tSize, newSize, journal);
      if (capacity * LoadFactor < newSize) {
        resize(journal, buckets);
      } else {
        const newBucket = prepend2(bucket, [key, value7]);
        unsafeSet(buckets.chunk[index], newBucket, journal);
      }
    }
  });
});
var setIfAbsent = dual(3, (self, key, value7) => flatMap3(get28(self, key), match2({
  onNone: () => set17(self, key, value7),
  onSome: () => void_3
})));
var size9 = (self) => get8(self.tSize);
var takeFirst = dual(2, (self, pf) => pipe(effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const size18 = unsafeGet4(self.tSize, journal);
  let result = none();
  let index = 0;
  while (index < capacity && isNone(result)) {
    const bucket = unsafeGet4(buckets.chunk[index], journal);
    const recreate = some2(bucket, (entry) => isSome(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty2();
      let next3;
      while ((next3 = iterator.next()) && !next3.done && isNone(result)) {
        const option5 = pf(next3.value[0], next3.value[1]);
        if (isSome(option5) && isNone(result)) {
          result = option5;
        } else {
          newBucket = prepend2(newBucket, next3.value);
        }
      }
      unsafeSet(buckets.chunk[index], newBucket, journal);
    }
    index = index + 1;
  }
  if (isSome(result)) {
    unsafeSet(self.tSize, size18 - 1, journal);
  }
  return result;
}), collect((option5) => isSome(option5) ? some(option5.value) : none())));
var takeFirstSTM = dual(2, (self, pf) => pipe(findSTM(self, (key, value7) => map8(pf(key, value7), (a) => [key, a])), collect((option5) => isSome(option5) ? some(option5.value) : none()), flatMap3((entry) => as3(remove6(self, entry[0]), entry[1]))));
var takeSome = dual(2, (self, pf) => pipe(effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const builder = [];
  let newSize = 0;
  let index = 0;
  while (index < capacity) {
    const bucket = unsafeGet4(buckets.chunk[index], journal);
    const recreate = some2(bucket, (entry) => isSome(pf(entry[0], entry[1])));
    if (recreate) {
      const iterator = bucket[Symbol.iterator]();
      let newBucket = empty2();
      let next3;
      while ((next3 = iterator.next()) && !next3.done) {
        const option5 = pf(next3.value[0], next3.value[1]);
        if (isSome(option5)) {
          builder.push(option5.value);
        } else {
          newBucket = prepend2(newBucket, next3.value);
          newSize = newSize + 1;
        }
      }
      unsafeSet(buckets.chunk[index], newBucket, journal);
    } else {
      newSize = newSize + bucket.length;
    }
    index = index + 1;
  }
  unsafeSet(self.tSize, newSize, journal);
  if (builder.length > 0) {
    return some(builder);
  }
  return none();
}), collect((option5) => isSome(option5) ? some(option5.value) : none())));
var takeSomeSTM = dual(2, (self, pf) => pipe(findAllSTM(self, (key, value7) => map8(pf(key, value7), (a) => [key, a])), map8((chunk3) => isNonEmptyArray(chunk3) ? some(chunk3) : none()), collect((option5) => isSome(option5) ? some(option5.value) : none()), flatMap3((entries4) => as3(removeAll(self, entries4.map((entry) => entry[0])), map3(entries4, (entry) => entry[1])))));
var toReadonlyArray = (self) => effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const builder = [];
  let index = 0;
  while (index < capacity) {
    const bucket = buckets.chunk[index];
    for (const entry of unsafeGet4(bucket, journal)) {
      builder.push(entry);
    }
    index = index + 1;
  }
  return builder;
});
var toChunk = (self) => reduce12(self, empty2(), (acc, value7, key) => append(acc, [key, value7]));
var toHashMap = (self) => reduce12(self, empty4(), (acc, value7, key) => pipe(acc, set2(key, value7)));
var toArray3 = (self) => reduce12(self, [], (acc, value7, key) => {
  acc.unshift([key, value7]);
  return acc;
});
var toMap = (self) => reduce12(self, /* @__PURE__ */ new Map(), (acc, value7, key) => acc.set(key, value7));
var transform3 = dual(2, (self, f) => effect2((journal) => {
  const buckets = pipe(self.tBuckets, unsafeGet4(journal));
  const capacity = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity
  }, () => empty2());
  let newSize = 0;
  let index = 0;
  while (index < capacity) {
    const bucket = buckets.chunk[index];
    const pairs = unsafeGet4(bucket, journal);
    const iterator = pairs[Symbol.iterator]();
    let next3;
    while ((next3 = iterator.next()) && !next3.done) {
      const newPair = f(next3.value[0], next3.value[1]);
      const index2 = indexOf(newPair[0], capacity);
      const newBucket = newBuckets[index2];
      if (!some2(newBucket, (entry) => equals(entry[0], newPair[0]))) {
        newBuckets[index2] = prepend2(newBucket, newPair);
        newSize = newSize + 1;
      }
    }
    index = index + 1;
  }
  index = 0;
  while (index < capacity) {
    unsafeSet(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet(self.tSize, newSize, journal);
}));
var transformSTM3 = dual(2, (self, f) => pipe(flatMap3(toReadonlyArray(self), forEach2((entry) => f(entry[0], entry[1]))), flatMap3((newData) => effect2((journal) => {
  const buckets = unsafeGet4(self.tBuckets, journal);
  const capacity = buckets.chunk.length;
  const newBuckets = Array.from({
    length: capacity
  }, () => empty2());
  const iterator = newData[Symbol.iterator]();
  let newSize = 0;
  let next3;
  while ((next3 = iterator.next()) && !next3.done) {
    const index2 = indexOf(next3.value[0], capacity);
    const newBucket = newBuckets[index2];
    if (!some2(newBucket, (entry) => equals(entry[0])(next3.value[0]))) {
      newBuckets[index2] = prepend2(newBucket, next3.value);
      newSize = newSize + 1;
    }
  }
  let index = 0;
  while (index < capacity) {
    unsafeSet(buckets.chunk[index], newBuckets[index], journal);
    index = index + 1;
  }
  unsafeSet(self.tSize, newSize, journal);
}))));
var transformValues = dual(2, (self, f) => transform3(self, (key, value7) => [key, f(value7)]));
var transformValuesSTM = dual(2, (self, f) => transformSTM3(self, (key, value7) => map8(f(value7), (value8) => [key, value8])));
var updateWith = dual(3, (self, key, f) => flatMap3(get28(self, key), (option5) => match2(f(option5), {
  onNone: () => as3(remove6(self, key), none()),
  onSome: (value7) => as3(set17(self, key, value7), some(value7))
})));
var values3 = (self) => map8(toReadonlyArray(self), map3((entry) => entry[1]));

// node_modules/effect/dist/esm/TMap.js
var TMapTypeId2 = TMapTypeId;
var empty15 = empty14;
var find2 = find;
var findSTM2 = findSTM;
var findAll2 = findAll;
var findAllSTM2 = findAllSTM;
var forEach7 = forEach6;
var fromIterable15 = fromIterable14;
var get29 = get28;
var getOrElse3 = getOrElse2;
var has9 = has8;
var isEmpty4 = isEmpty3;
var keys7 = keys6;
var make64 = make63;
var merge7 = merge6;
var reduce13 = reduce12;
var reduceSTM4 = reduceSTM3;
var remove7 = remove6;
var removeAll2 = removeAll;
var removeIf2 = removeIf;
var retainIf2 = retainIf;
var set18 = set17;
var setIfAbsent2 = setIfAbsent;
var size10 = size9;
var takeFirst2 = takeFirst;
var takeFirstSTM2 = takeFirstSTM;
var takeSome2 = takeSome;
var takeSomeSTM2 = takeSomeSTM;
var toChunk2 = toChunk;
var toHashMap2 = toHashMap;
var toArray4 = toArray3;
var toMap2 = toMap;
var transform4 = transform3;
var transformSTM4 = transformSTM3;
var transformValues2 = transformValues;
var transformValuesSTM2 = transformValuesSTM;
var updateWith2 = updateWith;
var values4 = values3;

// node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueue_exports = {};
__export(TPriorityQueue_exports, {
  TPriorityQueueTypeId: () => TPriorityQueueTypeId2,
  empty: () => empty17,
  fromIterable: () => fromIterable17,
  isEmpty: () => isEmpty6,
  isNonEmpty: () => isNonEmpty4,
  make: () => make66,
  offer: () => offer4,
  offerAll: () => offerAll2,
  peek: () => peek2,
  peekOption: () => peekOption2,
  removeIf: () => removeIf4,
  retainIf: () => retainIf4,
  size: () => size12,
  take: () => take2,
  takeAll: () => takeAll2,
  takeOption: () => takeOption2,
  takeUpTo: () => takeUpTo2,
  toArray: () => toArray6,
  toChunk: () => toChunk4
});

// node_modules/effect/dist/esm/internal/stm/tPriorityQueue.js
var TPriorityQueueSymbolKey = "effect/TPriorityQueue";
var TPriorityQueueTypeId = Symbol.for(TPriorityQueueSymbolKey);
var tPriorityQueueVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TPriorityQueueImpl = class {
  ref;
  [TPriorityQueueTypeId] = tPriorityQueueVariance;
  constructor(ref) {
    this.ref = ref;
  }
};
var empty16 = (order) => pipe(make18(empty11(order)), map8((ref) => new TPriorityQueueImpl(ref)));
var fromIterable16 = (order) => (iterable) => pipe(make18(fromIterable(iterable).reduce((map18, value7) => pipe(map18, set13(value7, pipe(map18, get22(value7), match2({
  onNone: () => of(value7),
  onSome: prepend(value7)
})))), empty11(order))), map8((ref) => new TPriorityQueueImpl(ref)));
var isEmpty5 = (self) => map8(get8(self.ref), isEmpty2);
var isNonEmpty3 = (self) => map8(get8(self.ref), isNonEmpty2);
var make65 = (order) => (...elements) => fromIterable16(order)(elements);
var offer3 = dual(2, (self, value7) => update5(self.ref, (map18) => set13(map18, value7, match2(get22(map18, value7), {
  onNone: () => of(value7),
  onSome: prepend(value7)
}))));
var offerAll = dual(2, (self, values7) => update5(self.ref, (map18) => fromIterable(values7).reduce((map19, value7) => set13(map19, value7, match2(get22(map19, value7), {
  onNone: () => of(value7),
  onSome: prepend(value7)
})), map18)));
var peek = (self) => withSTMRuntime((runtime4) => {
  const map18 = unsafeGet4(self.ref, runtime4.journal);
  return match2(headOption(map18), {
    onNone: () => retry,
    onSome: (elements) => succeed5(elements[0])
  });
});
var peekOption = (self) => modify4(self.ref, (map18) => [map(headOption(map18), (elements) => elements[0]), map18]);
var removeIf3 = dual(2, (self, predicate) => retainIf3(self, (a) => !predicate(a)));
var retainIf3 = dual(2, (self, predicate) => update5(self.ref, (map18) => reduce9(map18, empty11(getOrder2(map18)), (map19, value7, key) => {
  const filtered = filter2(value7, predicate);
  return filtered.length > 0 ? set13(map19, key, filtered) : remove5(map19, key);
})));
var size11 = (self) => modify4(self.ref, (map18) => [reduce9(map18, 0, (n, as5) => n + as5.length), map18]);
var take = (self) => withSTMRuntime((runtime4) => {
  const map18 = unsafeGet4(self.ref, runtime4.journal);
  return match2(headOption(map18), {
    onNone: () => retry,
    onSome: (values7) => {
      const head3 = values7[1][0];
      const tail = values7[1].slice(1);
      unsafeSet(self.ref, tail.length > 0 ? set13(map18, head3, tail) : remove5(map18, head3), runtime4.journal);
      return succeed5(head3);
    }
  });
});
var takeAll = (self) => modify4(self.ref, (map18) => {
  const builder = [];
  for (const entry of map18) {
    for (const value7 of entry[1]) {
      builder.push(value7);
    }
  }
  return [builder, empty11(getOrder2(map18))];
});
var takeOption = (self) => effect2((journal) => {
  const map18 = pipe(self.ref, unsafeGet4(journal));
  return match2(headOption(map18), {
    onNone: () => none(),
    onSome: ([key, value7]) => {
      const tail = value7.slice(1);
      unsafeSet(self.ref, tail.length > 0 ? set13(map18, key, tail) : remove5(map18, key), journal);
      return some(value7[0]);
    }
  });
});
var takeUpTo = dual(2, (self, n) => modify4(self.ref, (map18) => {
  const builder = [];
  const iterator = map18[Symbol.iterator]();
  let updated = map18;
  let index = 0;
  let next3;
  while ((next3 = iterator.next()) && !next3.done && index < n) {
    const [key, value7] = next3.value;
    const [left2, right2] = pipe(value7, splitAt(n - index));
    for (const value8 of left2) {
      builder.push(value8);
    }
    if (right2.length > 0) {
      updated = set13(updated, key, right2);
    } else {
      updated = remove5(updated, key);
    }
    index = index + left2.length;
  }
  return [builder, updated];
}));
var toChunk3 = (self) => modify4(self.ref, (map18) => {
  const builder = [];
  for (const entry of map18) {
    for (const value7 of entry[1]) {
      builder.push(value7);
    }
  }
  return [unsafeFromArray(builder), map18];
});
var toArray5 = (self) => modify4(self.ref, (map18) => {
  const builder = [];
  for (const entry of map18) {
    for (const value7 of entry[1]) {
      builder.push(value7);
    }
  }
  return [builder, map18];
});

// node_modules/effect/dist/esm/TPriorityQueue.js
var TPriorityQueueTypeId2 = TPriorityQueueTypeId;
var empty17 = empty16;
var fromIterable17 = fromIterable16;
var isEmpty6 = isEmpty5;
var isNonEmpty4 = isNonEmpty3;
var make66 = make65;
var offer4 = offer3;
var offerAll2 = offerAll;
var peek2 = peek;
var peekOption2 = peekOption;
var removeIf4 = removeIf3;
var retainIf4 = retainIf3;
var size12 = size11;
var take2 = take;
var takeAll2 = takeAll;
var takeOption2 = takeOption;
var takeUpTo2 = takeUpTo;
var toChunk4 = toChunk3;
var toArray6 = toArray5;

// node_modules/effect/dist/esm/TRandom.js
var TRandom_exports = {};
__export(TRandom_exports, {
  TRandomTypeId: () => TRandomTypeId2,
  Tag: () => Tag2,
  live: () => live2,
  next: () => next2,
  nextBoolean: () => nextBoolean2,
  nextInt: () => nextInt2,
  nextIntBetween: () => nextIntBetween2,
  nextRange: () => nextRange2,
  shuffle: () => shuffle2
});

// node_modules/effect/dist/esm/internal/stm/tRandom.js
var TRandomSymbolKey = "effect/TRandom";
var TRandomTypeId = Symbol.for(TRandomSymbolKey);
var randomInteger = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.integer(0), prng.getState()];
};
var randomIntegerBetween = (low, high) => {
  return (state) => {
    const prng = new PCGRandom();
    prng.setState(state);
    return [prng.integer(high - low) + low, prng.getState()];
  };
};
var randomNumber = (state) => {
  const prng = new PCGRandom();
  prng.setState(state);
  return [prng.number(), prng.getState()];
};
var withState = (state, f) => {
  return pipe(state, modify4(f));
};
var shuffleWith = (iterable, nextIntBounded) => {
  const swap = (buffer, index1, index2) => pipe(buffer, get26(index1), flatMap3((tmp) => pipe(buffer, updateSTM(index1, () => pipe(buffer, get26(index2))), zipRight3(pipe(buffer, update9(index2, () => tmp))))));
  return pipe(fromIterable12(iterable), flatMap3((buffer) => {
    const array = [];
    for (let i = array.length; i >= 2; i = i - 1) {
      array.push(i);
    }
    return pipe(array, forEach2((n) => pipe(nextIntBounded(n), flatMap3((k) => swap(buffer, n - 1, k))), {
      discard: true
    }), zipRight3(toArray(buffer)));
  }));
};
var Tag = GenericTag("effect/TRandom");
var TRandomImpl = class {
  state;
  [TRandomTypeId] = TRandomTypeId;
  constructor(state) {
    this.state = state;
    this.next = withState(this.state, randomNumber);
    this.nextBoolean = flatMap3(this.next, (n) => succeed5(n > 0.5));
    this.nextInt = withState(this.state, randomInteger);
  }
  next;
  nextBoolean;
  nextInt;
  nextRange(min, max) {
    return flatMap3(this.next, (n) => succeed5((max - min) * n + min));
  }
  nextIntBetween(low, high) {
    return withState(this.state, randomIntegerBetween(low, high));
  }
  shuffle(elements) {
    return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
  }
};
var live = effect(Tag, pipe(make18(new PCGRandom(Math.random() * 4294967296 >>> 0).getState()), map8((seed) => new TRandomImpl(seed)), commit));
var next = flatMap3(Tag, (random) => random.next);
var nextBoolean = flatMap3(Tag, (random) => random.nextBoolean);
var nextInt = flatMap3(Tag, (random) => random.nextInt);
var nextIntBetween = (low, high) => flatMap3(Tag, (random) => random.nextIntBetween(low, high));
var nextRange = (min, max) => flatMap3(Tag, (random) => random.nextRange(min, max));
var shuffle = (elements) => flatMap3(Tag, (random) => random.shuffle(elements));

// node_modules/effect/dist/esm/TRandom.js
var TRandomTypeId2 = TRandomTypeId;
var Tag2 = Tag;
var live2 = live;
var next2 = next;
var nextBoolean2 = nextBoolean;
var nextInt2 = nextInt;
var nextIntBetween2 = nextIntBetween;
var nextRange2 = nextRange;
var shuffle2 = shuffle;

// node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLock_exports = {};
__export(TReentrantLock_exports, {
  TReentrantLockTypeId: () => TReentrantLockTypeId2,
  acquireRead: () => acquireRead2,
  acquireWrite: () => acquireWrite2,
  fiberReadLocks: () => fiberReadLocks2,
  fiberWriteLocks: () => fiberWriteLocks2,
  lock: () => lock2,
  locked: () => locked2,
  make: () => make68,
  readLock: () => readLock2,
  readLocked: () => readLocked2,
  readLocks: () => readLocks2,
  releaseRead: () => releaseRead2,
  releaseWrite: () => releaseWrite2,
  withLock: () => withLock2,
  withReadLock: () => withReadLock2,
  withWriteLock: () => withWriteLock2,
  writeLock: () => writeLock2,
  writeLocked: () => writeLocked2,
  writeLocks: () => writeLocks2
});

// node_modules/effect/dist/esm/internal/stm/tReentrantLock.js
var TReentrantLockSymbolKey = "effect/TReentrantLock";
var TReentrantLockTypeId = Symbol.for(TReentrantLockSymbolKey);
var WriteLockTypeId = Symbol.for("effect/TReentrantLock/WriteLock");
var ReadLockTypeId = Symbol.for("effect/TReentrantLock/ReadLock");
var TReentranLockImpl = class {
  state;
  [TReentrantLockTypeId] = TReentrantLockTypeId;
  constructor(state) {
    this.state = state;
  }
};
var ReadLock = class {
  readers;
  [ReadLockTypeId] = ReadLockTypeId;
  constructor(readers) {
    this.readers = readers;
  }
  get readLocks() {
    return Array.from(this.readers).reduce((acc, curr) => acc + curr[1], 0);
  }
  get writeLocks() {
    return 0;
  }
  readLocksHeld(fiberId4) {
    return getOrElse(get3(this.readers, fiberId4), () => 0);
  }
  writeLocksHeld(_fiberId) {
    return 0;
  }
};
var WriteLock = class {
  readLocks;
  writeLocks;
  fiberId;
  [WriteLockTypeId] = WriteLockTypeId;
  constructor(readLocks3, writeLocks3, fiberId4) {
    this.readLocks = readLocks3;
    this.writeLocks = writeLocks3;
    this.fiberId = fiberId4;
  }
  readLocksHeld(fiberId4) {
    return equals(fiberId4)(this.fiberId) ? this.readLocks : 0;
  }
  writeLocksHeld(fiberId4) {
    return equals(fiberId4)(this.fiberId) ? this.writeLocks : 0;
  }
};
var isReadLock = (lock3) => {
  return ReadLockTypeId in lock3;
};
var isWriteLock = (lock3) => {
  return WriteLockTypeId in lock3;
};
var emptyReadLock = new ReadLock(empty4());
var makeReadLock = (fiberId4, count5) => {
  if (count5 <= 0) {
    return emptyReadLock;
  }
  return new ReadLock(make5([fiberId4, count5]));
};
var noOtherHolder = (readLock3, fiberId4) => {
  return isEmpty(readLock3.readers) || size(readLock3.readers) === 1 && has2(readLock3.readers, fiberId4);
};
var adjustReadLock = (readLock3, fiberId4, adjustment) => {
  const total = readLock3.readLocksHeld(fiberId4);
  const newTotal = total + adjustment;
  if (newTotal < 0) {
    throw new Error("BUG - TReentrantLock.ReadLock.adjust - please report an issue at https://github.com/Effect-TS/effect/issues");
  }
  if (newTotal === 0) {
    return new ReadLock(remove(readLock3.readers, fiberId4));
  }
  return new ReadLock(set2(readLock3.readers, fiberId4, newTotal));
};
var adjustRead = (self, delta) => withSTMRuntime((runtime4) => {
  const lock3 = unsafeGet4(self.state, runtime4.journal);
  if (isReadLock(lock3)) {
    const result = adjustReadLock(lock3, runtime4.fiberId, delta);
    unsafeSet(self.state, result, runtime4.journal);
    return succeed5(result.readLocksHeld(runtime4.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime4.fiberId)(lock3.fiberId)) {
    const newTotal = lock3.readLocks + delta;
    if (newTotal < 0) {
      throw new Error(`Defect: Fiber ${threadName(runtime4.fiberId)} releasing read locks it does not hold, newTotal: ${newTotal}`);
    }
    unsafeSet(self.state, new WriteLock(newTotal, lock3.writeLocks, runtime4.fiberId), runtime4.journal);
    return succeed5(newTotal);
  }
  return retry;
});
var acquireRead = (self) => adjustRead(self, 1);
var acquireWrite = (self) => withSTMRuntime((runtime4) => {
  const lock3 = unsafeGet4(self.state, runtime4.journal);
  if (isReadLock(lock3) && noOtherHolder(lock3, runtime4.fiberId)) {
    unsafeSet(self.state, new WriteLock(lock3.readLocksHeld(runtime4.fiberId), 1, runtime4.fiberId), runtime4.journal);
    return succeed5(1);
  }
  if (isWriteLock(lock3) && equals(runtime4.fiberId)(lock3.fiberId)) {
    unsafeSet(self.state, new WriteLock(lock3.readLocks, lock3.writeLocks + 1, runtime4.fiberId), runtime4.journal);
    return succeed5(lock3.writeLocks + 1);
  }
  return retry;
});
var fiberReadLocks = (self) => effect2((journal, fiberId4) => unsafeGet4(self.state, journal).readLocksHeld(fiberId4));
var fiberWriteLocks = (self) => effect2((journal, fiberId4) => unsafeGet4(self.state, journal).writeLocksHeld(fiberId4));
var lock = (self) => writeLock(self);
var locked = (self) => zipWith2(readLocked(self), writeLocked(self), (x, y) => x || y);
var make67 = map8(make18(emptyReadLock), (readLock3) => new TReentranLockImpl(readLock3));
var readLock = (self) => acquireRelease2(commit(acquireRead(self)), () => commit(releaseRead(self)));
var readLocks = (self) => map8(get8(self.state), (state) => state.readLocks);
var readLocked = (self) => map8(get8(self.state), (state) => state.readLocks > 0);
var releaseRead = (self) => adjustRead(self, -1);
var releaseWrite = (self) => withSTMRuntime((runtime4) => {
  const lock3 = unsafeGet4(self.state, runtime4.journal);
  if (isWriteLock(lock3) && lock3.writeLocks === 1 && equals(runtime4.fiberId)(lock3.fiberId)) {
    const result = makeReadLock(lock3.fiberId, lock3.readLocks);
    unsafeSet(self.state, result, runtime4.journal);
    return succeed5(result.writeLocksHeld(runtime4.fiberId));
  }
  if (isWriteLock(lock3) && equals(runtime4.fiberId)(lock3.fiberId)) {
    const result = new WriteLock(lock3.readLocks, lock3.writeLocks - 1, runtime4.fiberId);
    unsafeSet(self.state, result, runtime4.journal);
    return succeed5(result.writeLocksHeld(runtime4.fiberId));
  }
  throw new Error(`Defect: Fiber ${threadName(runtime4.fiberId)} releasing write lock it does not hold`);
});
var withLock = dual(2, (effect3, self) => withWriteLock(effect3, self));
var withReadLock = dual(2, (effect3, self) => uninterruptibleMask2((restore) => zipRight2(restore(commit(acquireRead(self))), ensuring2(effect3, commit(releaseRead(self))))));
var withWriteLock = dual(2, (effect3, self) => uninterruptibleMask2((restore) => zipRight2(restore(commit(acquireWrite(self))), ensuring2(effect3, commit(releaseWrite(self))))));
var writeLock = (self) => acquireRelease2(commit(acquireWrite(self)), () => commit(releaseWrite(self)));
var writeLocked = (self) => map8(get8(self.state), (state) => state.writeLocks > 0);
var writeLocks = (self) => map8(get8(self.state), (state) => state.writeLocks);

// node_modules/effect/dist/esm/TReentrantLock.js
var TReentrantLockTypeId2 = TReentrantLockTypeId;
var acquireRead2 = acquireRead;
var acquireWrite2 = acquireWrite;
var fiberReadLocks2 = fiberReadLocks;
var fiberWriteLocks2 = fiberWriteLocks;
var lock2 = lock;
var locked2 = locked;
var make68 = make67;
var readLock2 = readLock;
var readLocks2 = readLocks;
var readLocked2 = readLocked;
var releaseRead2 = releaseRead;
var releaseWrite2 = releaseWrite;
var withLock2 = withLock;
var withReadLock2 = withReadLock;
var withWriteLock2 = withWriteLock;
var writeLock2 = writeLock;
var writeLocked2 = writeLocked;
var writeLocks2 = writeLocks;

// node_modules/effect/dist/esm/TRef.js
var TRef_exports = {};
__export(TRef_exports, {
  TRefTypeId: () => TRefTypeId2,
  get: () => get30,
  getAndSet: () => getAndSet6,
  getAndUpdate: () => getAndUpdate6,
  getAndUpdateSome: () => getAndUpdateSome6,
  make: () => make69,
  modify: () => modify9,
  modifySome: () => modifySome6,
  set: () => set19,
  setAndGet: () => setAndGet6,
  update: () => update11,
  updateAndGet: () => updateAndGet6,
  updateSome: () => updateSome6,
  updateSomeAndGet: () => updateSomeAndGet6
});
var TRefTypeId2 = TRefTypeId;
var get30 = get8;
var getAndSet6 = getAndSet3;
var getAndUpdate6 = getAndUpdate3;
var getAndUpdateSome6 = getAndUpdateSome3;
var make69 = make18;
var modify9 = modify4;
var modifySome6 = modifySome3;
var set19 = set7;
var setAndGet6 = setAndGet3;
var update11 = update5;
var updateAndGet6 = updateAndGet3;
var updateSome6 = updateSome3;
var updateSomeAndGet6 = updateSomeAndGet3;

// node_modules/effect/dist/esm/TSemaphore.js
var TSemaphore_exports = {};
__export(TSemaphore_exports, {
  TSemaphoreTypeId: () => TSemaphoreTypeId2,
  acquire: () => acquire3,
  acquireN: () => acquireN2,
  available: () => available2,
  make: () => make71,
  release: () => release3,
  releaseN: () => releaseN2,
  unsafeMake: () => unsafeMake10,
  withPermit: () => withPermit2,
  withPermitScoped: () => withPermitScoped2,
  withPermits: () => withPermits2,
  withPermitsScoped: () => withPermitsScoped2
});

// node_modules/effect/dist/esm/internal/stm/tSemaphore.js
var TSemaphoreSymbolKey = "effect/TSemaphore";
var TSemaphoreTypeId = Symbol.for(TSemaphoreSymbolKey);
var TSemaphoreImpl = class {
  permits;
  [TSemaphoreTypeId] = TSemaphoreTypeId;
  constructor(permits) {
    this.permits = permits;
  }
};
var make70 = (permits) => map12(make18(permits), (permits2) => new TSemaphoreImpl(permits2));
var acquire2 = (self) => acquireN(self, 1);
var acquireN = dual(2, (self, n) => withSTMRuntime((driver) => {
  if (n < 0) {
    throw new IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.acquireN`);
  }
  const value7 = unsafeGet4(self.permits, driver.journal);
  if (value7 < n) {
    return retry4;
  } else {
    return succeed7(unsafeSet(self.permits, value7 - n, driver.journal));
  }
}));
var available = (self) => get8(self.permits);
var release2 = (self) => releaseN(self, 1);
var releaseN = dual(2, (self, n) => withSTMRuntime((driver) => {
  if (n < 0) {
    throw new IllegalArgumentException(`Unexpected negative value ${n} passed to Semaphore.releaseN`);
  }
  const current = unsafeGet4(self.permits, driver.journal);
  return succeed7(unsafeSet(self.permits, current + n, driver.journal));
}));
var withPermit = dual(2, (self, semaphore) => withPermits(self, semaphore, 1));
var withPermits = dual(3, (self, semaphore, permits) => uninterruptibleMask2((restore) => zipRight2(restore(commit(acquireN(permits)(semaphore))), ensuring2(self, commit(releaseN(permits)(semaphore))))));
var withPermitScoped = (self) => withPermitsScoped(self, 1);
var withPermitsScoped = dual(2, (self, permits) => acquireReleaseInterruptible(commit(acquireN(self, permits)), () => commit(releaseN(self, permits))));
var unsafeMakeSemaphore2 = (permits) => {
  return new TSemaphoreImpl(new TRefImpl(permits));
};

// node_modules/effect/dist/esm/TSemaphore.js
var TSemaphoreTypeId2 = TSemaphoreTypeId;
var acquire3 = acquire2;
var acquireN2 = acquireN;
var available2 = available;
var make71 = make70;
var release3 = release2;
var releaseN2 = releaseN;
var withPermit2 = withPermit;
var withPermits2 = withPermits;
var withPermitScoped2 = withPermitScoped;
var withPermitsScoped2 = withPermitsScoped;
var unsafeMake10 = unsafeMakeSemaphore2;

// node_modules/effect/dist/esm/TSet.js
var TSet_exports = {};
__export(TSet_exports, {
  TSetTypeId: () => TSetTypeId2,
  add: () => add5,
  difference: () => difference2,
  empty: () => empty19,
  forEach: () => forEach9,
  fromIterable: () => fromIterable19,
  has: () => has11,
  intersection: () => intersection2,
  isEmpty: () => isEmpty8,
  make: () => make73,
  reduce: () => reduce15,
  reduceSTM: () => reduceSTM6,
  remove: () => remove9,
  removeAll: () => removeAll4,
  removeIf: () => removeIf6,
  retainIf: () => retainIf6,
  size: () => size14,
  takeFirst: () => takeFirst4,
  takeFirstSTM: () => takeFirstSTM4,
  takeSome: () => takeSome4,
  takeSomeSTM: () => takeSomeSTM4,
  toArray: () => toArray8,
  toChunk: () => toChunk6,
  toHashSet: () => toHashSet2,
  toReadonlySet: () => toReadonlySet2,
  transform: () => transform6,
  transformSTM: () => transformSTM6,
  union: () => union4
});

// node_modules/effect/dist/esm/internal/stm/tSet.js
var TSetSymbolKey = "effect/TSet";
var TSetTypeId = Symbol.for(TSetSymbolKey);
var tSetVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TSetImpl = class {
  tMap;
  [TSetTypeId] = tSetVariance;
  constructor(tMap) {
    this.tMap = tMap;
  }
};
var isTSet = (u) => hasProperty(u, TSetTypeId);
var add4 = dual(2, (self, value7) => set17(self.tMap, value7, void 0));
var difference = dual(2, (self, other) => flatMap3(toHashSet(other), (values7) => removeIf5(self, (value7) => has(values7, value7), {
  discard: true
})));
var empty18 = () => fromIterable18([]);
var forEach8 = dual(2, (self, f) => reduceSTM5(self, void 0, (_, value7) => f(value7)));
var fromIterable18 = (iterable) => map8(fromIterable14(Array.from(iterable).map((a) => [a, void 0])), (tMap) => new TSetImpl(tMap));
var has10 = dual(2, (self, value7) => has8(self.tMap, value7));
var intersection = dual(2, (self, other) => flatMap3(toHashSet(other), (values7) => pipe(self, retainIf5((value7) => pipe(values7, has(value7)), {
  discard: true
}))));
var isEmpty7 = (self) => isEmpty3(self.tMap);
var make72 = (...elements) => fromIterable18(elements);
var reduce14 = dual(3, (self, zero, f) => reduce12(self.tMap, zero, (acc, _, key) => f(acc, key)));
var reduceSTM5 = dual(3, (self, zero, f) => reduceSTM3(self.tMap, zero, (acc, _, key) => f(acc, key)));
var remove8 = dual(2, (self, value7) => remove6(self.tMap, value7));
var removeAll3 = dual(2, (self, iterable) => removeAll(self.tMap, iterable));
var removeIf5 = dual((args) => isTSet(args[0]), (self, predicate, options) => options?.discard === true ? removeIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(removeIf(self.tMap, (key) => predicate(key)), map8(map3((entry) => entry[0]))));
var retainIf5 = dual((args) => isTSet(args[0]), (self, predicate, options) => options?.discard === true ? retainIf(self.tMap, (key) => predicate(key), {
  discard: true
}) : pipe(retainIf(self.tMap, (key) => predicate(key)), map8(map3((entry) => entry[0]))));
var size13 = (self) => map8(toChunk5(self), (chunk3) => chunk3.length);
var takeFirst3 = dual(2, (self, pf) => takeFirst(self.tMap, (key) => pf(key)));
var takeFirstSTM3 = dual(2, (self, pf) => takeFirstSTM(self.tMap, (key) => pf(key)));
var takeSome3 = dual(2, (self, pf) => takeSome(self.tMap, (key) => pf(key)));
var takeSomeSTM3 = dual(2, (self, pf) => takeSomeSTM(self.tMap, (key) => pf(key)));
var toChunk5 = (self) => keys6(self.tMap).pipe(map12(unsafeFromArray));
var toHashSet = (self) => reduce14(self, empty3(), (acc, value7) => pipe(acc, add2(value7)));
var toArray7 = (self) => reduce14(self, [], (acc, value7) => [...acc, value7]);
var toReadonlySet = (self) => map8(toArray7(self), (values7) => new Set(values7));
var transform5 = dual(2, (self, f) => transform3(self.tMap, (key, value7) => [f(key), value7]));
var transformSTM5 = dual(2, (self, f) => transformSTM3(self.tMap, (key, value7) => map8(f(key), (a) => [a, value7])));
var union3 = dual(2, (self, other) => forEach8(other, (value7) => add4(self, value7)));

// node_modules/effect/dist/esm/TSet.js
var TSetTypeId2 = TSetTypeId;
var add5 = add4;
var difference2 = difference;
var empty19 = empty18;
var forEach9 = forEach8;
var fromIterable19 = fromIterable18;
var has11 = has10;
var intersection2 = intersection;
var isEmpty8 = isEmpty7;
var make73 = make72;
var reduce15 = reduce14;
var reduceSTM6 = reduceSTM5;
var remove9 = remove8;
var removeAll4 = removeAll3;
var removeIf6 = removeIf5;
var retainIf6 = retainIf5;
var size14 = size13;
var takeFirst4 = takeFirst3;
var takeFirstSTM4 = takeFirstSTM3;
var takeSome4 = takeSome3;
var takeSomeSTM4 = takeSomeSTM3;
var toChunk6 = toChunk5;
var toHashSet2 = toHashSet;
var toArray8 = toArray7;
var toReadonlySet2 = toReadonlySet;
var transform6 = transform5;
var transformSTM6 = transformSTM5;
var union4 = union3;

// node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRef_exports = {};
__export(TSubscriptionRef_exports, {
  TSubscriptionRefTypeId: () => TSubscriptionRefTypeId2,
  changes: () => changes,
  changesScoped: () => changesScoped2,
  changesStream: () => changesStream2,
  get: () => get32,
  getAndSet: () => getAndSet8,
  getAndUpdate: () => getAndUpdate8,
  getAndUpdateSome: () => getAndUpdateSome8,
  make: () => make75,
  modify: () => modify11,
  modifySome: () => modifySome8,
  set: () => set21,
  setAndGet: () => setAndGet8,
  update: () => update13,
  updateAndGet: () => updateAndGet8,
  updateSome: () => updateSome8,
  updateSomeAndGet: () => updateSomeAndGet8
});

// node_modules/effect/dist/esm/internal/stm/tSubscriptionRef.js
var TSubscriptionRefSymbolKey = "effect/TSubscriptionRef";
var TSubscriptionRefTypeId = Symbol.for(TSubscriptionRefSymbolKey);
var TSubscriptionRefVariance = {
  /* c8 ignore next */
  _A: (_) => _
};
var TDequeueMerge = class {
  first;
  second;
  [TDequeueTypeId] = tDequeueVariance;
  constructor(first4, second) {
    this.first = first4;
    this.second = second;
  }
  peek = gen4(this, function* () {
    const first4 = yield* this.peekOption;
    if (first4._tag === "Some") {
      return first4.value;
    }
    return yield* retry4;
  });
  peekOption = gen4(this, function* () {
    const first4 = yield* this.first.peekOption;
    if (first4._tag === "Some") {
      return first4;
    }
    const second = yield* this.second.peekOption;
    if (second._tag === "Some") {
      return second;
    }
    return none();
  });
  take = gen4(this, function* () {
    if (!(yield* this.first.isEmpty)) {
      return yield* this.first.take;
    }
    if (!(yield* this.second.isEmpty)) {
      return yield* this.second.take;
    }
    return yield* retry4;
  });
  takeAll = gen4(this, function* () {
    return [...yield* this.first.takeAll, ...yield* this.second.takeAll];
  });
  takeUpTo(max) {
    return gen4(this, function* () {
      const first4 = yield* this.first.takeUpTo(max);
      if (first4.length >= max) {
        return first4;
      }
      return [...first4, ...yield* this.second.takeUpTo(max - first4.length)];
    });
  }
  capacity() {
    return this.first.capacity() + this.second.capacity();
  }
  size = gen4(this, function* () {
    return (yield* this.first.size) + (yield* this.second.size);
  });
  isFull = gen4(this, function* () {
    return (yield* this.first.isFull) && (yield* this.second.isFull);
  });
  isEmpty = gen4(this, function* () {
    return (yield* this.first.isEmpty) && (yield* this.second.isEmpty);
  });
  shutdown = gen4(this, function* () {
    yield* this.first.shutdown;
    yield* this.second.shutdown;
  });
  isShutdown = gen4(this, function* () {
    return (yield* this.first.isShutdown) && (yield* this.second.isShutdown);
  });
  awaitShutdown = gen4(this, function* () {
    yield* this.first.awaitShutdown;
    yield* this.second.awaitShutdown;
  });
};
var TSubscriptionRefImpl = class {
  ref;
  pubsub;
  [TSubscriptionRefTypeId] = TSubscriptionRefVariance;
  [TRefTypeId2] = tRefVariance;
  constructor(ref, pubsub) {
    this.ref = ref;
    this.pubsub = pubsub;
  }
  get todos() {
    return this.ref.todos;
  }
  get versioned() {
    return this.ref.versioned;
  }
  pipe() {
    return pipeArguments(this, arguments);
  }
  get changes() {
    return gen4(this, function* () {
      const first4 = yield* unbounded4();
      yield* offer2(first4, yield* get30(this.ref));
      return new TDequeueMerge(first4, yield* subscribe(this.pubsub));
    });
  }
  modify(f) {
    return pipe(get30(this.ref), map12(f), flatMap4(([b, a]) => pipe(set19(this.ref, a), as4(b), zipLeft3(publish2(this.pubsub, a)))));
  }
};
var make74 = (value7) => pipe(all4([unbounded3(), make69(value7)]), map12(([pubsub, ref]) => new TSubscriptionRefImpl(ref, pubsub)));
var get31 = (self) => get30(self.ref);
var set20 = dual(2, (self, value7) => self.modify(() => [void 0, value7]));
var getAndSet7 = dual(2, (self, value7) => self.modify((a) => [a, value7]));
var getAndUpdate7 = dual(2, (self, f) => self.modify((a) => [a, f(a)]));
var getAndUpdateSome7 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [a, b]
})));
var setAndGet7 = dual(2, (self, value7) => self.modify(() => [value7, value7]));
var modify10 = dual(2, (self, f) => self.modify(f));
var modifySome7 = dual(3, (self, fallback, f) => self.modify((a) => match2(f(a), {
  onNone: () => [fallback, a],
  onSome: (b) => b
})));
var update12 = dual(2, (self, f) => self.modify((a) => [void 0, f(a)]));
var updateAndGet7 = dual(2, (self, f) => self.modify((a) => {
  const b = f(a);
  return [b, b];
}));
var updateSome7 = dual(2, (self, f) => self.modify((a) => [void 0, match2(f(a), {
  onNone: () => a,
  onSome: (b) => b
})]));
var updateSomeAndGet7 = dual(2, (self, f) => self.modify((a) => match2(f(a), {
  onNone: () => [a, a],
  onSome: (b) => [b, b]
})));
var changesScoped = (self) => acquireRelease2(self.changes, shutdown);
var changesStream = (self) => unwrap(map7(self.changes, fromTQueue));

// node_modules/effect/dist/esm/TSubscriptionRef.js
var TSubscriptionRefTypeId2 = TSubscriptionRefTypeId;
var get32 = get31;
var getAndSet8 = getAndSet7;
var getAndUpdate8 = getAndUpdate7;
var getAndUpdateSome8 = getAndUpdateSome7;
var make75 = make74;
var modify11 = modify10;
var modifySome8 = modifySome7;
var set21 = set20;
var setAndGet8 = setAndGet7;
var update13 = update12;
var updateAndGet8 = updateAndGet7;
var updateSome8 = updateSome7;
var updateSomeAndGet8 = updateSomeAndGet7;
var changesScoped2 = changesScoped;
var changesStream2 = changesStream;
var changes = (self) => self.changes;

// node_modules/effect/dist/esm/Take.js
var Take_exports = {};
__export(Take_exports, {
  TakeTypeId: () => TakeTypeId2,
  chunk: () => chunk2,
  die: () => die5,
  dieMessage: () => dieMessage4,
  done: () => done5,
  end: () => end2,
  fail: () => fail7,
  failCause: () => failCause3,
  fromEffect: () => fromEffect6,
  fromExit: () => fromExit2,
  fromPull: () => fromPull2,
  isDone: () => isDone3,
  isFailure: () => isFailure5,
  isSuccess: () => isSuccess5,
  make: () => make76,
  map: () => map15,
  match: () => match16,
  matchEffect: () => matchEffect3,
  of: () => of3,
  tap: () => tap6
});
var TakeTypeId2 = TakeTypeId;
var chunk2 = chunk;
var die5 = die3;
var dieMessage4 = dieMessage2;
var done5 = done2;
var end2 = end;
var fail7 = fail3;
var failCause3 = failCause2;
var fromEffect6 = fromEffect2;
var fromExit2 = fromExit;
var fromPull2 = fromPull;
var isDone3 = isDone2;
var isFailure5 = isFailure3;
var isSuccess5 = isSuccess3;
var make76 = make19;
var map15 = map9;
var match16 = match9;
var matchEffect3 = matchEffect2;
var of3 = of2;
var tap6 = tap4;

// node_modules/effect/dist/esm/TestAnnotation.js
var TestAnnotation_exports = {};
__export(TestAnnotation_exports, {
  TestAnnotationTypeId: () => TestAnnotationTypeId,
  compose: () => compose,
  fibers: () => fibers,
  ignored: () => ignored,
  isTestAnnotation: () => isTestAnnotation,
  make: () => make77,
  repeated: () => repeated,
  retried: () => retried,
  tagged: () => tagged5
});
var TestAnnotationSymbolKey = "effect/TestAnnotation";
var TestAnnotationTypeId = Symbol.for(TestAnnotationSymbolKey);
var TestAnnotationImpl = class {
  identifier;
  initial;
  combine;
  [TestAnnotationTypeId] = {
    _A: (_) => _
  };
  constructor(identifier, initial, combine5) {
    this.identifier = identifier;
    this.initial = initial;
    this.combine = combine5;
  }
  [symbol2]() {
    return pipe(hash(TestAnnotationSymbolKey), combine(hash(this.identifier)), cached(this));
  }
  [symbol3](that) {
    return isTestAnnotation(that) && this.identifier === that.identifier;
  }
};
var isTestAnnotation = (u) => hasProperty(u, TestAnnotationTypeId);
var make77 = (identifier, initial, combine5) => {
  return new TestAnnotationImpl(identifier, initial, combine5);
};
var compose = (left2, right2) => {
  if (isLeft(left2) && isLeft(right2)) {
    return left(left2.left + right2.left);
  }
  if (isRight(left2) && isRight(right2)) {
    return right(pipe(left2.right, appendAll(right2.right)));
  }
  if (isRight(left2) && isLeft(right2)) {
    return right2;
  }
  if (isLeft(left2) && isRight(right2)) {
    return right2;
  }
  throw new Error(getBugErrorMessage("TestAnnotation.compose"));
};
var fibers = make77("fibers", left(0), compose);
var ignored = make77("ignored", 0, (a, b) => a + b);
var repeated = make77("repeated", 0, (a, b) => a + b);
var retried = make77("retried", 0, (a, b) => a + b);
var tagged5 = make77("tagged", empty3(), (a, b) => pipe(a, union(b)));

// node_modules/effect/dist/esm/TestAnnotationMap.js
var TestAnnotationMap_exports = {};
__export(TestAnnotationMap_exports, {
  TestAnnotationMapTypeId: () => TestAnnotationMapTypeId,
  annotate: () => annotate,
  combine: () => combine4,
  empty: () => empty20,
  get: () => get33,
  isTestAnnotationMap: () => isTestAnnotationMap,
  make: () => make78,
  overwrite: () => overwrite,
  update: () => update14
});
var TestAnnotationMapTypeId = Symbol.for("effect/TestAnnotationMap");
var TestAnnotationMapImpl = class {
  map;
  [TestAnnotationMapTypeId] = TestAnnotationMapTypeId;
  constructor(map18) {
    this.map = map18;
  }
};
var isTestAnnotationMap = (u) => hasProperty(u, TestAnnotationMapTypeId);
var empty20 = () => new TestAnnotationMapImpl(empty4());
var make78 = (map18) => {
  return new TestAnnotationMapImpl(map18);
};
var overwrite = dual(3, (self, key, value7) => make78(set2(self.map, key, value7)));
var update14 = dual(3, (self, key, f) => {
  let value7 = key.initial;
  if (has2(self.map, key)) {
    value7 = unsafeGet2(self.map, key);
  }
  return overwrite(self, key, f(value7));
});
var get33 = dual(2, (self, key) => {
  if (has2(self.map, key)) {
    return unsafeGet2(self.map, key);
  }
  return key.initial;
});
var annotate = dual(3, (self, key, value7) => update14(self, key, (_) => key.combine(_, value7)));
var combine4 = dual(2, (self, that) => {
  let result = self.map;
  for (const entry of that.map) {
    if (has2(result, entry[0])) {
      const value7 = get3(result, entry[0]);
      result = set2(result, entry[0], entry[0].combine(value7, entry[1]));
    } else {
      result = set2(result, entry[0], entry[1]);
    }
  }
  return make78(result);
});

// node_modules/effect/dist/esm/TestAnnotations.js
var TestAnnotations_exports = {};
__export(TestAnnotations_exports, {
  TestAnnotations: () => TestAnnotations,
  TestAnnotationsTypeId: () => TestAnnotationsTypeId,
  isTestAnnotations: () => isTestAnnotations,
  make: () => make79
});
var TestAnnotationsTypeId = Symbol.for("effect/TestAnnotations");
var AnnotationsImpl = class {
  ref;
  [TestAnnotationsTypeId] = TestAnnotationsTypeId;
  constructor(ref) {
    this.ref = ref;
  }
  get(key) {
    return map5(get6(this.ref), get33(key));
  }
  annotate(key, value7) {
    return update3(this.ref, annotate(key, value7));
  }
  get supervisedFibers() {
    return descriptorWith((descriptor) => flatMap(this.get(fibers), (either5) => {
      switch (either5._tag) {
        case "Left": {
          return succeed(empty8(Order2));
        }
        case "Right": {
          return pipe(either5.right, forEachSequential((ref) => sync(() => get2(ref))), map5(reduce(empty8(Order2), (a, b) => union2(a, b))), map5(filter3((fiber) => !equals(fiber.id(), descriptor.id))));
        }
      }
    }));
  }
};
var TestAnnotations = GenericTag("effect/Annotations");
var isTestAnnotations = (u) => hasProperty(u, TestAnnotationsTypeId);
var make79 = (ref) => new AnnotationsImpl(ref);

// node_modules/effect/dist/esm/TestClock.js
var TestClock_exports = {};
__export(TestClock_exports, {
  TestClock: () => TestClock,
  TestClockImpl: () => TestClockImpl,
  adjust: () => adjust,
  adjustWith: () => adjustWith,
  currentTimeMillis: () => currentTimeMillis,
  defaultTestClock: () => defaultTestClock,
  live: () => live3,
  makeData: () => makeData,
  save: () => save,
  setTime: () => setTime,
  sleep: () => sleep2,
  sleeps: () => sleeps,
  testClock: () => testClock,
  testClockWith: () => testClockWith
});

// node_modules/effect/dist/esm/internal/testing/suspendedWarningData.js
var OP_SUSPENDED_WARNING_DATA_START = "Start";
var OP_SUSPENDED_WARNING_DATA_PENDING = "Pending";
var OP_SUSPENDED_WARNING_DATA_DONE = "Done";
var start = {
  _tag: OP_SUSPENDED_WARNING_DATA_START
};
var pending2 = (fiber) => {
  return {
    _tag: OP_SUSPENDED_WARNING_DATA_PENDING,
    fiber
  };
};
var done6 = {
  _tag: OP_SUSPENDED_WARNING_DATA_DONE
};
var isStart = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_START;
};
var isPending2 = (self) => {
  return self._tag === OP_SUSPENDED_WARNING_DATA_PENDING;
};

// node_modules/effect/dist/esm/internal/testing/warningData.js
var OP_WARNING_DATA_START = "Start";
var OP_WARNING_DATA_PENDING = "Pending";
var OP_WARNING_DATA_DONE = "Done";
var start2 = {
  _tag: OP_WARNING_DATA_START
};
var pending3 = (fiber) => {
  return {
    _tag: OP_WARNING_DATA_PENDING,
    fiber
  };
};
var done7 = {
  _tag: OP_WARNING_DATA_DONE
};
var isStart2 = (self) => {
  return self._tag === OP_WARNING_DATA_START;
};
var isPending3 = (self) => {
  return self._tag === OP_WARNING_DATA_PENDING;
};

// node_modules/effect/dist/esm/TestLive.js
var TestLive_exports = {};
__export(TestLive_exports, {
  TestLive: () => TestLive,
  TestLiveTypeId: () => TestLiveTypeId,
  make: () => make80
});
var TestLiveTypeId = Symbol.for("effect/TestLive");
var TestLive = GenericTag("effect/TestLive");
var LiveImpl = class {
  services;
  [TestLiveTypeId] = TestLiveTypeId;
  constructor(services) {
    this.services = services;
  }
  provide(effect3) {
    return fiberRefLocallyWith(currentServices, merge(this.services))(effect3);
  }
};
var make80 = (services) => new LiveImpl(services);

// node_modules/effect/dist/esm/TestClock.js
var makeData = (instant, sleeps2) => ({
  instant,
  sleeps: sleeps2
});
var TestClock = GenericTag("effect/TestClock");
var warning = "Warning: A test is using time, but is not advancing the test clock, which may result in the test hanging. Use TestClock.adjust to manually advance the time.";
var suspendedWarning = "Warning: A test is advancing the test clock, but a fiber is not suspending, which may result in the test hanging. Use TestAspect.diagnose to identity the fiber that is not suspending.";
var TestClockImpl = class {
  clockState;
  live;
  annotations;
  warningState;
  suspendedWarningState;
  [ClockTypeId] = ClockTypeId;
  constructor(clockState, live6, annotations2, warningState, suspendedWarningState) {
    this.clockState = clockState;
    this.live = live6;
    this.annotations = annotations2;
    this.warningState = warningState;
    this.suspendedWarningState = suspendedWarningState;
    this.currentTimeMillis = map5(get5(this.clockState), (data) => data.instant);
    this.currentTimeNanos = map5(get5(this.clockState), (data) => BigInt(data.instant * 1e6));
  }
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis() {
    return unsafeGet3(this.clockState).instant;
  }
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos() {
    return BigInt(unsafeGet3(this.clockState).instant * 1e6);
  }
  /**
   * Returns the current clock time in milliseconds.
   */
  currentTimeMillis;
  /**
   * Returns the current clock time in nanoseconds.
   */
  currentTimeNanos;
  /**
   * Saves the `TestClock`'s current state in an effect which, when run, will
   * restore the `TestClock` state to the saved state.
   */
  get save() {
    return map5(get5(this.clockState), (data) => set4(this.clockState, data));
  }
  /**
   * Sets the current clock time to the specified instant. Any effects that
   * were scheduled to occur on or before the new time will be run in order.
   */
  setTime(instant) {
    return zipRight(this.warningDone(), this.run(() => instant));
  }
  /**
   * Semantically blocks the current fiber until the clock time is equal to or
   * greater than the specified duration. Once the clock time is adjusted to
   * on or after the duration, the fiber will automatically be resumed.
   */
  sleep(durationInput) {
    const duration = decode(durationInput);
    return flatMap(deferredMake(), (deferred) => pipe(modify(this.clockState, (data) => {
      const end3 = data.instant + toMillis(duration);
      if (end3 > data.instant) {
        return [true, makeData(data.instant, pipe(data.sleeps, prepend2([end3, deferred])))];
      }
      return [false, data];
    }), flatMap((shouldAwait) => shouldAwait ? pipe(this.warningStart(), zipRight(deferredAwait(deferred))) : pipe(deferredSucceed(deferred, void 0), asVoid))));
  }
  /**
   * Returns a list of the times at which all queued effects are scheduled to
   * resume.
   */
  get sleeps() {
    return map5(get5(this.clockState), (data) => map4(data.sleeps, (_) => _[0]));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjust(durationInput) {
    const duration = decode(durationInput);
    return zipRight(this.warningDone(), this.run((n) => n + toMillis(duration)));
  }
  /**
   * Increments the current clock time by the specified duration. Any effects
   * that were scheduled to occur on or before the new time will be run in
   * order.
   */
  adjustWith(durationInput) {
    const duration = decode(durationInput);
    return (effect3) => zipLeftOptions(effect3, this.adjust(duration), {
      concurrent: true
    });
  }
  /**
   * Returns a set of all fibers in this test.
   */
  supervisedFibers() {
    return this.annotations.supervisedFibers;
  }
  /**
   * Captures a "snapshot" of the identifier and status of all fibers in this
   * test other than the current fiber. Fails with the `void` value if any of
   * these fibers are not done or suspended. Note that because we cannot
   * synchronize on the status of multiple fibers at the same time this
   * snapshot may not be fully consistent.
   */
  freeze() {
    return flatMap(this.supervisedFibers(), (fibers2) => pipe(fibers2, reduce4(empty4(), (map18, fiber) => pipe(fiber.status, flatMap((status) => {
      if (isDone(status)) {
        return succeed(set2(map18, fiber.id(), status));
      }
      if (isSuspended(status)) {
        return succeed(set2(map18, fiber.id(), status));
      }
      return fail(void 0);
    })))));
  }
  /**
   * Forks a fiber that will display a warning message if a test is using time
   * but is not advancing the `TestClock`.
   */
  warningStart() {
    return updateSomeEffect(this.warningState, (data) => isStart2(data) ? some(pipe(this.live.provide(pipe(logWarning(warning), delay(seconds(5)))), interruptible2, fork, map5((fiber) => pending3(fiber)))) : none());
  }
  /**
   * Cancels the warning message that is displayed if a test is using time but
   * is not advancing the `TestClock`.
   */
  warningDone() {
    return updateSomeEffect(this.warningState, (warningData) => {
      if (isStart2(warningData)) {
        return some(succeed(done7));
      }
      if (isPending3(warningData)) {
        return some(pipe(interruptFiber(warningData.fiber), as(done7)));
      }
      return none();
    });
  }
  yieldTimer = async_((resume) => {
    const timer3 = setTimeout(() => {
      resume(void_);
    }, 0);
    return sync(() => clearTimeout(timer3));
  });
  /**
   * Returns whether all descendants of this fiber are done or suspended.
   */
  suspended() {
    return pipe(this.freeze(), zip(pipe(this.yieldTimer, zipRight(this.freeze()))), flatMap(([first4, last2]) => equals(first4, last2) ? succeed(first4) : fail(void 0)));
  }
  /**
   * Polls until all descendants of this fiber are done or suspended.
   */
  awaitSuspended() {
    return pipe(this.suspendedWarningStart(), zipRight(pipe(this.suspended(), zipWith(pipe(this.yieldTimer, zipRight(this.suspended())), equals), filterOrFail(identity, constVoid), eventually)), zipRight(this.suspendedWarningDone()));
  }
  /**
   * Forks a fiber that will display a warning message if a test is advancing
   * the `TestClock` but a fiber is not suspending.
   */
  suspendedWarningStart() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isStart(suspendedWarningData)) {
        return some(pipe(this.live.provide(pipe(logWarning(suspendedWarning), zipRight(set4(this.suspendedWarningState, done6)), delay(seconds(5)))), interruptible2, fork, map5((fiber) => pending2(fiber))));
      }
      return none();
    });
  }
  /**
   * Cancels the warning message that is displayed if a test is advancing the
   * `TestClock` but a fiber is not suspending.
   */
  suspendedWarningDone() {
    return updateSomeEffect(this.suspendedWarningState, (suspendedWarningData) => {
      if (isPending2(suspendedWarningData)) {
        return some(pipe(interruptFiber(suspendedWarningData.fiber), as(start)));
      }
      return none();
    });
  }
  /**
   * Runs all effects scheduled to occur on or before the specified instant,
   * which may depend on the current time, in order.
   */
  run(f) {
    return pipe(this.awaitSuspended(), zipRight(pipe(modify(this.clockState, (data) => {
      const end3 = f(data.instant);
      const sorted = pipe(data.sleeps, sort(pipe(Order, mapInput((_) => _[0]))));
      if (isNonEmpty(sorted)) {
        const [instant, deferred] = headNonEmpty(sorted);
        if (instant <= end3) {
          return [some([end3, deferred]), makeData(instant, tailNonEmpty(sorted))];
        }
      }
      return [none(), makeData(end3, data.sleeps)];
    }), flatMap((option5) => {
      switch (option5._tag) {
        case "None": {
          return void_;
        }
        case "Some": {
          const [end3, deferred] = option5.value;
          return pipe(deferredSucceed(deferred, void 0), zipRight(yieldNow()), zipRight(this.run(() => end3)));
        }
      }
    }))));
  }
};
var live3 = (data) => scoped(TestClock, gen(function* ($) {
  const live6 = yield* $(TestLive);
  const annotations2 = yield* $(TestAnnotations);
  const clockState = yield* $(sync(() => unsafeMake2(data)));
  const warningState = yield* $(makeSynchronized(start2));
  const suspendedWarningState = yield* $(makeSynchronized(start));
  const testClock2 = new TestClockImpl(clockState, live6, annotations2, warningState, suspendedWarningState);
  yield* $(withClockScoped(testClock2));
  yield* $(addFinalizer(() => zipRight(testClock2.warningDone(), testClock2.suspendedWarningDone())));
  return testClock2;
}));
var defaultTestClock = live3(makeData((/* @__PURE__ */ new Date(0)).getTime(), empty2()));
var adjust = (durationInput) => {
  const duration = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjust(duration));
};
var adjustWith = dual(2, (effect3, durationInput) => {
  const duration = decode(durationInput);
  return testClockWith((testClock2) => testClock2.adjustWith(duration)(effect3));
});
var save = () => testClockWith((testClock2) => testClock2.save);
var setTime = (input) => testClockWith((testClock2) => testClock2.setTime(typeof input === "number" ? input : unsafeMake5(input).epochMillis));
var sleep2 = (durationInput) => {
  const duration = decode(durationInput);
  return testClockWith((testClock2) => testClock2.sleep(duration));
};
var sleeps = () => testClockWith((testClock2) => testClock2.sleeps);
var testClock = () => testClockWith(succeed);
var testClockWith = (f) => fiberRefGetWith(currentServices, (services) => f(pipe(services, get(clockTag))));
var currentTimeMillis = testClockWith((testClock2) => testClock2.currentTimeMillis);

// node_modules/effect/dist/esm/TestConfig.js
var TestConfig_exports = {};
__export(TestConfig_exports, {
  TestConfig: () => TestConfig,
  make: () => make81
});
var TestConfig = GenericTag("effect/TestConfig");
var make81 = (params) => params;

// node_modules/effect/dist/esm/TestContext.js
var TestContext_exports = {};
__export(TestContext_exports, {
  LiveContext: () => LiveContext,
  TestContext: () => TestContext,
  live: () => live5
});

// node_modules/effect/dist/esm/TestServices.js
var TestServices_exports = {};
__export(TestServices_exports, {
  annotate: () => annotate2,
  annotations: () => annotations,
  annotationsLayer: () => annotationsLayer,
  annotationsWith: () => annotationsWith,
  currentServices: () => currentServices2,
  get: () => get34,
  live: () => live4,
  liveLayer: () => liveLayer,
  liveServices: () => liveServices2,
  liveWith: () => liveWith,
  provideLive: () => provideLive,
  provideWithLive: () => provideWithLive,
  repeats: () => repeats,
  retries: () => retries,
  samples: () => samples,
  shrinks: () => shrinks,
  size: () => size15,
  sized: () => sized,
  sizedLayer: () => sizedLayer,
  sizedWith: () => sizedWith,
  supervisedFibers: () => supervisedFibers,
  testConfig: () => testConfig,
  testConfigLayer: () => testConfigLayer,
  testConfigWith: () => testConfigWith,
  withAnnotations: () => withAnnotations,
  withAnnotationsScoped: () => withAnnotationsScoped,
  withLive: () => withLive,
  withLiveScoped: () => withLiveScoped,
  withSize: () => withSize,
  withSized: () => withSized,
  withSizedScoped: () => withSizedScoped,
  withTestConfig: () => withTestConfig,
  withTestConfigScoped: () => withTestConfigScoped
});

// node_modules/effect/dist/esm/TestSized.js
var TestSized_exports = {};
__export(TestSized_exports, {
  TestSized: () => TestSized,
  TestSizedTypeId: () => TestSizedTypeId,
  fromFiberRef: () => fromFiberRef,
  make: () => make82
});
var TestSizedTypeId = Symbol.for("effect/TestSized");
var TestSized = GenericTag("effect/TestSized");
var SizedImpl = class {
  fiberRef;
  [TestSizedTypeId] = TestSizedTypeId;
  constructor(fiberRef) {
    this.fiberRef = fiberRef;
  }
  get size() {
    return fiberRefGet(this.fiberRef);
  }
  withSize(size18) {
    return (effect3) => fiberRefLocally(this.fiberRef, size18)(effect3);
  }
};
var make82 = (size18) => new SizedImpl(fiberRefUnsafeMake(size18));
var fromFiberRef = (fiberRef) => new SizedImpl(fiberRef);

// node_modules/effect/dist/esm/TestServices.js
var liveServices2 = pipe(make(TestAnnotations, make79(unsafeMake2(empty20()))), add(TestLive, make80(liveServices)), add(TestSized, make82(100)), add(TestConfig, make81({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var currentServices2 = fiberRefUnsafeMakeContext(liveServices2);
var annotations = () => annotationsWith(succeed);
var annotationsWith = (f) => fiberRefGetWith(currentServices2, (services) => f(get(services, TestAnnotations)));
var withAnnotations = dual(2, (effect3, annotations2) => fiberRefLocallyWith(currentServices2, add(TestAnnotations, annotations2))(effect3));
var withAnnotationsScoped = (annotations2) => fiberRefLocallyScopedWith(currentServices2, add(TestAnnotations, annotations2));
var annotationsLayer = () => scoped(TestAnnotations, pipe(sync(() => unsafeMake2(empty20())), map5(make79), tap(withAnnotationsScoped)));
var get34 = (key) => annotationsWith((annotations2) => annotations2.get(key));
var annotate2 = (key, value7) => annotationsWith((annotations2) => annotations2.annotate(key, value7));
var supervisedFibers = () => annotationsWith((annotations2) => annotations2.supervisedFibers);
var liveWith = (f) => fiberRefGetWith(currentServices2, (services) => f(get(services, TestLive)));
var live4 = liveWith(succeed);
var withLive = dual(2, (effect3, live6) => fiberRefLocallyWith(currentServices2, add(TestLive, live6))(effect3));
var withLiveScoped = (live6) => fiberRefLocallyScopedWith(currentServices2, add(TestLive, live6));
var liveLayer = () => scoped(TestLive, pipe(context(), map5(make80), tap(withLiveScoped)));
var provideLive = (effect3) => liveWith((live6) => live6.provide(effect3));
var provideWithLive = dual(2, (self, f) => fiberRefGetWith(currentServices, (services) => provideLive(f(fiberRefLocally(currentServices, services)(self)))));
var sizedWith = (f) => fiberRefGetWith(currentServices2, (services) => f(get(services, TestSized)));
var sized = sizedWith(succeed);
var withSized = dual(2, (effect3, sized2) => fiberRefLocallyWith(currentServices2, add(TestSized, sized2))(effect3));
var withSizedScoped = (sized2) => fiberRefLocallyScopedWith(currentServices2, add(TestSized, sized2));
var sizedLayer = (size18) => scoped(TestSized, pipe(fiberRefMake(size18), map5(fromFiberRef), tap(withSizedScoped)));
var size15 = sizedWith((sized2) => sized2.size);
var withSize = dual(2, (effect3, size18) => sizedWith((sized2) => sized2.withSize(size18)(effect3)));
var testConfigWith = (f) => fiberRefGetWith(currentServices2, (services) => f(get(services, TestConfig)));
var testConfig = testConfigWith(succeed);
var withTestConfig = dual(2, (effect3, config) => fiberRefLocallyWith(currentServices2, add(TestConfig, config))(effect3));
var withTestConfigScoped = (config) => fiberRefLocallyScopedWith(currentServices2, add(TestConfig, config));
var testConfigLayer = (params) => scoped(TestConfig, suspend2(() => {
  const testConfig2 = make81(params);
  return pipe(withTestConfigScoped(testConfig2), as(testConfig2));
}));
var repeats = testConfigWith((config) => succeed(config.repeats));
var retries = testConfigWith((config) => succeed(config.retries));
var samples = testConfigWith((config) => succeed(config.samples));
var shrinks = testConfigWith((config) => succeed(config.shrinks));

// node_modules/effect/dist/esm/TestContext.js
var live5 = pipe(annotationsLayer(), merge2(liveLayer()), merge2(sizedLayer(100)), merge2(pipe(defaultTestClock, provideMerge(merge2(liveLayer(), annotationsLayer())))), merge2(testConfigLayer({
  repeats: 100,
  retries: 100,
  samples: 200,
  shrinks: 1e3
})));
var LiveContext = syncContext(() => liveServices);
var TestContext = provideMerge(live5, LiveContext);

// node_modules/effect/dist/esm/Trie.js
var Trie_exports = {};
__export(Trie_exports, {
  compact: () => compact2,
  empty: () => empty22,
  entries: () => entries3,
  entriesWithPrefix: () => entriesWithPrefix2,
  filter: () => filter9,
  filterMap: () => filterMap2,
  forEach: () => forEach11,
  fromIterable: () => fromIterable21,
  get: () => get36,
  has: () => has13,
  insert: () => insert3,
  insertMany: () => insertMany2,
  isEmpty: () => isEmpty10,
  keys: () => keys9,
  keysWithPrefix: () => keysWithPrefix2,
  longestPrefixOf: () => longestPrefixOf2,
  make: () => make84,
  map: () => map17,
  modify: () => modify13,
  reduce: () => reduce17,
  remove: () => remove11,
  removeMany: () => removeMany2,
  size: () => size17,
  toEntries: () => toEntries,
  toEntriesWithPrefix: () => toEntriesWithPrefix2,
  unsafeGet: () => unsafeGet8,
  values: () => values6,
  valuesWithPrefix: () => valuesWithPrefix2
});

// node_modules/effect/dist/esm/internal/trie.js
var TrieSymbolKey = "effect/Trie";
var TrieTypeId = Symbol.for(TrieSymbolKey);
var trieVariance = {
  /* c8 ignore next */
  _Value: (_) => _
};
var TrieProto = {
  [TrieTypeId]: trieVariance,
  [Symbol.iterator]() {
    return new TrieIterator(this, (k, v) => [k, v], () => true);
  },
  [symbol2]() {
    let hash3 = hash(TrieSymbolKey);
    for (const item of this) {
      hash3 ^= pipe(hash(item[0]), combine(hash(item[1])));
    }
    return cached(this, hash3);
  },
  [symbol3](that) {
    if (isTrie(that)) {
      const entries4 = Array.from(that);
      return Array.from(this).every((itemSelf, i) => {
        const itemThat = entries4[i];
        return equals(itemSelf[0], itemThat[0]) && equals(itemSelf[1], itemThat[1]);
      });
    }
    return false;
  },
  toString() {
    return format(this.toJSON());
  },
  toJSON() {
    return {
      _id: "Trie",
      values: Array.from(this).map(toJSON)
    };
  },
  [NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return pipeArguments(this, arguments);
  }
};
var makeImpl3 = (root) => {
  const trie = Object.create(TrieProto);
  trie._root = root;
  trie._count = root?.count ?? 0;
  return trie;
};
var TrieIterator = class _TrieIterator {
  trie;
  f;
  filter;
  stack = [];
  constructor(trie, f, filter10) {
    this.trie = trie;
    this.f = f;
    this.filter = filter10;
    const root = trie._root !== void 0 ? trie._root : void 0;
    if (root !== void 0) {
      this.stack.push([root, "", false]);
    }
  }
  next() {
    while (this.stack.length > 0) {
      const [node, keyString, isAdded] = this.stack.pop();
      if (isAdded) {
        const value7 = node.value;
        if (value7 !== void 0) {
          const key = keyString + node.key;
          if (this.filter(key, value7)) {
            return {
              done: false,
              value: this.f(key, value7)
            };
          }
        }
      } else {
        this.addToStack(node, keyString);
      }
    }
    return {
      done: true,
      value: void 0
    };
  }
  addToStack(node, keyString) {
    if (node.right !== void 0) {
      this.stack.push([node.right, keyString, false]);
    }
    if (node.mid !== void 0) {
      this.stack.push([node.mid, keyString + node.key, false]);
    }
    this.stack.push([node, keyString, true]);
    if (node.left !== void 0) {
      this.stack.push([node.left, keyString, false]);
    }
  }
  [Symbol.iterator]() {
    return new _TrieIterator(this.trie, this.f, this.filter);
  }
};
var isTrie = (u) => hasProperty(u, TrieTypeId);
var empty21 = () => makeImpl3(void 0);
var fromIterable20 = (entries4) => {
  let trie = empty21();
  for (const [key, value7] of entries4) {
    trie = insert2(trie, key, value7);
  }
  return trie;
};
var make83 = (...entries4) => {
  return fromIterable20(entries4);
};
var insert2 = dual(3, (self, key, value7) => {
  if (key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let n = self._root ?? {
    key: key[0],
    count: 0
  };
  const count5 = n.count + 1;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    nStack.push(n);
    if (c > n.key) {
      dStack.push(1);
      if (n.right === void 0) {
        n = {
          key: c,
          count: count5
        };
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      dStack.push(-1);
      if (n.left === void 0) {
        n = {
          key: c,
          count: count5
        };
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        n.value = value7;
      } else if (n.mid === void 0) {
        dStack.push(0);
        n = {
          key: key[cIndex + 1],
          count: count5
        };
      } else {
        dStack.push(0);
        n = n.mid;
      }
      cIndex += 1;
    }
  }
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: nStack[s + 1],
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nStack[s + 1]
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: nStack[s + 1],
        right: n2.right
      };
    }
  }
  nStack[0].count = count5;
  return makeImpl3(nStack[0]);
});
var size16 = (self) => self._root?.count ?? 0;
var isEmpty9 = (self) => size16(self) === 0;
var keys8 = (self) => new TrieIterator(self, (key) => key, () => true);
var values5 = (self) => new TrieIterator(self, (_, value7) => value7, () => true);
var entries2 = (self) => new TrieIterator(self, (key, value7) => [key, value7], () => true);
var reduce16 = dual(3, (self, zero, f) => {
  let accumulator = zero;
  for (const entry of self) {
    accumulator = f(accumulator, entry[1], entry[0]);
  }
  return accumulator;
});
var map16 = dual(2, (self, f) => reduce16(self, empty21(), (trie, value7, key) => insert2(trie, key, f(value7, key))));
var filter8 = dual(2, (self, f) => reduce16(self, empty21(), (trie, value7, key) => f(value7, key) ? insert2(trie, key, value7) : trie));
var filterMap = dual(2, (self, f) => reduce16(self, empty21(), (trie, value7, key) => {
  const option5 = f(value7, key);
  return isSome(option5) ? insert2(trie, key, option5.value) : trie;
}));
var compact = (self) => filterMap(self, identity);
var forEach10 = dual(2, (self, f) => reduce16(self, void 0, (_, value7, key) => f(value7, key)));
var keysWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key) => key, (key) => key.startsWith(prefix)));
var valuesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (_, value7) => value7, (key) => key.startsWith(prefix)));
var entriesWithPrefix = dual(2, (self, prefix) => new TrieIterator(self, (key, value7) => [key, value7], (key) => key.startsWith(prefix)));
var toEntriesWithPrefix = dual(2, (self, prefix) => Array.from(entriesWithPrefix(self, prefix)));
var get35 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none();
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return none();
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return none();
      } else {
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        return fromNullable(n.value);
      } else {
        if (n.mid === void 0) {
          return none();
        } else {
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  return none();
});
var has12 = dual(2, (self, key) => isSome(get35(self, key)));
var unsafeGet7 = dual(2, (self, key) => {
  const element = get35(self, key);
  if (isNone(element)) {
    throw new Error("Expected trie to contain key");
  }
  return element.value;
});
var remove10 = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const count5 = n.count - 1;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const removeNode = nStack[nStack.length - 1];
  nStack[nStack.length - 1] = {
    key: removeNode.key,
    count: count5,
    left: removeNode.left,
    mid: removeNode.mid,
    right: removeNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    const nc = child.left === void 0 && child.mid === void 0 && child.right === void 0 ? void 0 : child;
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: nc,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: nc
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: count5,
        value: n2.value,
        left: n2.left,
        mid: nc,
        right: n2.right
      };
    }
  }
  nStack[0].count = count5;
  return makeImpl3(nStack[0]);
});
var removeMany = dual(2, (self, keys10) => {
  let trie = self;
  for (const key of keys10) {
    trie = remove10(key)(trie);
  }
  return trie;
});
var insertMany = dual(2, (self, iter) => {
  let trie = self;
  for (const [key, value7] of iter) {
    trie = insert2(key, value7)(trie);
  }
  return trie;
});
var modify12 = dual(3, (self, key, f) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return self;
  const dStack = [];
  const nStack = [];
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (c > n.key) {
      if (n.right === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(1);
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        return self;
      } else {
        nStack.push(n);
        dStack.push(-1);
        n = n.left;
      }
    } else {
      if (cIndex === key.length - 1) {
        if (n.value !== void 0) {
          nStack.push(n);
          dStack.push(0);
          cIndex += 1;
        } else {
          return self;
        }
      } else {
        if (n.mid === void 0) {
          return self;
        } else {
          nStack.push(n);
          dStack.push(0);
          n = n.mid;
          cIndex += 1;
        }
      }
    }
  }
  const updateNode = nStack[nStack.length - 1];
  if (updateNode.value === void 0) {
    return self;
  }
  nStack[nStack.length - 1] = {
    key: updateNode.key,
    count: updateNode.count,
    value: f(updateNode.value),
    // Update
    left: updateNode.left,
    mid: updateNode.mid,
    right: updateNode.right
  };
  for (let s = nStack.length - 2; s >= 0; --s) {
    const n2 = nStack[s];
    const d = dStack[s];
    const child = nStack[s + 1];
    if (d === -1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: child,
        mid: n2.mid,
        right: n2.right
      };
    } else if (d === 1) {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: n2.mid,
        right: child
      };
    } else {
      nStack[s] = {
        key: n2.key,
        count: n2.count,
        value: n2.value,
        left: n2.left,
        mid: child,
        right: n2.right
      };
    }
  }
  return makeImpl3(nStack[0]);
});
var longestPrefixOf = dual(2, (self, key) => {
  let n = self._root;
  if (n === void 0 || key.length === 0) return none();
  let longestPrefixNode = void 0;
  let cIndex = 0;
  while (cIndex < key.length) {
    const c = key[cIndex];
    if (n.value !== void 0) {
      longestPrefixNode = [key.slice(0, cIndex + 1), n.value];
    }
    if (c > n.key) {
      if (n.right === void 0) {
        break;
      } else {
        n = n.right;
      }
    } else if (c < n.key) {
      if (n.left === void 0) {
        break;
      } else {
        n = n.left;
      }
    } else {
      if (n.mid === void 0) {
        break;
      } else {
        n = n.mid;
        cIndex += 1;
      }
    }
  }
  return fromNullable(longestPrefixNode);
});

// node_modules/effect/dist/esm/Trie.js
var empty22 = empty21;
var fromIterable21 = fromIterable20;
var make84 = make83;
var insert3 = insert2;
var keys9 = keys8;
var values6 = values5;
var entries3 = entries2;
var toEntries = (self) => Array.from(entries3(self));
var keysWithPrefix2 = keysWithPrefix;
var valuesWithPrefix2 = valuesWithPrefix;
var entriesWithPrefix2 = entriesWithPrefix;
var toEntriesWithPrefix2 = toEntriesWithPrefix;
var longestPrefixOf2 = longestPrefixOf;
var size17 = size16;
var get36 = get35;
var has13 = has12;
var isEmpty10 = isEmpty9;
var unsafeGet8 = unsafeGet7;
var remove11 = remove10;
var reduce17 = reduce16;
var map17 = map16;
var filter9 = filter8;
var filterMap2 = filterMap;
var compact2 = compact;
var forEach11 = forEach10;
var modify13 = modify12;
var removeMany2 = removeMany;
var insertMany2 = insertMany;

// node_modules/effect/dist/esm/Types.js
var Types_exports = {};

// node_modules/effect/dist/esm/UpstreamPullRequest.js
var UpstreamPullRequest_exports = {};
__export(UpstreamPullRequest_exports, {
  NoUpstream: () => NoUpstream2,
  Pulled: () => Pulled2,
  UpstreamPullRequestTypeId: () => UpstreamPullRequestTypeId2,
  isNoUpstream: () => isNoUpstream2,
  isPulled: () => isPulled2,
  isUpstreamPullRequest: () => isUpstreamPullRequest2,
  match: () => match17
});
var UpstreamPullRequestTypeId2 = UpstreamPullRequestTypeId;
var Pulled2 = Pulled;
var NoUpstream2 = NoUpstream;
var isUpstreamPullRequest2 = isUpstreamPullRequest;
var isPulled2 = isPulled;
var isNoUpstream2 = isNoUpstream;
var match17 = match5;

// node_modules/effect/dist/esm/UpstreamPullStrategy.js
var UpstreamPullStrategy_exports = {};
__export(UpstreamPullStrategy_exports, {
  PullAfterAllEnqueued: () => PullAfterAllEnqueued2,
  PullAfterNext: () => PullAfterNext2,
  UpstreamPullStrategyTypeId: () => UpstreamPullStrategyTypeId2,
  isPullAfterAllEnqueued: () => isPullAfterAllEnqueued2,
  isPullAfterNext: () => isPullAfterNext2,
  isUpstreamPullStrategy: () => isUpstreamPullStrategy2,
  match: () => match18
});
var UpstreamPullStrategyTypeId2 = UpstreamPullStrategyTypeId;
var PullAfterNext2 = PullAfterNext;
var PullAfterAllEnqueued2 = PullAfterAllEnqueued;
var isUpstreamPullStrategy2 = isUpstreamPullStrategy;
var isPullAfterNext2 = isPullAfterNext;
var isPullAfterAllEnqueued2 = isPullAfterAllEnqueued;
var match18 = match4;
export {
  Arbitrary_exports as Arbitrary,
  Array_exports as Array,
  BigDecimal_exports as BigDecimal,
  BigInt_exports as BigInt,
  Boolean_exports as Boolean,
  Brand_exports as Brand,
  Cache_exports as Cache,
  Cause_exports as Cause,
  Channel_exports as Channel,
  ChildExecutorDecision_exports as ChildExecutorDecision,
  Chunk_exports as Chunk,
  Clock_exports as Clock,
  Config_exports as Config,
  ConfigError_exports as ConfigError,
  ConfigProvider_exports as ConfigProvider,
  ConfigProviderPathPatch_exports as ConfigProviderPathPatch,
  Console_exports as Console,
  Context_exports as Context,
  Cron_exports as Cron,
  Data_exports as Data,
  DateTime_exports as DateTime,
  DefaultServices_exports as DefaultServices,
  Deferred_exports as Deferred,
  Differ_exports as Differ,
  Duration_exports as Duration,
  Effect_exports as Effect,
  Effectable_exports as Effectable,
  Either_exports as Either,
  Encoding_exports as Encoding,
  Equal_exports as Equal,
  Equivalence_exports as Equivalence,
  ExecutionPlan_exports as ExecutionPlan,
  ExecutionStrategy_exports as ExecutionStrategy,
  Exit_exports as Exit,
  FastCheck_exports as FastCheck,
  Fiber_exports as Fiber,
  FiberHandle_exports as FiberHandle,
  FiberId_exports as FiberId,
  FiberMap_exports as FiberMap,
  FiberRef_exports as FiberRef,
  FiberRefs_exports as FiberRefs,
  FiberRefsPatch_exports as FiberRefsPatch,
  FiberSet_exports as FiberSet,
  FiberStatus_exports as FiberStatus,
  Function_exports as Function,
  GlobalValue_exports as GlobalValue,
  GroupBy_exports as GroupBy,
  HKT_exports as HKT,
  Hash_exports as Hash,
  HashMap_exports as HashMap,
  HashSet_exports as HashSet,
  Inspectable_exports as Inspectable,
  Iterable_exports as Iterable,
  JSONSchema_exports as JSONSchema,
  KeyedPool_exports as KeyedPool,
  Layer_exports as Layer,
  LayerMap_exports as LayerMap,
  List_exports as List,
  LogLevel_exports as LogLevel,
  LogSpan_exports as LogSpan,
  Logger_exports as Logger,
  Mailbox_exports as Mailbox,
  ManagedRuntime_exports as ManagedRuntime,
  Match_exports as Match,
  MergeDecision_exports as MergeDecision,
  MergeState_exports as MergeState,
  MergeStrategy_exports as MergeStrategy,
  Metric_exports as Metric,
  MetricBoundaries_exports as MetricBoundaries,
  MetricHook_exports as MetricHook,
  MetricKey_exports as MetricKey,
  MetricKeyType_exports as MetricKeyType,
  MetricLabel_exports as MetricLabel,
  MetricPair_exports as MetricPair,
  MetricPolling_exports as MetricPolling,
  MetricRegistry_exports as MetricRegistry,
  MetricState_exports as MetricState,
  Micro_exports as Micro,
  ModuleVersion_exports as ModuleVersion,
  MutableHashMap_exports as MutableHashMap,
  MutableHashSet_exports as MutableHashSet,
  MutableList_exports as MutableList,
  MutableQueue_exports as MutableQueue,
  MutableRef_exports as MutableRef,
  NonEmptyIterable_exports as NonEmptyIterable,
  Number_exports as Number,
  Option_exports as Option,
  Order_exports as Order,
  Ordering_exports as Ordering,
  ParseResult_exports as ParseResult,
  Pipeable_exports as Pipeable,
  Pool_exports as Pool,
  Predicate_exports as Predicate,
  Pretty_exports as Pretty,
  PrimaryKey_exports as PrimaryKey,
  PubSub_exports as PubSub,
  Queue_exports as Queue,
  Random_exports as Random,
  RateLimiter_exports as RateLimiter,
  RcMap_exports as RcMap,
  RcRef_exports as RcRef,
  Readable_exports as Readable,
  Record_exports as Record,
  RedBlackTree_exports as RedBlackTree,
  Redacted_exports as Redacted,
  Ref_exports as Ref,
  RegExp_exports as RegExp,
  Reloadable_exports as Reloadable,
  Request_exports as Request,
  RequestBlock_exports as RequestBlock,
  RequestResolver_exports as RequestResolver,
  Resource_exports as Resource,
  Runtime_exports as Runtime,
  RuntimeFlags_exports as RuntimeFlags,
  RuntimeFlagsPatch_exports as RuntimeFlagsPatch,
  STM_exports as STM,
  Schedule_exports as Schedule,
  ScheduleDecision_exports as ScheduleDecision,
  ScheduleInterval_exports as ScheduleInterval,
  ScheduleIntervals_exports as ScheduleIntervals,
  Scheduler_exports as Scheduler,
  Schema_exports as Schema,
  SchemaAST_exports as SchemaAST,
  Scope_exports as Scope,
  ScopedCache_exports as ScopedCache,
  ScopedRef_exports as ScopedRef,
  Secret_exports as Secret,
  SingleProducerAsyncInput_exports as SingleProducerAsyncInput,
  Sink_exports as Sink,
  SortedMap_exports as SortedMap,
  SortedSet_exports as SortedSet,
  Stream_exports as Stream,
  StreamEmit_exports as StreamEmit,
  StreamHaltStrategy_exports as StreamHaltStrategy,
  Streamable_exports as Streamable,
  String_exports as String,
  Struct_exports as Struct,
  Subscribable_exports as Subscribable,
  SubscriptionRef_exports as SubscriptionRef,
  Supervisor_exports as Supervisor,
  Symbol_exports as Symbol,
  SynchronizedRef_exports as SynchronizedRef,
  TArray_exports as TArray,
  TDeferred_exports as TDeferred,
  TMap_exports as TMap,
  TPriorityQueue_exports as TPriorityQueue,
  TPubSub_exports as TPubSub,
  TQueue_exports as TQueue,
  TRandom_exports as TRandom,
  TReentrantLock_exports as TReentrantLock,
  TRef_exports as TRef,
  TSemaphore_exports as TSemaphore,
  TSet_exports as TSet,
  TSubscriptionRef_exports as TSubscriptionRef,
  Take_exports as Take,
  TestAnnotation_exports as TestAnnotation,
  TestAnnotationMap_exports as TestAnnotationMap,
  TestAnnotations_exports as TestAnnotations,
  TestClock_exports as TestClock,
  TestConfig_exports as TestConfig,
  TestContext_exports as TestContext,
  TestLive_exports as TestLive,
  TestServices_exports as TestServices,
  TestSized_exports as TestSized,
  Tracer_exports as Tracer,
  Trie_exports as Trie,
  Tuple_exports as Tuple,
  Types_exports as Types,
  Unify_exports as Unify,
  UpstreamPullRequest_exports as UpstreamPullRequest,
  UpstreamPullStrategy_exports as UpstreamPullStrategy,
  Utils_exports as Utils,
  absurd,
  flow,
  hole,
  identity,
  pipe,
  unsafeCoerce
};
//# sourceMappingURL=effect.js.map
