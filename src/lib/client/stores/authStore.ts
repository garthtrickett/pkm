// src/lib/client/stores/authStore.ts

import { signal } from "@preact/signals-core";
import { Data, Effect, Layer, Queue, Stream } from "effect";
import { BrowserHttpClient } from "@effect/platform-browser";
import { RpcClient, RpcSerialization } from "@effect/rpc";
import { AuthError, AuthRpc } from "../../shared/api";
import type { User } from "../../../types/generated/public/User";
import { clientLog, RpcLogClient } from "../clientLog";
import { ClientLive, runClientUnscoped } from "../runtime";

// --- RPC Client Service Definition ---

const AuthProtocolLive = RpcClient.layerProtocolHttp({
  url: "/api/rpc",
}).pipe(
  Layer.provide([
    BrowserHttpClient.layerXMLHttpRequest,
    RpcSerialization.layerNdjson,
  ]),
);

export class RpcAuthClient extends Effect.Service<RpcAuthClient>()(
  "RpcAuthClient",
  {
    dependencies: [AuthProtocolLive],
    scoped: RpcClient.make(AuthRpc),
  },
) {}

// Use the .Default layer automatically generated by Effect.Service
const RpcAuthClientLive = RpcAuthClient.Default;

// --- Model & State ---
export interface AuthModel {
  status: "initializing" | "unauthenticated" | "authenticating" | "authenticated";
  user: User | null;
}

export const authState = signal<AuthModel>({
  status: "initializing",
  user: null,
});

// --- Errors ---
class AuthCheckError extends Data.TaggedError("AuthCheckError")<{
  cause: unknown;
}> {}

// --- Actions ---
type AuthAction =
  | { type: "AUTH_CHECK_START" }
  | { type: "AUTH_CHECK_SUCCESS"; payload: User }
  | { type: "AUTH_CHECK_FAILURE"; payload: AuthError | AuthCheckError }
  | { type: "LOGOUT_START" }
  | { type: "LOGOUT_SUCCESS" }
  | { type: "SET_AUTHENTICATED"; payload: User };

const _actionQueue = Effect.runSync(Queue.unbounded<AuthAction>());

export const proposeAuthAction = (action: AuthAction): void => {
  runClientUnscoped(Queue.offer(_actionQueue, action));
};

// --- Update Logic ---
const update = (model: AuthModel, action: AuthAction): AuthModel => {
  switch (action.type) {
    case "AUTH_CHECK_START":
      return { ...model, status: "authenticating" };
    case "AUTH_CHECK_SUCCESS":
      return { status: "authenticated", user: action.payload };
    case "AUTH_CHECK_FAILURE":
      return { status: "unauthenticated", user: null };
    case "LOGOUT_START":
      return { ...model, status: "authenticating" };
    case "LOGOUT_SUCCESS":
      return { status: "unauthenticated", user: null };
    case "SET_AUTHENTICATED":
      return { status: "authenticated", user: action.payload };
    default:
      return model;
  }
};

// --- Action Handler ---
// ✅ FIX: The signature now correctly states that it can fail with `Error`
// and requires both `RpcAuthClient` and `RpcLogClient`.
const handleAuthAction = (
  action: AuthAction,
): Effect.Effect<void, Error, RpcAuthClient | RpcLogClient> =>
  Effect.gen(function* () {
    const nextModel = update(authState.value, action);
    authState.value = nextModel;

    const authClient = yield* RpcAuthClient;

    switch (action.type) {
      case "AUTH_CHECK_START": {
        yield* clientLog("info", "Checking auth status...");
        const authCheckEffect = authClient.me().pipe(
          Effect.match({
            onSuccess: (user) =>
              proposeAuthAction({ type: "AUTH_CHECK_SUCCESS", payload: user }),
            onFailure: (error) =>
              proposeAuthAction({
                type: "AUTH_CHECK_FAILURE",
                payload: error,
              }),
          }),
        );
        yield* Effect.fork(authCheckEffect);
        break;
      }
      case "LOGOUT_START": {
        yield* clientLog("info", "Logging out...");
        const logoutEffect = authClient.logout().pipe(
          Effect.catchAll(() => Effect.void), // Ignore errors on logout
          Effect.andThen(() => proposeAuthAction({ type: "LOGOUT_SUCCESS" })),
        );
        yield* Effect.fork(logoutEffect);
        break;
      }
    }
  });

// --- Main Loop ---

// ✅ FIX: Create a single layer that provides all dependencies for the action handler.
const RpcClientsLive = Layer.merge(RpcAuthClientLive, RpcLogClient.Default);

const authProcess = Stream.fromQueue(_actionQueue).pipe(
  Stream.runForEach((action) =>
    handleAuthAction(action).pipe(
      // ✅ FIX: Provide the combined layer to satisfy all dependencies.
      Effect.provide(RpcClientsLive),
      // ✅ FIX: Catch any remaining errors and log to console as a last resort.
      Effect.catchAll((err) =>
        Effect.sync(() =>
          console.error(
            `[authStore] Unhandled error in action handler for "${action.type}":`,
            err,
          ),
        ),
      ),
    ),
  ),
);

// Run the main auth process, providing it with any further "global" client context.
runClientUnscoped(authProcess.pipe(Effect.provide(ClientLive)));

// Initial action to check auth status on load
proposeAuthAction({ type: "AUTH_CHECK_START" });
